// ==UserScript==
// @name         flycodegenerator
// @namespace    dwsy/flycodegenerator
// @version      1.0.0
// @author       monkey
// @icon         http://flydoc.dwsy.link/xwlogoblue.png
// @downloadURL  https://github.com/Dwsy/FlyCodeGenerator/blob/main/flycodegenerator.user.js
// @updateURL    https://github.com/Dwsy/FlyCodeGenerator/blob/main/flycodegenerator.user.js
// @match        http://ide.wxchina.com:9000/*
// @require      https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js
// @grant        GM_addStyle
// @grant        GM_getValue
// @grant        GM_registerMenuCommand
// @grant        GM_setClipboard
// @grant        GM_setValue
// @run-at       document-start
// ==/UserScript==

(A=>{if(typeof GM_addStyle=="function"){GM_addStyle(A);return}const V=document.createElement("style");V.textContent=A,document.head.append(V)})(" .n-list-item__divider{background-color:#4e4e4e66!important}.flycode-d{height:70%;overflow:auto;white-space:pre-wrap;word-wrap:break-word}@font-face{font-family:v-sans;font-weight:400;src:url(data:font/woff2;base64,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)}@font-face{font-family:v-sans;font-weight:600;src:url(data:font/woff2;base64,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)}@font-face{font-family:v-mono;font-weight:400;src:url(data:font/woff2;base64,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)} ");

(function (vue) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var require_main_001 = __commonJS({
    "main-f4cb4560.js"(exports, module) {
      let onceCbs = [];
      const paramsMap = /* @__PURE__ */ new WeakMap();
      function flushOnceCallbacks() {
        onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
        onceCbs = [];
      }
      function beforeNextFrameOnce(cb, ...params) {
        paramsMap.set(cb, params);
        if (onceCbs.includes(cb))
          return;
        onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
      }
      function getParentNode$1(node) {
        if (node.nodeType === 9) {
          return null;
        }
        return node.parentNode;
      }
      function getScrollParent$1(node) {
        if (node === null)
          return null;
        const parentNode = getParentNode$1(node);
        if (parentNode === null) {
          return null;
        }
        if (parentNode.nodeType === 9) {
          return document.documentElement;
        }
        if (parentNode.nodeType === 1) {
          const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
          if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
            return parentNode;
          }
        }
        return getScrollParent$1(parentNode);
      }
      function unwrapElement(target) {
        if (typeof target === "string")
          return document.querySelector(target);
        if (typeof target === "function")
          return target();
        return target;
      }
      function happensIn(e, dataSetPropName) {
        let { target } = e;
        while (target) {
          if (target.dataset) {
            if (target.dataset[dataSetPropName] !== void 0)
              return true;
          }
          target = target.parentElement;
        }
        return false;
      }
      function getPreciseEventTarget(event) {
        return event.composedPath()[0] || null;
      }
      function parseResponsiveProp(reponsiveProp) {
        if (typeof reponsiveProp === "number") {
          return {
            "": reponsiveProp.toString()
          };
        }
        const params = {};
        reponsiveProp.split(/ +/).forEach((pairLiteral) => {
          if (pairLiteral === "")
            return;
          const [prefix2, value] = pairLiteral.split(":");
          if (value === void 0) {
            params[""] = prefix2;
          } else {
            params[prefix2] = value;
          }
        });
        return params;
      }
      function parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {
        var _a;
        if (reponsiveProp === void 0 || reponsiveProp === null)
          return void 0;
        const classObj = parseResponsiveProp(reponsiveProp);
        if (activeKeyOrSize === void 0)
          return classObj[""];
        if (typeof activeKeyOrSize === "string") {
          return (_a = classObj[activeKeyOrSize]) !== null && _a !== void 0 ? _a : classObj[""];
        } else if (Array.isArray(activeKeyOrSize)) {
          for (let i = activeKeyOrSize.length - 1; i >= 0; --i) {
            const key = activeKeyOrSize[i];
            if (key in classObj)
              return classObj[key];
          }
          return classObj[""];
        } else {
          let activeValue = void 0;
          let activeKey = -1;
          Object.keys(classObj).forEach((key) => {
            const keyAsNum = Number(key);
            if (!Number.isNaN(keyAsNum) && activeKeyOrSize >= keyAsNum && keyAsNum >= activeKey) {
              activeKey = keyAsNum;
              activeValue = classObj[key];
            }
          });
          return activeValue;
        }
      }
      function depx(value) {
        if (typeof value === "string") {
          if (value.endsWith("px")) {
            return Number(value.slice(0, value.length - 2));
          }
          return Number(value);
        }
        return value;
      }
      function pxfy(value) {
        if (value === void 0 || value === null)
          return void 0;
        if (typeof value === "number")
          return `${value}px`;
        if (value.endsWith("px"))
          return value;
        return `${value}px`;
      }
      function getMargin(value, position) {
        const parts = value.trim().split(/\s+/g);
        const margin = {
          top: parts[0]
        };
        switch (parts.length) {
          case 1:
            margin.right = parts[0];
            margin.bottom = parts[0];
            margin.left = parts[0];
            break;
          case 2:
            margin.right = parts[1];
            margin.left = parts[1];
            margin.bottom = parts[0];
            break;
          case 3:
            margin.right = parts[1];
            margin.bottom = parts[2];
            margin.left = parts[1];
            break;
          case 4:
            margin.right = parts[1];
            margin.bottom = parts[2];
            margin.left = parts[3];
            break;
          default:
            throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
        }
        if (position === void 0)
          return margin;
        return margin[position];
      }
      function getGap(value, orient) {
        const [rowGap, colGap] = value.split(" ");
        if (!orient)
          return {
            row: rowGap,
            col: colGap || rowGap
          };
        return orient === "row" ? rowGap : colGap;
      }
      const colors = {
        black: "#000",
        silver: "#C0C0C0",
        gray: "#808080",
        white: "#FFF",
        maroon: "#800000",
        red: "#F00",
        purple: "#800080",
        fuchsia: "#F0F",
        green: "#008000",
        lime: "#0F0",
        olive: "#808000",
        yellow: "#FF0",
        navy: "#000080",
        blue: "#00F",
        teal: "#008080",
        aqua: "#0FF",
        transparent: "#0000"
      };
      function hsl2hsv(h2, s, l) {
        s /= 100;
        l /= 100;
        const v = s * Math.min(l, 1 - l) + l;
        return [h2, v ? (2 - 2 * l / v) * 100 : 0, v * 100];
      }
      function hsv2hsl(h2, s, v) {
        s /= 100;
        v /= 100;
        const l = v - v * s / 2;
        const m = Math.min(l, 1 - l);
        return [h2, m ? (v - l) / m * 100 : 0, l * 100];
      }
      function hsv2rgb(h2, s, v) {
        s /= 100;
        v /= 100;
        let f = (n, k = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5) * 255, f(3) * 255, f(1) * 255];
      }
      function rgb2hsv(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b);
        let h2 = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
        return [60 * (h2 < 0 ? h2 + 6 : h2), v && c2 / v * 100, v * 100];
      }
      function rgb2hsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b), f = 1 - Math.abs(v + v - c2 - 1);
        let h2 = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
        return [60 * (h2 < 0 ? h2 + 6 : h2), f ? c2 / f * 100 : 0, (v + v - c2) * 50];
      }
      function hsl2rgb(h2, s, l) {
        s /= 100;
        l /= 100;
        let a2 = s * Math.min(l, 1 - l);
        let f = (n, k = (n + h2 / 30) % 12) => l - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0) * 255, f(8) * 255, f(4) * 255];
      }
      const prefix$1 = "^\\s*";
      const suffix = "\\s*$";
      const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
      const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
      const hex = "([0-9A-Fa-f])";
      const dhex = "([0-9A-Fa-f]{2})";
      const hslRegex = new RegExp(`${prefix$1}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
      const hsvRegex = new RegExp(`${prefix$1}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
      const hslaRegex = new RegExp(`${prefix$1}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
      const hsvaRegex = new RegExp(`${prefix$1}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
      const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
      const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
      const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
      const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
      const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
      const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
      function parseHex(value) {
        return parseInt(value, 16);
      }
      function hsla(color) {
        try {
          let i;
          if (i = hslaRegex.exec(color)) {
            return [
              roundDeg(i[1]),
              roundPercent(i[5]),
              roundPercent(i[9]),
              roundAlpha(i[13])
            ];
          } else if (i = hslRegex.exec(color)) {
            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
          }
          throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
        } catch (e) {
          throw e;
        }
      }
      function hsva(color) {
        try {
          let i;
          if (i = hsvaRegex.exec(color)) {
            return [
              roundDeg(i[1]),
              roundPercent(i[5]),
              roundPercent(i[9]),
              roundAlpha(i[13])
            ];
          } else if (i = hsvRegex.exec(color)) {
            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
          }
          throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
        } catch (e) {
          throw e;
        }
      }
      function rgba(color) {
        try {
          let i;
          if (i = hexRegex.exec(color)) {
            return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
          } else if (i = rgbRegex.exec(color)) {
            return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
          } else if (i = rgbaRegex.exec(color)) {
            return [
              roundChannel(i[1]),
              roundChannel(i[5]),
              roundChannel(i[9]),
              roundAlpha(i[13])
            ];
          } else if (i = sHexRegex.exec(color)) {
            return [
              parseHex(i[1] + i[1]),
              parseHex(i[2] + i[2]),
              parseHex(i[3] + i[3]),
              1
            ];
          } else if (i = hexaRegex.exec(color)) {
            return [
              parseHex(i[1]),
              parseHex(i[2]),
              parseHex(i[3]),
              roundAlpha(parseHex(i[4]) / 255)
            ];
          } else if (i = sHexaRegex.exec(color)) {
            return [
              parseHex(i[1] + i[1]),
              parseHex(i[2] + i[2]),
              parseHex(i[3] + i[3]),
              roundAlpha(parseHex(i[4] + i[4]) / 255)
            ];
          } else if (color in colors) {
            return rgba(colors[color]);
          }
          throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
        } catch (e) {
          throw e;
        }
      }
      function normalizeAlpha$1(alphaValue) {
        return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
      }
      function stringifyRgb(r, g, b) {
        return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
      }
      function stringifyRgba(r, g, b, a2) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha$1(a2)})`;
      }
      function compositeChannel(v1, a1, v2, a2, a3) {
        return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a3);
      }
      function composite(background, overlay2) {
        if (!Array.isArray(background))
          background = rgba(background);
        if (!Array.isArray(overlay2))
          overlay2 = rgba(overlay2);
        const a1 = background[3];
        const a2 = overlay2[3];
        const alpha = roundAlpha(a1 + a2 - a1 * a2);
        return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
      }
      function changeColor(base2, options) {
        const [r, g, b, a2 = 1] = Array.isArray(base2) ? base2 : rgba(base2);
        if (options.alpha) {
          return stringifyRgba(r, g, b, options.alpha);
        }
        return stringifyRgba(r, g, b, a2);
      }
      function scaleColor(base2, options) {
        const [r, g, b, a2 = 1] = Array.isArray(base2) ? base2 : rgba(base2);
        const { lightness = 1, alpha = 1 } = options;
        return toRgbaString([r * lightness, g * lightness, b * lightness, a2 * alpha]);
      }
      function roundAlpha(value) {
        const v = Math.round(Number(value) * 100) / 100;
        if (v > 1)
          return 1;
        if (v < 0)
          return 0;
        return v;
      }
      function roundDeg(value) {
        const v = Math.round(Number(value));
        if (v >= 360)
          return 0;
        if (v < 0)
          return 0;
        return v;
      }
      function roundChannel(value) {
        const v = Math.round(Number(value));
        if (v > 255)
          return 255;
        if (v < 0)
          return 0;
        return v;
      }
      function roundPercent(value) {
        const v = Math.round(Number(value));
        if (v > 100)
          return 100;
        if (v < 0)
          return 0;
        return v;
      }
      function toRgbString(base2) {
        const [r, g, b] = Array.isArray(base2) ? base2 : rgba(base2);
        return stringifyRgb(r, g, b);
      }
      function toRgbaString(base2) {
        const [r, g, b] = base2;
        if (3 in base2) {
          return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
        }
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
      }
      function toHsvString(base2) {
        return `hsv(${roundDeg(base2[0])}, ${roundPercent(base2[1])}%, ${roundPercent(base2[2])}%)`;
      }
      function toHsvaString(base2) {
        const [h2, s, v] = base2;
        if (3 in base2) {
          return `hsva(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base2[3])})`;
        }
        return `hsva(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
      }
      function toHslString(base2) {
        return `hsl(${roundDeg(base2[0])}, ${roundPercent(base2[1])}%, ${roundPercent(base2[2])}%)`;
      }
      function toHslaString(base2) {
        const [h2, s, l] = base2;
        if (3 in base2) {
          return `hsla(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base2[3])})`;
        }
        return `hsla(${roundDeg(h2)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
      }
      function toHexaString(base2) {
        if (typeof base2 === "string") {
          let i;
          if (i = hexRegex.exec(base2)) {
            return `${i[0]}FF`;
          } else if (i = hexaRegex.exec(base2)) {
            return i[0];
          } else if (i = sHexRegex.exec(base2)) {
            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
          } else if (i = sHexaRegex.exec(base2)) {
            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
          }
          throw new Error(`[seemly/toHexString]: Invalid hex value ${base2}.`);
        }
        const hex2 = `#${base2.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
        const a2 = base2.length === 3 ? "FF" : roundChannel(base2[3] * 255).toString(16).padStart(2, "0").toUpperCase();
        return hex2 + a2;
      }
      function toHexString(base2) {
        if (typeof base2 === "string") {
          let i;
          if (i = hexRegex.exec(base2)) {
            return i[0];
          } else if (i = hexaRegex.exec(base2)) {
            return i[0].slice(0, 7);
          } else if (i = sHexRegex.exec(base2) || sHexaRegex.exec(base2)) {
            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
          }
          throw new Error(`[seemly/toHexString]: Invalid hex value ${base2}.`);
        }
        return `#${base2.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
      }
      function createId(length = 8) {
        return Math.random().toString(16).slice(2, 2 + length);
      }
      function repeat(count, v) {
        const ret = [];
        for (let i = 0; i < count; ++i) {
          ret.push(v);
        }
        return ret;
      }
      function indexMap(count, createValue) {
        const ret = [];
        if (!createValue) {
          for (let i = 0; i < count; ++i) {
            ret.push(i);
          }
          return ret;
        }
        for (let i = 0; i < count; ++i) {
          ret.push(createValue(i));
        }
        return ret;
      }
      function getSlot$1(instance, slotName = "default", fallback = []) {
        const slots = instance.$slots;
        const slot = slots[slotName];
        if (slot === void 0)
          return fallback;
        return slot();
      }
      function getVNodeChildren(vNode, slotName = "default", fallback = []) {
        const { children } = vNode;
        if (children !== null && typeof children === "object" && !Array.isArray(children)) {
          const slot = children[slotName];
          if (typeof slot === "function") {
            return slot();
          }
        }
        return fallback;
      }
      function keep(object2, keys2 = [], rest) {
        const keepedObject = {};
        keys2.forEach((key) => {
          keepedObject[key] = object2[key];
        });
        return Object.assign(keepedObject, rest);
      }
      function omit(object2, keys2 = [], rest) {
        const omitedObject = {};
        const originalKeys = Object.getOwnPropertyNames(object2);
        originalKeys.forEach((originalKey) => {
          if (!keys2.includes(originalKey)) {
            omitedObject[originalKey] = object2[originalKey];
          }
        });
        return Object.assign(omitedObject, rest);
      }
      function flatten$3(vNodes, filterCommentNode = true, result = []) {
        vNodes.forEach((vNode) => {
          if (vNode === null)
            return;
          if (typeof vNode !== "object") {
            if (typeof vNode === "string" || typeof vNode === "number") {
              result.push(vue.createTextVNode(String(vNode)));
            }
            return;
          }
          if (Array.isArray(vNode)) {
            flatten$3(vNode, filterCommentNode, result);
            return;
          }
          if (vNode.type === vue.Fragment) {
            if (vNode.children === null)
              return;
            if (Array.isArray(vNode.children)) {
              flatten$3(vNode.children, filterCommentNode, result);
            }
          } else if (vNode.type !== vue.Comment) {
            result.push(vNode);
          }
        });
        return result;
      }
      function call(funcs, ...args) {
        if (Array.isArray(funcs)) {
          funcs.forEach((func) => call(func, ...args));
        } else
          return funcs(...args);
      }
      function keysOf(obj) {
        return Object.keys(obj);
      }
      const render$1 = (r, ...args) => {
        if (typeof r === "function") {
          return r(...args);
        } else if (typeof r === "string") {
          return vue.createTextVNode(r);
        } else if (typeof r === "number") {
          return vue.createTextVNode(String(r));
        } else {
          return null;
        }
      };
      const warnedMessages = /* @__PURE__ */ new Set();
      function warnOnce(location, message2) {
        const mergedMessage = `[naive/${location}]: ${message2}`;
        if (warnedMessages.has(mergedMessage))
          return;
        warnedMessages.add(mergedMessage);
        console.error(mergedMessage);
      }
      function warn$2(location, message2) {
        console.error(`[naive/${location}]: ${message2}`);
      }
      function throwError(location, message2) {
        throw new Error(`[naive/${location}]: ${message2}`);
      }
      function smallerSize(size2) {
        switch (size2) {
          case "tiny":
            return "mini";
          case "small":
            return "tiny";
          case "medium":
            return "small";
          case "large":
            return "medium";
          case "huge":
            return "large";
        }
        throw Error(`${size2} has no smaller size.`);
      }
      function getTitleAttribute(value) {
        switch (typeof value) {
          case "string":
            return value || void 0;
          case "number":
            return String(value);
          default:
            return void 0;
        }
      }
      function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
        const slot = slots[slotName];
        if (!slot) {
          warn$2("getFirstSlotVNode", `slot[${slotName}] is empty`);
          return null;
        }
        const slotContent = flatten$3(slot(props));
        if (slotContent.length === 1) {
          return slotContent[0];
        } else {
          warn$2("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
          return null;
        }
      }
      function createDataKey(key) {
        return typeof key === "string" ? `s-${key}` : `n-${key}`;
      }
      function createRefSetter(ref2) {
        return (inst) => {
          if (inst) {
            ref2.value = inst.$el;
          } else {
            ref2.value = null;
          }
        };
      }
      function createInjectionKey(key) {
        return key;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!vue.isVNode(child)) {
            return true;
          }
          if (child.type === vue.Comment) {
            return false;
          }
          if (child.type === vue.Fragment && !ensureValidVNode(child.children)) {
            return false;
          }
          return true;
        }) ? vnodes : null;
      }
      function resolveSlot(slot, fallback) {
        return slot && ensureValidVNode(slot()) || fallback();
      }
      function resolveSlotWithProps(slot, props, fallback) {
        return slot && ensureValidVNode(slot(props)) || fallback(props);
      }
      function resolveWrappedSlot(slot, wrapper) {
        const children = slot && ensureValidVNode(slot());
        return wrapper(children || null);
      }
      function resolveWrappedSlotWithProps(slot, props, wrapper) {
        const children = slot && ensureValidVNode(slot(props));
        return wrapper(children || null);
      }
      function isSlotEmpty(slot) {
        return !(slot && ensureValidVNode(slot()));
      }
      function mergeEventHandlers(handlers) {
        const filteredHandlers = handlers.filter((handler) => handler !== void 0);
        if (filteredHandlers.length === 0)
          return void 0;
        if (filteredHandlers.length === 1)
          return filteredHandlers[0];
        return (e) => {
          handlers.forEach((handler) => {
            if (handler) {
              handler(e);
            }
          });
        };
      }
      function isNodeVShowFalse(vNode) {
        var _a;
        const showDir = (_a = vNode.dirs) === null || _a === void 0 ? void 0 : _a.find(({ dir }) => dir === vue.vShow);
        return !!(showDir && showDir.value === false);
      }
      const Wrapper = vue.defineComponent({
        render() {
          var _a, _b;
          return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      });
      const pureNumberRegex = /^(\d|\.)+$/;
      const numberRegex = /(\d|\.)+/;
      function formatLength(length, { c: c2 = 1, offset = 0, attachPx = true } = {}) {
        if (typeof length === "number") {
          const result = (length + offset) * c2;
          if (result === 0)
            return "0";
          return `${result}px`;
        } else if (typeof length === "string") {
          if (pureNumberRegex.test(length)) {
            const result = (Number(length) + offset) * c2;
            if (attachPx) {
              if (result === 0)
                return "0";
              return `${result}px`;
            } else {
              return `${result}`;
            }
          } else {
            const result = numberRegex.exec(length);
            if (!result)
              return length;
            return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
          }
        }
        return length;
      }
      function color2Class(color) {
        return color.replace(/#|\(|\)|,|\s/g, "_");
      }
      function ampCount(selector) {
        let cnt = 0;
        for (let i = 0; i < selector.length; ++i) {
          if (selector[i] === "&")
            ++cnt;
        }
        return cnt;
      }
      const separatorRegex = /\s*,(?![^(]*\))\s*/g;
      const extraSpaceRegex = /\s+/g;
      function resolveSelectorWithAmp(amp, selector) {
        const nextAmp = [];
        selector.split(separatorRegex).forEach((partialSelector) => {
          let round2 = ampCount(partialSelector);
          if (!round2) {
            amp.forEach((partialAmp) => {
              nextAmp.push(
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                (partialAmp && partialAmp + " ") + partialSelector
              );
            });
            return;
          } else if (round2 === 1) {
            amp.forEach((partialAmp) => {
              nextAmp.push(partialSelector.replace("&", partialAmp));
            });
            return;
          }
          let partialNextAmp = [
            partialSelector
          ];
          while (round2--) {
            const nextPartialNextAmp = [];
            partialNextAmp.forEach((selectorItr) => {
              amp.forEach((partialAmp) => {
                nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
              });
            });
            partialNextAmp = nextPartialNextAmp;
          }
          partialNextAmp.forEach((part) => nextAmp.push(part));
        });
        return nextAmp;
      }
      function resolveSelector(amp, selector) {
        const nextAmp = [];
        selector.split(separatorRegex).forEach((partialSelector) => {
          amp.forEach((partialAmp) => {
            nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
          });
        });
        return nextAmp;
      }
      function parseSelectorPath(selectorPaths) {
        let amp = [""];
        selectorPaths.forEach((selector) => {
          selector = selector && selector.trim();
          if (
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            !selector
          ) {
            return;
          }
          if (selector.includes("&")) {
            amp = resolveSelectorWithAmp(amp, selector);
          } else {
            amp = resolveSelector(amp, selector);
          }
        });
        return amp.join(", ").replace(extraSpaceRegex, " ");
      }
      function removeElement(el) {
        if (!el)
          return;
        const parentElement = el.parentElement;
        if (parentElement)
          parentElement.removeChild(el);
      }
      function queryElement(id) {
        return document.querySelector(`style[cssr-id="${id}"]`);
      }
      function createElement(id) {
        const el = document.createElement("style");
        el.setAttribute("cssr-id", id);
        return el;
      }
      function isMediaOrSupports(selector) {
        if (!selector)
          return false;
        return /^\s*@(s|m)/.test(selector);
      }
      const kebabRegex = /[A-Z]/g;
      function kebabCase$2(pattern2) {
        return pattern2.replace(kebabRegex, (match2) => "-" + match2.toLowerCase());
      }
      function unwrapProperty(prop, indent = "  ") {
        if (typeof prop === "object" && prop !== null) {
          return " {\n" + Object.entries(prop).map((v) => {
            return indent + `  ${kebabCase$2(v[0])}: ${v[1]};`;
          }).join("\n") + "\n" + indent + "}";
        }
        return `: ${prop};`;
      }
      function unwrapProperties(props, instance, params) {
        if (typeof props === "function") {
          return props({
            context: instance.context,
            props: params
          });
        }
        return props;
      }
      function createStyle(selector, props, instance, params) {
        if (!props)
          return "";
        const unwrappedProps = unwrapProperties(props, instance, params);
        if (!unwrappedProps)
          return "";
        if (typeof unwrappedProps === "string") {
          return `${selector} {
${unwrappedProps}
}`;
        }
        const propertyNames = Object.keys(unwrappedProps);
        if (propertyNames.length === 0) {
          if (instance.config.keepEmptyBlock)
            return selector + " {\n}";
          return "";
        }
        const statements = selector ? [
          selector + " {"
        ] : [];
        propertyNames.forEach((propertyName) => {
          const property2 = unwrappedProps[propertyName];
          if (propertyName === "raw") {
            statements.push("\n" + property2 + "\n");
            return;
          }
          propertyName = kebabCase$2(propertyName);
          if (property2 !== null && property2 !== void 0) {
            statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
          }
        });
        if (selector) {
          statements.push("}");
        }
        return statements.join("\n");
      }
      function loopCNodeListWithCallback(children, options, callback) {
        if (!children)
          return;
        children.forEach((child) => {
          if (Array.isArray(child)) {
            loopCNodeListWithCallback(child, options, callback);
          } else if (typeof child === "function") {
            const grandChildren = child(options);
            if (Array.isArray(grandChildren)) {
              loopCNodeListWithCallback(grandChildren, options, callback);
            } else if (grandChildren) {
              callback(grandChildren);
            }
          } else if (child) {
            callback(child);
          }
        });
      }
      function traverseCNode(node, selectorPaths, styles2, instance, params, styleSheet) {
        const $2 = node.$;
        let blockSelector = "";
        if (!$2 || typeof $2 === "string") {
          if (isMediaOrSupports($2)) {
            blockSelector = $2;
          } else {
            selectorPaths.push($2);
          }
        } else if (typeof $2 === "function") {
          const selector2 = $2({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        } else {
          if ($2.before)
            $2.before(instance.context);
          if (!$2.$ || typeof $2.$ === "string") {
            if (isMediaOrSupports($2.$)) {
              blockSelector = $2.$;
            } else {
              selectorPaths.push($2.$);
            }
          } else if ($2.$) {
            const selector2 = $2.$({
              context: instance.context,
              props: params
            });
            if (isMediaOrSupports(selector2)) {
              blockSelector = selector2;
            } else {
              selectorPaths.push(selector2);
            }
          }
        }
        const selector = parseSelectorPath(selectorPaths);
        const style2 = createStyle(selector, node.props, instance, params);
        if (blockSelector) {
          styles2.push(`${blockSelector} {`);
          if (styleSheet && style2) {
            styleSheet.insertRule(`${blockSelector} {
${style2}
}
`);
          }
        } else {
          if (styleSheet && style2) {
            styleSheet.insertRule(style2);
          }
          if (!styleSheet && style2.length)
            styles2.push(style2);
        }
        if (node.children) {
          loopCNodeListWithCallback(node.children, {
            context: instance.context,
            props: params
          }, (childNode) => {
            if (typeof childNode === "string") {
              const style3 = createStyle(selector, { raw: childNode }, instance, params);
              if (styleSheet) {
                styleSheet.insertRule(style3);
              } else {
                styles2.push(style3);
              }
            } else {
              traverseCNode(childNode, selectorPaths, styles2, instance, params, styleSheet);
            }
          });
        }
        selectorPaths.pop();
        if (blockSelector) {
          styles2.push("}");
        }
        if ($2 && $2.after)
          $2.after(instance.context);
      }
      function render(node, instance, props, insertRule = false) {
        const styles2 = [];
        traverseCNode(node, [], styles2, instance, props, insertRule ? node.instance.__styleSheet : void 0);
        if (insertRule)
          return "";
        return styles2.join("\n\n");
      }
      function murmur2(str) {
        var h2 = 0;
        var k, i = 0, len2 = str.length;
        for (; len2 >= 4; ++i, len2 -= 4) {
          k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
          k = /* Math.imul(k, m): */
          (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
          k ^= /* k >>> r: */
          k >>> 24;
          h2 = /* Math.imul(k, m): */
          (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        switch (len2) {
          case 3:
            h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
          case 2:
            h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
          case 1:
            h2 ^= str.charCodeAt(i) & 255;
            h2 = /* Math.imul(h, m): */
            (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        h2 ^= h2 >>> 13;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
      }
      if (typeof window !== "undefined") {
        window.__cssrContext = {};
      }
      function unmount(intance, node, id) {
        const { els } = node;
        if (id === void 0) {
          els.forEach(removeElement);
          node.els = [];
        } else {
          const target = queryElement(id);
          if (target && els.includes(target)) {
            removeElement(target);
            node.els = els.filter((el) => el !== target);
          }
        }
      }
      function addElementToList(els, target) {
        els.push(target);
      }
      function mount(instance, node, id, props, head2, silent, force, anchorMetaName, ssrAdapter2) {
        if (silent && !ssrAdapter2) {
          if (id === void 0) {
            console.error("[css-render/mount]: `id` is required in `silent` mode.");
            return;
          }
          const cssrContext = window.__cssrContext;
          if (!cssrContext[id]) {
            cssrContext[id] = true;
            render(node, instance, props, silent);
          }
          return;
        }
        let style2;
        if (id === void 0) {
          style2 = node.render(props);
          id = murmur2(style2);
        }
        if (ssrAdapter2) {
          ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
          return;
        }
        const queriedTarget = queryElement(id);
        if (queriedTarget !== null && !force) {
          return queriedTarget;
        }
        const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
        if (style2 === void 0)
          style2 = node.render(props);
        target.textContent = style2;
        if (queriedTarget !== null)
          return queriedTarget;
        if (anchorMetaName) {
          const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
          if (anchorMetaEl) {
            document.head.insertBefore(target, anchorMetaEl);
            addElementToList(node.els, target);
            return target;
          }
        }
        if (head2) {
          document.head.insertBefore(target, document.head.querySelector("style, link"));
        } else {
          document.head.appendChild(target);
        }
        addElementToList(node.els, target);
        return target;
      }
      function wrappedRender(props) {
        return render(this, this.instance, props);
      }
      function wrappedMount(options = {}) {
        const { id, ssr, props, head: head2 = false, silent = false, force = false, anchorMetaName } = options;
        const targetElement = mount(this.instance, this, id, props, head2, silent, force, anchorMetaName, ssr);
        return targetElement;
      }
      function wrappedUnmount(options = {}) {
        const { id } = options;
        unmount(this.instance, this, id);
      }
      const createCNode = function(instance, $2, props, children) {
        return {
          instance,
          $: $2,
          props,
          children,
          els: [],
          render: wrappedRender,
          mount: wrappedMount,
          unmount: wrappedUnmount
        };
      };
      const c$2 = function(instance, $2, props, children) {
        if (Array.isArray($2)) {
          return createCNode(instance, { $: null }, null, $2);
        } else if (Array.isArray(props)) {
          return createCNode(instance, $2, null, props);
        } else if (Array.isArray(children)) {
          return createCNode(instance, $2, props, children);
        } else {
          return createCNode(instance, $2, props, null);
        }
      };
      function CssRender(config = {}) {
        let styleSheet = null;
        const cssr2 = {
          c: (...args) => c$2(cssr2, ...args),
          use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
          find: queryElement,
          context: {},
          config,
          get __styleSheet() {
            if (!styleSheet) {
              const style2 = document.createElement("style");
              document.head.appendChild(style2);
              styleSheet = document.styleSheets[document.styleSheets.length - 1];
              return styleSheet;
            }
            return styleSheet;
          }
        };
        return cssr2;
      }
      function exists(id, ssr) {
        if (id === void 0)
          return false;
        if (ssr) {
          const { context: { ids } } = ssr;
          return ids.has(id);
        }
        return queryElement(id) !== null;
      }
      function plugin$1(options) {
        let _bPrefix = ".";
        let _ePrefix = "__";
        let _mPrefix = "--";
        let c2;
        if (options) {
          let t = options.blockPrefix;
          if (t) {
            _bPrefix = t;
          }
          t = options.elementPrefix;
          if (t) {
            _ePrefix = t;
          }
          t = options.modifierPrefix;
          if (t) {
            _mPrefix = t;
          }
        }
        const _plugin = {
          install(instance) {
            c2 = instance.c;
            const ctx2 = instance.context;
            ctx2.bem = {};
            ctx2.bem.b = null;
            ctx2.bem.els = null;
          }
        };
        function b(arg) {
          let memorizedB;
          let memorizedE;
          return {
            before(ctx2) {
              memorizedB = ctx2.bem.b;
              memorizedE = ctx2.bem.els;
              ctx2.bem.els = null;
            },
            after(ctx2) {
              ctx2.bem.b = memorizedB;
              ctx2.bem.els = memorizedE;
            },
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              context.bem.b = arg;
              return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
            }
          };
        }
        function e(arg) {
          let memorizedE;
          return {
            before(ctx2) {
              memorizedE = ctx2.bem.els;
            },
            after(ctx2) {
              ctx2.bem.els = memorizedE;
            },
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              context.bem.els = arg.split(",").map((v) => v.trim());
              return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
            }
          };
        }
        function m(arg) {
          return {
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              const modifiers = arg.split(",").map((v) => v.trim());
              function elementToSelector(el) {
                return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
              }
              const els = context.bem.els;
              if (els !== null) {
                return elementToSelector(els[0]);
              } else {
                return elementToSelector();
              }
            }
          };
        }
        function notM(arg) {
          return {
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              const els = context.bem.els;
              return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
            }
          };
        }
        const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
        const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
        const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
        const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
        Object.assign(_plugin, {
          cB: cB2,
          cE: cE2,
          cM: cM2,
          cNotM: cNotM2
        });
        return _plugin;
      }
      function createKey(prefix2, suffix2) {
        return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
      }
      createKey("abc", "def");
      const namespace = "n";
      const prefix = `.${namespace}-`;
      const elementPrefix = "__";
      const modifierPrefix = "--";
      const cssr = CssRender();
      const plugin = plugin$1({
        blockPrefix: prefix,
        elementPrefix,
        modifierPrefix
      });
      cssr.use(plugin);
      const { c: c$1, find } = cssr;
      const { cB, cE, cM, cNotM } = plugin;
      function insideModal(style2) {
        return c$1(({ props: { bPrefix } }) => `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`, [style2]);
      }
      function insidePopover(style2) {
        return c$1(({ props: { bPrefix } }) => `${bPrefix || prefix}popover`, [style2]);
      }
      function asModal(style2) {
        return c$1(({ props: { bPrefix } }) => `&${bPrefix || prefix}modal`, style2);
      }
      const cCB = (...args) => {
        return c$1(">", [cB(...args)]);
      };
      let _isJsdom;
      function isJsdom() {
        if (_isJsdom === void 0) {
          _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
        }
        return _isJsdom;
      }
      const isBrowser$2 = typeof document !== "undefined" && typeof window !== "undefined";
      const eventSet = /* @__PURE__ */ new WeakSet();
      function markEventEffectPerformed(event) {
        eventSet.add(event);
      }
      function eventEffectNotPerformed(event) {
        return !eventSet.has(event);
      }
      function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
        var _a;
        const injection = vue.inject(injectionName, null);
        if (injection === null)
          return;
        const vm = (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
        vue.watch(registerKeyRef, registerInstance);
        registerInstance(registerKeyRef.value);
        vue.onBeforeUnmount(() => {
          registerInstance(void 0, registerKeyRef.value);
        });
        function registerInstance(key, oldKey) {
          const collection = injection[collectionKey];
          if (oldKey !== void 0)
            removeInstance(collection, oldKey);
          if (key !== void 0)
            addInstance(collection, key);
        }
        function removeInstance(collection, key) {
          if (!collection[key])
            collection[key] = [];
          collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);
        }
        function addInstance(collection, key) {
          if (!collection[key])
            collection[key] = [];
          if (!~collection[key].findIndex((instance) => instance === vm)) {
            collection[key].push(vm);
          }
        }
      }
      function useInjectionCollection(injectionName, collectionKey, valueRef) {
        const injection = vue.inject(injectionName, null);
        if (injection === null)
          return;
        if (!(collectionKey in injection)) {
          injection[collectionKey] = [];
        }
        injection[collectionKey].push(valueRef.value);
        vue.watch(valueRef, (value, prevValue) => {
          const collectionArray = injection[collectionKey];
          const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);
          if (~index)
            collectionArray.splice(index, 1);
          collectionArray.push(value);
        });
        vue.onBeforeUnmount(() => {
          const collectionArray = injection[collectionKey];
          const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);
          if (~index)
            collectionArray.splice(index, 1);
        });
      }
      function useInjectionElementCollection(injectionName, collectionKey, getElement) {
        const injection = vue.inject(injectionName, null);
        if (injection === null)
          return;
        if (!(collectionKey in injection)) {
          injection[collectionKey] = [];
        }
        vue.onMounted(() => {
          const el = getElement();
          if (!el)
            return;
          injection[collectionKey].push(el);
        });
        vue.onBeforeUnmount(() => {
          const collectionArray = injection[collectionKey];
          const element = getElement();
          const index = collectionArray.findIndex((collectionElement) => collectionElement === element);
          if (~index)
            collectionArray.splice(index, 1);
        });
      }
      function useDeferredTrue(valueRef, delay, shouldDelayRef) {
        if (!delay)
          return valueRef;
        const delayedRef = vue.ref(valueRef.value);
        let timerId = null;
        vue.watch(valueRef, (value) => {
          if (timerId !== null)
            window.clearTimeout(timerId);
          if (value === true) {
            if (shouldDelayRef && !shouldDelayRef.value) {
              delayedRef.value = true;
            } else {
              timerId = window.setTimeout(() => {
                delayedRef.value = true;
              }, delay);
            }
          } else {
            delayedRef.value = false;
          }
        });
        return delayedRef;
      }
      function useFalseUntilTruthy(originalRef) {
        const currentRef = vue.ref(!!originalRef.value);
        if (currentRef.value)
          return vue.readonly(currentRef);
        const stop = vue.watch(originalRef, (value) => {
          if (value) {
            currentRef.value = true;
            stop();
          }
        });
        return vue.readonly(currentRef);
      }
      function useMemo(getterOrOptions) {
        const computedValueRef = vue.computed(getterOrOptions);
        const valueRef = vue.ref(computedValueRef.value);
        vue.watch(computedValueRef, (value) => {
          valueRef.value = value;
        });
        if (typeof getterOrOptions === "function") {
          return valueRef;
        } else {
          return {
            __v_isRef: true,
            get value() {
              return valueRef.value;
            },
            set value(v) {
              getterOrOptions.set(v);
            }
          };
        }
      }
      function hasInstance() {
        return vue.getCurrentInstance() !== null;
      }
      const isBrowser$1 = typeof window !== "undefined";
      let fontsReady;
      let isFontReady;
      const init$1 = () => {
        var _a, _b;
        fontsReady = isBrowser$1 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
        isFontReady = false;
        if (fontsReady !== void 0) {
          void fontsReady.then(() => {
            isFontReady = true;
          });
        } else {
          isFontReady = true;
        }
      };
      init$1();
      function onFontsReady(cb) {
        if (isFontReady)
          return;
        let deactivated = false;
        vue.onMounted(() => {
          if (!isFontReady) {
            fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
              if (deactivated)
                return;
              cb();
            });
          }
        });
        vue.onBeforeUnmount(() => {
          deactivated = true;
        });
      }
      function getEventTarget(e) {
        const path = e.composedPath();
        return path[0];
      }
      const traps = {
        mousemoveoutside: /* @__PURE__ */ new WeakMap(),
        clickoutside: /* @__PURE__ */ new WeakMap()
      };
      function createTrapHandler(name, el, originalHandler) {
        if (name === "mousemoveoutside") {
          const moveHandler = (e) => {
            if (el.contains(getEventTarget(e)))
              return;
            originalHandler(e);
          };
          return {
            mousemove: moveHandler,
            touchstart: moveHandler
          };
        } else if (name === "clickoutside") {
          let mouseDownOutside = false;
          const downHandler = (e) => {
            mouseDownOutside = !el.contains(getEventTarget(e));
          };
          const upHanlder = (e) => {
            if (!mouseDownOutside)
              return;
            if (el.contains(getEventTarget(e)))
              return;
            originalHandler(e);
          };
          return {
            mousedown: downHandler,
            mouseup: upHanlder,
            touchstart: downHandler,
            touchend: upHanlder
          };
        }
        console.error(
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
        );
        return {};
      }
      function ensureTrapHandlers(name, el, handler) {
        const handlers = traps[name];
        let elHandlers = handlers.get(el);
        if (elHandlers === void 0) {
          handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
        }
        let trapHandler = elHandlers.get(handler);
        if (trapHandler === void 0) {
          elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
        }
        return trapHandler;
      }
      function trapOn(name, el, handler, options) {
        if (name === "mousemoveoutside" || name === "clickoutside") {
          const trapHandlers = ensureTrapHandlers(name, el, handler);
          Object.keys(trapHandlers).forEach((key) => {
            on(key, document, trapHandlers[key], options);
          });
          return true;
        }
        return false;
      }
      function trapOff(name, el, handler, options) {
        if (name === "mousemoveoutside" || name === "clickoutside") {
          const trapHandlers = ensureTrapHandlers(name, el, handler);
          Object.keys(trapHandlers).forEach((key) => {
            off(key, document, trapHandlers[key], options);
          });
          return true;
        }
        return false;
      }
      function createDelegate() {
        if (typeof window === "undefined") {
          return {
            on: () => {
            },
            off: () => {
            }
          };
        }
        const propagationStopped = /* @__PURE__ */ new WeakMap();
        const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
        function trackPropagation() {
          propagationStopped.set(this, true);
        }
        function trackImmediate() {
          propagationStopped.set(this, true);
          immediatePropagationStopped.set(this, true);
        }
        function spy(event, propName, fn) {
          const source = event[propName];
          event[propName] = function() {
            fn.apply(event, arguments);
            return source.apply(event, arguments);
          };
          return event;
        }
        function unspy(event, propName) {
          event[propName] = Event.prototype[propName];
        }
        const currentTargets = /* @__PURE__ */ new WeakMap();
        const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
        function getCurrentTarget() {
          var _a;
          return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
        }
        function defineCurrentTarget(event, getter) {
          if (currentTargetDescriptor === void 0)
            return;
          Object.defineProperty(event, "currentTarget", {
            configurable: true,
            enumerable: true,
            get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
          });
        }
        const phaseToTypeToElToHandlers = {
          bubble: {},
          capture: {}
        };
        const typeToWindowEventHandlers = {};
        function createUnifiedHandler() {
          const delegeteHandler = function(e) {
            const { type: type2, eventPhase, bubbles } = e;
            const target = getEventTarget(e);
            if (eventPhase === 2)
              return;
            const phase = eventPhase === 1 ? "capture" : "bubble";
            let cursor = target;
            const path = [];
            while (true) {
              if (cursor === null)
                cursor = window;
              path.push(cursor);
              if (cursor === window) {
                break;
              }
              cursor = cursor.parentNode || null;
            }
            const captureElToHandlers = phaseToTypeToElToHandlers.capture[type2];
            const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type2];
            spy(e, "stopPropagation", trackPropagation);
            spy(e, "stopImmediatePropagation", trackImmediate);
            defineCurrentTarget(e, getCurrentTarget);
            if (phase === "capture") {
              if (captureElToHandlers === void 0)
                return;
              for (let i = path.length - 1; i >= 0; --i) {
                if (propagationStopped.has(e))
                  break;
                const target2 = path[i];
                const handlers = captureElToHandlers.get(target2);
                if (handlers !== void 0) {
                  currentTargets.set(e, target2);
                  for (const handler of handlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
                if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                  const bubbleHandlers = bubbleElToHandlers.get(target2);
                  if (bubbleHandlers !== void 0) {
                    for (const handler of bubbleHandlers) {
                      if (immediatePropagationStopped.has(e))
                        break;
                      handler(e);
                    }
                  }
                }
              }
            } else if (phase === "bubble") {
              if (bubbleElToHandlers === void 0)
                return;
              for (let i = 0; i < path.length; ++i) {
                if (propagationStopped.has(e))
                  break;
                const target2 = path[i];
                const handlers = bubbleElToHandlers.get(target2);
                if (handlers !== void 0) {
                  currentTargets.set(e, target2);
                  for (const handler of handlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
            unspy(e, "stopPropagation");
            unspy(e, "stopImmediatePropagation");
            defineCurrentTarget(e);
          };
          delegeteHandler.displayName = "evtdUnifiedHandler";
          return delegeteHandler;
        }
        function createUnifiedWindowEventHandler() {
          const delegateHandler = function(e) {
            const { type: type2, eventPhase } = e;
            if (eventPhase !== 2)
              return;
            const handlers = typeToWindowEventHandlers[type2];
            if (handlers === void 0)
              return;
            handlers.forEach((handler) => handler(e));
          };
          delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
          return delegateHandler;
        }
        const unifiedHandler = createUnifiedHandler();
        const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
        function ensureElToHandlers(phase, type2) {
          const phaseHandlers = phaseToTypeToElToHandlers[phase];
          if (phaseHandlers[type2] === void 0) {
            phaseHandlers[type2] = /* @__PURE__ */ new Map();
            window.addEventListener(type2, unifiedHandler, phase === "capture");
          }
          return phaseHandlers[type2];
        }
        function ensureWindowEventHandlers(type2) {
          const windowEventHandlers = typeToWindowEventHandlers[type2];
          if (windowEventHandlers === void 0) {
            typeToWindowEventHandlers[type2] = /* @__PURE__ */ new Set();
            window.addEventListener(type2, unfiendWindowEventHandler);
          }
          return typeToWindowEventHandlers[type2];
        }
        function ensureHandlers(elToHandlers, el) {
          let elHandlers = elToHandlers.get(el);
          if (elHandlers === void 0) {
            elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
          }
          return elHandlers;
        }
        function handlerExist(el, phase, type2, handler) {
          const elToHandlers = phaseToTypeToElToHandlers[phase][type2];
          if (elToHandlers !== void 0) {
            const handlers = elToHandlers.get(el);
            if (handlers !== void 0) {
              if (handlers.has(handler))
                return true;
            }
          }
          return false;
        }
        function windowEventHandlerExist(type2, handler) {
          const handlers = typeToWindowEventHandlers[type2];
          if (handlers !== void 0) {
            if (handlers.has(handler)) {
              return true;
            }
          }
          return false;
        }
        function on2(type2, el, handler, options) {
          let mergedHandler;
          if (typeof options === "object" && options.once === true) {
            mergedHandler = (e) => {
              off2(type2, el, mergedHandler, options);
              handler(e);
            };
          } else {
            mergedHandler = handler;
          }
          const trapped = trapOn(type2, el, mergedHandler, options);
          if (trapped)
            return;
          const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
          const elToHandlers = ensureElToHandlers(phase, type2);
          const handlers = ensureHandlers(elToHandlers, el);
          if (!handlers.has(mergedHandler))
            handlers.add(mergedHandler);
          if (el === window) {
            const windowEventHandlers = ensureWindowEventHandlers(type2);
            if (!windowEventHandlers.has(mergedHandler)) {
              windowEventHandlers.add(mergedHandler);
            }
          }
        }
        function off2(type2, el, handler, options) {
          const trapped = trapOff(type2, el, handler, options);
          if (trapped)
            return;
          const capture = options === true || typeof options === "object" && options.capture === true;
          const phase = capture ? "capture" : "bubble";
          const elToHandlers = ensureElToHandlers(phase, type2);
          const handlers = ensureHandlers(elToHandlers, el);
          if (el === window) {
            const mirrorPhase = capture ? "bubble" : "capture";
            if (!handlerExist(el, mirrorPhase, type2, handler) && windowEventHandlerExist(type2, handler)) {
              const windowEventHandlers = typeToWindowEventHandlers[type2];
              windowEventHandlers.delete(handler);
              if (windowEventHandlers.size === 0) {
                window.removeEventListener(type2, unfiendWindowEventHandler);
                typeToWindowEventHandlers[type2] = void 0;
              }
            }
          }
          if (handlers.has(handler))
            handlers.delete(handler);
          if (handlers.size === 0) {
            elToHandlers.delete(el);
          }
          if (elToHandlers.size === 0) {
            window.removeEventListener(type2, unifiedHandler, phase === "capture");
            phaseToTypeToElToHandlers[phase][type2] = void 0;
          }
        }
        return {
          on: on2,
          off: off2
        };
      }
      const { on, off } = createDelegate();
      const mousePositionRef = vue.ref(null);
      function clickHandler(e) {
        if (e.clientX > 0 || e.clientY > 0) {
          mousePositionRef.value = {
            x: e.clientX,
            y: e.clientY
          };
        } else {
          const { target } = e;
          if (target instanceof Element) {
            const { left, top, width, height } = target.getBoundingClientRect();
            if (left > 0 || top > 0) {
              mousePositionRef.value = {
                x: left + width / 2,
                y: top + height / 2
              };
            } else {
              mousePositionRef.value = { x: 0, y: 0 };
            }
          } else {
            mousePositionRef.value = null;
          }
        }
      }
      let usedCount$1 = 0;
      let managable$1 = true;
      function useClickPosition() {
        if (!isBrowser$1)
          return vue.readonly(vue.ref(null));
        if (usedCount$1 === 0)
          on("click", document, clickHandler, true);
        const setup2 = () => {
          usedCount$1 += 1;
        };
        if (managable$1 && (managable$1 = hasInstance())) {
          vue.onBeforeMount(setup2);
          vue.onBeforeUnmount(() => {
            usedCount$1 -= 1;
            if (usedCount$1 === 0)
              off("click", document, clickHandler, true);
          });
        } else {
          setup2();
        }
        return vue.readonly(mousePositionRef);
      }
      const clickedTimeRef = vue.ref(void 0);
      let usedCount = 0;
      function handleClick() {
        clickedTimeRef.value = Date.now();
      }
      let managable = true;
      function useClicked(timeout) {
        if (!isBrowser$1)
          return vue.readonly(vue.ref(false));
        const clickedRef = vue.ref(false);
        let timerId = null;
        function clearTimer() {
          if (timerId !== null)
            window.clearTimeout(timerId);
        }
        function clickedHandler() {
          clearTimer();
          clickedRef.value = true;
          timerId = window.setTimeout(() => {
            clickedRef.value = false;
          }, timeout);
        }
        if (usedCount === 0) {
          on("click", window, handleClick, true);
        }
        const setup2 = () => {
          usedCount += 1;
          on("click", window, clickedHandler, true);
        };
        if (managable && (managable = hasInstance())) {
          vue.onBeforeMount(setup2);
          vue.onBeforeUnmount(() => {
            usedCount -= 1;
            if (usedCount === 0) {
              off("click", window, handleClick, true);
            }
            off("click", window, clickedHandler, true);
            clearTimer();
          });
        } else {
          setup2();
        }
        return vue.readonly(clickedRef);
      }
      function useMergedState(controlledStateRef, uncontrolledStateRef) {
        vue.watch(controlledStateRef, (value) => {
          if (value !== void 0) {
            uncontrolledStateRef.value = value;
          }
        });
        return vue.computed(() => {
          if (controlledStateRef.value === void 0) {
            return uncontrolledStateRef.value;
          }
          return controlledStateRef.value;
        });
      }
      function isMounted() {
        const isMounted2 = vue.ref(false);
        vue.onMounted(() => {
          isMounted2.value = true;
        });
        return vue.readonly(isMounted2);
      }
      function useCompitable(reactive2, keys2) {
        return vue.computed(() => {
          for (const key of keys2) {
            if (reactive2[key] !== void 0)
              return reactive2[key];
          }
          return reactive2[keys2[keys2.length - 1]];
        });
      }
      const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      !window.MSStream;
      function useIsIos() {
        return isIos;
      }
      const defaultBreakpointOptions = {
        // mobile
        // 0 ~ 640 doesn't mean it should display well in all the range,
        // but means you should treat it like a mobile phone.)
        xs: 0,
        s: 640,
        m: 1024,
        l: 1280,
        xl: 1536,
        "2xl": 1920
        // normal desktop display
      };
      function createMediaQuery(screenWidth) {
        return `(min-width: ${screenWidth}px)`;
      }
      const mqlMap = {};
      function useBreakpoints(screens = defaultBreakpointOptions) {
        if (!isBrowser$1)
          return vue.computed(() => []);
        if (typeof window.matchMedia !== "function")
          return vue.computed(() => []);
        const breakpointStatusRef = vue.ref({});
        const breakpoints = Object.keys(screens);
        const updateBreakpoints = (e, breakpointName) => {
          if (e.matches)
            breakpointStatusRef.value[breakpointName] = true;
          else
            breakpointStatusRef.value[breakpointName] = false;
        };
        breakpoints.forEach((key) => {
          const breakpointValue = screens[key];
          let mql;
          let cbs;
          if (mqlMap[breakpointValue] === void 0) {
            mql = window.matchMedia(createMediaQuery(breakpointValue));
            if (mql.addEventListener) {
              mql.addEventListener("change", (e) => {
                cbs.forEach((cb) => {
                  cb(e, key);
                });
              });
            } else if (mql.addListener) {
              mql.addListener((e) => {
                cbs.forEach((cb) => {
                  cb(e, key);
                });
              });
            }
            cbs = /* @__PURE__ */ new Set();
            mqlMap[breakpointValue] = {
              mql,
              cbs
            };
          } else {
            mql = mqlMap[breakpointValue].mql;
            cbs = mqlMap[breakpointValue].cbs;
          }
          cbs.add(updateBreakpoints);
          if (mql.matches) {
            cbs.forEach((cb) => {
              cb(mql, key);
            });
          }
        });
        vue.onBeforeUnmount(() => {
          breakpoints.forEach((breakpoint) => {
            const { cbs } = mqlMap[screens[breakpoint]];
            if (cbs.has(updateBreakpoints)) {
              cbs.delete(updateBreakpoints);
            }
          });
        });
        return vue.computed(() => {
          const { value } = breakpointStatusRef;
          return breakpoints.filter((key) => value[key]);
        });
      }
      function useKeyboard$1(options = {}, enabledRef) {
        const state = vue.reactive({
          ctrl: false,
          command: false,
          win: false,
          shift: false,
          tab: false
        });
        const { keydown, keyup } = options;
        const keydownHandler = (e) => {
          switch (e.key) {
            case "Control":
              state.ctrl = true;
              break;
            case "Meta":
              state.command = true;
              state.win = true;
              break;
            case "Shift":
              state.shift = true;
              break;
            case "Tab":
              state.tab = true;
              break;
          }
          if (keydown !== void 0) {
            Object.keys(keydown).forEach((key) => {
              if (key !== e.key)
                return;
              const handler = keydown[key];
              if (typeof handler === "function") {
                handler(e);
              } else {
                const { stop = false, prevent = false } = handler;
                if (stop)
                  e.stopPropagation();
                if (prevent)
                  e.preventDefault();
                handler.handler(e);
              }
            });
          }
        };
        const keyupHandler = (e) => {
          switch (e.key) {
            case "Control":
              state.ctrl = false;
              break;
            case "Meta":
              state.command = false;
              state.win = false;
              break;
            case "Shift":
              state.shift = false;
              break;
            case "Tab":
              state.tab = false;
              break;
          }
          if (keyup !== void 0) {
            Object.keys(keyup).forEach((key) => {
              if (key !== e.key)
                return;
              const handler = keyup[key];
              if (typeof handler === "function") {
                handler(e);
              } else {
                const { stop = false, prevent = false } = handler;
                if (stop)
                  e.stopPropagation();
                if (prevent)
                  e.preventDefault();
                handler.handler(e);
              }
            });
          }
        };
        const setup2 = () => {
          if (enabledRef === void 0 || enabledRef.value) {
            on("keydown", document, keydownHandler);
            on("keyup", document, keyupHandler);
          }
          if (enabledRef !== void 0) {
            vue.watch(enabledRef, (value) => {
              if (value) {
                on("keydown", document, keydownHandler);
                on("keyup", document, keyupHandler);
              } else {
                off("keydown", document, keydownHandler);
                off("keyup", document, keyupHandler);
              }
            });
          }
        };
        if (hasInstance()) {
          vue.onBeforeMount(setup2);
          vue.onBeforeUnmount(() => {
            if (enabledRef === void 0 || enabledRef.value) {
              off("keydown", document, keydownHandler);
              off("keyup", document, keyupHandler);
            }
          });
        } else {
          setup2();
        }
        return vue.readonly(state);
      }
      const internalSelectionMenuInjectionKey = createInjectionKey("n-internal-select-menu");
      const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
      const modalBodyInjectionKey = createInjectionKey("n-modal-body");
      const modalInjectionKey = createInjectionKey("n-modal");
      const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
      const drawerInjectionKey = createInjectionKey("n-drawer");
      const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
      const teleportDisabled = "__disabled__";
      function useAdjustedTo(props) {
        const modal = vue.inject(modalBodyInjectionKey, null);
        const drawer = vue.inject(drawerBodyInjectionKey, null);
        const popover = vue.inject(popoverBodyInjectionKey, null);
        const selectMenu = vue.inject(internalSelectionMenuBodyInjectionKey, null);
        const fullscreenElementRef = vue.ref();
        if (typeof document !== "undefined") {
          fullscreenElementRef.value = document.fullscreenElement;
          const handleFullscreenChange = () => {
            fullscreenElementRef.value = document.fullscreenElement;
          };
          vue.onMounted(() => {
            on("fullscreenchange", document, handleFullscreenChange);
          });
          vue.onBeforeUnmount(() => {
            off("fullscreenchange", document, handleFullscreenChange);
          });
        }
        return useMemo(() => {
          var _a;
          const { to } = props;
          if (to !== void 0) {
            if (to === false)
              return teleportDisabled;
            if (to === true)
              return fullscreenElementRef.value || "body";
            return to;
          }
          if (modal === null || modal === void 0 ? void 0 : modal.value) {
            return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
          }
          if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
            return drawer.value;
          if (popover === null || popover === void 0 ? void 0 : popover.value)
            return popover.value;
          if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
            return selectMenu.value;
          return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
        });
      }
      useAdjustedTo.tdkey = teleportDisabled;
      useAdjustedTo.propTo = {
        type: [String, Object, Boolean],
        default: void 0
      };
      let houdiniRegistered = false;
      function useHoudini() {
        if (!isBrowser$2)
          return;
        if (!window.CSS)
          return;
        if (!houdiniRegistered) {
          houdiniRegistered = true;
          if ("registerProperty" in (window === null || window === void 0 ? void 0 : window.CSS)) {
            try {
              ;
              CSS.registerProperty({
                name: "--n-color-start",
                syntax: "<color>",
                inherits: false,
                initialValue: "#0000"
              });
              CSS.registerProperty({
                name: "--n-color-end",
                syntax: "<color>",
                inherits: false,
                initialValue: "#0000"
              });
            } catch (e) {
            }
          }
        }
      }
      function getSlot(scope, slots, slotName = "default") {
        const slot = slots[slotName];
        if (slot === void 0) {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
        }
        return slot();
      }
      function flatten$2(vNodes, filterCommentNode = true, result = []) {
        vNodes.forEach((vNode) => {
          if (vNode === null)
            return;
          if (typeof vNode !== "object") {
            if (typeof vNode === "string" || typeof vNode === "number") {
              result.push(vue.createTextVNode(String(vNode)));
            }
            return;
          }
          if (Array.isArray(vNode)) {
            flatten$2(vNode, filterCommentNode, result);
            return;
          }
          if (vNode.type === vue.Fragment) {
            if (vNode.children === null)
              return;
            if (Array.isArray(vNode.children)) {
              flatten$2(vNode.children, filterCommentNode, result);
            }
          } else if (vNode.type !== vue.Comment) {
            result.push(vNode);
          }
        });
        return result;
      }
      function getFirstVNode(scope, slots, slotName = "default") {
        const slot = slots[slotName];
        if (slot === void 0) {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
        }
        const content = flatten$2(slot());
        if (content.length === 1) {
          return content[0];
        } else {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
        }
      }
      let viewMeasurer = null;
      function ensureViewBoundingRect() {
        if (viewMeasurer === null) {
          viewMeasurer = document.getElementById("v-binder-view-measurer");
          if (viewMeasurer === null) {
            viewMeasurer = document.createElement("div");
            viewMeasurer.id = "v-binder-view-measurer";
            const { style: style2 } = viewMeasurer;
            style2.position = "fixed";
            style2.left = "0";
            style2.right = "0";
            style2.top = "0";
            style2.bottom = "0";
            style2.pointerEvents = "none";
            style2.visibility = "hidden";
            document.body.appendChild(viewMeasurer);
          }
        }
        return viewMeasurer.getBoundingClientRect();
      }
      function getPointRect(x, y) {
        const viewRect = ensureViewBoundingRect();
        return {
          top: y,
          left: x,
          height: 0,
          width: 0,
          right: viewRect.width - x,
          bottom: viewRect.height - y
        };
      }
      function getRect$1(el) {
        const elRect = el.getBoundingClientRect();
        const viewRect = ensureViewBoundingRect();
        return {
          left: elRect.left - viewRect.left,
          top: elRect.top - viewRect.top,
          bottom: viewRect.height + viewRect.top - elRect.bottom,
          right: viewRect.width + viewRect.left - elRect.right,
          width: elRect.width,
          height: elRect.height
        };
      }
      function getParentNode(node) {
        if (node.nodeType === 9) {
          return null;
        }
        return node.parentNode;
      }
      function getScrollParent(node) {
        if (node === null)
          return null;
        const parentNode = getParentNode(node);
        if (parentNode === null) {
          return null;
        }
        if (parentNode.nodeType === 9) {
          return document;
        }
        if (parentNode.nodeType === 1) {
          const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
          if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
            return parentNode;
          }
        }
        return getScrollParent(parentNode);
      }
      const Binder = vue.defineComponent({
        name: "Binder",
        props: {
          syncTargetWithParent: Boolean,
          syncTarget: {
            type: Boolean,
            default: true
          }
        },
        setup(props) {
          var _a;
          vue.provide("VBinder", (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
          const VBinder2 = vue.inject("VBinder", null);
          const targetRef = vue.ref(null);
          const setTargetRef = (el) => {
            targetRef.value = el;
            if (VBinder2 && props.syncTargetWithParent) {
              VBinder2.setTargetRef(el);
            }
          };
          let scrollableNodes = [];
          const ensureScrollListener = () => {
            let cursor = targetRef.value;
            while (true) {
              cursor = getScrollParent(cursor);
              if (cursor === null)
                break;
              scrollableNodes.push(cursor);
            }
            for (const el of scrollableNodes) {
              on("scroll", el, onScroll, true);
            }
          };
          const removeScrollListeners = () => {
            for (const el of scrollableNodes) {
              off("scroll", el, onScroll, true);
            }
            scrollableNodes = [];
          };
          const followerScrollListeners = /* @__PURE__ */ new Set();
          const addScrollListener = (listener) => {
            if (followerScrollListeners.size === 0) {
              ensureScrollListener();
            }
            if (!followerScrollListeners.has(listener)) {
              followerScrollListeners.add(listener);
            }
          };
          const removeScrollListener = (listener) => {
            if (followerScrollListeners.has(listener)) {
              followerScrollListeners.delete(listener);
            }
            if (followerScrollListeners.size === 0) {
              removeScrollListeners();
            }
          };
          const onScroll = () => {
            beforeNextFrameOnce(onScrollRaf);
          };
          const onScrollRaf = () => {
            followerScrollListeners.forEach((listener) => listener());
          };
          const followerResizeListeners = /* @__PURE__ */ new Set();
          const addResizeListener = (listener) => {
            if (followerResizeListeners.size === 0) {
              on("resize", window, onResize);
            }
            if (!followerResizeListeners.has(listener)) {
              followerResizeListeners.add(listener);
            }
          };
          const removeResizeListener = (listener) => {
            if (followerResizeListeners.has(listener)) {
              followerResizeListeners.delete(listener);
            }
            if (followerResizeListeners.size === 0) {
              off("resize", window, onResize);
            }
          };
          const onResize = () => {
            followerResizeListeners.forEach((listener) => listener());
          };
          vue.onBeforeUnmount(() => {
            off("resize", window, onResize);
            removeScrollListeners();
          });
          return {
            targetRef,
            setTargetRef,
            addScrollListener,
            removeScrollListener,
            addResizeListener,
            removeResizeListener
          };
        },
        render() {
          return getSlot("binder", this.$slots);
        }
      });
      const VBinder = Binder;
      const VTarget = vue.defineComponent({
        name: "Target",
        setup() {
          const { setTargetRef, syncTarget } = vue.inject("VBinder");
          const setTargetDirective = {
            mounted: setTargetRef,
            updated: setTargetRef
          };
          return {
            syncTarget,
            setTargetDirective
          };
        },
        render() {
          const { syncTarget, setTargetDirective } = this;
          if (syncTarget) {
            return vue.withDirectives(getFirstVNode("follower", this.$slots), [
              [setTargetDirective]
            ]);
          }
          return getFirstVNode("follower", this.$slots);
        }
      });
      const ctxKey$1 = "@@mmoContext";
      const mousemoveoutside = {
        mounted(el, { value }) {
          el[ctxKey$1] = {
            handler: void 0
          };
          if (typeof value === "function") {
            el[ctxKey$1].handler = value;
            on("mousemoveoutside", el, value);
          }
        },
        updated(el, { value }) {
          const ctx2 = el[ctxKey$1];
          if (typeof value === "function") {
            if (ctx2.handler) {
              if (ctx2.handler !== value) {
                off("mousemoveoutside", el, ctx2.handler);
                ctx2.handler = value;
                on("mousemoveoutside", el, value);
              }
            } else {
              el[ctxKey$1].handler = value;
              on("mousemoveoutside", el, value);
            }
          } else {
            if (ctx2.handler) {
              off("mousemoveoutside", el, ctx2.handler);
              ctx2.handler = void 0;
            }
          }
        },
        unmounted(el) {
          const { handler } = el[ctxKey$1];
          if (handler) {
            off("mousemoveoutside", el, handler);
          }
          el[ctxKey$1].handler = void 0;
        }
      };
      const mousemoveoutside$1 = mousemoveoutside;
      const ctxKey = "@@coContext";
      const clickoutside = {
        mounted(el, { value, modifiers }) {
          el[ctxKey] = {
            handler: void 0
          };
          if (typeof value === "function") {
            el[ctxKey].handler = value;
            on("clickoutside", el, value, {
              capture: modifiers.capture
            });
          }
        },
        updated(el, { value, modifiers }) {
          const ctx2 = el[ctxKey];
          if (typeof value === "function") {
            if (ctx2.handler) {
              if (ctx2.handler !== value) {
                off("clickoutside", el, ctx2.handler, {
                  capture: modifiers.capture
                });
                ctx2.handler = value;
                on("clickoutside", el, value, {
                  capture: modifiers.capture
                });
              }
            } else {
              el[ctxKey].handler = value;
              on("clickoutside", el, value, {
                capture: modifiers.capture
              });
            }
          } else {
            if (ctx2.handler) {
              off("clickoutside", el, ctx2.handler, {
                capture: modifiers.capture
              });
              ctx2.handler = void 0;
            }
          }
        },
        unmounted(el, { modifiers }) {
          const { handler } = el[ctxKey];
          if (handler) {
            off("clickoutside", el, handler, {
              capture: modifiers.capture
            });
          }
          el[ctxKey].handler = void 0;
        }
      };
      const clickoutside$1 = clickoutside;
      function warn$1(location, message2) {
        console.error(`[vdirs/${location}]: ${message2}`);
      }
      class ZIndexManager {
        constructor() {
          this.elementZIndex = /* @__PURE__ */ new Map();
          this.nextZIndex = 2e3;
        }
        get elementCount() {
          return this.elementZIndex.size;
        }
        ensureZIndex(el, zIndex) {
          const { elementZIndex } = this;
          if (zIndex !== void 0) {
            el.style.zIndex = `${zIndex}`;
            elementZIndex.delete(el);
            return;
          }
          const { nextZIndex } = this;
          if (elementZIndex.has(el)) {
            const currentZIndex = elementZIndex.get(el);
            if (currentZIndex + 1 === this.nextZIndex)
              return;
          }
          el.style.zIndex = `${nextZIndex}`;
          elementZIndex.set(el, nextZIndex);
          this.nextZIndex = nextZIndex + 1;
          this.squashState();
        }
        unregister(el, zIndex) {
          const { elementZIndex } = this;
          if (elementZIndex.has(el)) {
            elementZIndex.delete(el);
          } else if (zIndex === void 0) {
            warn$1("z-index-manager/unregister-element", "Element not found when unregistering.");
          }
          this.squashState();
        }
        squashState() {
          const { elementCount } = this;
          if (!elementCount) {
            this.nextZIndex = 2e3;
          }
          if (this.nextZIndex - elementCount > 2500)
            this.rearrange();
        }
        rearrange() {
          const elementZIndexPair = Array.from(this.elementZIndex.entries());
          elementZIndexPair.sort((pair1, pair2) => {
            return pair1[1] - pair2[1];
          });
          this.nextZIndex = 2e3;
          elementZIndexPair.forEach((pair) => {
            const el = pair[0];
            const zIndex = this.nextZIndex++;
            if (`${zIndex}` !== el.style.zIndex)
              el.style.zIndex = `${zIndex}`;
          });
        }
      }
      const zIndexManager = new ZIndexManager();
      const ctx = "@@ziContext";
      const zindexable = {
        mounted(el, bindings) {
          const { value = {} } = bindings;
          const { zIndex, enabled } = value;
          el[ctx] = {
            enabled: !!enabled,
            initialized: false
          };
          if (enabled) {
            zIndexManager.ensureZIndex(el, zIndex);
            el[ctx].initialized = true;
          }
        },
        updated(el, bindings) {
          const { value = {} } = bindings;
          const { zIndex, enabled } = value;
          const cachedEnabled = el[ctx].enabled;
          if (enabled && !cachedEnabled) {
            zIndexManager.ensureZIndex(el, zIndex);
            el[ctx].initialized = true;
          }
          el[ctx].enabled = !!enabled;
        },
        unmounted(el, bindings) {
          if (!el[ctx].initialized)
            return;
          const { value = {} } = bindings;
          const { zIndex } = value;
          zIndexManager.unregister(el, zIndex);
        }
      };
      const zindexable$1 = zindexable;
      const ssrContextKey = Symbol("@css-render/vue3-ssr");
      function createStyleString(id, style2) {
        return `<style cssr-id="${id}">
${style2}
</style>`;
      }
      function ssrAdapter(id, style2) {
        const ssrContext = vue.inject(ssrContextKey, null);
        if (ssrContext === null) {
          console.error("[css-render/vue3-ssr]: no ssr context found.");
          return;
        }
        const { styles: styles2, ids } = ssrContext;
        if (ids.has(id))
          return;
        if (styles2 !== null) {
          ids.add(id);
          styles2.push(createStyleString(id, style2));
        }
      }
      const isBrowser = typeof document !== "undefined";
      function useSsrAdapter() {
        if (isBrowser)
          return void 0;
        const context = vue.inject(ssrContextKey, null);
        if (context === null)
          return void 0;
        return {
          adapter: ssrAdapter,
          context
        };
      }
      function warn(location, message2) {
        console.error(`[vueuc/${location}]: ${message2}`);
      }
      const { c } = CssRender();
      const cssrAnchorMetaName$1 = "vueuc-style";
      function lowBit(n) {
        return n & -n;
      }
      class FinweckTree {
        /**
         * @param l length of the array
         * @param min min value of the array
         */
        constructor(l, min) {
          this.l = l;
          this.min = min;
          const ft = new Array(l + 1);
          for (let i = 0; i < l + 1; ++i) {
            ft[i] = 0;
          }
          this.ft = ft;
        }
        /**
         * Add arr[i] by n, start from 0
         * @param i the index of the element to be added
         * @param n the value to be added
         */
        add(i, n) {
          if (n === 0)
            return;
          const { l, ft } = this;
          i += 1;
          while (i <= l) {
            ft[i] += n;
            i += lowBit(i);
          }
        }
        /**
         * Get the value of index i
         * @param i index
         * @returns value of the index
         */
        get(i) {
          return this.sum(i + 1) - this.sum(i);
        }
        /**
         * Get the sum of first i elements
         * @param i count of head elements to be added
         * @returns the sum of first i elements
         */
        sum(i) {
          if (i === void 0)
            i = this.l;
          if (i <= 0)
            return 0;
          const { ft, min, l } = this;
          if (i > l)
            throw new Error("[FinweckTree.sum]: `i` is larger than length.");
          let ret = i * min;
          while (i > 0) {
            ret += ft[i];
            i -= lowBit(i);
          }
          return ret;
        }
        /**
         * Get the largest count of head elements whose sum are <= threshold
         * @param threshold
         * @returns the largest count of head elements whose sum are <= threshold
         */
        getBound(threshold) {
          let l = 0;
          let r = this.l;
          while (r > l) {
            const m = Math.floor((l + r) / 2);
            const sumM = this.sum(m);
            if (sumM > threshold) {
              r = m;
              continue;
            } else if (sumM < threshold) {
              if (l === m) {
                if (this.sum(l + 1) <= threshold)
                  return l + 1;
                return m;
              }
              l = m;
            } else {
              return m;
            }
          }
          return l;
        }
      }
      function resolveTo(selector) {
        if (typeof selector === "string") {
          return document.querySelector(selector);
        }
        return selector();
      }
      const LazyTeleport = vue.defineComponent({
        name: "LazyTeleport",
        props: {
          to: {
            type: [String, Object],
            default: void 0
          },
          disabled: Boolean,
          show: {
            type: Boolean,
            required: true
          }
        },
        setup(props) {
          return {
            showTeleport: useFalseUntilTruthy(vue.toRef(props, "show")),
            mergedTo: vue.computed(() => {
              const { to } = props;
              return to !== null && to !== void 0 ? to : "body";
            })
          };
        },
        render() {
          return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : vue.h(vue.Teleport, {
            disabled: this.disabled,
            to: this.mergedTo
          }, getSlot("lazy-teleport", this.$slots)) : null;
        }
      });
      const oppositionPositions = {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      };
      const oppositeAligns = {
        start: "end",
        center: "center",
        end: "start"
      };
      const propToCompare = {
        top: "height",
        bottom: "height",
        left: "width",
        right: "width"
      };
      const transformOrigins = {
        "bottom-start": "top left",
        bottom: "top center",
        "bottom-end": "top right",
        "top-start": "bottom left",
        top: "bottom center",
        "top-end": "bottom right",
        "right-start": "top left",
        right: "center left",
        "right-end": "bottom left",
        "left-start": "top right",
        left: "center right",
        "left-end": "bottom right"
      };
      const overlapTransformOrigin = {
        "bottom-start": "bottom left",
        bottom: "bottom center",
        "bottom-end": "bottom right",
        "top-start": "top left",
        top: "top center",
        "top-end": "top right",
        "right-start": "top right",
        right: "center right",
        "right-end": "bottom right",
        "left-start": "top left",
        left: "center left",
        "left-end": "bottom left"
      };
      const oppositeAlignCssPositionProps = {
        "bottom-start": "right",
        "bottom-end": "left",
        "top-start": "right",
        "top-end": "left",
        "right-start": "bottom",
        "right-end": "top",
        "left-start": "bottom",
        "left-end": "top"
      };
      const keepOffsetDirection = {
        top: true,
        bottom: false,
        left: true,
        right: false
        // left--
      };
      const cssPositionToOppositeAlign = {
        top: "end",
        bottom: "start",
        left: "end",
        right: "start"
      };
      function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
        if (!flip || overlap) {
          return { placement, top: 0, left: 0 };
        }
        const [position, align] = placement.split("-");
        let properAlign = align !== null && align !== void 0 ? align : "center";
        let properOffset = {
          top: 0,
          left: 0
        };
        const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
          let left = 0;
          let top = 0;
          const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
          if (diff > 0 && shift) {
            if (offsetVertically2) {
              top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
            } else {
              left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
            }
          }
          return {
            left,
            top
          };
        };
        const offsetVertically = position === "left" || position === "right";
        if (properAlign !== "center") {
          const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
          const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
          const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
          if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
            if (
              // current space is not enough
              // ----------[ target ]---------|
              // -------[     follower        ]
              targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
            ) {
              const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
              if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
                if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
                  properAlign = oppositeAligns[align];
                  properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
                } else {
                  properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
                }
              } else {
                properAlign = "center";
              }
            }
          } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
            if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
            // ------------[   target   ]
            // ----------------[follower]
            targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
              properAlign = oppositeAligns[align];
            }
          }
        } else {
          const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
          const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
          const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
          const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
          if (
            // center is not enough
            // ----------- [ target ]--|
            // -------[     follower     ]
            targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
          ) {
            if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
              properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
              properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
            } else {
              properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
              properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
            }
          }
        }
        let properPosition = position;
        if (
          // space is not enough
          targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
          targetRect[position] < targetRect[oppositionPositions[position]]
        ) {
          properPosition = oppositionPositions[position];
        }
        return {
          placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
          left: properOffset.left,
          top: properOffset.top
        };
      }
      function getProperTransformOrigin(placement, overlap) {
        if (overlap)
          return overlapTransformOrigin[placement];
        return transformOrigins[placement];
      }
      function getOffset$1(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
        if (overlap) {
          switch (placement) {
            case "bottom-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: "translateY(-100%)"
              };
            case "bottom-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%) translateY(-100%)"
              };
            case "top-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: ""
              };
            case "top-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%)"
              };
            case "right-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%)"
              };
            case "right-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%) translateY(-100%)"
              };
            case "left-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: ""
              };
            case "left-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: "translateY(-100%)"
              };
            case "top":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                transform: "translateX(-50%)"
              };
            case "right":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%) translateY(-50%)"
              };
            case "left":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: "translateY(-50%)"
              };
            case "bottom":
            default:
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                transform: "translateX(-50%) translateY(-100%)"
              };
          }
        }
        switch (placement) {
          case "bottom-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: ""
            };
          case "bottom-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%)"
            };
          case "top-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-100%)"
            };
          case "top-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%) translateY(-100%)"
            };
          case "right-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: ""
            };
          case "right-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-100%)"
            };
          case "left-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%)"
            };
          case "left-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%) translateY(-100%)"
            };
          case "top":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-100%) translateX(-50%)"
            };
          case "right":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-50%)"
            };
          case "left":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-50%) translateX(-100%)"
            };
          case "bottom":
          default:
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-50%)"
            };
        }
      }
      const style$1B = c([
        c(".v-binder-follower-container", {
          position: "absolute",
          left: "0",
          right: "0",
          top: "0",
          height: "0",
          pointerEvents: "none",
          zIndex: "auto"
        }),
        c(".v-binder-follower-content", {
          position: "absolute",
          zIndex: "auto"
        }, [
          c("> *", {
            pointerEvents: "all"
          })
        ])
      ]);
      const VFollower = vue.defineComponent({
        name: "Follower",
        inheritAttrs: false,
        props: {
          show: Boolean,
          enabled: {
            type: Boolean,
            default: void 0
          },
          placement: {
            type: String,
            default: "bottom"
          },
          syncTrigger: {
            type: Array,
            default: ["resize", "scroll"]
          },
          to: [String, Object],
          flip: {
            type: Boolean,
            default: true
          },
          internalShift: Boolean,
          x: Number,
          y: Number,
          width: String,
          minWidth: String,
          containerClass: String,
          teleportDisabled: Boolean,
          zindexable: {
            type: Boolean,
            default: true
          },
          zIndex: Number,
          overlap: Boolean
        },
        setup(props) {
          const VBinder2 = vue.inject("VBinder");
          const mergedEnabledRef = useMemo(() => {
            return props.enabled !== void 0 ? props.enabled : props.show;
          });
          const followerRef = vue.ref(null);
          const offsetContainerRef = vue.ref(null);
          const ensureListeners = () => {
            const { syncTrigger } = props;
            if (syncTrigger.includes("scroll")) {
              VBinder2.addScrollListener(syncPosition);
            }
            if (syncTrigger.includes("resize")) {
              VBinder2.addResizeListener(syncPosition);
            }
          };
          const removeListeners = () => {
            VBinder2.removeScrollListener(syncPosition);
            VBinder2.removeResizeListener(syncPosition);
          };
          vue.onMounted(() => {
            if (mergedEnabledRef.value) {
              syncPosition();
              ensureListeners();
            }
          });
          const ssrAdapter2 = useSsrAdapter();
          style$1B.mount({
            id: "vueuc/binder",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          vue.onBeforeUnmount(() => {
            removeListeners();
          });
          onFontsReady(() => {
            if (mergedEnabledRef.value) {
              syncPosition();
            }
          });
          const syncPosition = () => {
            if (!mergedEnabledRef.value) {
              return;
            }
            const follower = followerRef.value;
            if (follower === null)
              return;
            const target = VBinder2.targetRef;
            const { x, y, overlap } = props;
            const targetRect = x !== void 0 && y !== void 0 ? getPointRect(x, y) : getRect$1(target);
            follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
            follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
            const { width, minWidth, placement, internalShift, flip } = props;
            follower.setAttribute("v-placement", placement);
            if (overlap) {
              follower.setAttribute("v-overlap", "");
            } else {
              follower.removeAttribute("v-overlap");
            }
            const { style: style2 } = follower;
            if (width === "target") {
              style2.width = `${targetRect.width}px`;
            } else if (width !== void 0) {
              style2.width = width;
            } else {
              style2.width = "";
            }
            if (minWidth === "target") {
              style2.minWidth = `${targetRect.width}px`;
            } else if (minWidth !== void 0) {
              style2.minWidth = minWidth;
            } else {
              style2.minWidth = "";
            }
            const followerRect = getRect$1(follower);
            const offsetContainerRect = getRect$1(offsetContainerRef.value);
            const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
            const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
            const { left, top, transform } = getOffset$1(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
            follower.setAttribute("v-placement", properPlacement);
            follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
            follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
            follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
            follower.style.setProperty("--v-transform-origin", properTransformOrigin);
            follower.style.transformOrigin = properTransformOrigin;
          };
          vue.watch(mergedEnabledRef, (value) => {
            if (value) {
              ensureListeners();
              syncOnNextTick();
            } else {
              removeListeners();
            }
          });
          const syncOnNextTick = () => {
            vue.nextTick().then(syncPosition).catch((e) => console.error(e));
          };
          [
            "placement",
            "x",
            "y",
            "internalShift",
            "flip",
            "width",
            "overlap",
            "minWidth"
          ].forEach((prop) => {
            vue.watch(vue.toRef(props, prop), syncPosition);
          });
          ["teleportDisabled"].forEach((prop) => {
            vue.watch(vue.toRef(props, prop), syncOnNextTick);
          });
          vue.watch(vue.toRef(props, "syncTrigger"), (value) => {
            if (!value.includes("resize")) {
              VBinder2.removeResizeListener(syncPosition);
            } else {
              VBinder2.addResizeListener(syncPosition);
            }
            if (!value.includes("scroll")) {
              VBinder2.removeScrollListener(syncPosition);
            } else {
              VBinder2.addScrollListener(syncPosition);
            }
          });
          const isMountedRef = isMounted();
          const mergedToRef = useMemo(() => {
            const { to } = props;
            if (to !== void 0)
              return to;
            if (isMountedRef.value) {
              return void 0;
            }
            return void 0;
          });
          return {
            VBinder: VBinder2,
            mergedEnabled: mergedEnabledRef,
            offsetContainerRef,
            followerRef,
            mergedTo: mergedToRef,
            syncPosition
          };
        },
        render() {
          return vue.h(LazyTeleport, {
            show: this.show,
            to: this.mergedTo,
            disabled: this.teleportDisabled
          }, {
            default: () => {
              var _a, _b;
              const vNode = vue.h("div", {
                class: ["v-binder-follower-container", this.containerClass],
                ref: "offsetContainerRef"
              }, [
                vue.h("div", {
                  class: "v-binder-follower-content",
                  ref: "followerRef"
                }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
              ]);
              if (this.zindexable) {
                return vue.withDirectives(vNode, [
                  [
                    zindexable$1,
                    {
                      enabled: this.mergedEnabled,
                      zIndex: this.zIndex
                    }
                  ]
                ]);
              }
              return vNode;
            }
          });
        }
      });
      var resizeObservers = [];
      var hasActiveObservations = function() {
        return resizeObservers.some(function(ro) {
          return ro.activeTargets.length > 0;
        });
      };
      var hasSkippedObservations = function() {
        return resizeObservers.some(function(ro) {
          return ro.skippedTargets.length > 0;
        });
      };
      var msg = "ResizeObserver loop completed with undelivered notifications.";
      var deliverResizeLoopError = function() {
        var event;
        if (typeof ErrorEvent === "function") {
          event = new ErrorEvent("error", {
            message: msg
          });
        } else {
          event = document.createEvent("Event");
          event.initEvent("error", false, false);
          event.message = msg;
        }
        window.dispatchEvent(event);
      };
      var ResizeObserverBoxOptions;
      (function(ResizeObserverBoxOptions2) {
        ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
        ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
        ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
      })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
      var freeze = function(obj) {
        return Object.freeze(obj);
      };
      var ResizeObserverSize = function() {
        function ResizeObserverSize2(inlineSize, blockSize) {
          this.inlineSize = inlineSize;
          this.blockSize = blockSize;
          freeze(this);
        }
        return ResizeObserverSize2;
      }();
      var DOMRectReadOnly = function() {
        function DOMRectReadOnly2(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.top = this.y;
          this.left = this.x;
          this.bottom = this.top + this.height;
          this.right = this.left + this.width;
          return freeze(this);
        }
        DOMRectReadOnly2.prototype.toJSON = function() {
          var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
          return { x, y, top, right, bottom, left, width, height };
        };
        DOMRectReadOnly2.fromRect = function(rectangle) {
          return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
        };
        return DOMRectReadOnly2;
      }();
      var isSVG = function(target) {
        return target instanceof SVGElement && "getBBox" in target;
      };
      var isHidden = function(target) {
        if (isSVG(target)) {
          var _a = target.getBBox(), width = _a.width, height = _a.height;
          return !width && !height;
        }
        var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
        return !(offsetWidth || offsetHeight || target.getClientRects().length);
      };
      var isElement = function(obj) {
        var _a;
        if (obj instanceof Element) {
          return true;
        }
        var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
        return !!(scope && obj instanceof scope.Element);
      };
      var isReplacedElement = function(target) {
        switch (target.tagName) {
          case "INPUT":
            if (target.type !== "image") {
              break;
            }
          case "VIDEO":
          case "AUDIO":
          case "EMBED":
          case "OBJECT":
          case "CANVAS":
          case "IFRAME":
          case "IMG":
            return true;
        }
        return false;
      };
      var global$1 = typeof window !== "undefined" ? window : {};
      var cache = /* @__PURE__ */ new WeakMap();
      var scrollRegexp = /auto|scroll/;
      var verticalRegexp = /^tb|vertical/;
      var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
      var parseDimension = function(pixel) {
        return parseFloat(pixel || "0");
      };
      var size = function(inlineSize, blockSize, switchSizes) {
        if (inlineSize === void 0) {
          inlineSize = 0;
        }
        if (blockSize === void 0) {
          blockSize = 0;
        }
        if (switchSizes === void 0) {
          switchSizes = false;
        }
        return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
      };
      var zeroBoxes = freeze({
        devicePixelContentBoxSize: size(),
        borderBoxSize: size(),
        contentBoxSize: size(),
        contentRect: new DOMRectReadOnly(0, 0, 0, 0)
      });
      var calculateBoxSizes = function(target, forceRecalculation) {
        if (forceRecalculation === void 0) {
          forceRecalculation = false;
        }
        if (cache.has(target) && !forceRecalculation) {
          return cache.get(target);
        }
        if (isHidden(target)) {
          cache.set(target, zeroBoxes);
          return zeroBoxes;
        }
        var cs = getComputedStyle(target);
        var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
        var removePadding = !IE && cs.boxSizing === "border-box";
        var switchSizes = verticalRegexp.test(cs.writingMode || "");
        var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
        var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
        var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
        var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
        var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
        var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
        var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
        var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
        var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
        var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
        var horizontalPadding = paddingLeft + paddingRight;
        var verticalPadding = paddingTop + paddingBottom;
        var horizontalBorderArea = borderLeft + borderRight;
        var verticalBorderArea = borderTop + borderBottom;
        var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
        var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
        var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
        var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
        var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
        var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
        var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
        var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
        var boxes = freeze({
          devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
          borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
          contentBoxSize: size(contentWidth, contentHeight, switchSizes),
          contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
        });
        cache.set(target, boxes);
        return boxes;
      };
      var calculateBoxSize = function(target, observedBox, forceRecalculation) {
        var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
        switch (observedBox) {
          case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
          case ResizeObserverBoxOptions.BORDER_BOX:
            return borderBoxSize;
          default:
            return contentBoxSize;
        }
      };
      var ResizeObserverEntry = function() {
        function ResizeObserverEntry2(target) {
          var boxes = calculateBoxSizes(target);
          this.target = target;
          this.contentRect = boxes.contentRect;
          this.borderBoxSize = freeze([boxes.borderBoxSize]);
          this.contentBoxSize = freeze([boxes.contentBoxSize]);
          this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
        }
        return ResizeObserverEntry2;
      }();
      var calculateDepthForNode = function(node) {
        if (isHidden(node)) {
          return Infinity;
        }
        var depth = 0;
        var parent = node.parentNode;
        while (parent) {
          depth += 1;
          parent = parent.parentNode;
        }
        return depth;
      };
      var broadcastActiveObservations = function() {
        var shallowestDepth = Infinity;
        var callbacks2 = [];
        resizeObservers.forEach(function processObserver(ro) {
          if (ro.activeTargets.length === 0) {
            return;
          }
          var entries = [];
          ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new ResizeObserverEntry(ot.target);
            var targetDepth = calculateDepthForNode(ot.target);
            entries.push(entry);
            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
              shallowestDepth = targetDepth;
            }
          });
          callbacks2.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
          });
          ro.activeTargets.splice(0, ro.activeTargets.length);
        });
        for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
          var callback = callbacks_1[_i];
          callback();
        }
        return shallowestDepth;
      };
      var gatherActiveObservationsAtDepth = function(depth) {
        resizeObservers.forEach(function processObserver(ro) {
          ro.activeTargets.splice(0, ro.activeTargets.length);
          ro.skippedTargets.splice(0, ro.skippedTargets.length);
          ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
              if (calculateDepthForNode(ot.target) > depth) {
                ro.activeTargets.push(ot);
              } else {
                ro.skippedTargets.push(ot);
              }
            }
          });
        });
      };
      var process$1 = function() {
        var depth = 0;
        gatherActiveObservationsAtDepth(depth);
        while (hasActiveObservations()) {
          depth = broadcastActiveObservations();
          gatherActiveObservationsAtDepth(depth);
        }
        if (hasSkippedObservations()) {
          deliverResizeLoopError();
        }
        return depth > 0;
      };
      var trigger;
      var callbacks = [];
      var notify = function() {
        return callbacks.splice(0).forEach(function(cb) {
          return cb();
        });
      };
      var queueMicroTask = function(callback) {
        if (!trigger) {
          var toggle_1 = 0;
          var el_1 = document.createTextNode("");
          var config = { characterData: true };
          new MutationObserver(function() {
            return notify();
          }).observe(el_1, config);
          trigger = function() {
            el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
          };
        }
        callbacks.push(callback);
        trigger();
      };
      var queueResizeObserver = function(cb) {
        queueMicroTask(function ResizeObserver2() {
          requestAnimationFrame(cb);
        });
      };
      var watching = 0;
      var isWatching = function() {
        return !!watching;
      };
      var CATCH_PERIOD = 250;
      var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
      var events = [
        "resize",
        "load",
        "transitionend",
        "animationend",
        "animationstart",
        "animationiteration",
        "keyup",
        "keydown",
        "mouseup",
        "mousedown",
        "mouseover",
        "mouseout",
        "blur",
        "focus"
      ];
      var time$1 = function(timeout) {
        if (timeout === void 0) {
          timeout = 0;
        }
        return Date.now() + timeout;
      };
      var scheduled = false;
      var Scheduler = function() {
        function Scheduler2() {
          var _this = this;
          this.stopped = true;
          this.listener = function() {
            return _this.schedule();
          };
        }
        Scheduler2.prototype.run = function(timeout) {
          var _this = this;
          if (timeout === void 0) {
            timeout = CATCH_PERIOD;
          }
          if (scheduled) {
            return;
          }
          scheduled = true;
          var until = time$1(timeout);
          queueResizeObserver(function() {
            var elementsHaveResized = false;
            try {
              elementsHaveResized = process$1();
            } finally {
              scheduled = false;
              timeout = until - time$1();
              if (!isWatching()) {
                return;
              }
              if (elementsHaveResized) {
                _this.run(1e3);
              } else if (timeout > 0) {
                _this.run(timeout);
              } else {
                _this.start();
              }
            }
          });
        };
        Scheduler2.prototype.schedule = function() {
          this.stop();
          this.run();
        };
        Scheduler2.prototype.observe = function() {
          var _this = this;
          var cb = function() {
            return _this.observer && _this.observer.observe(document.body, observerConfig);
          };
          document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
        };
        Scheduler2.prototype.start = function() {
          var _this = this;
          if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events.forEach(function(name) {
              return global$1.addEventListener(name, _this.listener, true);
            });
          }
        };
        Scheduler2.prototype.stop = function() {
          var _this = this;
          if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events.forEach(function(name) {
              return global$1.removeEventListener(name, _this.listener, true);
            });
            this.stopped = true;
          }
        };
        return Scheduler2;
      }();
      var scheduler = new Scheduler();
      var updateCount = function(n) {
        !watching && n > 0 && scheduler.start();
        watching += n;
        !watching && scheduler.stop();
      };
      var skipNotifyOnElement = function(target) {
        return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
      };
      var ResizeObservation = function() {
        function ResizeObservation2(target, observedBox) {
          this.target = target;
          this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
          this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
          };
        }
        ResizeObservation2.prototype.isActive = function() {
          var size2 = calculateBoxSize(this.target, this.observedBox, true);
          if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size2;
          }
          if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
            return true;
          }
          return false;
        };
        return ResizeObservation2;
      }();
      var ResizeObserverDetail = function() {
        function ResizeObserverDetail2(resizeObserver, callback) {
          this.activeTargets = [];
          this.skippedTargets = [];
          this.observationTargets = [];
          this.observer = resizeObserver;
          this.callback = callback;
        }
        return ResizeObserverDetail2;
      }();
      var observerMap = /* @__PURE__ */ new WeakMap();
      var getObservationIndex = function(observationTargets, target) {
        for (var i = 0; i < observationTargets.length; i += 1) {
          if (observationTargets[i].target === target) {
            return i;
          }
        }
        return -1;
      };
      var ResizeObserverController = function() {
        function ResizeObserverController2() {
        }
        ResizeObserverController2.connect = function(resizeObserver, callback) {
          var detail = new ResizeObserverDetail(resizeObserver, callback);
          observerMap.set(resizeObserver, detail);
        };
        ResizeObserverController2.observe = function(resizeObserver, target, options) {
          var detail = observerMap.get(resizeObserver);
          var firstObservation = detail.observationTargets.length === 0;
          if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && resizeObservers.push(detail);
            detail.observationTargets.push(new ResizeObservation(target, options && options.box));
            updateCount(1);
            scheduler.schedule();
          }
        };
        ResizeObserverController2.unobserve = function(resizeObserver, target) {
          var detail = observerMap.get(resizeObserver);
          var index = getObservationIndex(detail.observationTargets, target);
          var lastObservation = detail.observationTargets.length === 1;
          if (index >= 0) {
            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            updateCount(-1);
          }
        };
        ResizeObserverController2.disconnect = function(resizeObserver) {
          var _this = this;
          var detail = observerMap.get(resizeObserver);
          detail.observationTargets.slice().forEach(function(ot) {
            return _this.unobserve(resizeObserver, ot.target);
          });
          detail.activeTargets.splice(0, detail.activeTargets.length);
        };
        return ResizeObserverController2;
      }();
      var ResizeObserver = function() {
        function ResizeObserver2(callback) {
          if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (typeof callback !== "function") {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
          }
          ResizeObserverController.connect(this, callback);
        }
        ResizeObserver2.prototype.observe = function(target, options) {
          if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (!isElement(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
          }
          ResizeObserverController.observe(this, target, options);
        };
        ResizeObserver2.prototype.unobserve = function(target) {
          if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (!isElement(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
          }
          ResizeObserverController.unobserve(this, target);
        };
        ResizeObserver2.prototype.disconnect = function() {
          ResizeObserverController.disconnect(this);
        };
        ResizeObserver2.toString = function() {
          return "function ResizeObserver () { [polyfill code] }";
        };
        return ResizeObserver2;
      }();
      class ResizeObserverDelegate {
        constructor() {
          this.handleResize = this.handleResize.bind(this);
          this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
          this.elHandlersMap = /* @__PURE__ */ new Map();
        }
        handleResize(entries) {
          for (const entry of entries) {
            const handler = this.elHandlersMap.get(entry.target);
            if (handler !== void 0) {
              handler(entry);
            }
          }
        }
        registerHandler(el, handler) {
          this.elHandlersMap.set(el, handler);
          this.observer.observe(el);
        }
        unregisterHandler(el) {
          if (!this.elHandlersMap.has(el)) {
            return;
          }
          this.elHandlersMap.delete(el);
          this.observer.unobserve(el);
        }
      }
      const resizeObserverManager = new ResizeObserverDelegate();
      const VResizeObserver = vue.defineComponent({
        name: "ResizeObserver",
        props: {
          onResize: Function
        },
        setup(props) {
          let registered = false;
          const proxy = vue.getCurrentInstance().proxy;
          function handleResize(entry) {
            const { onResize } = props;
            if (onResize !== void 0)
              onResize(entry);
          }
          vue.onMounted(() => {
            const el = proxy.$el;
            if (el === void 0) {
              warn("resize-observer", "$el does not exist.");
              return;
            }
            if (el.nextElementSibling !== el.nextSibling) {
              if (el.nodeType === 3 && el.nodeValue !== "") {
                warn("resize-observer", "$el can not be observed (it may be a text node).");
                return;
              }
            }
            if (el.nextElementSibling !== null) {
              resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
              registered = true;
            }
          });
          vue.onBeforeUnmount(() => {
            if (registered) {
              resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
            }
          });
        },
        render() {
          return vue.renderSlot(this.$slots, "default");
        }
      });
      let maybeTouch;
      function ensureMaybeTouch() {
        if (maybeTouch === void 0) {
          if ("matchMedia" in window) {
            maybeTouch = window.matchMedia("(pointer:coarse)").matches;
          } else {
            maybeTouch = false;
          }
        }
        return maybeTouch;
      }
      let wheelScale;
      function ensureWheelScale() {
        if (wheelScale === void 0) {
          wheelScale = "chrome" in window ? window.devicePixelRatio : 1;
        }
        return wheelScale;
      }
      const styles$1 = c(".v-vl", {
        maxHeight: "inherit",
        height: "100%",
        overflow: "auto",
        minWidth: "1px"
        // a zero width container won't be scrollable
      }, [
        c("&:not(.v-vl--show-scrollbar)", {
          scrollbarWidth: "none"
        }, [
          c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", {
            width: 0,
            height: 0,
            display: "none"
          })
        ])
      ]);
      const VVirtualList = vue.defineComponent({
        name: "VirtualList",
        inheritAttrs: false,
        props: {
          showScrollbar: {
            type: Boolean,
            default: true
          },
          items: {
            type: Array,
            default: () => []
          },
          // it is suppose to be the min height
          itemSize: {
            type: Number,
            required: true
          },
          itemResizable: Boolean,
          itemsStyle: [String, Object],
          visibleItemsTag: {
            type: [String, Object],
            default: "div"
          },
          visibleItemsProps: Object,
          ignoreItemResize: Boolean,
          onScroll: Function,
          onWheel: Function,
          onResize: Function,
          defaultScrollKey: [Number, String],
          defaultScrollIndex: Number,
          keyField: {
            type: String,
            default: "key"
          },
          // Whether it is a good API?
          // ResizeObserver + footer & header is not enough.
          // Too complex for simple case
          paddingTop: {
            type: [Number, String],
            default: 0
          },
          paddingBottom: {
            type: [Number, String],
            default: 0
          }
        },
        setup(props) {
          const ssrAdapter2 = useSsrAdapter();
          styles$1.mount({
            id: "vueuc/virtual-list",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          vue.onMounted(() => {
            const { defaultScrollIndex, defaultScrollKey } = props;
            if (defaultScrollIndex !== void 0 && defaultScrollIndex !== null) {
              scrollTo({ index: defaultScrollIndex });
            } else if (defaultScrollKey !== void 0 && defaultScrollKey !== null) {
              scrollTo({ key: defaultScrollKey });
            }
          });
          let isDeactivated = false;
          let activateStateInitialized = false;
          vue.onActivated(() => {
            isDeactivated = false;
            if (!activateStateInitialized) {
              activateStateInitialized = true;
              return;
            }
            scrollTo({ top: scrollTopRef.value, left: scrollLeft });
          });
          vue.onDeactivated(() => {
            isDeactivated = true;
            if (!activateStateInitialized) {
              activateStateInitialized = true;
            }
          });
          const keyIndexMapRef = vue.computed(() => {
            const map2 = /* @__PURE__ */ new Map();
            const { keyField } = props;
            props.items.forEach((item, index) => {
              map2.set(item[keyField], index);
            });
            return map2;
          });
          const listElRef = vue.ref(null);
          const listHeightRef = vue.ref(void 0);
          const keyToHeightOffset = /* @__PURE__ */ new Map();
          const finweckTreeRef = vue.computed(() => {
            const { items, itemSize, keyField } = props;
            const ft = new FinweckTree(items.length, itemSize);
            items.forEach((item, index) => {
              const key = item[keyField];
              const heightOffset = keyToHeightOffset.get(key);
              if (heightOffset !== void 0) {
                ft.add(index, heightOffset);
              }
            });
            return ft;
          });
          const finweckTreeUpdateTrigger = vue.ref(0);
          let scrollLeft = 0;
          const scrollTopRef = vue.ref(0);
          const startIndexRef = useMemo(() => {
            return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);
          });
          const viewportItemsRef = vue.computed(() => {
            const { value: listHeight } = listHeightRef;
            if (listHeight === void 0)
              return [];
            const { items, itemSize } = props;
            const startIndex = startIndexRef.value;
            const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);
            const viewportItems = [];
            for (let i = startIndex; i <= endIndex; ++i) {
              viewportItems.push(items[i]);
            }
            return viewportItems;
          });
          const scrollTo = (options, y) => {
            if (typeof options === "number") {
              scrollToPosition(options, y, "auto");
              return;
            }
            const { left, top, index, key, position, behavior, debounce: debounce2 = true } = options;
            if (left !== void 0 || top !== void 0) {
              scrollToPosition(left, top, behavior);
            } else if (index !== void 0) {
              scrollToIndex(index, behavior, debounce2);
            } else if (key !== void 0) {
              const toIndex = keyIndexMapRef.value.get(key);
              if (toIndex !== void 0)
                scrollToIndex(toIndex, behavior, debounce2);
            } else if (position === "bottom") {
              scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);
            } else if (position === "top") {
              scrollToPosition(0, 0, behavior);
            }
          };
          let anchorIndex;
          let anchorTimerId = null;
          function scrollToIndex(index, behavior, debounce2) {
            const { value: ft } = finweckTreeRef;
            const targetTop = ft.sum(index) + depx(props.paddingTop);
            if (!debounce2) {
              listElRef.value.scrollTo({
                left: 0,
                top: targetTop,
                behavior
              });
            } else {
              anchorIndex = index;
              if (anchorTimerId !== null) {
                window.clearTimeout(anchorTimerId);
              }
              anchorTimerId = window.setTimeout(() => {
                anchorIndex = void 0;
                anchorTimerId = null;
              }, 16);
              const { scrollTop, offsetHeight } = listElRef.value;
              if (targetTop > scrollTop) {
                const itemSize = ft.get(index);
                if (targetTop + itemSize <= scrollTop + offsetHeight)
                  ;
                else {
                  listElRef.value.scrollTo({
                    left: 0,
                    top: targetTop + itemSize - offsetHeight,
                    behavior
                  });
                }
              } else {
                listElRef.value.scrollTo({
                  left: 0,
                  top: targetTop,
                  behavior
                });
              }
            }
          }
          function scrollToPosition(left, top, behavior) {
            listElRef.value.scrollTo({
              left,
              top,
              behavior
            });
          }
          function handleItemResize(key, entry) {
            var _a, _b, _c;
            if (isDeactivated)
              return;
            if (props.ignoreItemResize)
              return;
            if (isHideByVShow(entry.target))
              return;
            const { value: ft } = finweckTreeRef;
            const index = keyIndexMapRef.value.get(key);
            const previousHeight = ft.get(index);
            const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;
            if (height === previousHeight)
              return;
            const offset = height - props.itemSize;
            if (offset === 0) {
              keyToHeightOffset.delete(key);
            } else {
              keyToHeightOffset.set(key, height - props.itemSize);
            }
            const delta = height - previousHeight;
            if (delta === 0)
              return;
            ft.add(index, delta);
            const listEl = listElRef.value;
            if (listEl != null) {
              if (anchorIndex === void 0) {
                const previousHeightSum = ft.sum(index);
                if (listEl.scrollTop > previousHeightSum) {
                  listEl.scrollBy(0, delta);
                }
              } else {
                if (index < anchorIndex) {
                  listEl.scrollBy(0, delta);
                } else if (index === anchorIndex) {
                  const previousHeightSum = ft.sum(index);
                  if (height + previousHeightSum > // Note, listEl shouldn't have border, nor offsetHeight won't be
                  // correct
                  listEl.scrollTop + listEl.offsetHeight) {
                    listEl.scrollBy(0, delta);
                  }
                }
              }
              syncViewport();
            }
            finweckTreeUpdateTrigger.value++;
          }
          const mayUseWheel = !ensureMaybeTouch();
          let wheelCatched = false;
          function handleListScroll(e) {
            var _a;
            (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
            if (!mayUseWheel || !wheelCatched) {
              syncViewport();
            }
          }
          function handleListWheel(e) {
            var _a;
            (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
            if (mayUseWheel) {
              const listEl = listElRef.value;
              if (listEl != null) {
                if (e.deltaX === 0) {
                  if (listEl.scrollTop === 0 && e.deltaY <= 0) {
                    return;
                  }
                  if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {
                    return;
                  }
                }
                e.preventDefault();
                listEl.scrollTop += e.deltaY / ensureWheelScale();
                listEl.scrollLeft += e.deltaX / ensureWheelScale();
                syncViewport();
                wheelCatched = true;
                beforeNextFrameOnce(() => {
                  wheelCatched = false;
                });
              }
            }
          }
          function handleListResize(entry) {
            if (isDeactivated)
              return;
            if (isHideByVShow(entry.target))
              return;
            if (entry.contentRect.height === listHeightRef.value)
              return;
            listHeightRef.value = entry.contentRect.height;
            const { onResize } = props;
            if (onResize !== void 0)
              onResize(entry);
          }
          function syncViewport() {
            const { value: listEl } = listElRef;
            if (listEl == null)
              return;
            scrollTopRef.value = listEl.scrollTop;
            scrollLeft = listEl.scrollLeft;
          }
          function isHideByVShow(el) {
            let cursor = el;
            while (cursor !== null) {
              if (cursor.style.display === "none")
                return true;
              cursor = cursor.parentElement;
            }
            return false;
          }
          return {
            listHeight: listHeightRef,
            listStyle: {
              overflow: "auto"
            },
            keyToIndex: keyIndexMapRef,
            itemsStyle: vue.computed(() => {
              const { itemResizable } = props;
              const height = pxfy(finweckTreeRef.value.sum());
              finweckTreeUpdateTrigger.value;
              return [
                props.itemsStyle,
                {
                  boxSizing: "content-box",
                  height: itemResizable ? "" : height,
                  minHeight: itemResizable ? height : "",
                  paddingTop: pxfy(props.paddingTop),
                  paddingBottom: pxfy(props.paddingBottom)
                }
              ];
            }),
            visibleItemsStyle: vue.computed(() => {
              finweckTreeUpdateTrigger.value;
              return {
                transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`
              };
            }),
            viewportItems: viewportItemsRef,
            listElRef,
            itemsElRef: vue.ref(null),
            scrollTo,
            handleListResize,
            handleListScroll,
            handleListWheel,
            handleItemResize
          };
        },
        render() {
          const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;
          return vue.h(VResizeObserver, {
            onResize: this.handleListResize
          }, {
            default: () => {
              var _a, _b;
              return vue.h("div", vue.mergeProps(this.$attrs, {
                class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"],
                onScroll: this.handleListScroll,
                onWheel: this.handleListWheel,
                ref: "listElRef"
              }), [
                this.items.length !== 0 ? vue.h("div", {
                  ref: "itemsElRef",
                  class: "v-vl-items",
                  style: this.itemsStyle
                }, [
                  vue.h(visibleItemsTag, Object.assign({
                    class: "v-vl-visible-items",
                    style: this.visibleItemsStyle
                  }, this.visibleItemsProps), {
                    default: () => this.viewportItems.map((item) => {
                      const key = item[keyField];
                      const index = keyToIndex.get(key);
                      const itemVNode = this.$slots.default({
                        item,
                        index
                      })[0];
                      if (itemResizable) {
                        return vue.h(VResizeObserver, {
                          key,
                          onResize: (entry) => this.handleItemResize(key, entry)
                        }, {
                          default: () => itemVNode
                        });
                      }
                      itemVNode.key = key;
                      return itemVNode;
                    })
                  })
                ]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)
              ]);
            }
          });
        }
      });
      const styles = c(".v-x-scroll", {
        overflow: "auto",
        scrollbarWidth: "none"
      }, [
        c("&::-webkit-scrollbar", {
          width: 0,
          height: 0
        })
      ]);
      const VXScroll = vue.defineComponent({
        name: "XScroll",
        props: {
          disabled: Boolean,
          onScroll: Function
        },
        setup() {
          const selfRef = vue.ref(null);
          function handleWheel(e) {
            const preventYWheel = e.currentTarget.offsetWidth < e.currentTarget.scrollWidth;
            if (!preventYWheel || e.deltaY === 0)
              return;
            e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
            e.preventDefault();
          }
          const ssrAdapter2 = useSsrAdapter();
          styles.mount({
            id: "vueuc/x-scroll",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          const exposedMethods = {
            scrollTo(...args) {
              var _a;
              (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...args);
            }
          };
          return Object.assign({
            selfRef,
            handleWheel
          }, exposedMethods);
        },
        render() {
          return vue.h("div", {
            ref: "selfRef",
            onScroll: this.onScroll,
            onWheel: this.disabled ? void 0 : this.handleWheel,
            class: "v-x-scroll"
          }, this.$slots);
        }
      });
      const hiddenAttr = "v-hidden";
      const style$1A = c("[v-hidden]", {
        display: "none!important"
      });
      const VOverflow = vue.defineComponent({
        name: "Overflow",
        props: {
          getCounter: Function,
          getTail: Function,
          updateCounter: Function,
          onUpdateOverflow: Function
        },
        setup(props, { slots }) {
          const selfRef = vue.ref(null);
          const counterRef = vue.ref(null);
          function deriveCounter() {
            const { value: self2 } = selfRef;
            const { getCounter, getTail } = props;
            let counter;
            if (getCounter !== void 0)
              counter = getCounter();
            else {
              counter = counterRef.value;
            }
            if (!self2 || !counter)
              return;
            if (counter.hasAttribute(hiddenAttr)) {
              counter.removeAttribute(hiddenAttr);
            }
            const { children } = self2;
            const containerWidth = self2.offsetWidth;
            const childWidths = [];
            const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
            let childWidthSum = tail ? tail.offsetWidth : 0;
            let overflow = false;
            const len2 = self2.children.length - (slots.tail ? 1 : 0);
            for (let i = 0; i < len2 - 1; ++i) {
              if (i < 0)
                continue;
              const child = children[i];
              if (overflow) {
                if (!child.hasAttribute(hiddenAttr)) {
                  child.setAttribute(hiddenAttr, "");
                }
                continue;
              } else if (child.hasAttribute(hiddenAttr)) {
                child.removeAttribute(hiddenAttr);
              }
              const childWidth = child.offsetWidth;
              childWidthSum += childWidth;
              childWidths[i] = childWidth;
              if (childWidthSum > containerWidth) {
                const { updateCounter } = props;
                for (let j = i; j >= 0; --j) {
                  const restCount = len2 - 1 - j;
                  if (updateCounter !== void 0) {
                    updateCounter(restCount);
                  } else {
                    counter.textContent = `${restCount}`;
                  }
                  const counterWidth = counter.offsetWidth;
                  childWidthSum -= childWidths[j];
                  if (childWidthSum + counterWidth <= containerWidth || j === 0) {
                    overflow = true;
                    i = j - 1;
                    if (tail) {
                      if (i === -1) {
                        tail.style.maxWidth = `${containerWidth - counterWidth}px`;
                        tail.style.boxSizing = "border-box";
                      } else {
                        tail.style.maxWidth = "";
                      }
                    }
                    break;
                  }
                }
              }
            }
            const { onUpdateOverflow } = props;
            if (!overflow) {
              if (onUpdateOverflow !== void 0) {
                onUpdateOverflow(false);
              }
              counter.setAttribute(hiddenAttr, "");
            } else {
              if (onUpdateOverflow !== void 0) {
                onUpdateOverflow(true);
              }
            }
          }
          const ssrAdapter2 = useSsrAdapter();
          style$1A.mount({
            id: "vueuc/overflow",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          vue.onMounted(deriveCounter);
          return {
            selfRef,
            counterRef,
            sync: deriveCounter
          };
        },
        render() {
          const { $slots } = this;
          vue.nextTick(this.sync);
          return vue.h("div", {
            class: "v-overflow",
            ref: "selfRef"
          }, [
            vue.renderSlot($slots, "default"),
            // $slots.counter should only has 1 element
            $slots.counter ? $slots.counter() : vue.h("span", {
              style: {
                display: "inline-block"
              },
              ref: "counterRef"
            }),
            // $slots.tail should only has 1 element
            $slots.tail ? $slots.tail() : null
          ]);
        }
      });
      function isHTMLElement(node) {
        return node instanceof HTMLElement;
      }
      function focusFirstDescendant(node) {
        for (let i = 0; i < node.childNodes.length; i++) {
          const child = node.childNodes[i];
          if (isHTMLElement(child)) {
            if (attemptFocus(child) || focusFirstDescendant(child)) {
              return true;
            }
          }
        }
        return false;
      }
      function focusLastDescendant(element) {
        for (let i = element.childNodes.length - 1; i >= 0; i--) {
          const child = element.childNodes[i];
          if (isHTMLElement(child)) {
            if (attemptFocus(child) || focusLastDescendant(child)) {
              return true;
            }
          }
        }
        return false;
      }
      function attemptFocus(element) {
        if (!isFocusable(element)) {
          return false;
        }
        try {
          element.focus({ preventScroll: true });
        } catch (e) {
        }
        return document.activeElement === element;
      }
      function isFocusable(element) {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.getAttribute("disabled")) {
          return false;
        }
        switch (element.nodeName) {
          case "A":
            return !!element.href && element.rel !== "ignore";
          case "INPUT":
            return element.type !== "hidden" && element.type !== "file";
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA":
            return true;
          default:
            return false;
        }
      }
      let stack = [];
      const FocusTrap = vue.defineComponent({
        name: "FocusTrap",
        props: {
          disabled: Boolean,
          active: Boolean,
          autoFocus: {
            type: Boolean,
            default: true
          },
          onEsc: Function,
          initialFocusTo: String,
          finalFocusTo: String,
          returnFocusOnDeactivated: {
            type: Boolean,
            default: true
          }
        },
        setup(props) {
          const id = createId();
          const focusableStartRef = vue.ref(null);
          const focusableEndRef = vue.ref(null);
          let activated = false;
          let ignoreInternalFocusChange = false;
          const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
          function isCurrentActive() {
            const currentActiveId = stack[stack.length - 1];
            return currentActiveId === id;
          }
          function handleDocumentKeydown(e) {
            var _a;
            if (e.code === "Escape") {
              if (isCurrentActive()) {
                (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
              }
            }
          }
          vue.onMounted(() => {
            vue.watch(() => props.active, (value) => {
              if (value) {
                activate();
                on("keydown", document, handleDocumentKeydown);
              } else {
                off("keydown", document, handleDocumentKeydown);
                if (activated) {
                  deactivate();
                }
              }
            }, {
              immediate: true
            });
          });
          vue.onBeforeUnmount(() => {
            off("keydown", document, handleDocumentKeydown);
            if (activated)
              deactivate();
          });
          function handleDocumentFocus(e) {
            if (ignoreInternalFocusChange)
              return;
            if (isCurrentActive()) {
              const mainEl = getMainEl();
              if (mainEl === null)
                return;
              if (mainEl.contains(getPreciseEventTarget(e)))
                return;
              resetFocusTo("first");
            }
          }
          function getMainEl() {
            const focusableStartEl = focusableStartRef.value;
            if (focusableStartEl === null)
              return null;
            let mainEl = focusableStartEl;
            while (true) {
              mainEl = mainEl.nextSibling;
              if (mainEl === null)
                break;
              if (mainEl instanceof Element && mainEl.tagName === "DIV") {
                break;
              }
            }
            return mainEl;
          }
          function activate() {
            var _a;
            if (props.disabled)
              return;
            stack.push(id);
            if (props.autoFocus) {
              const { initialFocusTo } = props;
              if (initialFocusTo === void 0) {
                resetFocusTo("first");
              } else {
                (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
              }
            }
            activated = true;
            document.addEventListener("focus", handleDocumentFocus, true);
          }
          function deactivate() {
            var _a;
            if (props.disabled)
              return;
            document.removeEventListener("focus", handleDocumentFocus, true);
            stack = stack.filter((idInStack) => idInStack !== id);
            if (isCurrentActive())
              return;
            const { finalFocusTo } = props;
            if (finalFocusTo !== void 0) {
              (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            } else if (props.returnFocusOnDeactivated) {
              if (lastFocusedElement instanceof HTMLElement) {
                ignoreInternalFocusChange = true;
                lastFocusedElement.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
          function resetFocusTo(target) {
            if (!isCurrentActive())
              return;
            if (props.active) {
              const focusableStartEl = focusableStartRef.value;
              const focusableEndEl = focusableEndRef.value;
              if (focusableStartEl !== null && focusableEndEl !== null) {
                const mainEl = getMainEl();
                if (mainEl == null || mainEl === focusableEndEl) {
                  ignoreInternalFocusChange = true;
                  focusableStartEl.focus({ preventScroll: true });
                  ignoreInternalFocusChange = false;
                  return;
                }
                ignoreInternalFocusChange = true;
                const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
                ignoreInternalFocusChange = false;
                if (!focused) {
                  ignoreInternalFocusChange = true;
                  focusableStartEl.focus({ preventScroll: true });
                  ignoreInternalFocusChange = false;
                }
              }
            }
          }
          function handleStartFocus(e) {
            if (ignoreInternalFocusChange)
              return;
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
              resetFocusTo("last");
            } else {
              resetFocusTo("first");
            }
          }
          function handleEndFocus(e) {
            if (ignoreInternalFocusChange)
              return;
            if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
              resetFocusTo("last");
            } else {
              resetFocusTo("first");
            }
          }
          return {
            focusableStartRef,
            focusableEndRef,
            focusableStyle: "position: absolute; height: 0; width: 0;",
            handleStartFocus,
            handleEndFocus
          };
        },
        render() {
          const { default: defaultSlot } = this.$slots;
          if (defaultSlot === void 0)
            return null;
          if (this.disabled)
            return defaultSlot();
          const { active, focusableStyle } = this;
          return vue.h(vue.Fragment, null, [
            vue.h("div", {
              "aria-hidden": "true",
              tabindex: active ? "0" : "-1",
              ref: "focusableStartRef",
              style: focusableStyle,
              onFocus: this.handleStartFocus
            }),
            defaultSlot(),
            vue.h("div", {
              "aria-hidden": "true",
              style: focusableStyle,
              ref: "focusableEndRef",
              tabindex: active ? "0" : "-1",
              onFocus: this.handleEndFocus
            })
          ]);
        }
      });
      function useOnResize(elRef, onResize) {
        if (onResize) {
          vue.onMounted(() => {
            const { value: el } = elRef;
            if (el) {
              resizeObserverManager.registerHandler(el, onResize);
            }
          });
          vue.onBeforeUnmount(() => {
            const { value: el } = elRef;
            if (el) {
              resizeObserverManager.unregisterHandler(el);
            }
          });
        }
      }
      let lockCount = 0;
      let originalMarginRight = "";
      let originalOverflow = "";
      let originalOverflowX = "";
      let originalOverflowY = "";
      const lockHtmlScrollRightCompensationRef = vue.ref("0px");
      function useLockHtmlScroll(lockRef) {
        if (typeof document === "undefined")
          return;
        const el = document.documentElement;
        let watchStopHandle;
        let activated = false;
        const unlock = () => {
          el.style.marginRight = originalMarginRight;
          el.style.overflow = originalOverflow;
          el.style.overflowX = originalOverflowX;
          el.style.overflowY = originalOverflowY;
          lockHtmlScrollRightCompensationRef.value = "0px";
        };
        vue.onMounted(() => {
          watchStopHandle = vue.watch(lockRef, (value) => {
            if (value) {
              if (!lockCount) {
                const scrollbarWidth = window.innerWidth - el.offsetWidth;
                if (scrollbarWidth > 0) {
                  originalMarginRight = el.style.marginRight;
                  el.style.marginRight = `${scrollbarWidth}px`;
                  lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
                }
                originalOverflow = el.style.overflow;
                originalOverflowX = el.style.overflowX;
                originalOverflowY = el.style.overflowY;
                el.style.overflow = "hidden";
                el.style.overflowX = "hidden";
                el.style.overflowY = "hidden";
              }
              activated = true;
              lockCount++;
            } else {
              lockCount--;
              if (!lockCount) {
                unlock();
              }
              activated = false;
            }
          }, {
            immediate: true
          });
        });
        vue.onBeforeUnmount(() => {
          watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
          if (activated) {
            lockCount--;
            if (!lockCount) {
              unlock();
            }
            activated = false;
          }
        });
      }
      const isComposingRef = vue.ref(false);
      const compositionStartHandler = () => {
        isComposingRef.value = true;
      };
      const compositionEndHandler = () => {
        isComposingRef.value = false;
      };
      let mountedCount = 0;
      const useIsComposing = () => {
        if (isBrowser$2) {
          vue.onBeforeMount(() => {
            if (!mountedCount) {
              window.addEventListener("compositionstart", compositionStartHandler);
              window.addEventListener("compositionend", compositionEndHandler);
            }
            mountedCount++;
          });
          vue.onBeforeUnmount(() => {
            if (mountedCount <= 1) {
              window.removeEventListener("compositionstart", compositionStartHandler);
              window.removeEventListener("compositionend", compositionEndHandler);
              mountedCount = 0;
            } else {
              mountedCount--;
            }
          });
        }
        return isComposingRef;
      };
      function useReactivated(callback) {
        const isDeactivatedRef = { isDeactivated: false };
        let activateStateInitialized = false;
        vue.onActivated(() => {
          isDeactivatedRef.isDeactivated = false;
          if (!activateStateInitialized) {
            activateStateInitialized = true;
            return;
          }
          callback();
        });
        vue.onDeactivated(() => {
          isDeactivatedRef.isDeactivated = true;
          if (!activateStateInitialized) {
            activateStateInitialized = true;
          }
        });
        return isDeactivatedRef;
      }
      function isDocument(node) {
        return node.nodeName === "#document";
      }
      const formItemInjectionKey = createInjectionKey("n-form-item");
      function useFormItem(props, { defaultSize = "medium", mergedSize, mergedDisabled } = {}) {
        const NFormItem2 = vue.inject(formItemInjectionKey, null);
        vue.provide(formItemInjectionKey, null);
        const mergedSizeRef = vue.computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
          const { size: size2 } = props;
          if (size2)
            return size2;
          if (NFormItem2) {
            const { mergedSize: mergedSize2 } = NFormItem2;
            if (mergedSize2.value !== void 0) {
              return mergedSize2.value;
            }
          }
          return defaultSize;
        });
        const mergedDisabledRef = vue.computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
          const { disabled } = props;
          if (disabled !== void 0) {
            return disabled;
          }
          if (NFormItem2) {
            return NFormItem2.disabled.value;
          }
          return false;
        });
        const mergedStatusRef = vue.computed(() => {
          const { status } = props;
          if (status)
            return status;
          return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
        });
        vue.onBeforeUnmount(() => {
          if (NFormItem2) {
            NFormItem2.restoreValidation();
          }
        });
        return {
          mergedSizeRef,
          mergedDisabledRef,
          mergedStatusRef,
          nTriggerFormBlur() {
            if (NFormItem2) {
              NFormItem2.handleContentBlur();
            }
          },
          nTriggerFormChange() {
            if (NFormItem2) {
              NFormItem2.handleContentChange();
            }
          },
          nTriggerFormFocus() {
            if (NFormItem2) {
              NFormItem2.handleContentFocus();
            }
          },
          nTriggerFormInput() {
            if (NFormItem2) {
              NFormItem2.handleContentInput();
            }
          }
        };
      }
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      const freeGlobal$1 = freeGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal$1 || freeSelf || Function("return this")();
      const root$1 = root;
      var Symbol$1 = root$1.Symbol;
      const Symbol$2 = Symbol$1;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$c = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$1 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      var isArray$1 = Array.isArray;
      const isArray$2 = isArray$1;
      var INFINITY$2 = 1 / 0;
      var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject$1(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject$1(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject$1(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$1 || value === -INFINITY$1) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger$3(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction$1(value) {
        if (!isObject$1(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      const coreJsData$1 = coreJsData;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$b = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject$1(value) || isMasked(value)) {
          return false;
        }
        var pattern2 = isFunction$1(value) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value));
      }
      function getValue$1(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function getNative(object2, key) {
        var value = getValue$1(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root$1, "WeakMap");
      const WeakMap$2 = WeakMap$1;
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject$1(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result = new object2();
          object2.prototype = void 0;
          return result;
        };
      }();
      const baseCreate$1 = baseCreate;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array2) {
        var index = -1, length = source.length;
        array2 || (array2 = Array(length));
        while (++index < length) {
          array2[index] = source[index];
        }
        return array2;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      const defineProperty$1 = defineProperty;
      var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
        return defineProperty$1(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      const setToString$1 = setToString;
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty$1) {
          defineProperty$1(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$a = objectProto$b.hasOwnProperty;
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty$a.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function copyObject(source, props, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object2, key, newValue);
          } else {
            assignValue(object2, key, newValue);
          }
        }
        return object2;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
          while (++index < length) {
            array2[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array2);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString$1(overRest(func, start, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction$1(value);
      }
      function isIterateeCall(value, index, object2) {
        if (!isObject$1(object2)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
          return eq(object2[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object2, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object2 = Object(object2);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object2, source, index, customizer);
            }
          }
          return object2;
        });
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$2 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$2;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      const isArguments$1 = isArguments;
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
      var isBuffer$1 = nativeIsBuffer || stubFalse;
      const isBuffer$2 = isBuffer$1;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal$1.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      const nodeUtil$1 = nodeUtil;
      var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
      var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      const isTypedArray$2 = isTypedArray$1;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      const nativeKeys$1 = nativeKeys;
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys$1(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty$7.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys$1(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function nativeKeysIn(object2) {
        var result = [];
        if (object2 != null) {
          for (var key in Object(object2)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object2) {
        if (!isObject$1(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result = [];
        for (var key in object2) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object2, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray$2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      var nativeCreate = getNative(Object, "create");
      const nativeCreate$1 = nativeCreate;
      function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate$1) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      const Map$2 = Map$1;
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$2 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match2, number2, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
        });
        return result;
      });
      const stringToPath$1 = stringToPath;
      function toString$1(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object2) {
        if (isArray$2(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath$1(toString$1(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length = path.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      function get(object2, path, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = getPrototype;
      var objectTag$2 = "[object Object]";
      var funcProto = Function.prototype, objectProto$3 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject$2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
          return false;
        }
        var proto = getPrototype$1(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
      var rsZWJ$2 = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
      var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString$1(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      var upperFirst = createCaseFirst("toUpperCase");
      const upperFirst$1 = upperFirst;
      function capitalize(string2) {
        return upperFirst$1(toString$1(string2).toLowerCase());
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var deburrLetter = basePropertyOf(deburredLetters);
      const deburrLetter$1 = deburrLetter;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
      var rsCombo$1 = "[" + rsComboRange$1 + "]";
      var reComboMark = RegExp(rsCombo$1, "g");
      function deburr(string2) {
        string2 = toString$1(string2);
        return string2 && string2.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
      }
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos$1 = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      function words(string2, pattern2, guard) {
        string2 = toString$1(string2);
        pattern2 = guard ? void 0 : pattern2;
        if (pattern2 === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern2) || [];
      }
      var rsApos = "[']";
      var reApos = RegExp(rsApos, "g");
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      var camelCase = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      const camelCase$1 = camelCase;
      var nativeIsFinite = root$1.isFinite, nativeMin$1 = Math.min;
      function createRound(methodName) {
        var func = Math[methodName];
        return function(number2, precision) {
          number2 = toNumber(number2);
          precision = precision == null ? 0 : nativeMin$1(toInteger$3(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString$1(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString$1(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$2 = Object.prototype;
      var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      const getSymbols$1 = getSymbols;
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray$2(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys$1, getSymbols$1);
      }
      var DataView$1 = getNative(root$1, "DataView");
      const DataView$2 = DataView$1;
      var Promise$1 = getNative(root$1, "Promise");
      const Promise$2 = Promise$1;
      var Set$1 = getNative(root$1, "Set");
      const Set$2 = Set$1;
      var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
      var dataViewTag$1 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
      var getTag = baseGetTag;
      if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$1;
              case mapCtorString:
                return mapTag$1;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$1;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var Uint8Array$1 = root$1.Uint8Array;
      const Uint8Array$2 = Uint8Array$1;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array2);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack2.set(array2, other);
        stack2.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack2) : customizer(arrValue, othValue, index, array2, other, stack2);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result = false;
            break;
          }
        }
        stack2["delete"](array2);
        stack2["delete"](other);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert2 || (convert2 = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack2.set(object2, other);
            var result = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object2);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack2.set(object2, other);
        stack2.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack2["delete"](object2);
        stack2["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty$1 = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray$2(object2), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$2(object2)) {
          if (!isBuffer$2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray$2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty$1.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object2, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object2 == null) {
          return !length;
        }
        object2 = Object(object2);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object2, source, stack2);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject$1(value);
      }
      function getMatchData(object2) {
        var result = keys$1(object2), length = result.length;
        while (length--) {
          var key = result[length], value = object2[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray$2(object2) || isArguments$1(object2));
      }
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object2) {
          var objValue = get(object2, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object2) {
          return baseGet(object2, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray$2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function createBaseFor(fromRight) {
        return function(object2, iteratee, keysFunc) {
          var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      var baseFor = createBaseFor();
      const baseFor$1 = baseFor;
      function baseForOwn(object2, iteratee) {
        return object2 && baseFor$1(object2, iteratee, keys$1);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      const baseEach$1 = baseEach;
      var now = function() {
        return root$1.Date.now();
      };
      const now$1 = now;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject$1(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time2;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time2) : result;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now$1();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now$1());
        }
        function debounced() {
          var time2 = now$1(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object2, key, value) {
        if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object2, key) {
        if (key === "constructor" && typeof object2[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object2[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object2, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray$2(srcValue), isBuff = !isArr && isBuffer$2(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray$2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject$2(srcValue) || isArguments$1(srcValue)) {
            newValue = objValue;
            if (isArguments$1(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject$1(objValue) || isFunction$1(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object2, key, newValue);
      }
      function baseMerge(object2, source, srcIndex, customizer, stack2) {
        if (object2 === source) {
          return;
        }
        baseFor$1(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject$1(srcValue)) {
            baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object2, key, newValue);
          }
        }, keysIn);
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach$1(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray$2(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      var kebabCase = createCompounder(function(result, word, index) {
        return result + (index ? "-" : "") + word.toLowerCase();
      });
      const kebabCase$1 = kebabCase;
      var merge$2 = createAssigner(function(object2, source, srcIndex) {
        baseMerge(object2, source, srcIndex);
      });
      const merge$3 = merge$2;
      var round = createRound("round");
      const round$1 = round;
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject$1(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      const commonVariables$m = {
        fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
        fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
        fontWeight: "400",
        fontWeightStrong: "500",
        cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
        cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
        cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
        borderRadius: "3px",
        borderRadiusSmall: "2px",
        fontSize: "14px",
        fontSizeMini: "12px",
        fontSizeTiny: "12px",
        fontSizeSmall: "14px",
        fontSizeMedium: "14px",
        fontSizeLarge: "15px",
        fontSizeHuge: "16px",
        lineHeight: "1.6",
        heightMini: "16px",
        heightTiny: "22px",
        heightSmall: "28px",
        heightMedium: "34px",
        heightLarge: "40px",
        heightHuge: "46px"
      };
      const {
        fontSize,
        fontFamily,
        lineHeight: lineHeight$1
      } = commonVariables$m;
      const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight$1};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
      const configProviderInjectionKey = createInjectionKey("n-config-provider");
      const cssrAnchorMetaName = "naive-ui-style";
      function createTheme(theme) {
        return theme;
      }
      function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
        const ssrAdapter2 = useSsrAdapter();
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        if (style2) {
          const mountStyle = () => {
            const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
            style2.mount({
              id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
              head: true,
              props: {
                bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
              },
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2
            });
            if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
              globalStyle.mount({
                id: "n-global",
                head: true,
                anchorMetaName: cssrAnchorMetaName,
                ssr: ssrAdapter2
              });
            }
          };
          if (ssrAdapter2) {
            mountStyle();
          } else {
            vue.onBeforeMount(mountStyle);
          }
        }
        const mergedThemeRef = vue.computed(() => {
          var _a;
          const { theme: { common: selfCommon, self: self2, peers = {} } = {}, themeOverrides: selfOverrides = {}, builtinThemeOverrides: builtinOverrides = {} } = props;
          const { common: selfCommonOverrides, peers: peersOverrides } = selfOverrides;
          const { common: globalCommon = void 0, [resolveId]: { common: globalSelfCommon = void 0, self: globalSelf = void 0, peers: globalPeers = {} } = {} } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
          const { common: globalCommonOverrides = void 0, [resolveId]: globalSelfOverrides = {} } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
          const { common: globalSelfCommonOverrides, peers: globalPeersOverrides = {} } = globalSelfOverrides;
          const mergedCommon = merge$3({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
          const mergedSelf = merge$3(
            // {}, executed every time, no need for empty obj
            (_a = self2 || globalSelf || defaultTheme.self) === null || _a === void 0 ? void 0 : _a(mergedCommon),
            builtinOverrides,
            globalSelfOverrides,
            selfOverrides
          );
          return {
            common: mergedCommon,
            self: mergedSelf,
            peers: merge$3({}, defaultTheme.peers, globalPeers, peers),
            peerOverrides: merge$3({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
          };
        });
        return mergedThemeRef;
      }
      useTheme.props = {
        theme: Object,
        themeOverrides: Object,
        builtinThemeOverrides: Object
      };
      const defaultClsPrefix = "n";
      function useConfig(props = {}, options = {
        defaultBordered: true
      }) {
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        return {
          // NConfigProvider,
          inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
          mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
          mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
          mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
          mergedBorderedRef: vue.computed(() => {
            var _a, _b;
            const { bordered } = props;
            if (bordered !== void 0)
              return bordered;
            return (_b = (_a = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
          }),
          mergedClsPrefixRef: vue.computed(() => {
            const clsPrefix = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedClsPrefixRef.value;
            return clsPrefix || defaultClsPrefix;
          }),
          namespaceRef: vue.computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
        };
      }
      const enUS$1 = {
        name: "en-US",
        global: {
          undo: "Undo",
          redo: "Redo",
          confirm: "Confirm",
          clear: "Clear"
        },
        Popconfirm: {
          positiveText: "Confirm",
          negativeText: "Cancel"
        },
        Cascader: {
          placeholder: "Please Select",
          loading: "Loading",
          loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
        },
        Time: {
          dateFormat: "yyyy-MM-dd",
          dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
        },
        DatePicker: {
          yearFormat: "yyyy",
          monthFormat: "MMM",
          dayFormat: "eeeeee",
          yearTypeFormat: "yyyy",
          monthTypeFormat: "yyyy-MM",
          dateFormat: "yyyy-MM-dd",
          dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
          quarterFormat: "yyyy-qqq",
          clear: "Clear",
          now: "Now",
          confirm: "Confirm",
          selectTime: "Select Time",
          selectDate: "Select Date",
          datePlaceholder: "Select Date",
          datetimePlaceholder: "Select Date and Time",
          monthPlaceholder: "Select Month",
          yearPlaceholder: "Select Year",
          quarterPlaceholder: "Select Quarter",
          startDatePlaceholder: "Start Date",
          endDatePlaceholder: "End Date",
          startDatetimePlaceholder: "Start Date and Time",
          endDatetimePlaceholder: "End Date and Time",
          startMonthPlaceholder: "Start Month",
          endMonthPlaceholder: "End Month",
          monthBeforeYear: true,
          firstDayOfWeek: 6,
          today: "Today"
        },
        DataTable: {
          checkTableAll: "Select all in the table",
          uncheckTableAll: "Unselect all in the table",
          confirm: "Confirm",
          clear: "Clear"
        },
        LegacyTransfer: {
          sourceTitle: "Source",
          targetTitle: "Target"
        },
        Transfer: {
          selectAll: "Select all",
          unselectAll: "Unselect all",
          clearAll: "Clear",
          total: (num) => `Total ${num} items`,
          selected: (num) => `${num} items selected`
        },
        Empty: {
          description: "No Data"
        },
        Select: {
          placeholder: "Please Select"
        },
        TimePicker: {
          placeholder: "Select Time",
          positiveText: "OK",
          negativeText: "Cancel",
          now: "Now"
        },
        Pagination: {
          goto: "Goto",
          selectionSuffix: "page"
        },
        DynamicTags: {
          add: "Add"
        },
        Log: {
          loading: "Loading"
        },
        Input: {
          placeholder: "Please Input"
        },
        InputNumber: {
          placeholder: "Please Input"
        },
        DynamicInput: {
          create: "Create"
        },
        ThemeEditor: {
          title: "Theme Editor",
          clearAllVars: "Clear All Variables",
          clearSearch: "Clear Search",
          filterCompName: "Filter Component Name",
          filterVarName: "Filter Variable Name",
          import: "Import",
          export: "Export",
          restore: "Reset to Default"
        },
        Image: {
          tipPrevious: "Previous picture ()",
          tipNext: "Next picture ()",
          tipCounterclockwise: "Counterclockwise",
          tipClockwise: "Clockwise",
          tipZoomOut: "Zoom out",
          tipZoomIn: "Zoom in",
          tipClose: "Close (Esc)",
          // TODO: translation
          tipOriginalSize: "Zoom to original size"
        }
      };
      const enUS$2 = enUS$1;
      function buildFormatLongFn$1(args) {
        return function() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var width = options.width ? String(options.width) : args.defaultWidth;
          var format2 = args.formats[width] || args.formats[args.defaultWidth];
          return format2;
        };
      }
      function requiredArgs$1(required2, args) {
        if (args.length < required2) {
          throw new TypeError(required2 + " argument" + (required2 > 1 ? "s" : "") + " required, but only " + args.length + " present");
        }
      }
      function _typeof$1(o) {
        "@babel/helpers - typeof";
        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$1(o);
      }
      function toDate$2(argument) {
        requiredArgs$1(1, arguments);
        var argStr = Object.prototype.toString.call(argument);
        if (argument instanceof Date || _typeof$1(argument) === "object" && argStr === "[object Date]") {
          return new Date(argument.getTime());
        } else if (typeof argument === "number" || argStr === "[object Number]") {
          return new Date(argument);
        } else {
          if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
            console.warn(new Error().stack);
          }
          return /* @__PURE__ */ new Date(NaN);
        }
      }
      function toInteger$2(dirtyNumber) {
        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
          return NaN;
        }
        var number2 = Number(dirtyNumber);
        if (isNaN(number2)) {
          return number2;
        }
        return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
      }
      var defaultOptions$2 = {};
      function getDefaultOptions$1() {
        return defaultOptions$2;
      }
      function startOfUTCWeek$1(dirtyDate, options) {
        var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
        requiredArgs$1(1, arguments);
        var defaultOptions2 = getDefaultOptions$1();
        var weekStartsOn = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
          throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        }
        var date2 = toDate$2(dirtyDate);
        var day = date2.getUTCDay();
        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
        date2.setUTCDate(date2.getUTCDate() - diff);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
      function buildLocalizeFn$1(args) {
        return function(dirtyIndex, options) {
          var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
          var valuesArray;
          if (context === "formatting" && args.formattingValues) {
            var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
          } else {
            var _defaultWidth = args.defaultWidth;
            var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[_width] || args.values[_defaultWidth];
          }
          var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
          return valuesArray[index];
        };
      }
      function buildMatchFn$1(args) {
        return function(string2) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var width = options.width;
          var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
          var matchResult = string2.match(matchPattern);
          if (!matchResult) {
            return null;
          }
          var matchedString = matchResult[0];
          var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
          var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern2) {
            return pattern2.test(matchedString);
          }) : findKey$1(parsePatterns, function(pattern2) {
            return pattern2.test(matchedString);
          });
          var value;
          value = args.valueCallback ? args.valueCallback(key) : key;
          value = options.valueCallback ? options.valueCallback(value) : value;
          var rest = string2.slice(matchedString.length);
          return {
            value,
            rest
          };
        };
      }
      function findKey$1(object2, predicate) {
        for (var key in object2) {
          if (object2.hasOwnProperty(key) && predicate(object2[key])) {
            return key;
          }
        }
        return void 0;
      }
      function findIndex(array2, predicate) {
        for (var key = 0; key < array2.length; key++) {
          if (predicate(array2[key])) {
            return key;
          }
        }
        return void 0;
      }
      function buildMatchPatternFn$1(args) {
        return function(string2) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var matchResult = string2.match(args.matchPattern);
          if (!matchResult)
            return null;
          var matchedString = matchResult[0];
          var parseResult = string2.match(args.parsePattern);
          if (!parseResult)
            return null;
          var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
          value = options.valueCallback ? options.valueCallback(value) : value;
          var rest = string2.slice(matchedString.length);
          return {
            value,
            rest
          };
        };
      }
      var formatDistanceLocale = {
        lessThanXSeconds: {
          one: "less than a second",
          other: "less than {{count}} seconds"
        },
        xSeconds: {
          one: "1 second",
          other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
          one: "less than a minute",
          other: "less than {{count}} minutes"
        },
        xMinutes: {
          one: "1 minute",
          other: "{{count}} minutes"
        },
        aboutXHours: {
          one: "about 1 hour",
          other: "about {{count}} hours"
        },
        xHours: {
          one: "1 hour",
          other: "{{count}} hours"
        },
        xDays: {
          one: "1 day",
          other: "{{count}} days"
        },
        aboutXWeeks: {
          one: "about 1 week",
          other: "about {{count}} weeks"
        },
        xWeeks: {
          one: "1 week",
          other: "{{count}} weeks"
        },
        aboutXMonths: {
          one: "about 1 month",
          other: "about {{count}} months"
        },
        xMonths: {
          one: "1 month",
          other: "{{count}} months"
        },
        aboutXYears: {
          one: "about 1 year",
          other: "about {{count}} years"
        },
        xYears: {
          one: "1 year",
          other: "{{count}} years"
        },
        overXYears: {
          one: "over 1 year",
          other: "over {{count}} years"
        },
        almostXYears: {
          one: "almost 1 year",
          other: "almost {{count}} years"
        }
      };
      var formatDistance$1 = function formatDistance2(token, count, options) {
        var result;
        var tokenValue = formatDistanceLocale[token];
        if (typeof tokenValue === "string") {
          result = tokenValue;
        } else if (count === 1) {
          result = tokenValue.one;
        } else {
          result = tokenValue.other.replace("{{count}}", count.toString());
        }
        if (options !== null && options !== void 0 && options.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            return "in " + result;
          } else {
            return result + " ago";
          }
        }
        return result;
      };
      const formatDistance$2 = formatDistance$1;
      var dateFormats = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
      };
      var timeFormats = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      };
      var dateTimeFormats = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
      };
      var formatLong$1 = {
        date: buildFormatLongFn$1({
          formats: dateFormats,
          defaultWidth: "full"
        }),
        time: buildFormatLongFn$1({
          formats: timeFormats,
          defaultWidth: "full"
        }),
        dateTime: buildFormatLongFn$1({
          formats: dateTimeFormats,
          defaultWidth: "full"
        })
      };
      const formatLong$2 = formatLong$1;
      var formatRelativeLocale = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
      };
      var formatRelative$1 = function formatRelative2(token, _date, _baseDate, _options) {
        return formatRelativeLocale[token];
      };
      const formatRelative$2 = formatRelative$1;
      var eraValues = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
      };
      var quarterValues = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
      };
      var monthValues = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
      };
      var dayValues = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      };
      var dayPeriodValues = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        }
      };
      var formattingDayPeriodValues = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        }
      };
      var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
        var number2 = Number(dirtyNumber);
        var rem100 = number2 % 100;
        if (rem100 > 20 || rem100 < 10) {
          switch (rem100 % 10) {
            case 1:
              return number2 + "st";
            case 2:
              return number2 + "nd";
            case 3:
              return number2 + "rd";
          }
        }
        return number2 + "th";
      };
      var localize$1 = {
        ordinalNumber,
        era: buildLocalizeFn$1({
          values: eraValues,
          defaultWidth: "wide"
        }),
        quarter: buildLocalizeFn$1({
          values: quarterValues,
          defaultWidth: "wide",
          argumentCallback: function argumentCallback(quarter) {
            return quarter - 1;
          }
        }),
        month: buildLocalizeFn$1({
          values: monthValues,
          defaultWidth: "wide"
        }),
        day: buildLocalizeFn$1({
          values: dayValues,
          defaultWidth: "wide"
        }),
        dayPeriod: buildLocalizeFn$1({
          values: dayPeriodValues,
          defaultWidth: "wide",
          formattingValues: formattingDayPeriodValues,
          defaultFormattingWidth: "wide"
        })
      };
      const localize$2 = localize$1;
      var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
      var parseOrdinalNumberPattern = /\d+/i;
      var matchEraPatterns = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
      };
      var parseEraPatterns = {
        any: [/^b/i, /^(a|c)/i]
      };
      var matchQuarterPatterns = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
      };
      var parseQuarterPatterns = {
        any: [/1/i, /2/i, /3/i, /4/i]
      };
      var matchMonthPatterns = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
      };
      var parseMonthPatterns = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
      };
      var matchDayPatterns = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
      };
      var parseDayPatterns = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
      };
      var matchDayPeriodPatterns = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
      };
      var parseDayPeriodPatterns = {
        any: {
          am: /^a/i,
          pm: /^p/i,
          midnight: /^mi/i,
          noon: /^no/i,
          morning: /morning/i,
          afternoon: /afternoon/i,
          evening: /evening/i,
          night: /night/i
        }
      };
      var match$1 = {
        ordinalNumber: buildMatchPatternFn$1({
          matchPattern: matchOrdinalNumberPattern,
          parsePattern: parseOrdinalNumberPattern,
          valueCallback: function valueCallback(value) {
            return parseInt(value, 10);
          }
        }),
        era: buildMatchFn$1({
          matchPatterns: matchEraPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseEraPatterns,
          defaultParseWidth: "any"
        }),
        quarter: buildMatchFn$1({
          matchPatterns: matchQuarterPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseQuarterPatterns,
          defaultParseWidth: "any",
          valueCallback: function valueCallback(index) {
            return index + 1;
          }
        }),
        month: buildMatchFn$1({
          matchPatterns: matchMonthPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseMonthPatterns,
          defaultParseWidth: "any"
        }),
        day: buildMatchFn$1({
          matchPatterns: matchDayPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseDayPatterns,
          defaultParseWidth: "any"
        }),
        dayPeriod: buildMatchFn$1({
          matchPatterns: matchDayPeriodPatterns,
          defaultMatchWidth: "any",
          parsePatterns: parseDayPeriodPatterns,
          defaultParseWidth: "any"
        })
      };
      const match$2 = match$1;
      var locale = {
        code: "en-US",
        formatDistance: formatDistance$2,
        formatLong: formatLong$2,
        formatRelative: formatRelative$2,
        localize: localize$2,
        match: match$2,
        options: {
          weekStartsOn: 0,
          firstWeekContainsDate: 1
        }
      };
      const defaultLocale$1 = locale;
      const dateEnUs = {
        name: "en-US",
        locale: defaultLocale$1
      };
      const dateEnUS = dateEnUs;
      function addDays(dirtyDate, dirtyAmount) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var amount = toInteger$2(dirtyAmount);
        if (isNaN(amount)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        if (!amount) {
          return date2;
        }
        date2.setDate(date2.getDate() + amount);
        return date2;
      }
      function addMonths(dirtyDate, dirtyAmount) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var amount = toInteger$2(dirtyAmount);
        if (isNaN(amount)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        if (!amount) {
          return date2;
        }
        var dayOfMonth = date2.getDate();
        var endOfDesiredMonth = new Date(date2.getTime());
        endOfDesiredMonth.setMonth(date2.getMonth() + amount + 1, 0);
        var daysInMonth = endOfDesiredMonth.getDate();
        if (dayOfMonth >= daysInMonth) {
          return endOfDesiredMonth;
        } else {
          date2.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
          return date2;
        }
      }
      function addMilliseconds$1(dirtyDate, dirtyAmount) {
        requiredArgs$1(2, arguments);
        var timestamp = toDate$2(dirtyDate).getTime();
        var amount = toInteger$2(dirtyAmount);
        return new Date(timestamp + amount);
      }
      function getTimezoneOffsetInMilliseconds$2(date2) {
        var utcDate = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
        utcDate.setUTCFullYear(date2.getFullYear());
        return date2.getTime() - utcDate.getTime();
      }
      function startOfDay(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        date2.setHours(0, 0, 0, 0);
        return date2;
      }
      function addQuarters(dirtyDate, dirtyAmount) {
        requiredArgs$1(2, arguments);
        var amount = toInteger$2(dirtyAmount);
        var months2 = amount * 3;
        return addMonths(dirtyDate, months2);
      }
      function addYears(dirtyDate, dirtyAmount) {
        requiredArgs$1(2, arguments);
        var amount = toInteger$2(dirtyAmount);
        return addMonths(dirtyDate, amount * 12);
      }
      function compareAsc(dirtyDateLeft, dirtyDateRight) {
        requiredArgs$1(2, arguments);
        var dateLeft = toDate$2(dirtyDateLeft);
        var dateRight = toDate$2(dirtyDateRight);
        var diff = dateLeft.getTime() - dateRight.getTime();
        if (diff < 0) {
          return -1;
        } else if (diff > 0) {
          return 1;
        } else {
          return diff;
        }
      }
      var millisecondsInMinute = 6e4;
      var millisecondsInHour = 36e5;
      var millisecondsInSecond = 1e3;
      function isSameDay(dirtyDateLeft, dirtyDateRight) {
        requiredArgs$1(2, arguments);
        var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
        var dateRightStartOfDay = startOfDay(dirtyDateRight);
        return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
      }
      function isDate$2(value) {
        requiredArgs$1(1, arguments);
        return value instanceof Date || _typeof$1(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
      }
      function isValid$1(dirtyDate) {
        requiredArgs$1(1, arguments);
        if (!isDate$2(dirtyDate) && typeof dirtyDate !== "number") {
          return false;
        }
        var date2 = toDate$2(dirtyDate);
        return !isNaN(Number(date2));
      }
      function getQuarter(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var quarter = Math.floor(date2.getMonth() / 3) + 1;
        return quarter;
      }
      function startOfMinute(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        date2.setSeconds(0, 0);
        return date2;
      }
      function startOfQuarter(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var currentMonth = date2.getMonth();
        var month = currentMonth - currentMonth % 3;
        date2.setMonth(month, 1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      }
      function startOfMonth(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        date2.setDate(1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      }
      function startOfYear(dirtyDate) {
        requiredArgs$1(1, arguments);
        var cleanDate = toDate$2(dirtyDate);
        var date2 = /* @__PURE__ */ new Date(0);
        date2.setFullYear(cleanDate.getFullYear(), 0, 1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      }
      function subMilliseconds$1(dirtyDate, dirtyAmount) {
        requiredArgs$1(2, arguments);
        var amount = toInteger$2(dirtyAmount);
        return addMilliseconds$1(dirtyDate, -amount);
      }
      var MILLISECONDS_IN_DAY = 864e5;
      function getUTCDayOfYear$1(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var timestamp = date2.getTime();
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
        var startOfYearTimestamp = date2.getTime();
        var difference = timestamp - startOfYearTimestamp;
        return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
      }
      function startOfUTCISOWeek$1(dirtyDate) {
        requiredArgs$1(1, arguments);
        var weekStartsOn = 1;
        var date2 = toDate$2(dirtyDate);
        var day = date2.getUTCDay();
        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
        date2.setUTCDate(date2.getUTCDate() - diff);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
      function getUTCISOWeekYear$1(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var year = date2.getUTCFullYear();
        var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
        fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
        fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
        var startOfNextYear = startOfUTCISOWeek$1(fourthOfJanuaryOfNextYear);
        var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
        fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
        fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
        var startOfThisYear = startOfUTCISOWeek$1(fourthOfJanuaryOfThisYear);
        if (date2.getTime() >= startOfNextYear.getTime()) {
          return year + 1;
        } else if (date2.getTime() >= startOfThisYear.getTime()) {
          return year;
        } else {
          return year - 1;
        }
      }
      function startOfUTCISOWeekYear$1(dirtyDate) {
        requiredArgs$1(1, arguments);
        var year = getUTCISOWeekYear$1(dirtyDate);
        var fourthOfJanuary = /* @__PURE__ */ new Date(0);
        fourthOfJanuary.setUTCFullYear(year, 0, 4);
        fourthOfJanuary.setUTCHours(0, 0, 0, 0);
        var date2 = startOfUTCISOWeek$1(fourthOfJanuary);
        return date2;
      }
      var MILLISECONDS_IN_WEEK$1 = 6048e5;
      function getUTCISOWeek$1(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var diff = startOfUTCISOWeek$1(date2).getTime() - startOfUTCISOWeekYear$1(date2).getTime();
        return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
      }
      function getUTCWeekYear$1(dirtyDate, options) {
        var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var year = date2.getUTCFullYear();
        var defaultOptions2 = getDefaultOptions$1();
        var firstWeekContainsDate = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
          throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        }
        var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
        firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
        firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
        var startOfNextYear = startOfUTCWeek$1(firstWeekOfNextYear, options);
        var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
        firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
        firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
        var startOfThisYear = startOfUTCWeek$1(firstWeekOfThisYear, options);
        if (date2.getTime() >= startOfNextYear.getTime()) {
          return year + 1;
        } else if (date2.getTime() >= startOfThisYear.getTime()) {
          return year;
        } else {
          return year - 1;
        }
      }
      function startOfUTCWeekYear$1(dirtyDate, options) {
        var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
        requiredArgs$1(1, arguments);
        var defaultOptions2 = getDefaultOptions$1();
        var firstWeekContainsDate = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
        var year = getUTCWeekYear$1(dirtyDate, options);
        var firstWeek = /* @__PURE__ */ new Date(0);
        firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
        firstWeek.setUTCHours(0, 0, 0, 0);
        var date2 = startOfUTCWeek$1(firstWeek, options);
        return date2;
      }
      var MILLISECONDS_IN_WEEK = 6048e5;
      function getUTCWeek$1(dirtyDate, options) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var diff = startOfUTCWeek$1(date2, options).getTime() - startOfUTCWeekYear$1(date2, options).getTime();
        return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
      }
      function addLeadingZeros$2(number2, targetLength) {
        var sign = number2 < 0 ? "-" : "";
        var output = Math.abs(number2).toString();
        while (output.length < targetLength) {
          output = "0" + output;
        }
        return sign + output;
      }
      var formatters$5 = {
        // Year
        y: function y(date2, token) {
          var signedYear = date2.getUTCFullYear();
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return addLeadingZeros$2(token === "yy" ? year % 100 : year, token.length);
        },
        // Month
        M: function M(date2, token) {
          var month = date2.getUTCMonth();
          return token === "M" ? String(month + 1) : addLeadingZeros$2(month + 1, 2);
        },
        // Day of the month
        d: function d(date2, token) {
          return addLeadingZeros$2(date2.getUTCDate(), token.length);
        },
        // AM or PM
        a: function a2(date2, token) {
          var dayPeriodEnumValue = date2.getUTCHours() / 12 >= 1 ? "pm" : "am";
          switch (token) {
            case "a":
            case "aa":
              return dayPeriodEnumValue.toUpperCase();
            case "aaa":
              return dayPeriodEnumValue;
            case "aaaaa":
              return dayPeriodEnumValue[0];
            case "aaaa":
            default:
              return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
          }
        },
        // Hour [1-12]
        h: function h2(date2, token) {
          return addLeadingZeros$2(date2.getUTCHours() % 12 || 12, token.length);
        },
        // Hour [0-23]
        H: function H(date2, token) {
          return addLeadingZeros$2(date2.getUTCHours(), token.length);
        },
        // Minute
        m: function m(date2, token) {
          return addLeadingZeros$2(date2.getUTCMinutes(), token.length);
        },
        // Second
        s: function s(date2, token) {
          return addLeadingZeros$2(date2.getUTCSeconds(), token.length);
        },
        // Fraction of second
        S: function S(date2, token) {
          var numberOfDigits = token.length;
          var milliseconds = date2.getUTCMilliseconds();
          var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
          return addLeadingZeros$2(fractionalSeconds, token.length);
        }
      };
      const formatters$6 = formatters$5;
      var dayPeriodEnum = {
        am: "am",
        pm: "pm",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      };
      var formatters$3 = {
        // Era
        G: function G(date2, token, localize2) {
          var era = date2.getUTCFullYear() > 0 ? 1 : 0;
          switch (token) {
            case "G":
            case "GG":
            case "GGG":
              return localize2.era(era, {
                width: "abbreviated"
              });
            case "GGGGG":
              return localize2.era(era, {
                width: "narrow"
              });
            case "GGGG":
            default:
              return localize2.era(era, {
                width: "wide"
              });
          }
        },
        // Year
        y: function y(date2, token, localize2) {
          if (token === "yo") {
            var signedYear = date2.getUTCFullYear();
            var year = signedYear > 0 ? signedYear : 1 - signedYear;
            return localize2.ordinalNumber(year, {
              unit: "year"
            });
          }
          return formatters$6.y(date2, token);
        },
        // Local week-numbering year
        Y: function Y(date2, token, localize2, options) {
          var signedWeekYear = getUTCWeekYear$1(date2, options);
          var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
          if (token === "YY") {
            var twoDigitYear = weekYear % 100;
            return addLeadingZeros$2(twoDigitYear, 2);
          }
          if (token === "Yo") {
            return localize2.ordinalNumber(weekYear, {
              unit: "year"
            });
          }
          return addLeadingZeros$2(weekYear, token.length);
        },
        // ISO week-numbering year
        R: function R(date2, token) {
          var isoWeekYear = getUTCISOWeekYear$1(date2);
          return addLeadingZeros$2(isoWeekYear, token.length);
        },
        // Extended year. This is a single number designating the year of this calendar system.
        // The main difference between `y` and `u` localizers are B.C. years:
        // | Year | `y` | `u` |
        // |------|-----|-----|
        // | AC 1 |   1 |   1 |
        // | BC 1 |   1 |   0 |
        // | BC 2 |   2 |  -1 |
        // Also `yy` always returns the last two digits of a year,
        // while `uu` pads single digit years to 2 characters and returns other years unchanged.
        u: function u(date2, token) {
          var year = date2.getUTCFullYear();
          return addLeadingZeros$2(year, token.length);
        },
        // Quarter
        Q: function Q(date2, token, localize2) {
          var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
          switch (token) {
            case "Q":
              return String(quarter);
            case "QQ":
              return addLeadingZeros$2(quarter, 2);
            case "Qo":
              return localize2.ordinalNumber(quarter, {
                unit: "quarter"
              });
            case "QQQ":
              return localize2.quarter(quarter, {
                width: "abbreviated",
                context: "formatting"
              });
            case "QQQQQ":
              return localize2.quarter(quarter, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQ":
            default:
              return localize2.quarter(quarter, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // Stand-alone quarter
        q: function q(date2, token, localize2) {
          var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
          switch (token) {
            case "q":
              return String(quarter);
            case "qq":
              return addLeadingZeros$2(quarter, 2);
            case "qo":
              return localize2.ordinalNumber(quarter, {
                unit: "quarter"
              });
            case "qqq":
              return localize2.quarter(quarter, {
                width: "abbreviated",
                context: "standalone"
              });
            case "qqqqq":
              return localize2.quarter(quarter, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqq":
            default:
              return localize2.quarter(quarter, {
                width: "wide",
                context: "standalone"
              });
          }
        },
        // Month
        M: function M(date2, token, localize2) {
          var month = date2.getUTCMonth();
          switch (token) {
            case "M":
            case "MM":
              return formatters$6.M(date2, token);
            case "Mo":
              return localize2.ordinalNumber(month + 1, {
                unit: "month"
              });
            case "MMM":
              return localize2.month(month, {
                width: "abbreviated",
                context: "formatting"
              });
            case "MMMMM":
              return localize2.month(month, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMM":
            default:
              return localize2.month(month, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // Stand-alone month
        L: function L(date2, token, localize2) {
          var month = date2.getUTCMonth();
          switch (token) {
            case "L":
              return String(month + 1);
            case "LL":
              return addLeadingZeros$2(month + 1, 2);
            case "Lo":
              return localize2.ordinalNumber(month + 1, {
                unit: "month"
              });
            case "LLL":
              return localize2.month(month, {
                width: "abbreviated",
                context: "standalone"
              });
            case "LLLLL":
              return localize2.month(month, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLL":
            default:
              return localize2.month(month, {
                width: "wide",
                context: "standalone"
              });
          }
        },
        // Local week of year
        w: function w(date2, token, localize2, options) {
          var week = getUTCWeek$1(date2, options);
          if (token === "wo") {
            return localize2.ordinalNumber(week, {
              unit: "week"
            });
          }
          return addLeadingZeros$2(week, token.length);
        },
        // ISO week of year
        I: function I(date2, token, localize2) {
          var isoWeek = getUTCISOWeek$1(date2);
          if (token === "Io") {
            return localize2.ordinalNumber(isoWeek, {
              unit: "week"
            });
          }
          return addLeadingZeros$2(isoWeek, token.length);
        },
        // Day of the month
        d: function d(date2, token, localize2) {
          if (token === "do") {
            return localize2.ordinalNumber(date2.getUTCDate(), {
              unit: "date"
            });
          }
          return formatters$6.d(date2, token);
        },
        // Day of year
        D: function D(date2, token, localize2) {
          var dayOfYear = getUTCDayOfYear$1(date2);
          if (token === "Do") {
            return localize2.ordinalNumber(dayOfYear, {
              unit: "dayOfYear"
            });
          }
          return addLeadingZeros$2(dayOfYear, token.length);
        },
        // Day of week
        E: function E(date2, token, localize2) {
          var dayOfWeek = date2.getUTCDay();
          switch (token) {
            case "E":
            case "EE":
            case "EEE":
              return localize2.day(dayOfWeek, {
                width: "abbreviated",
                context: "formatting"
              });
            case "EEEEE":
              return localize2.day(dayOfWeek, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEEE":
              return localize2.day(dayOfWeek, {
                width: "short",
                context: "formatting"
              });
            case "EEEE":
            default:
              return localize2.day(dayOfWeek, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // Local day of week
        e: function e(date2, token, localize2, options) {
          var dayOfWeek = date2.getUTCDay();
          var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
          switch (token) {
            case "e":
              return String(localDayOfWeek);
            case "ee":
              return addLeadingZeros$2(localDayOfWeek, 2);
            case "eo":
              return localize2.ordinalNumber(localDayOfWeek, {
                unit: "day"
              });
            case "eee":
              return localize2.day(dayOfWeek, {
                width: "abbreviated",
                context: "formatting"
              });
            case "eeeee":
              return localize2.day(dayOfWeek, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeeee":
              return localize2.day(dayOfWeek, {
                width: "short",
                context: "formatting"
              });
            case "eeee":
            default:
              return localize2.day(dayOfWeek, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // Stand-alone local day of week
        c: function c2(date2, token, localize2, options) {
          var dayOfWeek = date2.getUTCDay();
          var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
          switch (token) {
            case "c":
              return String(localDayOfWeek);
            case "cc":
              return addLeadingZeros$2(localDayOfWeek, token.length);
            case "co":
              return localize2.ordinalNumber(localDayOfWeek, {
                unit: "day"
              });
            case "ccc":
              return localize2.day(dayOfWeek, {
                width: "abbreviated",
                context: "standalone"
              });
            case "ccccc":
              return localize2.day(dayOfWeek, {
                width: "narrow",
                context: "standalone"
              });
            case "cccccc":
              return localize2.day(dayOfWeek, {
                width: "short",
                context: "standalone"
              });
            case "cccc":
            default:
              return localize2.day(dayOfWeek, {
                width: "wide",
                context: "standalone"
              });
          }
        },
        // ISO day of week
        i: function i(date2, token, localize2) {
          var dayOfWeek = date2.getUTCDay();
          var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
          switch (token) {
            case "i":
              return String(isoDayOfWeek);
            case "ii":
              return addLeadingZeros$2(isoDayOfWeek, token.length);
            case "io":
              return localize2.ordinalNumber(isoDayOfWeek, {
                unit: "day"
              });
            case "iii":
              return localize2.day(dayOfWeek, {
                width: "abbreviated",
                context: "formatting"
              });
            case "iiiii":
              return localize2.day(dayOfWeek, {
                width: "narrow",
                context: "formatting"
              });
            case "iiiiii":
              return localize2.day(dayOfWeek, {
                width: "short",
                context: "formatting"
              });
            case "iiii":
            default:
              return localize2.day(dayOfWeek, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // AM or PM
        a: function a2(date2, token, localize2) {
          var hours = date2.getUTCHours();
          var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
          switch (token) {
            case "a":
            case "aa":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "abbreviated",
                context: "formatting"
              });
            case "aaa":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "abbreviated",
                context: "formatting"
              }).toLowerCase();
            case "aaaaa":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaa":
            default:
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // AM, PM, midnight, noon
        b: function b(date2, token, localize2) {
          var hours = date2.getUTCHours();
          var dayPeriodEnumValue;
          if (hours === 12) {
            dayPeriodEnumValue = dayPeriodEnum.noon;
          } else if (hours === 0) {
            dayPeriodEnumValue = dayPeriodEnum.midnight;
          } else {
            dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
          }
          switch (token) {
            case "b":
            case "bb":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "abbreviated",
                context: "formatting"
              });
            case "bbb":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "abbreviated",
                context: "formatting"
              }).toLowerCase();
            case "bbbbb":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbb":
            default:
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // in the morning, in the afternoon, in the evening, at night
        B: function B(date2, token, localize2) {
          var hours = date2.getUTCHours();
          var dayPeriodEnumValue;
          if (hours >= 17) {
            dayPeriodEnumValue = dayPeriodEnum.evening;
          } else if (hours >= 12) {
            dayPeriodEnumValue = dayPeriodEnum.afternoon;
          } else if (hours >= 4) {
            dayPeriodEnumValue = dayPeriodEnum.morning;
          } else {
            dayPeriodEnumValue = dayPeriodEnum.night;
          }
          switch (token) {
            case "B":
            case "BB":
            case "BBB":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "abbreviated",
                context: "formatting"
              });
            case "BBBBB":
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBB":
            default:
              return localize2.dayPeriod(dayPeriodEnumValue, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        // Hour [1-12]
        h: function h2(date2, token, localize2) {
          if (token === "ho") {
            var hours = date2.getUTCHours() % 12;
            if (hours === 0)
              hours = 12;
            return localize2.ordinalNumber(hours, {
              unit: "hour"
            });
          }
          return formatters$6.h(date2, token);
        },
        // Hour [0-23]
        H: function H(date2, token, localize2) {
          if (token === "Ho") {
            return localize2.ordinalNumber(date2.getUTCHours(), {
              unit: "hour"
            });
          }
          return formatters$6.H(date2, token);
        },
        // Hour [0-11]
        K: function K(date2, token, localize2) {
          var hours = date2.getUTCHours() % 12;
          if (token === "Ko") {
            return localize2.ordinalNumber(hours, {
              unit: "hour"
            });
          }
          return addLeadingZeros$2(hours, token.length);
        },
        // Hour [1-24]
        k: function k(date2, token, localize2) {
          var hours = date2.getUTCHours();
          if (hours === 0)
            hours = 24;
          if (token === "ko") {
            return localize2.ordinalNumber(hours, {
              unit: "hour"
            });
          }
          return addLeadingZeros$2(hours, token.length);
        },
        // Minute
        m: function m(date2, token, localize2) {
          if (token === "mo") {
            return localize2.ordinalNumber(date2.getUTCMinutes(), {
              unit: "minute"
            });
          }
          return formatters$6.m(date2, token);
        },
        // Second
        s: function s(date2, token, localize2) {
          if (token === "so") {
            return localize2.ordinalNumber(date2.getUTCSeconds(), {
              unit: "second"
            });
          }
          return formatters$6.s(date2, token);
        },
        // Fraction of second
        S: function S(date2, token) {
          return formatters$6.S(date2, token);
        },
        // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
        X: function X(date2, token, _localize, options) {
          var originalDate = options._originalDate || date2;
          var timezoneOffset = originalDate.getTimezoneOffset();
          if (timezoneOffset === 0) {
            return "Z";
          }
          switch (token) {
            case "X":
              return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
            case "XXXX":
            case "XX":
              return formatTimezone$1(timezoneOffset);
            case "XXXXX":
            case "XXX":
            default:
              return formatTimezone$1(timezoneOffset, ":");
          }
        },
        // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
        x: function x(date2, token, _localize, options) {
          var originalDate = options._originalDate || date2;
          var timezoneOffset = originalDate.getTimezoneOffset();
          switch (token) {
            case "x":
              return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
            case "xxxx":
            case "xx":
              return formatTimezone$1(timezoneOffset);
            case "xxxxx":
            case "xxx":
            default:
              return formatTimezone$1(timezoneOffset, ":");
          }
        },
        // Timezone (GMT)
        O: function O(date2, token, _localize, options) {
          var originalDate = options._originalDate || date2;
          var timezoneOffset = originalDate.getTimezoneOffset();
          switch (token) {
            case "O":
            case "OO":
            case "OOO":
              return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
            case "OOOO":
            default:
              return "GMT" + formatTimezone$1(timezoneOffset, ":");
          }
        },
        // Timezone (specific non-location)
        z: function z(date2, token, _localize, options) {
          var originalDate = options._originalDate || date2;
          var timezoneOffset = originalDate.getTimezoneOffset();
          switch (token) {
            case "z":
            case "zz":
            case "zzz":
              return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
            case "zzzz":
            default:
              return "GMT" + formatTimezone$1(timezoneOffset, ":");
          }
        },
        // Seconds timestamp
        t: function t(date2, token, _localize, options) {
          var originalDate = options._originalDate || date2;
          var timestamp = Math.floor(originalDate.getTime() / 1e3);
          return addLeadingZeros$2(timestamp, token.length);
        },
        // Milliseconds timestamp
        T: function T(date2, token, _localize, options) {
          var originalDate = options._originalDate || date2;
          var timestamp = originalDate.getTime();
          return addLeadingZeros$2(timestamp, token.length);
        }
      };
      function formatTimezoneShort$1(offset, dirtyDelimiter) {
        var sign = offset > 0 ? "-" : "+";
        var absOffset = Math.abs(offset);
        var hours = Math.floor(absOffset / 60);
        var minutes = absOffset % 60;
        if (minutes === 0) {
          return sign + String(hours);
        }
        var delimiter = dirtyDelimiter || "";
        return sign + String(hours) + delimiter + addLeadingZeros$2(minutes, 2);
      }
      function formatTimezoneWithOptionalMinutes$1(offset, dirtyDelimiter) {
        if (offset % 60 === 0) {
          var sign = offset > 0 ? "-" : "+";
          return sign + addLeadingZeros$2(Math.abs(offset) / 60, 2);
        }
        return formatTimezone$1(offset, dirtyDelimiter);
      }
      function formatTimezone$1(offset, dirtyDelimiter) {
        var delimiter = dirtyDelimiter || "";
        var sign = offset > 0 ? "-" : "+";
        var absOffset = Math.abs(offset);
        var hours = addLeadingZeros$2(Math.floor(absOffset / 60), 2);
        var minutes = addLeadingZeros$2(absOffset % 60, 2);
        return sign + hours + delimiter + minutes;
      }
      const formatters$4 = formatters$3;
      var dateLongFormatter = function dateLongFormatter2(pattern2, formatLong2) {
        switch (pattern2) {
          case "P":
            return formatLong2.date({
              width: "short"
            });
          case "PP":
            return formatLong2.date({
              width: "medium"
            });
          case "PPP":
            return formatLong2.date({
              width: "long"
            });
          case "PPPP":
          default:
            return formatLong2.date({
              width: "full"
            });
        }
      };
      var timeLongFormatter = function timeLongFormatter2(pattern2, formatLong2) {
        switch (pattern2) {
          case "p":
            return formatLong2.time({
              width: "short"
            });
          case "pp":
            return formatLong2.time({
              width: "medium"
            });
          case "ppp":
            return formatLong2.time({
              width: "long"
            });
          case "pppp":
          default:
            return formatLong2.time({
              width: "full"
            });
        }
      };
      var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern2, formatLong2) {
        var matchResult = pattern2.match(/(P+)(p+)?/) || [];
        var datePattern = matchResult[1];
        var timePattern = matchResult[2];
        if (!timePattern) {
          return dateLongFormatter(pattern2, formatLong2);
        }
        var dateTimeFormat;
        switch (datePattern) {
          case "P":
            dateTimeFormat = formatLong2.dateTime({
              width: "short"
            });
            break;
          case "PP":
            dateTimeFormat = formatLong2.dateTime({
              width: "medium"
            });
            break;
          case "PPP":
            dateTimeFormat = formatLong2.dateTime({
              width: "long"
            });
            break;
          case "PPPP":
          default:
            dateTimeFormat = formatLong2.dateTime({
              width: "full"
            });
            break;
        }
        return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
      };
      var longFormatters$1 = {
        p: timeLongFormatter,
        P: dateTimeLongFormatter
      };
      const longFormatters$2 = longFormatters$1;
      var protectedDayOfYearTokens$1 = ["D", "DD"];
      var protectedWeekYearTokens$1 = ["YY", "YYYY"];
      function isProtectedDayOfYearToken$1(token) {
        return protectedDayOfYearTokens$1.indexOf(token) !== -1;
      }
      function isProtectedWeekYearToken$1(token) {
        return protectedWeekYearTokens$1.indexOf(token) !== -1;
      }
      function throwProtectedError$1(token, format2, input) {
        if (token === "YYYY") {
          throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        } else if (token === "YY") {
          throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        } else if (token === "D") {
          throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        } else if (token === "DD") {
          throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        }
      }
      var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
      var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
      var escapedStringRegExp$1 = /^'([^]*?)'?$/;
      var doubleQuoteRegExp$1 = /''/g;
      var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
      function format$4(dirtyDate, dirtyFormatStr, options) {
        var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
        requiredArgs$1(2, arguments);
        var formatStr = String(dirtyFormatStr);
        var defaultOptions2 = getDefaultOptions$1();
        var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
        var firstWeekContainsDate = toInteger$2((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
          throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        }
        var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
          throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        }
        if (!locale2.localize) {
          throw new RangeError("locale must contain localize property");
        }
        if (!locale2.formatLong) {
          throw new RangeError("locale must contain formatLong property");
        }
        var originalDate = toDate$2(dirtyDate);
        if (!isValid$1(originalDate)) {
          throw new RangeError("Invalid time value");
        }
        var timezoneOffset = getTimezoneOffsetInMilliseconds$2(originalDate);
        var utcDate = subMilliseconds$1(originalDate, timezoneOffset);
        var formatterOptions = {
          firstWeekContainsDate,
          weekStartsOn,
          locale: locale2,
          _originalDate: originalDate
        };
        var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
          var firstCharacter = substring[0];
          if (firstCharacter === "p" || firstCharacter === "P") {
            var longFormatter = longFormatters$2[firstCharacter];
            return longFormatter(substring, locale2.formatLong);
          }
          return substring;
        }).join("").match(formattingTokensRegExp$1).map(function(substring) {
          if (substring === "''") {
            return "'";
          }
          var firstCharacter = substring[0];
          if (firstCharacter === "'") {
            return cleanEscapedString$1(substring);
          }
          var formatter = formatters$4[firstCharacter];
          if (formatter) {
            if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(substring)) {
              throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
            }
            if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(substring)) {
              throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
            }
            return formatter(utcDate, substring, locale2.localize, formatterOptions);
          }
          if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
          }
          return substring;
        }).join("");
        return result;
      }
      function cleanEscapedString$1(input) {
        var matched = input.match(escapedStringRegExp$1);
        if (!matched) {
          return input;
        }
        return matched[1].replace(doubleQuoteRegExp$1, "'");
      }
      function assign$2(target, object2) {
        if (target == null) {
          throw new TypeError("assign requires that input parameter not be null or undefined");
        }
        for (var property2 in object2) {
          if (Object.prototype.hasOwnProperty.call(object2, property2)) {
            target[property2] = object2[property2];
          }
        }
        return target;
      }
      function cloneObject$2(object2) {
        return assign$2({}, object2);
      }
      var MILLISECONDS_IN_MINUTE$3 = 1e3 * 60;
      var MINUTES_IN_DAY = 60 * 24;
      var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
      var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;
      function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
        var _ref, _options$locale, _options$roundingMeth;
        requiredArgs$1(2, arguments);
        var defaultOptions2 = getDefaultOptions$1();
        var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
        if (!locale2.formatDistance) {
          throw new RangeError("locale must contain localize.formatDistance property");
        }
        var comparison = compareAsc(dirtyDate, dirtyBaseDate);
        if (isNaN(comparison)) {
          throw new RangeError("Invalid time value");
        }
        var localizeOptions = assign$2(cloneObject$2(options), {
          addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
          comparison
        });
        var dateLeft;
        var dateRight;
        if (comparison > 0) {
          dateLeft = toDate$2(dirtyBaseDate);
          dateRight = toDate$2(dirtyDate);
        } else {
          dateLeft = toDate$2(dirtyDate);
          dateRight = toDate$2(dirtyBaseDate);
        }
        var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : "round");
        var roundingMethodFn;
        if (roundingMethod === "floor") {
          roundingMethodFn = Math.floor;
        } else if (roundingMethod === "ceil") {
          roundingMethodFn = Math.ceil;
        } else if (roundingMethod === "round") {
          roundingMethodFn = Math.round;
        } else {
          throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
        }
        var milliseconds = dateRight.getTime() - dateLeft.getTime();
        var minutes = milliseconds / MILLISECONDS_IN_MINUTE$3;
        var timezoneOffset = getTimezoneOffsetInMilliseconds$2(dateRight) - getTimezoneOffsetInMilliseconds$2(dateLeft);
        var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE$3;
        var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
        var unit;
        if (!defaultUnit) {
          if (minutes < 1) {
            unit = "second";
          } else if (minutes < 60) {
            unit = "minute";
          } else if (minutes < MINUTES_IN_DAY) {
            unit = "hour";
          } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
            unit = "day";
          } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
            unit = "month";
          } else {
            unit = "year";
          }
        } else {
          unit = String(defaultUnit);
        }
        if (unit === "second") {
          var seconds = roundingMethodFn(milliseconds / 1e3);
          return locale2.formatDistance("xSeconds", seconds, localizeOptions);
        } else if (unit === "minute") {
          var roundedMinutes = roundingMethodFn(minutes);
          return locale2.formatDistance("xMinutes", roundedMinutes, localizeOptions);
        } else if (unit === "hour") {
          var hours = roundingMethodFn(minutes / 60);
          return locale2.formatDistance("xHours", hours, localizeOptions);
        } else if (unit === "day") {
          var days2 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
          return locale2.formatDistance("xDays", days2, localizeOptions);
        } else if (unit === "month") {
          var months2 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
          return months2 === 12 && defaultUnit !== "month" ? locale2.formatDistance("xYears", 1, localizeOptions) : locale2.formatDistance("xMonths", months2, localizeOptions);
        } else if (unit === "year") {
          var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
          return locale2.formatDistance("xYears", years, localizeOptions);
        }
        throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
      }
      function fromUnixTime(dirtyUnixTime) {
        requiredArgs$1(1, arguments);
        var unixTime = toInteger$2(dirtyUnixTime);
        return toDate$2(unixTime * 1e3);
      }
      function getDate(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var dayOfMonth = date2.getDate();
        return dayOfMonth;
      }
      function getDay(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var day = date2.getDay();
        return day;
      }
      function getDaysInMonth(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var year = date2.getFullYear();
        var monthIndex = date2.getMonth();
        var lastDayOfMonth = /* @__PURE__ */ new Date(0);
        lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
        lastDayOfMonth.setHours(0, 0, 0, 0);
        return lastDayOfMonth.getDate();
      }
      function getHours(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var hours = date2.getHours();
        return hours;
      }
      function getMinutes(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var minutes = date2.getMinutes();
        return minutes;
      }
      function getMonth(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var month = date2.getMonth();
        return month;
      }
      function getSeconds(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var seconds = date2.getSeconds();
        return seconds;
      }
      function getTime(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        var timestamp = date2.getTime();
        return timestamp;
      }
      function getYear(dirtyDate) {
        requiredArgs$1(1, arguments);
        return toDate$2(dirtyDate).getFullYear();
      }
      function _arrayLikeToArray(arr, len2) {
        if (len2 == null || len2 > arr.length)
          len2 = arr.length;
        for (var i = 0, arr2 = new Array(len2); i < len2; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i = 0;
            var F = function F2() {
            };
            return {
              s: F,
              n: function n() {
                if (i >= o.length)
                  return {
                    done: true
                  };
                return {
                  done: false,
                  value: o[i++]
                };
              },
              e: function e(_e) {
                throw _e;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
          s: function s() {
            it = it.call(o);
          },
          n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          },
          e: function e(_e2) {
            didErr = true;
            err = _e2;
          },
          f: function f() {
            try {
              if (!normalCompletion && it["return"] != null)
                it["return"]();
            } finally {
              if (didErr)
                throw err;
            }
          }
        };
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _setPrototypeOf$1(o, p2) {
        _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf$1(o, p2);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass)
          _setPrototypeOf$1(subClass, superClass);
      }
      function _getPrototypeOf$1(o) {
        _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf$1(o);
      }
      function _isNativeReflectConstruct$1() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _possibleConstructorReturn(self2, call2) {
        if (call2 && (_typeof$1(call2) === "object" || typeof call2 === "function")) {
          return call2;
        } else if (call2 !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf$1(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$1(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _toPrimitive(input, hint) {
        if (_typeof$1(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof$1(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof$1(key) === "symbol" ? key : String(key);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var TIMEZONE_UNIT_PRIORITY = 10;
      var Setter = /* @__PURE__ */ function() {
        function Setter2() {
          _classCallCheck(this, Setter2);
          _defineProperty(this, "priority", void 0);
          _defineProperty(this, "subPriority", 0);
        }
        _createClass(Setter2, [{
          key: "validate",
          value: function validate(_utcDate, _options) {
            return true;
          }
        }]);
        return Setter2;
      }();
      var ValueSetter = /* @__PURE__ */ function(_Setter) {
        _inherits(ValueSetter2, _Setter);
        var _super = _createSuper(ValueSetter2);
        function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
          var _this;
          _classCallCheck(this, ValueSetter2);
          _this = _super.call(this);
          _this.value = value;
          _this.validateValue = validateValue;
          _this.setValue = setValue;
          _this.priority = priority;
          if (subPriority) {
            _this.subPriority = subPriority;
          }
          return _this;
        }
        _createClass(ValueSetter2, [{
          key: "validate",
          value: function validate(utcDate, options) {
            return this.validateValue(utcDate, this.value, options);
          }
        }, {
          key: "set",
          value: function set2(utcDate, flags, options) {
            return this.setValue(utcDate, flags, this.value, options);
          }
        }]);
        return ValueSetter2;
      }(Setter);
      var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
        _inherits(DateToSystemTimezoneSetter2, _Setter2);
        var _super2 = _createSuper(DateToSystemTimezoneSetter2);
        function DateToSystemTimezoneSetter2() {
          var _this2;
          _classCallCheck(this, DateToSystemTimezoneSetter2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _super2.call.apply(_super2, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
          _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
          return _this2;
        }
        _createClass(DateToSystemTimezoneSetter2, [{
          key: "set",
          value: function set2(date2, flags) {
            if (flags.timestampIsSet) {
              return date2;
            }
            var convertedDate = /* @__PURE__ */ new Date(0);
            convertedDate.setFullYear(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate());
            convertedDate.setHours(date2.getUTCHours(), date2.getUTCMinutes(), date2.getUTCSeconds(), date2.getUTCMilliseconds());
            return convertedDate;
          }
        }]);
        return DateToSystemTimezoneSetter2;
      }(Setter);
      var Parser = /* @__PURE__ */ function() {
        function Parser2() {
          _classCallCheck(this, Parser2);
          _defineProperty(this, "incompatibleTokens", void 0);
          _defineProperty(this, "priority", void 0);
          _defineProperty(this, "subPriority", void 0);
        }
        _createClass(Parser2, [{
          key: "run",
          value: function run(dateString, token, match2, options) {
            var result = this.parse(dateString, token, match2, options);
            if (!result) {
              return null;
            }
            return {
              setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
              rest: result.rest
            };
          }
        }, {
          key: "validate",
          value: function validate(_utcDate, _value, _options) {
            return true;
          }
        }]);
        return Parser2;
      }();
      var EraParser = /* @__PURE__ */ function(_Parser) {
        _inherits(EraParser2, _Parser);
        var _super = _createSuper(EraParser2);
        function EraParser2() {
          var _this;
          _classCallCheck(this, EraParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 140);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
          return _this;
        }
        _createClass(EraParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "G":
              case "GG":
              case "GGG":
                return match2.era(dateString, {
                  width: "abbreviated"
                }) || match2.era(dateString, {
                  width: "narrow"
                });
              case "GGGGG":
                return match2.era(dateString, {
                  width: "narrow"
                });
              case "GGGG":
              default:
                return match2.era(dateString, {
                  width: "wide"
                }) || match2.era(dateString, {
                  width: "abbreviated"
                }) || match2.era(dateString, {
                  width: "narrow"
                });
            }
          }
        }, {
          key: "set",
          value: function set2(date2, flags, value) {
            flags.era = value;
            date2.setUTCFullYear(value, 0, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return EraParser2;
      }(Parser);
      var numericPatterns = {
        month: /^(1[0-2]|0?\d)/,
        // 0 to 12
        date: /^(3[0-1]|[0-2]?\d)/,
        // 0 to 31
        dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
        // 0 to 366
        week: /^(5[0-3]|[0-4]?\d)/,
        // 0 to 53
        hour23h: /^(2[0-3]|[0-1]?\d)/,
        // 0 to 23
        hour24h: /^(2[0-4]|[0-1]?\d)/,
        // 0 to 24
        hour11h: /^(1[0-1]|0?\d)/,
        // 0 to 11
        hour12h: /^(1[0-2]|0?\d)/,
        // 0 to 12
        minute: /^[0-5]?\d/,
        // 0 to 59
        second: /^[0-5]?\d/,
        // 0 to 59
        singleDigit: /^\d/,
        // 0 to 9
        twoDigits: /^\d{1,2}/,
        // 0 to 99
        threeDigits: /^\d{1,3}/,
        // 0 to 999
        fourDigits: /^\d{1,4}/,
        // 0 to 9999
        anyDigitsSigned: /^-?\d+/,
        singleDigitSigned: /^-?\d/,
        // 0 to 9, -0 to -9
        twoDigitsSigned: /^-?\d{1,2}/,
        // 0 to 99, -0 to -99
        threeDigitsSigned: /^-?\d{1,3}/,
        // 0 to 999, -0 to -999
        fourDigitsSigned: /^-?\d{1,4}/
        // 0 to 9999, -0 to -9999
      };
      var timezonePatterns = {
        basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
        basic: /^([+-])(\d{2})(\d{2})|Z/,
        basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
        extended: /^([+-])(\d{2}):(\d{2})|Z/,
        extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
      };
      function mapValue(parseFnResult, mapFn) {
        if (!parseFnResult) {
          return parseFnResult;
        }
        return {
          value: mapFn(parseFnResult.value),
          rest: parseFnResult.rest
        };
      }
      function parseNumericPattern(pattern2, dateString) {
        var matchResult = dateString.match(pattern2);
        if (!matchResult) {
          return null;
        }
        return {
          value: parseInt(matchResult[0], 10),
          rest: dateString.slice(matchResult[0].length)
        };
      }
      function parseTimezonePattern(pattern2, dateString) {
        var matchResult = dateString.match(pattern2);
        if (!matchResult) {
          return null;
        }
        if (matchResult[0] === "Z") {
          return {
            value: 0,
            rest: dateString.slice(1)
          };
        }
        var sign = matchResult[1] === "+" ? 1 : -1;
        var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
        var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
        var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
        return {
          value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
          rest: dateString.slice(matchResult[0].length)
        };
      }
      function parseAnyDigitsSigned(dateString) {
        return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
      }
      function parseNDigits(n, dateString) {
        switch (n) {
          case 1:
            return parseNumericPattern(numericPatterns.singleDigit, dateString);
          case 2:
            return parseNumericPattern(numericPatterns.twoDigits, dateString);
          case 3:
            return parseNumericPattern(numericPatterns.threeDigits, dateString);
          case 4:
            return parseNumericPattern(numericPatterns.fourDigits, dateString);
          default:
            return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
        }
      }
      function parseNDigitsSigned(n, dateString) {
        switch (n) {
          case 1:
            return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
          case 2:
            return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
          case 3:
            return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
          case 4:
            return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
          default:
            return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
        }
      }
      function dayPeriodEnumToHours(dayPeriod) {
        switch (dayPeriod) {
          case "morning":
            return 4;
          case "evening":
            return 17;
          case "pm":
          case "noon":
          case "afternoon":
            return 12;
          case "am":
          case "midnight":
          case "night":
          default:
            return 0;
        }
      }
      function normalizeTwoDigitYear(twoDigitYear, currentYear) {
        var isCommonEra = currentYear > 0;
        var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
        var result;
        if (absCurrentYear <= 50) {
          result = twoDigitYear || 100;
        } else {
          var rangeEnd = absCurrentYear + 50;
          var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
          var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
          result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
        }
        return isCommonEra ? result : 1 - result;
      }
      function isLeapYearIndex$1(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }
      var YearParser = /* @__PURE__ */ function(_Parser) {
        _inherits(YearParser2, _Parser);
        var _super = _createSuper(YearParser2);
        function YearParser2() {
          var _this;
          _classCallCheck(this, YearParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 130);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(YearParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            var valueCallback = function valueCallback2(year) {
              return {
                year,
                isTwoDigitYear: token === "yy"
              };
            };
            switch (token) {
              case "y":
                return mapValue(parseNDigits(4, dateString), valueCallback);
              case "yo":
                return mapValue(match2.ordinalNumber(dateString, {
                  unit: "year"
                }), valueCallback);
              default:
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value.isTwoDigitYear || value.year > 0;
          }
        }, {
          key: "set",
          value: function set2(date2, flags, value) {
            var currentYear = date2.getUTCFullYear();
            if (value.isTwoDigitYear) {
              var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
              date2.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
              date2.setUTCHours(0, 0, 0, 0);
              return date2;
            }
            var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
            date2.setUTCFullYear(year, 0, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return YearParser2;
      }(Parser);
      var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
        _inherits(LocalWeekYearParser2, _Parser);
        var _super = _createSuper(LocalWeekYearParser2);
        function LocalWeekYearParser2() {
          var _this;
          _classCallCheck(this, LocalWeekYearParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 130);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
          return _this;
        }
        _createClass(LocalWeekYearParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            var valueCallback = function valueCallback2(year) {
              return {
                year,
                isTwoDigitYear: token === "YY"
              };
            };
            switch (token) {
              case "Y":
                return mapValue(parseNDigits(4, dateString), valueCallback);
              case "Yo":
                return mapValue(match2.ordinalNumber(dateString, {
                  unit: "year"
                }), valueCallback);
              default:
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value.isTwoDigitYear || value.year > 0;
          }
        }, {
          key: "set",
          value: function set2(date2, flags, value, options) {
            var currentYear = getUTCWeekYear$1(date2, options);
            if (value.isTwoDigitYear) {
              var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
              date2.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
              date2.setUTCHours(0, 0, 0, 0);
              return startOfUTCWeek$1(date2, options);
            }
            var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
            date2.setUTCFullYear(year, 0, options.firstWeekContainsDate);
            date2.setUTCHours(0, 0, 0, 0);
            return startOfUTCWeek$1(date2, options);
          }
        }]);
        return LocalWeekYearParser2;
      }(Parser);
      var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
        _inherits(ISOWeekYearParser2, _Parser);
        var _super = _createSuper(ISOWeekYearParser2);
        function ISOWeekYearParser2() {
          var _this;
          _classCallCheck(this, ISOWeekYearParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 130);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(ISOWeekYearParser2, [{
          key: "parse",
          value: function parse2(dateString, token) {
            if (token === "R") {
              return parseNDigitsSigned(4, dateString);
            }
            return parseNDigitsSigned(token.length, dateString);
          }
        }, {
          key: "set",
          value: function set2(_date, _flags, value) {
            var firstWeekOfYear = /* @__PURE__ */ new Date(0);
            firstWeekOfYear.setUTCFullYear(value, 0, 4);
            firstWeekOfYear.setUTCHours(0, 0, 0, 0);
            return startOfUTCISOWeek$1(firstWeekOfYear);
          }
        }]);
        return ISOWeekYearParser2;
      }(Parser);
      var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
        _inherits(ExtendedYearParser2, _Parser);
        var _super = _createSuper(ExtendedYearParser2);
        function ExtendedYearParser2() {
          var _this;
          _classCallCheck(this, ExtendedYearParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 130);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(ExtendedYearParser2, [{
          key: "parse",
          value: function parse2(dateString, token) {
            if (token === "u") {
              return parseNDigitsSigned(4, dateString);
            }
            return parseNDigitsSigned(token.length, dateString);
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCFullYear(value, 0, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return ExtendedYearParser2;
      }(Parser);
      var QuarterParser = /* @__PURE__ */ function(_Parser) {
        _inherits(QuarterParser2, _Parser);
        var _super = _createSuper(QuarterParser2);
        function QuarterParser2() {
          var _this;
          _classCallCheck(this, QuarterParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 120);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(QuarterParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "Q":
              case "QQ":
                return parseNDigits(token.length, dateString);
              case "Qo":
                return match2.ordinalNumber(dateString, {
                  unit: "quarter"
                });
              case "QQQ":
                return match2.quarter(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.quarter(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "QQQQQ":
                return match2.quarter(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "QQQQ":
              default:
                return match2.quarter(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.quarter(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.quarter(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 4;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMonth((value - 1) * 3, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return QuarterParser2;
      }(Parser);
      var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
        _inherits(StandAloneQuarterParser2, _Parser);
        var _super = _createSuper(StandAloneQuarterParser2);
        function StandAloneQuarterParser2() {
          var _this;
          _classCallCheck(this, StandAloneQuarterParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 120);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(StandAloneQuarterParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "q":
              case "qq":
                return parseNDigits(token.length, dateString);
              case "qo":
                return match2.ordinalNumber(dateString, {
                  unit: "quarter"
                });
              case "qqq":
                return match2.quarter(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match2.quarter(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "qqqqq":
                return match2.quarter(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "qqqq":
              default:
                return match2.quarter(dateString, {
                  width: "wide",
                  context: "standalone"
                }) || match2.quarter(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match2.quarter(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 4;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMonth((value - 1) * 3, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return StandAloneQuarterParser2;
      }(Parser);
      var MonthParser = /* @__PURE__ */ function(_Parser) {
        _inherits(MonthParser2, _Parser);
        var _super = _createSuper(MonthParser2);
        function MonthParser2() {
          var _this;
          _classCallCheck(this, MonthParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
          _defineProperty(_assertThisInitialized(_this), "priority", 110);
          return _this;
        }
        _createClass(MonthParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            var valueCallback = function valueCallback2(value) {
              return value - 1;
            };
            switch (token) {
              case "M":
                return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
              case "MM":
                return mapValue(parseNDigits(2, dateString), valueCallback);
              case "Mo":
                return mapValue(match2.ordinalNumber(dateString, {
                  unit: "month"
                }), valueCallback);
              case "MMM":
                return match2.month(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.month(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "MMMMM":
                return match2.month(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "MMMM":
              default:
                return match2.month(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.month(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.month(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 11;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMonth(value, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return MonthParser2;
      }(Parser);
      var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
        _inherits(StandAloneMonthParser2, _Parser);
        var _super = _createSuper(StandAloneMonthParser2);
        function StandAloneMonthParser2() {
          var _this;
          _classCallCheck(this, StandAloneMonthParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 110);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(StandAloneMonthParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            var valueCallback = function valueCallback2(value) {
              return value - 1;
            };
            switch (token) {
              case "L":
                return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
              case "LL":
                return mapValue(parseNDigits(2, dateString), valueCallback);
              case "Lo":
                return mapValue(match2.ordinalNumber(dateString, {
                  unit: "month"
                }), valueCallback);
              case "LLL":
                return match2.month(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match2.month(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "LLLLL":
                return match2.month(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "LLLL":
              default:
                return match2.month(dateString, {
                  width: "wide",
                  context: "standalone"
                }) || match2.month(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match2.month(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 11;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMonth(value, 1);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return StandAloneMonthParser2;
      }(Parser);
      function setUTCWeek(dirtyDate, dirtyWeek, options) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var week = toInteger$2(dirtyWeek);
        var diff = getUTCWeek$1(date2, options) - week;
        date2.setUTCDate(date2.getUTCDate() - diff * 7);
        return date2;
      }
      var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
        _inherits(LocalWeekParser2, _Parser);
        var _super = _createSuper(LocalWeekParser2);
        function LocalWeekParser2() {
          var _this;
          _classCallCheck(this, LocalWeekParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 100);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
          return _this;
        }
        _createClass(LocalWeekParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "w":
                return parseNumericPattern(numericPatterns.week, dateString);
              case "wo":
                return match2.ordinalNumber(dateString, {
                  unit: "week"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 53;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value, options) {
            return startOfUTCWeek$1(setUTCWeek(date2, value, options), options);
          }
        }]);
        return LocalWeekParser2;
      }(Parser);
      function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var isoWeek = toInteger$2(dirtyISOWeek);
        var diff = getUTCISOWeek$1(date2) - isoWeek;
        date2.setUTCDate(date2.getUTCDate() - diff * 7);
        return date2;
      }
      var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
        _inherits(ISOWeekParser2, _Parser);
        var _super = _createSuper(ISOWeekParser2);
        function ISOWeekParser2() {
          var _this;
          _classCallCheck(this, ISOWeekParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 100);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(ISOWeekParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "I":
                return parseNumericPattern(numericPatterns.week, dateString);
              case "Io":
                return match2.ordinalNumber(dateString, {
                  unit: "week"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 53;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            return startOfUTCISOWeek$1(setUTCISOWeek(date2, value));
          }
        }]);
        return ISOWeekParser2;
      }(Parser);
      var DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DateParser = /* @__PURE__ */ function(_Parser) {
        _inherits(DateParser2, _Parser);
        var _super = _createSuper(DateParser2);
        function DateParser2() {
          var _this;
          _classCallCheck(this, DateParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 90);
          _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(DateParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "d":
                return parseNumericPattern(numericPatterns.date, dateString);
              case "do":
                return match2.ordinalNumber(dateString, {
                  unit: "date"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(date2, value) {
            var year = date2.getUTCFullYear();
            var isLeapYear = isLeapYearIndex$1(year);
            var month = date2.getUTCMonth();
            if (isLeapYear) {
              return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
            } else {
              return value >= 1 && value <= DAYS_IN_MONTH$1[month];
            }
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCDate(value);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return DateParser2;
      }(Parser);
      var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
        _inherits(DayOfYearParser2, _Parser);
        var _super = _createSuper(DayOfYearParser2);
        function DayOfYearParser2() {
          var _this;
          _classCallCheck(this, DayOfYearParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 90);
          _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(DayOfYearParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "D":
              case "DD":
                return parseNumericPattern(numericPatterns.dayOfYear, dateString);
              case "Do":
                return match2.ordinalNumber(dateString, {
                  unit: "date"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(date2, value) {
            var year = date2.getUTCFullYear();
            var isLeapYear = isLeapYearIndex$1(year);
            if (isLeapYear) {
              return value >= 1 && value <= 366;
            } else {
              return value >= 1 && value <= 365;
            }
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMonth(0, value);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return DayOfYearParser2;
      }(Parser);
      function setUTCDay(dirtyDate, dirtyDay, options) {
        var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
        requiredArgs$1(2, arguments);
        var defaultOptions2 = getDefaultOptions$1();
        var weekStartsOn = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
          throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        }
        var date2 = toDate$2(dirtyDate);
        var day = toInteger$2(dirtyDay);
        var currentDay = date2.getUTCDay();
        var remainder = day % 7;
        var dayIndex = (remainder + 7) % 7;
        var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
        date2.setUTCDate(date2.getUTCDate() + diff);
        return date2;
      }
      var DayParser = /* @__PURE__ */ function(_Parser) {
        _inherits(DayParser2, _Parser);
        var _super = _createSuper(DayParser2);
        function DayParser2() {
          var _this;
          _classCallCheck(this, DayParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 90);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(DayParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "E":
              case "EE":
              case "EEE":
                return match2.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "EEEEE":
                return match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "EEEEEE":
                return match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "EEEE":
              default:
                return match2.day(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 6;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value, options) {
            date2 = setUTCDay(date2, value, options);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return DayParser2;
      }(Parser);
      var LocalDayParser = /* @__PURE__ */ function(_Parser) {
        _inherits(LocalDayParser2, _Parser);
        var _super = _createSuper(LocalDayParser2);
        function LocalDayParser2() {
          var _this;
          _classCallCheck(this, LocalDayParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 90);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
          return _this;
        }
        _createClass(LocalDayParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2, options) {
            var valueCallback = function valueCallback2(value) {
              var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
              return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
            };
            switch (token) {
              case "e":
              case "ee":
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
              case "eo":
                return mapValue(match2.ordinalNumber(dateString, {
                  unit: "day"
                }), valueCallback);
              case "eee":
                return match2.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "eeeee":
                return match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "eeeeee":
                return match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "eeee":
              default:
                return match2.day(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 6;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value, options) {
            date2 = setUTCDay(date2, value, options);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return LocalDayParser2;
      }(Parser);
      var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
        _inherits(StandAloneLocalDayParser2, _Parser);
        var _super = _createSuper(StandAloneLocalDayParser2);
        function StandAloneLocalDayParser2() {
          var _this;
          _classCallCheck(this, StandAloneLocalDayParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 90);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
          return _this;
        }
        _createClass(StandAloneLocalDayParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2, options) {
            var valueCallback = function valueCallback2(value) {
              var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
              return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
            };
            switch (token) {
              case "c":
              case "cc":
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
              case "co":
                return mapValue(match2.ordinalNumber(dateString, {
                  unit: "day"
                }), valueCallback);
              case "ccc":
                return match2.day(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "standalone"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "ccccc":
                return match2.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "cccccc":
                return match2.day(dateString, {
                  width: "short",
                  context: "standalone"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
              case "cccc":
              default:
                return match2.day(dateString, {
                  width: "wide",
                  context: "standalone"
                }) || match2.day(dateString, {
                  width: "abbreviated",
                  context: "standalone"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "standalone"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "standalone"
                });
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 6;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value, options) {
            date2 = setUTCDay(date2, value, options);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return StandAloneLocalDayParser2;
      }(Parser);
      function setUTCISODay(dirtyDate, dirtyDay) {
        requiredArgs$1(2, arguments);
        var day = toInteger$2(dirtyDay);
        if (day % 7 === 0) {
          day = day - 7;
        }
        var weekStartsOn = 1;
        var date2 = toDate$2(dirtyDate);
        var currentDay = date2.getUTCDay();
        var remainder = day % 7;
        var dayIndex = (remainder + 7) % 7;
        var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
        date2.setUTCDate(date2.getUTCDate() + diff);
        return date2;
      }
      var ISODayParser = /* @__PURE__ */ function(_Parser) {
        _inherits(ISODayParser2, _Parser);
        var _super = _createSuper(ISODayParser2);
        function ISODayParser2() {
          var _this;
          _classCallCheck(this, ISODayParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 90);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
          return _this;
        }
        _createClass(ISODayParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            var valueCallback = function valueCallback2(value) {
              if (value === 0) {
                return 7;
              }
              return value;
            };
            switch (token) {
              case "i":
              case "ii":
                return parseNDigits(token.length, dateString);
              case "io":
                return match2.ordinalNumber(dateString, {
                  unit: "day"
                });
              case "iii":
                return mapValue(match2.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
              case "iiiii":
                return mapValue(match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
              case "iiiiii":
                return mapValue(match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
              case "iiii":
              default:
                return mapValue(match2.day(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "short",
                  context: "formatting"
                }) || match2.day(dateString, {
                  width: "narrow",
                  context: "formatting"
                }), valueCallback);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 7;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2 = setUTCISODay(date2, value);
            date2.setUTCHours(0, 0, 0, 0);
            return date2;
          }
        }]);
        return ISODayParser2;
      }(Parser);
      var AMPMParser = /* @__PURE__ */ function(_Parser) {
        _inherits(AMPMParser2, _Parser);
        var _super = _createSuper(AMPMParser2);
        function AMPMParser2() {
          var _this;
          _classCallCheck(this, AMPMParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 80);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
          return _this;
        }
        _createClass(AMPMParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "a":
              case "aa":
              case "aaa":
                return match2.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "aaaaa":
                return match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "aaaa":
              default:
                return match2.dayPeriod(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
            return date2;
          }
        }]);
        return AMPMParser2;
      }(Parser);
      var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
        _inherits(AMPMMidnightParser2, _Parser);
        var _super = _createSuper(AMPMMidnightParser2);
        function AMPMMidnightParser2() {
          var _this;
          _classCallCheck(this, AMPMMidnightParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 80);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
          return _this;
        }
        _createClass(AMPMMidnightParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "b":
              case "bb":
              case "bbb":
                return match2.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "bbbbb":
                return match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "bbbb":
              default:
                return match2.dayPeriod(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
            return date2;
          }
        }]);
        return AMPMMidnightParser2;
      }(Parser);
      var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
        _inherits(DayPeriodParser2, _Parser);
        var _super = _createSuper(DayPeriodParser2);
        function DayPeriodParser2() {
          var _this;
          _classCallCheck(this, DayPeriodParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 80);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
          return _this;
        }
        _createClass(DayPeriodParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "B":
              case "BB":
              case "BBB":
                return match2.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "BBBBB":
                return match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
              case "BBBB":
              default:
                return match2.dayPeriod(dateString, {
                  width: "wide",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "abbreviated",
                  context: "formatting"
                }) || match2.dayPeriod(dateString, {
                  width: "narrow",
                  context: "formatting"
                });
            }
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
            return date2;
          }
        }]);
        return DayPeriodParser2;
      }(Parser);
      var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
        _inherits(Hour1to12Parser2, _Parser);
        var _super = _createSuper(Hour1to12Parser2);
        function Hour1to12Parser2() {
          var _this;
          _classCallCheck(this, Hour1to12Parser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 70);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
          return _this;
        }
        _createClass(Hour1to12Parser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "h":
                return parseNumericPattern(numericPatterns.hour12h, dateString);
              case "ho":
                return match2.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 12;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            var isPM = date2.getUTCHours() >= 12;
            if (isPM && value < 12) {
              date2.setUTCHours(value + 12, 0, 0, 0);
            } else if (!isPM && value === 12) {
              date2.setUTCHours(0, 0, 0, 0);
            } else {
              date2.setUTCHours(value, 0, 0, 0);
            }
            return date2;
          }
        }]);
        return Hour1to12Parser2;
      }(Parser);
      var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
        _inherits(Hour0to23Parser2, _Parser);
        var _super = _createSuper(Hour0to23Parser2);
        function Hour0to23Parser2() {
          var _this;
          _classCallCheck(this, Hour0to23Parser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 70);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
          return _this;
        }
        _createClass(Hour0to23Parser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "H":
                return parseNumericPattern(numericPatterns.hour23h, dateString);
              case "Ho":
                return match2.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 23;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCHours(value, 0, 0, 0);
            return date2;
          }
        }]);
        return Hour0to23Parser2;
      }(Parser);
      var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
        _inherits(Hour0To11Parser2, _Parser);
        var _super = _createSuper(Hour0To11Parser2);
        function Hour0To11Parser2() {
          var _this;
          _classCallCheck(this, Hour0To11Parser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 70);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
          return _this;
        }
        _createClass(Hour0To11Parser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "K":
                return parseNumericPattern(numericPatterns.hour11h, dateString);
              case "Ko":
                return match2.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 11;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            var isPM = date2.getUTCHours() >= 12;
            if (isPM && value < 12) {
              date2.setUTCHours(value + 12, 0, 0, 0);
            } else {
              date2.setUTCHours(value, 0, 0, 0);
            }
            return date2;
          }
        }]);
        return Hour0To11Parser2;
      }(Parser);
      var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
        _inherits(Hour1To24Parser2, _Parser);
        var _super = _createSuper(Hour1To24Parser2);
        function Hour1To24Parser2() {
          var _this;
          _classCallCheck(this, Hour1To24Parser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 70);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
          return _this;
        }
        _createClass(Hour1To24Parser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "k":
                return parseNumericPattern(numericPatterns.hour24h, dateString);
              case "ko":
                return match2.ordinalNumber(dateString, {
                  unit: "hour"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 1 && value <= 24;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            var hours = value <= 24 ? value % 24 : value;
            date2.setUTCHours(hours, 0, 0, 0);
            return date2;
          }
        }]);
        return Hour1To24Parser2;
      }(Parser);
      var MinuteParser = /* @__PURE__ */ function(_Parser) {
        _inherits(MinuteParser2, _Parser);
        var _super = _createSuper(MinuteParser2);
        function MinuteParser2() {
          var _this;
          _classCallCheck(this, MinuteParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 60);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
          return _this;
        }
        _createClass(MinuteParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "m":
                return parseNumericPattern(numericPatterns.minute, dateString);
              case "mo":
                return match2.ordinalNumber(dateString, {
                  unit: "minute"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 59;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMinutes(value, 0, 0);
            return date2;
          }
        }]);
        return MinuteParser2;
      }(Parser);
      var SecondParser = /* @__PURE__ */ function(_Parser) {
        _inherits(SecondParser2, _Parser);
        var _super = _createSuper(SecondParser2);
        function SecondParser2() {
          var _this;
          _classCallCheck(this, SecondParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 50);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
          return _this;
        }
        _createClass(SecondParser2, [{
          key: "parse",
          value: function parse2(dateString, token, match2) {
            switch (token) {
              case "s":
                return parseNumericPattern(numericPatterns.second, dateString);
              case "so":
                return match2.ordinalNumber(dateString, {
                  unit: "second"
                });
              default:
                return parseNDigits(token.length, dateString);
            }
          }
        }, {
          key: "validate",
          value: function validate(_date, value) {
            return value >= 0 && value <= 59;
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCSeconds(value, 0);
            return date2;
          }
        }]);
        return SecondParser2;
      }(Parser);
      var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
        _inherits(FractionOfSecondParser2, _Parser);
        var _super = _createSuper(FractionOfSecondParser2);
        function FractionOfSecondParser2() {
          var _this;
          _classCallCheck(this, FractionOfSecondParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 30);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
          return _this;
        }
        _createClass(FractionOfSecondParser2, [{
          key: "parse",
          value: function parse2(dateString, token) {
            var valueCallback = function valueCallback2(value) {
              return Math.floor(value * Math.pow(10, -token.length + 3));
            };
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          }
        }, {
          key: "set",
          value: function set2(date2, _flags, value) {
            date2.setUTCMilliseconds(value);
            return date2;
          }
        }]);
        return FractionOfSecondParser2;
      }(Parser);
      var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
        _inherits(ISOTimezoneWithZParser2, _Parser);
        var _super = _createSuper(ISOTimezoneWithZParser2);
        function ISOTimezoneWithZParser2() {
          var _this;
          _classCallCheck(this, ISOTimezoneWithZParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 10);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
          return _this;
        }
        _createClass(ISOTimezoneWithZParser2, [{
          key: "parse",
          value: function parse2(dateString, token) {
            switch (token) {
              case "X":
                return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
              case "XX":
                return parseTimezonePattern(timezonePatterns.basic, dateString);
              case "XXXX":
                return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
              case "XXXXX":
                return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
              case "XXX":
              default:
                return parseTimezonePattern(timezonePatterns.extended, dateString);
            }
          }
        }, {
          key: "set",
          value: function set2(date2, flags, value) {
            if (flags.timestampIsSet) {
              return date2;
            }
            return new Date(date2.getTime() - value);
          }
        }]);
        return ISOTimezoneWithZParser2;
      }(Parser);
      var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
        _inherits(ISOTimezoneParser2, _Parser);
        var _super = _createSuper(ISOTimezoneParser2);
        function ISOTimezoneParser2() {
          var _this;
          _classCallCheck(this, ISOTimezoneParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 10);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
          return _this;
        }
        _createClass(ISOTimezoneParser2, [{
          key: "parse",
          value: function parse2(dateString, token) {
            switch (token) {
              case "x":
                return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
              case "xx":
                return parseTimezonePattern(timezonePatterns.basic, dateString);
              case "xxxx":
                return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
              case "xxxxx":
                return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
              case "xxx":
              default:
                return parseTimezonePattern(timezonePatterns.extended, dateString);
            }
          }
        }, {
          key: "set",
          value: function set2(date2, flags, value) {
            if (flags.timestampIsSet) {
              return date2;
            }
            return new Date(date2.getTime() - value);
          }
        }]);
        return ISOTimezoneParser2;
      }(Parser);
      var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
        _inherits(TimestampSecondsParser2, _Parser);
        var _super = _createSuper(TimestampSecondsParser2);
        function TimestampSecondsParser2() {
          var _this;
          _classCallCheck(this, TimestampSecondsParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 40);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
          return _this;
        }
        _createClass(TimestampSecondsParser2, [{
          key: "parse",
          value: function parse2(dateString) {
            return parseAnyDigitsSigned(dateString);
          }
        }, {
          key: "set",
          value: function set2(_date, _flags, value) {
            return [new Date(value * 1e3), {
              timestampIsSet: true
            }];
          }
        }]);
        return TimestampSecondsParser2;
      }(Parser);
      var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
        _inherits(TimestampMillisecondsParser2, _Parser);
        var _super = _createSuper(TimestampMillisecondsParser2);
        function TimestampMillisecondsParser2() {
          var _this;
          _classCallCheck(this, TimestampMillisecondsParser2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "priority", 20);
          _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
          return _this;
        }
        _createClass(TimestampMillisecondsParser2, [{
          key: "parse",
          value: function parse2(dateString) {
            return parseAnyDigitsSigned(dateString);
          }
        }, {
          key: "set",
          value: function set2(_date, _flags, value) {
            return [new Date(value), {
              timestampIsSet: true
            }];
          }
        }]);
        return TimestampMillisecondsParser2;
      }(Parser);
      var parsers = {
        G: new EraParser(),
        y: new YearParser(),
        Y: new LocalWeekYearParser(),
        R: new ISOWeekYearParser(),
        u: new ExtendedYearParser(),
        Q: new QuarterParser(),
        q: new StandAloneQuarterParser(),
        M: new MonthParser(),
        L: new StandAloneMonthParser(),
        w: new LocalWeekParser(),
        I: new ISOWeekParser(),
        d: new DateParser(),
        D: new DayOfYearParser(),
        E: new DayParser(),
        e: new LocalDayParser(),
        c: new StandAloneLocalDayParser(),
        i: new ISODayParser(),
        a: new AMPMParser(),
        b: new AMPMMidnightParser(),
        B: new DayPeriodParser(),
        h: new Hour1to12Parser(),
        H: new Hour0to23Parser(),
        K: new Hour0To11Parser(),
        k: new Hour1To24Parser(),
        m: new MinuteParser(),
        s: new SecondParser(),
        S: new FractionOfSecondParser(),
        X: new ISOTimezoneWithZParser(),
        x: new ISOTimezoneParser(),
        t: new TimestampSecondsParser(),
        T: new TimestampMillisecondsParser()
      };
      var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
      var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
      var escapedStringRegExp = /^'([^]*?)'?$/;
      var doubleQuoteRegExp = /''/g;
      var notWhitespaceRegExp = /\S/;
      var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
      function parse$1(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
        var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
        requiredArgs$1(3, arguments);
        var dateString = String(dirtyDateString);
        var formatString = String(dirtyFormatString);
        var defaultOptions2 = getDefaultOptions$1();
        var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
        if (!locale2.match) {
          throw new RangeError("locale must contain match property");
        }
        var firstWeekContainsDate = toInteger$2((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
          throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        }
        var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
          throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        }
        if (formatString === "") {
          if (dateString === "") {
            return toDate$2(dirtyReferenceDate);
          } else {
            return /* @__PURE__ */ new Date(NaN);
          }
        }
        var subFnOptions = {
          firstWeekContainsDate,
          weekStartsOn,
          locale: locale2
        };
        var setters = [new DateToSystemTimezoneSetter()];
        var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
          var firstCharacter = substring[0];
          if (firstCharacter in longFormatters$2) {
            var longFormatter = longFormatters$2[firstCharacter];
            return longFormatter(substring, locale2.formatLong);
          }
          return substring;
        }).join("").match(formattingTokensRegExp);
        var usedTokens = [];
        var _iterator = _createForOfIteratorHelper(tokens), _step;
        try {
          var _loop = function _loop2() {
            var token = _step.value;
            if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(token)) {
              throwProtectedError$1(token, formatString, dirtyDateString);
            }
            if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(token)) {
              throwProtectedError$1(token, formatString, dirtyDateString);
            }
            var firstCharacter = token[0];
            var parser = parsers[firstCharacter];
            if (parser) {
              var incompatibleTokens = parser.incompatibleTokens;
              if (Array.isArray(incompatibleTokens)) {
                var incompatibleToken = usedTokens.find(function(usedToken) {
                  return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
                });
                if (incompatibleToken) {
                  throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
                }
              } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
                throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
              }
              usedTokens.push({
                token: firstCharacter,
                fullToken: token
              });
              var parseResult = parser.run(dateString, token, locale2.match, subFnOptions);
              if (!parseResult) {
                return {
                  v: /* @__PURE__ */ new Date(NaN)
                };
              }
              setters.push(parseResult.setter);
              dateString = parseResult.rest;
            } else {
              if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
                throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
              }
              if (token === "''") {
                token = "'";
              } else if (firstCharacter === "'") {
                token = cleanEscapedString(token);
              }
              if (dateString.indexOf(token) === 0) {
                dateString = dateString.slice(token.length);
              } else {
                return {
                  v: /* @__PURE__ */ new Date(NaN)
                };
              }
            }
          };
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _ret = _loop();
            if (_typeof$1(_ret) === "object")
              return _ret.v;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        var uniquePrioritySetters = setters.map(function(setter2) {
          return setter2.priority;
        }).sort(function(a2, b) {
          return b - a2;
        }).filter(function(priority, index, array2) {
          return array2.indexOf(priority) === index;
        }).map(function(priority) {
          return setters.filter(function(setter2) {
            return setter2.priority === priority;
          }).sort(function(a2, b) {
            return b.subPriority - a2.subPriority;
          });
        }).map(function(setterArray) {
          return setterArray[0];
        });
        var date2 = toDate$2(dirtyReferenceDate);
        if (isNaN(date2.getTime())) {
          return /* @__PURE__ */ new Date(NaN);
        }
        var utcDate = subMilliseconds$1(date2, getTimezoneOffsetInMilliseconds$2(date2));
        var flags = {};
        var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var setter = _step2.value;
            if (!setter.validate(utcDate, subFnOptions)) {
              return /* @__PURE__ */ new Date(NaN);
            }
            var result = setter.set(utcDate, flags, subFnOptions);
            if (Array.isArray(result)) {
              utcDate = result[0];
              assign$2(flags, result[1]);
            } else {
              utcDate = result;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return utcDate;
      }
      function cleanEscapedString(input) {
        return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
      }
      function startOfHour(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        date2.setMinutes(0, 0, 0);
        return date2;
      }
      function isSameMonth(dirtyDateLeft, dirtyDateRight) {
        requiredArgs$1(2, arguments);
        var dateLeft = toDate$2(dirtyDateLeft);
        var dateRight = toDate$2(dirtyDateRight);
        return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
      }
      function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
        requiredArgs$1(2, arguments);
        var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
        var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
        return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
      }
      function startOfSecond(dirtyDate) {
        requiredArgs$1(1, arguments);
        var date2 = toDate$2(dirtyDate);
        date2.setMilliseconds(0);
        return date2;
      }
      function isSameYear(dirtyDateLeft, dirtyDateRight) {
        requiredArgs$1(2, arguments);
        var dateLeft = toDate$2(dirtyDateLeft);
        var dateRight = toDate$2(dirtyDateRight);
        return dateLeft.getFullYear() === dateRight.getFullYear();
      }
      function setMonth(dirtyDate, dirtyMonth) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var month = toInteger$2(dirtyMonth);
        var year = date2.getFullYear();
        var day = date2.getDate();
        var dateWithDesiredMonth = /* @__PURE__ */ new Date(0);
        dateWithDesiredMonth.setFullYear(year, month, 15);
        dateWithDesiredMonth.setHours(0, 0, 0, 0);
        var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
        date2.setMonth(month, Math.min(day, daysInMonth));
        return date2;
      }
      function set(dirtyDate, values) {
        requiredArgs$1(2, arguments);
        if (_typeof$1(values) !== "object" || values === null) {
          throw new RangeError("values parameter must be an object");
        }
        var date2 = toDate$2(dirtyDate);
        if (isNaN(date2.getTime())) {
          return /* @__PURE__ */ new Date(NaN);
        }
        if (values.year != null) {
          date2.setFullYear(values.year);
        }
        if (values.month != null) {
          date2 = setMonth(date2, values.month);
        }
        if (values.date != null) {
          date2.setDate(toInteger$2(values.date));
        }
        if (values.hours != null) {
          date2.setHours(toInteger$2(values.hours));
        }
        if (values.minutes != null) {
          date2.setMinutes(toInteger$2(values.minutes));
        }
        if (values.seconds != null) {
          date2.setSeconds(toInteger$2(values.seconds));
        }
        if (values.milliseconds != null) {
          date2.setMilliseconds(toInteger$2(values.milliseconds));
        }
        return date2;
      }
      function setHours(dirtyDate, dirtyHours) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var hours = toInteger$2(dirtyHours);
        date2.setHours(hours);
        return date2;
      }
      function setMinutes(dirtyDate, dirtyMinutes) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var minutes = toInteger$2(dirtyMinutes);
        date2.setMinutes(minutes);
        return date2;
      }
      function setQuarter(dirtyDate, dirtyQuarter) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var quarter = toInteger$2(dirtyQuarter);
        var oldQuarter = Math.floor(date2.getMonth() / 3) + 1;
        var diff = quarter - oldQuarter;
        return setMonth(date2, date2.getMonth() + diff * 3);
      }
      function setSeconds(dirtyDate, dirtySeconds) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var seconds = toInteger$2(dirtySeconds);
        date2.setSeconds(seconds);
        return date2;
      }
      function setYear(dirtyDate, dirtyYear) {
        requiredArgs$1(2, arguments);
        var date2 = toDate$2(dirtyDate);
        var year = toInteger$2(dirtyYear);
        if (isNaN(date2.getTime())) {
          return /* @__PURE__ */ new Date(NaN);
        }
        date2.setFullYear(year);
        return date2;
      }
      function useLocale(ns) {
        const { mergedLocaleRef, mergedDateLocaleRef } = vue.inject(configProviderInjectionKey, null) || {};
        const localeRef = vue.computed(() => {
          var _a, _b;
          return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : enUS$2[ns];
        });
        const dateLocaleRef = vue.computed(() => {
          var _a;
          return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : dateEnUS;
        });
        return {
          dateLocaleRef,
          localeRef
        };
      }
      function useStyle(mountId, style2, clsPrefixRef) {
        if (!style2) {
          return;
        }
        const ssrAdapter2 = useSsrAdapter();
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2
          });
          if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          vue.onBeforeMount(mountStyle);
        }
      }
      function useHljs(props, shouldHighlightRef) {
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        return vue.computed(() => {
          return props.hljs || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value);
        });
      }
      function useThemeClass(componentName, hashRef, cssVarsRef, props) {
        var _a;
        if (!cssVarsRef)
          throwError("useThemeClass", "cssVarsRef is not passed");
        const mergedThemeHashRef = (_a = vue.inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedThemeHashRef;
        const themeClassRef = vue.ref("");
        const ssrAdapter2 = useSsrAdapter();
        let renderCallback;
        const hashClassPrefix = `__${componentName}`;
        const mountStyle = () => {
          let finalThemeHash = hashClassPrefix;
          const hashValue = hashRef ? hashRef.value : void 0;
          const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
          if (themeHash)
            finalThemeHash += "-" + themeHash;
          if (hashValue)
            finalThemeHash += "-" + hashValue;
          const { themeOverrides, builtinThemeOverrides } = props;
          if (themeOverrides) {
            finalThemeHash += "-" + murmur2(JSON.stringify(themeOverrides));
          }
          if (builtinThemeOverrides) {
            finalThemeHash += "-" + murmur2(JSON.stringify(builtinThemeOverrides));
          }
          themeClassRef.value = finalThemeHash;
          renderCallback = () => {
            const cssVars = cssVarsRef.value;
            let style2 = "";
            for (const key in cssVars) {
              style2 += `${key}: ${cssVars[key]};`;
            }
            c$1(`.${finalThemeHash}`, style2).mount({
              id: finalThemeHash,
              ssr: ssrAdapter2
            });
            renderCallback = void 0;
          };
        };
        vue.watchEffect(() => {
          mountStyle();
        });
        return {
          themeClass: themeClassRef,
          onRender: () => {
            renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
          }
        };
      }
      function useRtl(mountId, rtlStateRef, clsPrefixRef) {
        if (!rtlStateRef)
          return void 0;
        const ssrAdapter2 = useSsrAdapter();
        const componentRtlStateRef = vue.computed(() => {
          const { value: rtlState } = rtlStateRef;
          if (!rtlState) {
            return void 0;
          }
          const componentRtlState = rtlState[mountId];
          if (!componentRtlState) {
            return void 0;
          }
          return componentRtlState;
        });
        const mountStyle = () => {
          vue.watchEffect(() => {
            const { value: clsPrefix } = clsPrefixRef;
            const id = `${clsPrefix}${mountId}Rtl`;
            if (exists(id, ssrAdapter2))
              return;
            const { value: componentRtlState } = componentRtlStateRef;
            if (!componentRtlState)
              return;
            componentRtlState.style.mount({
              id,
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              props: {
                bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
              },
              ssr: ssrAdapter2
            });
          });
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          vue.onBeforeMount(mountStyle);
        }
        return componentRtlStateRef;
      }
      function getScrollTop(target) {
        return target instanceof HTMLElement ? target.scrollTop : window.scrollY;
      }
      function getRect(target) {
        return target instanceof HTMLElement ? target.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
      }
      const style$1z = cB("affix", [cM("affixed", {
        position: "fixed"
      }, [cM("absolute-positioned", {
        position: "absolute"
      })])]);
      const affixProps = {
        listenTo: [String, Object, Function],
        top: Number,
        bottom: Number,
        triggerTop: Number,
        triggerBottom: Number,
        position: {
          type: String,
          default: "fix"
        },
        // deprecated
        offsetTop: {
          type: Number,
          validator: () => {
            return true;
          },
          default: void 0
        },
        offsetBottom: {
          type: Number,
          validator: () => {
            return true;
          },
          default: void 0
        },
        target: {
          type: Function,
          validator: () => {
            return true;
          },
          default: void 0
        }
      };
      const affixPropKeys = keysOf(affixProps);
      const NAffix = vue.defineComponent({
        name: "Affix",
        props: affixProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          useStyle("-affix", style$1z, mergedClsPrefixRef);
          let scrollTarget = null;
          const stickToTopRef = vue.ref(false);
          const stickToBottomRef = vue.ref(false);
          const bottomAffixedTriggerScrollTopRef = vue.ref(null);
          const topAffixedTriggerScrollTopRef = vue.ref(null);
          const affixedRef = vue.computed(() => {
            return stickToBottomRef.value || stickToTopRef.value;
          });
          const mergedOffsetTopRef = vue.computed(() => {
            var _a, _b;
            return (_b = (_a = props.triggerTop) !== null && _a !== void 0 ? _a : props.offsetTop) !== null && _b !== void 0 ? _b : props.top;
          });
          const mergedTopRef = vue.computed(() => {
            var _a, _b;
            return (_b = (_a = props.top) !== null && _a !== void 0 ? _a : props.triggerTop) !== null && _b !== void 0 ? _b : props.offsetTop;
          });
          const mergedBottomRef = vue.computed(() => {
            var _a, _b;
            return (_b = (_a = props.bottom) !== null && _a !== void 0 ? _a : props.triggerBottom) !== null && _b !== void 0 ? _b : props.offsetBottom;
          });
          const mergedOffsetBottomRef = vue.computed(() => {
            var _a, _b;
            return (_b = (_a = props.triggerBottom) !== null && _a !== void 0 ? _a : props.offsetBottom) !== null && _b !== void 0 ? _b : props.bottom;
          });
          const selfRef = vue.ref(null);
          const init2 = () => {
            const { target: getScrollTarget, listenTo } = props;
            if (getScrollTarget) {
              scrollTarget = getScrollTarget();
            } else if (listenTo) {
              scrollTarget = unwrapElement(listenTo);
            } else {
              scrollTarget = document;
            }
            if (scrollTarget) {
              scrollTarget.addEventListener("scroll", handleScroll);
              handleScroll();
            }
          };
          function handleScroll() {
            beforeNextFrameOnce(_handleScroll);
          }
          function _handleScroll() {
            const { value: selfEl } = selfRef;
            if (!scrollTarget || !selfEl)
              return;
            const scrollTop = getScrollTop(scrollTarget);
            if (affixedRef.value) {
              if (scrollTop < topAffixedTriggerScrollTopRef.value) {
                stickToTopRef.value = false;
                topAffixedTriggerScrollTopRef.value = null;
              }
              if (scrollTop > bottomAffixedTriggerScrollTopRef.value) {
                stickToBottomRef.value = false;
                bottomAffixedTriggerScrollTopRef.value = null;
              }
              return;
            }
            const containerRect = getRect(scrollTarget);
            const affixRect = selfEl.getBoundingClientRect();
            const pxToTop = affixRect.top - containerRect.top;
            const pxToBottom = containerRect.bottom - affixRect.bottom;
            const mergedOffsetTop = mergedOffsetTopRef.value;
            const mergedOffsetBottom = mergedOffsetBottomRef.value;
            if (mergedOffsetTop !== void 0 && pxToTop <= mergedOffsetTop) {
              stickToTopRef.value = true;
              topAffixedTriggerScrollTopRef.value = scrollTop - (mergedOffsetTop - pxToTop);
            } else {
              stickToTopRef.value = false;
              topAffixedTriggerScrollTopRef.value = null;
            }
            if (mergedOffsetBottom !== void 0 && pxToBottom <= mergedOffsetBottom) {
              stickToBottomRef.value = true;
              bottomAffixedTriggerScrollTopRef.value = scrollTop + mergedOffsetBottom - pxToBottom;
            } else {
              stickToBottomRef.value = false;
              bottomAffixedTriggerScrollTopRef.value = null;
            }
          }
          vue.onMounted(() => {
            init2();
          });
          vue.onBeforeUnmount(() => {
            if (!scrollTarget)
              return;
            scrollTarget.removeEventListener("scroll", handleScroll);
          });
          return {
            selfRef,
            affixed: affixedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedstyle: vue.computed(() => {
              const style2 = {};
              if (stickToTopRef.value && mergedOffsetTopRef.value !== void 0 && mergedTopRef.value !== void 0) {
                style2.top = `${mergedTopRef.value}px`;
              }
              if (stickToBottomRef.value && mergedOffsetBottomRef.value !== void 0 && mergedBottomRef.value !== void 0) {
                style2.bottom = `${mergedBottomRef.value}px`;
              }
              return style2;
            })
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h("div", { ref: "selfRef", class: [
            `${mergedClsPrefix}-affix`,
            {
              [`${mergedClsPrefix}-affix--affixed`]: this.affixed,
              [`${mergedClsPrefix}-affix--absolute-positioned`]: this.position === "absolute"
            }
          ], style: this.mergedstyle }, this.$slots);
        }
      });
      const AddIcon = vue.defineComponent({
        name: "Add",
        render() {
          return vue.h(
            "svg",
            { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" })
          );
        }
      });
      const ArrowDownIcon = vue.defineComponent({
        name: "ArrowDown",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
            vue.h(
              "g",
              { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
              vue.h(
                "g",
                { "fill-rule": "nonzero" },
                vue.h("path", { d: "M23.7916,15.2664 C24.0788,14.9679 24.0696,14.4931 23.7711,14.206 C23.4726,13.9188 22.9978,13.928 22.7106,14.2265 L14.7511,22.5007 L14.7511,3.74792 C14.7511,3.33371 14.4153,2.99792 14.0011,2.99792 C13.5869,2.99792 13.2511,3.33371 13.2511,3.74793 L13.2511,22.4998 L5.29259,14.2265 C5.00543,13.928 4.53064,13.9188 4.23213,14.206 C3.93361,14.4931 3.9244,14.9679 4.21157,15.2664 L13.2809,24.6944 C13.6743,25.1034 14.3289,25.1034 14.7223,24.6944 L23.7916,15.2664 Z" })
              )
            )
          );
        }
      });
      const ArrowUpIcon = vue.defineComponent({
        name: "ArrowUp",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
            vue.h(
              "g",
              { fill: "none" },
              vue.h("path", { d: "M3.13 9.163a.5.5 0 1 0 .74.674L9.5 3.67V17.5a.5.5 0 0 0 1 0V3.672l5.63 6.165a.5.5 0 0 0 .738-.674l-6.315-6.916a.746.746 0 0 0-.632-.24a.746.746 0 0 0-.476.24L3.131 9.163z", fill: "currentColor" })
            )
          );
        }
      });
      function replaceable(name, icon) {
        return vue.defineComponent({
          name: upperFirst$1(name),
          setup() {
            var _a;
            const mergedIconsRef = (_a = vue.inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedIconsRef;
            return () => {
              var _a2;
              const iconOverride = (_a2 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a2 === void 0 ? void 0 : _a2[name];
              return iconOverride ? iconOverride() : icon;
            };
          }
        });
      }
      const AttachIcon = replaceable("attach", vue.h(
        "svg",
        { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            vue.h("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" })
          )
        )
      ));
      const BackwardIcon = vue.defineComponent({
        name: "Backward",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M12.2674 15.793C11.9675 16.0787 11.4927 16.0672 11.2071 15.7673L6.20572 10.5168C5.9298 10.2271 5.9298 9.7719 6.20572 9.48223L11.2071 4.23177C11.4927 3.93184 11.9675 3.92031 12.2674 4.206C12.5673 4.49169 12.5789 4.96642 12.2932 5.26634L7.78458 9.99952L12.2932 14.7327C12.5789 15.0326 12.5673 15.5074 12.2674 15.793Z", fill: "currentColor" })
          );
        }
      });
      const DateIcon = replaceable("date", vue.h(
        "svg",
        { width: "28px", height: "28px", viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { "fill-rule": "nonzero" },
            vue.h("path", { d: "M21.75,3 C23.5449254,3 25,4.45507456 25,6.25 L25,21.75 C25,23.5449254 23.5449254,25 21.75,25 L6.25,25 C4.45507456,25 3,23.5449254 3,21.75 L3,6.25 C3,4.45507456 4.45507456,3 6.25,3 L21.75,3 Z M23.5,9.503 L4.5,9.503 L4.5,21.75 C4.5,22.7164983 5.28350169,23.5 6.25,23.5 L21.75,23.5 C22.7164983,23.5 23.5,22.7164983 23.5,21.75 L23.5,9.503 Z M21.75,4.5 L6.25,4.5 C5.28350169,4.5 4.5,5.28350169 4.5,6.25 L4.5,8.003 L23.5,8.003 L23.5,6.25 C23.5,5.28350169 22.7164983,4.5 21.75,4.5 Z" })
          )
        )
      ));
      const FinishedIcon = vue.defineComponent({
        name: "Checkmark",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
            vue.h(
              "g",
              { fill: "none" },
              vue.h("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })
            )
          );
        }
      });
      const ChevronLeftIcon = vue.defineComponent({
        name: "ChevronLeft",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" })
          );
        }
      });
      const ChevronRightIcon = vue.defineComponent({
        name: "ChevronRight",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z", fill: "currentColor" })
          );
        }
      });
      const ErrorIcon$1 = replaceable("close", vue.h(
        "svg",
        { viewBox: "0 0 12 12", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": true },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            vue.h("path", { d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z" })
          )
        )
      ));
      const EyeIcon = vue.defineComponent({
        name: "Eye",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
            vue.h("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }),
            vue.h("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" })
          );
        }
      });
      const EyeOffIcon = vue.defineComponent({
        name: "EyeOff",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
            vue.h("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }),
            vue.h("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }),
            vue.h("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }),
            vue.h("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }),
            vue.h("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" })
          );
        }
      });
      const TrashIcon = replaceable("trash", vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
        vue.h("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }),
        vue.h("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }),
        vue.h("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }),
        vue.h("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" })
      ));
      const DownloadIcon = replaceable("download", vue.h(
        "svg",
        { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            vue.h("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" })
          )
        )
      ));
      const EmptyIcon = vue.defineComponent({
        name: "Empty",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }),
            vue.h("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" })
          );
        }
      });
      const ErrorIcon = replaceable("error", vue.h(
        "svg",
        { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { "fill-rule": "nonzero" },
            vue.h("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z" })
          )
        )
      ));
      const FastBackwardIcon = vue.defineComponent({
        name: "FastBackward",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
            vue.h(
              "g",
              { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
              vue.h(
                "g",
                { fill: "currentColor", "fill-rule": "nonzero" },
                vue.h("path", { d: "M8.73171,16.7949 C9.03264,17.0795 9.50733,17.0663 9.79196,16.7654 C10.0766,16.4644 10.0634,15.9897 9.76243,15.7051 L4.52339,10.75 L17.2471,10.75 C17.6613,10.75 17.9971,10.4142 17.9971,10 C17.9971,9.58579 17.6613,9.25 17.2471,9.25 L4.52112,9.25 L9.76243,4.29275 C10.0634,4.00812 10.0766,3.53343 9.79196,3.2325 C9.50733,2.93156 9.03264,2.91834 8.73171,3.20297 L2.31449,9.27241 C2.14819,9.4297 2.04819,9.62981 2.01448,9.8386 C2.00308,9.89058 1.99707,9.94459 1.99707,10 C1.99707,10.0576 2.00356,10.1137 2.01585,10.1675 C2.05084,10.3733 2.15039,10.5702 2.31449,10.7254 L8.73171,16.7949 Z" })
              )
            )
          );
        }
      });
      const FastForwardIcon = vue.defineComponent({
        name: "FastForward",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
            vue.h(
              "g",
              { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
              vue.h(
                "g",
                { fill: "currentColor", "fill-rule": "nonzero" },
                vue.h("path", { d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z" })
              )
            )
          );
        }
      });
      const FilterIcon = vue.defineComponent({
        name: "Filter",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
            vue.h(
              "g",
              { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
              vue.h(
                "g",
                { "fill-rule": "nonzero" },
                vue.h("path", { d: "M17,19 C17.5522847,19 18,19.4477153 18,20 C18,20.5522847 17.5522847,21 17,21 L11,21 C10.4477153,21 10,20.5522847 10,20 C10,19.4477153 10.4477153,19 11,19 L17,19 Z M21,13 C21.5522847,13 22,13.4477153 22,14 C22,14.5522847 21.5522847,15 21,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4477153 6.44771525,13 7,13 L21,13 Z M24,7 C24.5522847,7 25,7.44771525 25,8 C25,8.55228475 24.5522847,9 24,9 L4,9 C3.44771525,9 3,8.55228475 3,8 C3,7.44771525 3.44771525,7 4,7 L24,7 Z" })
              )
            )
          );
        }
      });
      const ForwardIcon = vue.defineComponent({
        name: "Forward",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z", fill: "currentColor" })
          );
        }
      });
      const InfoIcon = replaceable("info", vue.h(
        "svg",
        { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { "fill-rule": "nonzero" },
            vue.h("path", { d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z" })
          )
        )
      ));
      const MoreIcon = vue.defineComponent({
        name: "More",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
            vue.h(
              "g",
              { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
              vue.h(
                "g",
                { fill: "currentColor", "fill-rule": "nonzero" },
                vue.h("path", { d: "M4,7 C4.55228,7 5,7.44772 5,8 C5,8.55229 4.55228,9 4,9 C3.44772,9 3,8.55229 3,8 C3,7.44772 3.44772,7 4,7 Z M8,7 C8.55229,7 9,7.44772 9,8 C9,8.55229 8.55229,9 8,9 C7.44772,9 7,8.55229 7,8 C7,7.44772 7.44772,7 8,7 Z M12,7 C12.5523,7 13,7.44772 13,8 C13,8.55229 12.5523,9 12,9 C11.4477,9 11,8.55229 11,8 C11,7.44772 11.4477,7 12,7 Z" })
              )
            )
          );
        }
      });
      const RemoveIcon = vue.defineComponent({
        name: "Remove",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
            vue.h("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      " })
          );
        }
      });
      const SearchIcon = vue.defineComponent({
        name: "Search",
        render() {
          return vue.h(
            "svg",
            { version: "1.1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", style: "enable-background: new 0 0 512 512" },
            vue.h("path", { d: "M443.5,420.2L336.7,312.4c20.9-26.2,33.5-59.4,33.5-95.5c0-84.5-68.5-153-153.1-153S64,132.5,64,217s68.5,153,153.1,153\n  c36.6,0,70.1-12.8,96.5-34.2l106.1,107.1c3.2,3.4,7.6,5.1,11.9,5.1c4.1,0,8.2-1.5,11.3-4.5C449.5,437.2,449.7,426.8,443.5,420.2z\n   M217.1,337.1c-32.1,0-62.3-12.5-85-35.2c-22.7-22.7-35.2-52.9-35.2-84.9c0-32.1,12.5-62.3,35.2-84.9c22.7-22.7,52.9-35.2,85-35.2\n  c32.1,0,62.3,12.5,85,35.2c22.7,22.7,35.2,52.9,35.2,84.9c0,32.1-12.5,62.3-35.2,84.9C279.4,324.6,249.2,337.1,217.1,337.1z" })
          );
        }
      });
      const SuccessIcon = replaceable("success", vue.h(
        "svg",
        { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { "fill-rule": "nonzero" },
            vue.h("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z" })
          )
        )
      ));
      const SwitcherIcon = vue.defineComponent({
        name: "Switcher",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
            vue.h("path", { d: "M12 8l10 8l-10 8z" })
          );
        }
      });
      const TimeIcon = replaceable("time", vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
        vue.h("path", { d: "M256,64C150,64,64,150,64,256s86,192,192,192,192-86,192-192S362,64,256,64Z", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-miterlimit: 10;\n        stroke-width: 32px;\n      " }),
        vue.h("polyline", { points: "256 128 256 272 352 272", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      " })
      ));
      const WarningIcon = replaceable("warning", vue.h(
        "svg",
        { viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { "fill-rule": "nonzero" },
            vue.h("path", { d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z" })
          )
        )
      ));
      const CancelIcon = replaceable("cancel", vue.h(
        "svg",
        { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            vue.h("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" })
          )
        )
      ));
      const ChevronDownIcon = vue.defineComponent({
        name: "ChevronDown",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" })
          );
        }
      });
      const ClearIcon = replaceable("clear", vue.h(
        "svg",
        { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            vue.h("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" })
          )
        )
      ));
      const ChevronDownFilledIcon = vue.defineComponent({
        name: "ChevronDownFilled",
        render() {
          return vue.h(
            "svg",
            { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            vue.h("path", { d: "M3.20041 5.73966C3.48226 5.43613 3.95681 5.41856 4.26034 5.70041L8 9.22652L11.7397 5.70041C12.0432 5.41856 12.5177 5.43613 12.7996 5.73966C13.0815 6.0432 13.0639 6.51775 12.7603 6.7996L8.51034 10.7996C8.22258 11.0668 7.77743 11.0668 7.48967 10.7996L3.23966 6.7996C2.93613 6.51775 2.91856 6.0432 3.20041 5.73966Z", fill: "currentColor" })
          );
        }
      });
      const ToIcon = replaceable("to", vue.h(
        "svg",
        { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { fill: "currentColor", "fill-rule": "nonzero" },
            vue.h("path", { d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z" })
          )
        )
      ));
      const RetryIcon = replaceable("retry", vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
        vue.h("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }),
        vue.h("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" })
      ));
      const ArrowBackIcon = vue.defineComponent({
        name: "ArrowBack",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
            vue.h("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
            vue.h("path", { d: "M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z" })
          );
        }
      });
      const RotateClockwiseIcon = replaceable("rotateClockwise", vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }),
        vue.h("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" })
      ));
      const RotateCounterclockwiseIcon = replaceable("rotateClockwise", vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }),
        vue.h("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" })
      ));
      const ZoomInIcon = replaceable("zoomIn", vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }),
        vue.h("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" })
      ));
      const ZoomOutIcon = replaceable("zoomOut", vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }),
        vue.h("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" })
      ));
      const ResizeSmallIcon = vue.defineComponent({
        name: "ResizeSmall",
        render() {
          return vue.h(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
            vue.h(
              "g",
              { fill: "none" },
              vue.h("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })
            )
          );
        }
      });
      const NIconSwitchTransition = vue.defineComponent({
        name: "BaseIconSwitchTransition",
        setup(_, { slots }) {
          const isMountedRef = isMounted();
          return () => vue.h(vue.Transition, { name: "icon-switch-transition", appear: isMountedRef.value }, slots);
        }
      });
      const NFadeInExpandTransition = vue.defineComponent({
        name: "FadeInExpandTransition",
        props: {
          appear: Boolean,
          group: Boolean,
          mode: String,
          onLeave: Function,
          onAfterLeave: Function,
          onAfterEnter: Function,
          width: Boolean,
          // reverse mode is only used in tree
          // it make it from expanded to collapsed after mounted
          reverse: Boolean
        },
        setup(props, { slots }) {
          function handleBeforeLeave(el) {
            if (props.width) {
              el.style.maxWidth = `${el.offsetWidth}px`;
            } else {
              el.style.maxHeight = `${el.offsetHeight}px`;
            }
            void el.offsetWidth;
          }
          function handleLeave(el) {
            if (props.width) {
              el.style.maxWidth = "0";
            } else {
              el.style.maxHeight = "0";
            }
            void el.offsetWidth;
            const { onLeave } = props;
            if (onLeave)
              onLeave();
          }
          function handleAfterLeave(el) {
            if (props.width) {
              el.style.maxWidth = "";
            } else {
              el.style.maxHeight = "";
            }
            const { onAfterLeave } = props;
            if (onAfterLeave)
              onAfterLeave();
          }
          function handleEnter(el) {
            el.style.transition = "none";
            if (props.width) {
              const memorizedWidth = el.offsetWidth;
              el.style.maxWidth = "0";
              void el.offsetWidth;
              el.style.transition = "";
              el.style.maxWidth = `${memorizedWidth}px`;
            } else {
              if (props.reverse) {
                el.style.maxHeight = `${el.offsetHeight}px`;
                void el.offsetHeight;
                el.style.transition = "";
                el.style.maxHeight = "0";
              } else {
                const memorizedHeight = el.offsetHeight;
                el.style.maxHeight = "0";
                void el.offsetWidth;
                el.style.transition = "";
                el.style.maxHeight = `${memorizedHeight}px`;
              }
            }
            void el.offsetWidth;
          }
          function handleAfterEnter(el) {
            var _a;
            if (props.width) {
              el.style.maxWidth = "";
            } else {
              if (!props.reverse) {
                el.style.maxHeight = "";
              }
            }
            (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return () => {
            const { group, width, appear, mode } = props;
            const type2 = group ? vue.TransitionGroup : vue.Transition;
            const resolvedProps = {
              name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
              appear,
              onEnter: handleEnter,
              onAfterEnter: handleAfterEnter,
              onBeforeLeave: handleBeforeLeave,
              onLeave: handleLeave,
              onAfterLeave: handleAfterLeave
            };
            if (!group) {
              resolvedProps.mode = mode;
            }
            return vue.h(type2, resolvedProps, slots);
          };
        }
      });
      const style$1y = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c$1("svg", `
 height: 1em;
 width: 1em;
 `)]);
      const NBaseIcon = vue.defineComponent({
        name: "BaseIcon",
        props: {
          role: String,
          ariaLabel: String,
          ariaDisabled: {
            type: Boolean,
            default: void 0
          },
          ariaHidden: {
            type: Boolean,
            default: void 0
          },
          clsPrefix: {
            type: String,
            required: true
          },
          onClick: Function,
          onMousedown: Function,
          onMouseup: Function
        },
        setup(props) {
          useStyle("-base-icon", style$1y, vue.toRef(props, "clsPrefix"));
        },
        render() {
          return vue.h("i", { class: `${this.clsPrefix}-base-icon`, onClick: this.onClick, onMousedown: this.onMousedown, onMouseup: this.onMouseup, role: this.role, "aria-label": this.ariaLabel, "aria-hidden": this.ariaHidden, "aria-disabled": this.ariaDisabled }, this.$slots);
        }
      });
      const style$1x = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c$1("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c$1("&::before", `
 border-radius: 50%;
 `)])]);
      const NBaseClose = vue.defineComponent({
        name: "BaseClose",
        props: {
          isButtonTag: {
            type: Boolean,
            default: true
          },
          clsPrefix: {
            type: String,
            required: true
          },
          disabled: {
            type: Boolean,
            default: void 0
          },
          focusable: {
            type: Boolean,
            default: true
          },
          round: Boolean,
          onClick: Function,
          absolute: Boolean
        },
        setup(props) {
          useStyle("-base-close", style$1x, vue.toRef(props, "clsPrefix"));
          return () => {
            const { clsPrefix, disabled, absolute, round: round2, isButtonTag } = props;
            const Tag = isButtonTag ? "button" : "div";
            return vue.h(
              Tag,
              { type: isButtonTag ? "button" : void 0, tabindex: disabled || !props.focusable ? -1 : 0, "aria-disabled": disabled, "aria-label": "close", role: isButtonTag ? void 0 : "button", disabled, class: [
                `${clsPrefix}-base-close`,
                absolute && `${clsPrefix}-base-close--absolute`,
                disabled && `${clsPrefix}-base-close--disabled`,
                round2 && `${clsPrefix}-base-close--round`
              ], onMousedown: (e) => {
                if (!props.focusable) {
                  e.preventDefault();
                }
              }, onClick: props.onClick },
              vue.h(NBaseIcon, { clsPrefix }, {
                default: () => vue.h(ErrorIcon$1, null)
              })
            );
          };
        }
      });
      const FocusDetector = vue.defineComponent({
        props: {
          onFocus: Function,
          onBlur: Function
        },
        setup(props) {
          return () => vue.h("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: props.onFocus, onBlur: props.onBlur });
        }
      });
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$4
      } = commonVariables$m;
      function iconSwitchTransition({
        originalTransform = "",
        left = 0,
        top = 0,
        transition = `all .3s ${cubicBezierEaseInOut$4} !important`
      } = {}) {
        return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
          transform: originalTransform + " scale(0.75)",
          left,
          top,
          opacity: 0
        }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
          transform: `scale(1) ${originalTransform}`,
          left,
          top,
          opacity: 1
        }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
          transformOrigin: "center",
          position: "absolute",
          left,
          top,
          transition
        })];
      }
      const style$1w = c$1([c$1("@keyframes loading-container-rotate", `
 to {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }
 `), c$1("@keyframes loading-layer-rotate", `
 12.5% {
 -webkit-transform: rotate(135deg);
 transform: rotate(135deg);
 }
 25% {
 -webkit-transform: rotate(270deg);
 transform: rotate(270deg);
 }
 37.5% {
 -webkit-transform: rotate(405deg);
 transform: rotate(405deg);
 }
 50% {
 -webkit-transform: rotate(540deg);
 transform: rotate(540deg);
 }
 62.5% {
 -webkit-transform: rotate(675deg);
 transform: rotate(675deg);
 }
 75% {
 -webkit-transform: rotate(810deg);
 transform: rotate(810deg);
 }
 87.5% {
 -webkit-transform: rotate(945deg);
 transform: rotate(945deg);
 }
 100% {
 -webkit-transform: rotate(1080deg);
 transform: rotate(1080deg);
 } 
 `), c$1("@keyframes loading-left-spin", `
 from {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 50% {
 -webkit-transform: rotate(130deg);
 transform: rotate(130deg);
 }
 to {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 `), c$1("@keyframes loading-right-spin", `
 from {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 50% {
 -webkit-transform: rotate(-130deg);
 transform: rotate(-130deg);
 }
 to {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 `), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("container", `
 display: inline-flex;
 position: relative;
 direction: ltr;
 line-height: 0;
 animation: loading-container-rotate 1568.2352941176ms linear infinite;
 font-size: 0;
 letter-spacing: 0;
 white-space: nowrap;
 opacity: 1;
 width: 100%;
 height: 100%;
 `, [cE("svg", `
 stroke: var(--n-text-color);
 fill: transparent;
 position: absolute;
 height: 100%;
 overflow: hidden;
 `), cE("container-layer", `
 position: absolute;
 width: 100%;
 height: 100%;
 animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 `, [cE("container-layer-left", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 width: 200%;
 `)]), cE("container-layer-patch", `
 position: absolute;
 top: 0;
 left: 47.5%;
 box-sizing: border-box;
 width: 5%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 left: -900%;
 width: 2000%;
 transform: rotate(180deg);
 `)]), cE("container-layer-right", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE("svg", `
 animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 left: -100%;
 width: 200%;
 `)])])]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
        left: "50%",
        top: "50%",
        originalTransform: "translateX(-50%) translateY(-50%)"
      })])])]);
      const exposedLoadingProps = {
        strokeWidth: {
          type: Number,
          default: 28
        },
        stroke: {
          type: String,
          default: void 0
        }
      };
      const NBaseLoading = vue.defineComponent({
        name: "BaseLoading",
        props: Object.assign({ clsPrefix: {
          type: String,
          required: true
        }, show: {
          type: Boolean,
          default: true
        }, scale: {
          type: Number,
          default: 1
        }, radius: {
          type: Number,
          default: 100
        } }, exposedLoadingProps),
        setup(props) {
          useStyle("-base-loading", style$1w, vue.toRef(props, "clsPrefix"));
        },
        render() {
          const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
          const scaledRadius = radius / scale;
          return vue.h(
            "div",
            { class: `${clsPrefix}-base-loading`, role: "img", "aria-label": "loading" },
            vue.h(NIconSwitchTransition, null, {
              default: () => this.show ? vue.h(
                "div",
                { key: "icon", class: `${clsPrefix}-base-loading__transition-wrapper` },
                vue.h(
                  "div",
                  { class: `${clsPrefix}-base-loading__container` },
                  vue.h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer` },
                    vue.h(
                      "div",
                      { class: `${clsPrefix}-base-loading__container-layer-left` },
                      vue.h(
                        "svg",
                        { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                        vue.h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                      )
                    ),
                    vue.h(
                      "div",
                      { class: `${clsPrefix}-base-loading__container-layer-patch` },
                      vue.h(
                        "svg",
                        { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                        vue.h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                      )
                    ),
                    vue.h(
                      "div",
                      { class: `${clsPrefix}-base-loading__container-layer-right` },
                      vue.h(
                        "svg",
                        { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                        vue.h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                      )
                    )
                  )
                )
              ) : vue.h("div", { key: "placeholder", class: `${clsPrefix}-base-loading__placeholder` }, this.$slots)
            })
          );
        }
      });
      function toArray$1(arg) {
        if (Array.isArray(arg))
          return arg;
        return [arg];
      }
      const TRAVERSE_COMMAND = {
        STOP: "STOP"
      };
      function traverseWithCb(treeNode, callback) {
        const command = callback(treeNode);
        if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
          treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
        }
      }
      function getNonLeafKeys(treeNodes, options = {}) {
        const { preserveGroup = false } = options;
        const keys2 = [];
        const cb = preserveGroup ? (node) => {
          if (!node.isLeaf) {
            keys2.push(node.key);
            traverse2(node.children);
          }
        } : (node) => {
          if (!node.isLeaf) {
            if (!node.isGroup)
              keys2.push(node.key);
            traverse2(node.children);
          }
        };
        function traverse2(nodes) {
          nodes.forEach(cb);
        }
        traverse2(treeNodes);
        return keys2;
      }
      function isLeaf(rawNode, getChildren) {
        const { isLeaf: isLeaf2 } = rawNode;
        if (isLeaf2 !== void 0)
          return isLeaf2;
        else if (!getChildren(rawNode))
          return true;
        return false;
      }
      function defaultGetChildren(node) {
        return node.children;
      }
      function defaultGetKey(node) {
        return node.key;
      }
      function isIgnored() {
        return false;
      }
      function isShallowLoaded(rawNode, getChildren) {
        const { isLeaf: isLeaf2 } = rawNode;
        if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
          return false;
        return true;
      }
      function isDisabled(rawNode) {
        return rawNode.disabled === true;
      }
      function isExpilicitlyNotLoaded(rawNode, getChildren) {
        return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
      }
      function unwrapCheckedKeys(result) {
        var _a;
        if (result === void 0 || result === null)
          return [];
        if (Array.isArray(result))
          return result;
        return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
      }
      function unwrapIndeterminateKeys(result) {
        var _a;
        if (result === void 0 || result === null || Array.isArray(result)) {
          return [];
        }
        return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
      }
      function merge$1(originalKeys, keysToAdd) {
        const set2 = new Set(originalKeys);
        keysToAdd.forEach((key) => {
          if (!set2.has(key)) {
            set2.add(key);
          }
        });
        return Array.from(set2);
      }
      function minus(originalKeys, keysToRemove) {
        const set2 = new Set(originalKeys);
        keysToRemove.forEach((key) => {
          if (set2.has(key)) {
            set2.delete(key);
          }
        });
        return Array.from(set2);
      }
      function isGroup(rawNode) {
        return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
      }
      function createIndexGetter(treeNodes) {
        const map2 = /* @__PURE__ */ new Map();
        treeNodes.forEach((treeNode, i) => {
          map2.set(treeNode.key, i);
        });
        return (key) => {
          var _a;
          return (_a = map2.get(key)) !== null && _a !== void 0 ? _a : null;
        };
      }
      class SubtreeNotLoadedError extends Error {
        constructor() {
          super();
          this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
        }
      }
      function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
        return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
      }
      function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
        const visitedKeys = /* @__PURE__ */ new Set();
        uncheckedKeys.forEach((uncheckedKey) => {
          const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
          if (uncheckedTreeNode !== void 0) {
            let nodeCursor = uncheckedTreeNode.parent;
            while (nodeCursor !== null) {
              if (nodeCursor.disabled)
                break;
              if (visitedKeys.has(nodeCursor.key))
                break;
              else {
                visitedKeys.add(nodeCursor.key);
              }
              nodeCursor = nodeCursor.parent;
            }
          }
        });
        return visitedKeys;
      }
      function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
        const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
        const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
        const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
        const keysToRemove = [];
        extendedCheckedKeySet.forEach((key) => {
          if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
            keysToRemove.push(key);
          }
        });
        keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
        return extendedCheckedKeySet;
      }
      function getCheckedKeys(options, treeMate) {
        const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
        if (!cascade) {
          if (keysToCheck !== void 0) {
            return {
              checkedKeys: merge$1(checkedKeys, keysToCheck),
              indeterminateKeys: Array.from(indeterminateKeys)
            };
          } else if (keysToUncheck !== void 0) {
            return {
              checkedKeys: minus(checkedKeys, keysToUncheck),
              indeterminateKeys: Array.from(indeterminateKeys)
            };
          } else {
            return {
              checkedKeys: Array.from(checkedKeys),
              indeterminateKeys: Array.from(indeterminateKeys)
            };
          }
        }
        const { levelTreeNodeMap } = treeMate;
        let extendedCheckedKeySet;
        if (keysToUncheck !== void 0) {
          extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
        } else if (keysToCheck !== void 0) {
          extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
        } else {
          extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
        }
        const checkStrategyIsParent = checkStrategy === "parent";
        const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
        const syntheticCheckedKeySet = extendedCheckedKeySet;
        const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
        const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
        for (let level = maxLevel; level >= 0; level -= 1) {
          const levelIsZero = level === 0;
          const levelTreeNodes = levelTreeNodeMap.get(level);
          for (const levelTreeNode of levelTreeNodes) {
            if (levelTreeNode.isLeaf)
              continue;
            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
            if (checkStrategyIsChild && shallowLoaded) {
              levelTreeNode.children.forEach((v) => {
                if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
                  syntheticCheckedKeySet.delete(v.key);
                }
              });
            }
            if (levelTreeNode.disabled || !shallowLoaded) {
              continue;
            }
            let fullyChecked = true;
            let partialChecked = false;
            let allDisabled = true;
            for (const childNode of levelTreeNode.children) {
              const childKey = childNode.key;
              if (childNode.disabled)
                continue;
              if (allDisabled)
                allDisabled = false;
              if (syntheticCheckedKeySet.has(childKey)) {
                partialChecked = true;
              } else if (syntheticIndeterminateKeySet.has(childKey)) {
                partialChecked = true;
                fullyChecked = false;
                break;
              } else {
                fullyChecked = false;
                if (partialChecked) {
                  break;
                }
              }
            }
            if (fullyChecked && !allDisabled) {
              if (checkStrategyIsParent) {
                levelTreeNode.children.forEach((v) => {
                  if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                    syntheticCheckedKeySet.delete(v.key);
                  }
                });
              }
              syntheticCheckedKeySet.add(levelTreeNodeKey);
            } else if (partialChecked) {
              syntheticIndeterminateKeySet.add(levelTreeNodeKey);
            }
            if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
              syntheticCheckedKeySet.delete(levelTreeNodeKey);
            }
          }
        }
        return {
          checkedKeys: Array.from(syntheticCheckedKeySet),
          indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
        };
      }
      function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
        const { treeNodeMap, getChildren } = treeMate;
        const visitedKeySet = /* @__PURE__ */ new Set();
        const extendedKeySet = new Set(checkedKeys);
        checkedKeys.forEach((checkedKey) => {
          const checkedTreeNode = treeNodeMap.get(checkedKey);
          if (checkedTreeNode !== void 0) {
            traverseWithCb(checkedTreeNode, (treeNode) => {
              if (treeNode.disabled) {
                return TRAVERSE_COMMAND.STOP;
              }
              const { key } = treeNode;
              if (visitedKeySet.has(key))
                return;
              visitedKeySet.add(key);
              extendedKeySet.add(key);
              if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
                if (isUnchecking) {
                  return TRAVERSE_COMMAND.STOP;
                } else if (!allowNotLoaded) {
                  throw new SubtreeNotLoadedError();
                }
              }
            });
          }
        });
        return extendedKeySet;
      }
      function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
        var _a;
        const treeNodeMap = treeMate.treeNodeMap;
        let treeNode = key === null || key === void 0 ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
        const mergedPath = {
          keyPath: [],
          treeNodePath: [],
          treeNode
        };
        if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
          mergedPath.treeNode = null;
          return mergedPath;
        }
        while (treeNode) {
          if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
            mergedPath.treeNodePath.push(treeNode);
          }
          treeNode = treeNode.parent;
        }
        mergedPath.treeNodePath.reverse();
        if (!includeSelf)
          mergedPath.treeNodePath.pop();
        mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
        return mergedPath;
      }
      function getFirstAvailableNode(nodes) {
        if (nodes.length === 0)
          return null;
        const node = nodes[0];
        if (node.isGroup || node.ignored || node.disabled) {
          return node.getNext();
        }
        return node;
      }
      function rawGetNext(node, loop) {
        const sibs = node.siblings;
        const l = sibs.length;
        const { index } = node;
        if (loop) {
          return sibs[(index + 1) % l];
        } else {
          if (index === sibs.length - 1)
            return null;
          return sibs[index + 1];
        }
      }
      function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
        const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
        const getChildOptions = {
          reverse: dir === "prev"
        };
        let meet = false;
        let endNode = null;
        function traverse2(node) {
          if (node === null)
            return;
          if (node === fromNode) {
            if (!meet) {
              meet = true;
            } else if (!fromNode.disabled && !fromNode.isGroup) {
              endNode = fromNode;
              return;
            }
          } else {
            if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
              endNode = node;
              return;
            }
          }
          if (node.isGroup) {
            const child = getChild(node, getChildOptions);
            if (child !== null) {
              endNode = child;
            } else {
              traverse2(iterate(node, loop));
            }
          } else {
            const nextNode = iterate(node, false);
            if (nextNode !== null) {
              traverse2(nextNode);
            } else {
              const parent = rawGetParent(node);
              if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
                traverse2(iterate(parent, loop));
              } else if (loop) {
                traverse2(iterate(node, true));
              }
            }
          }
        }
        traverse2(fromNode);
        return endNode;
      }
      function rawGetPrev(node, loop) {
        const sibs = node.siblings;
        const l = sibs.length;
        const { index } = node;
        if (loop) {
          return sibs[(index - 1 + l) % l];
        } else {
          if (index === 0)
            return null;
          return sibs[index - 1];
        }
      }
      function rawGetParent(node) {
        return node.parent;
      }
      function getChild(node, options = {}) {
        const { reverse = false } = options;
        const { children } = node;
        if (children) {
          const { length } = children;
          const start = reverse ? length - 1 : 0;
          const end = reverse ? -1 : length;
          const delta = reverse ? -1 : 1;
          for (let i = start; i !== end; i += delta) {
            const child = children[i];
            if (!child.disabled && !child.ignored) {
              if (child.isGroup) {
                const childInGroup = getChild(child, options);
                if (childInGroup !== null)
                  return childInGroup;
              } else {
                return child;
              }
            }
          }
        }
        return null;
      }
      const moveMethods = {
        getChild() {
          if (this.ignored)
            return null;
          return getChild(this);
        },
        getParent() {
          const { parent } = this;
          if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
            return parent.getParent();
          }
          return parent;
        },
        getNext(options = {}) {
          return move(this, "next", options);
        },
        getPrev(options = {}) {
          return move(this, "prev", options);
        }
      };
      function flatten$1(treeNodes, expandedKeys) {
        const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
        const flattenedNodes = [];
        function traverse2(treeNodes2) {
          treeNodes2.forEach((treeNode) => {
            flattenedNodes.push(treeNode);
            if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
              return;
            if (treeNode.isGroup) {
              traverse2(treeNode.children);
            } else if (
              // normal non-leaf node
              expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
            ) {
              traverse2(treeNode.children);
            }
          });
        }
        traverse2(treeNodes);
        return flattenedNodes;
      }
      function contains(parent, child) {
        const parentKey = parent.key;
        while (child) {
          if (child.key === parentKey)
            return true;
          child = child.parent;
        }
        return false;
      }
      function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
        const treeNodes = [];
        rawNodes.forEach((rawNode, index) => {
          var _a;
          const treeNode = Object.create(nodeProto);
          treeNode.rawNode = rawNode;
          treeNode.siblings = treeNodes;
          treeNode.level = level;
          treeNode.index = index;
          treeNode.isFirstChild = index === 0;
          treeNode.isLastChild = index + 1 === rawNodes.length;
          treeNode.parent = parent;
          if (!treeNode.ignored) {
            const rawChildren = getChildren(rawNode);
            if (Array.isArray(rawChildren)) {
              treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
            }
          }
          treeNodes.push(treeNode);
          treeNodeMap.set(treeNode.key, treeNode);
          if (!levelTreeNodeMap.has(level))
            levelTreeNodeMap.set(level, []);
          (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
        });
        return treeNodes;
      }
      function createTreeMate(rawNodes, options = {}) {
        var _a;
        const treeNodeMap = /* @__PURE__ */ new Map();
        const levelTreeNodeMap = /* @__PURE__ */ new Map();
        const { getDisabled = isDisabled, getIgnored: getIgnored2 = isIgnored, getIsGroup: getIsGroup2 = isGroup, getKey = defaultGetKey } = options;
        const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
        const getChildren = options.ignoreEmptyChildren ? (node) => {
          const children = _getChildren(node);
          if (Array.isArray(children)) {
            if (!children.length)
              return null;
            return children;
          }
          return children;
        } : _getChildren;
        const nodeProto = Object.assign({
          get key() {
            return getKey(this.rawNode);
          },
          get disabled() {
            return getDisabled(this.rawNode);
          },
          get isGroup() {
            return getIsGroup2(this.rawNode);
          },
          get isLeaf() {
            return isLeaf(this.rawNode, getChildren);
          },
          get shallowLoaded() {
            return isShallowLoaded(this.rawNode, getChildren);
          },
          get ignored() {
            return getIgnored2(this.rawNode);
          },
          contains(node) {
            return contains(this, node);
          }
        }, moveMethods);
        const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
        function getNode(key) {
          if (key === null || key === void 0)
            return null;
          const tmNode = treeNodeMap.get(key);
          if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
            return tmNode;
          }
          return null;
        }
        function _getNode(key) {
          if (key === null || key === void 0)
            return null;
          const tmNode = treeNodeMap.get(key);
          if (tmNode && !tmNode.ignored) {
            return tmNode;
          }
          return null;
        }
        function getPrev(key, options2) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getPrev(options2);
        }
        function getNext(key, options2) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getNext(options2);
        }
        function getParent(key) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getParent();
        }
        function getChild2(key) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getChild();
        }
        const treemate = {
          treeNodes,
          treeNodeMap,
          levelTreeNodeMap,
          maxLevel: Math.max(...levelTreeNodeMap.keys()),
          getChildren,
          getFlattenedNodes(expandedKeys) {
            return flatten$1(treeNodes, expandedKeys);
          },
          getNode,
          getPrev,
          getNext,
          getParent,
          getChild: getChild2,
          getFirstAvailableNode() {
            return getFirstAvailableNode(treeNodes);
          },
          getPath(key, options2 = {}) {
            return getPath(key, options2, treemate);
          },
          getCheckedKeys(checkedKeys, options2 = {}) {
            const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
            return getCheckedKeys({
              checkedKeys: unwrapCheckedKeys(checkedKeys),
              indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
              cascade,
              leafOnly,
              checkStrategy,
              allowNotLoaded
            }, treemate);
          },
          check(keysToCheck, checkedKeys, options2 = {}) {
            const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
            return getCheckedKeys({
              checkedKeys: unwrapCheckedKeys(checkedKeys),
              indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
              keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray$1(keysToCheck),
              cascade,
              leafOnly,
              checkStrategy,
              allowNotLoaded
            }, treemate);
          },
          uncheck(keysToUncheck, checkedKeys, options2 = {}) {
            const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
            return getCheckedKeys({
              checkedKeys: unwrapCheckedKeys(checkedKeys),
              indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
              keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray$1(keysToUncheck),
              cascade,
              leafOnly,
              checkStrategy,
              allowNotLoaded
            }, treemate);
          },
          getNonLeafKeys(options2 = {}) {
            return getNonLeafKeys(treeNodes, options2);
          }
        };
        return treemate;
      }
      const base$1 = {
        neutralBase: "#000",
        neutralInvertBase: "#fff",
        neutralTextBase: "#fff",
        neutralPopover: "rgb(72, 72, 78)",
        neutralCard: "rgb(24, 24, 28)",
        neutralModal: "rgb(44, 44, 50)",
        neutralBody: "rgb(16, 16, 20)",
        alpha1: "0.9",
        alpha2: "0.82",
        alpha3: "0.52",
        alpha4: "0.38",
        alpha5: "0.28",
        alphaClose: "0.52",
        alphaDisabled: "0.38",
        alphaDisabledInput: "0.06",
        alphaPending: "0.09",
        alphaTablePending: "0.06",
        alphaTableStriped: "0.05",
        alphaPressed: "0.05",
        alphaAvatar: "0.18",
        alphaRail: "0.2",
        alphaProgressRail: "0.12",
        alphaBorder: "0.24",
        alphaDivider: "0.09",
        alphaInput: "0.1",
        alphaAction: "0.06",
        alphaTab: "0.04",
        alphaScrollbar: "0.2",
        alphaScrollbarHover: "0.3",
        alphaCode: "0.12",
        alphaTag: "0.2",
        // primary
        primaryHover: "#7fe7c4",
        primaryDefault: "#63e2b7",
        primaryActive: "#5acea7",
        primarySuppl: "rgb(42, 148, 125)",
        // info
        infoHover: "#8acbec",
        infoDefault: "#70c0e8",
        infoActive: "#66afd3",
        infoSuppl: "rgb(56, 137, 197)",
        // error
        errorHover: "#e98b8b",
        errorDefault: "#e88080",
        errorActive: "#e57272",
        errorSuppl: "rgb(208, 58, 82)",
        // warning
        warningHover: "#f5d599",
        warningDefault: "#f2c97d",
        warningActive: "#e6c260",
        warningSuppl: "rgb(240, 138, 0)",
        // success
        successHover: "#7fe7c4",
        successDefault: "#63e2b7",
        successActive: "#5acea7",
        successSuppl: "rgb(42, 148, 125)"
      };
      const baseBackgroundRgb$1 = rgba(base$1.neutralBase);
      const baseInvertBackgroundRgb$1 = rgba(base$1.neutralInvertBase);
      const overlayPrefix$1 = "rgba(" + baseInvertBackgroundRgb$1.slice(0, 3).join(", ") + ", ";
      function overlay$1(alpha) {
        return overlayPrefix$1 + String(alpha) + ")";
      }
      function neutral$1(alpha) {
        const overlayRgba = Array.from(baseInvertBackgroundRgb$1);
        overlayRgba[3] = Number(alpha);
        return composite(baseBackgroundRgb$1, overlayRgba);
      }
      const derived$1 = Object.assign(Object.assign({ name: "common" }, commonVariables$m), {
        baseColor: base$1.neutralBase,
        // primary color
        primaryColor: base$1.primaryDefault,
        primaryColorHover: base$1.primaryHover,
        primaryColorPressed: base$1.primaryActive,
        primaryColorSuppl: base$1.primarySuppl,
        // info color
        infoColor: base$1.infoDefault,
        infoColorHover: base$1.infoHover,
        infoColorPressed: base$1.infoActive,
        infoColorSuppl: base$1.infoSuppl,
        // success color
        successColor: base$1.successDefault,
        successColorHover: base$1.successHover,
        successColorPressed: base$1.successActive,
        successColorSuppl: base$1.successSuppl,
        // warning color
        warningColor: base$1.warningDefault,
        warningColorHover: base$1.warningHover,
        warningColorPressed: base$1.warningActive,
        warningColorSuppl: base$1.warningSuppl,
        // error color
        errorColor: base$1.errorDefault,
        errorColorHover: base$1.errorHover,
        errorColorPressed: base$1.errorActive,
        errorColorSuppl: base$1.errorSuppl,
        // text color
        textColorBase: base$1.neutralTextBase,
        textColor1: overlay$1(base$1.alpha1),
        textColor2: overlay$1(base$1.alpha2),
        textColor3: overlay$1(base$1.alpha3),
        // textColor4: overlay(base.alpha4), // disabled, placeholder, icon
        // textColor5: overlay(base.alpha5),
        textColorDisabled: overlay$1(base$1.alpha4),
        placeholderColor: overlay$1(base$1.alpha4),
        placeholderColorDisabled: overlay$1(base$1.alpha5),
        iconColor: overlay$1(base$1.alpha4),
        iconColorDisabled: overlay$1(base$1.alpha5),
        iconColorHover: overlay$1(Number(base$1.alpha4) * 1.25),
        iconColorPressed: overlay$1(Number(base$1.alpha4) * 0.8),
        opacity1: base$1.alpha1,
        opacity2: base$1.alpha2,
        opacity3: base$1.alpha3,
        opacity4: base$1.alpha4,
        opacity5: base$1.alpha5,
        dividerColor: overlay$1(base$1.alphaDivider),
        borderColor: overlay$1(base$1.alphaBorder),
        // close
        closeIconColorHover: overlay$1(Number(base$1.alphaClose)),
        closeIconColor: overlay$1(Number(base$1.alphaClose)),
        closeIconColorPressed: overlay$1(Number(base$1.alphaClose)),
        closeColorHover: "rgba(255, 255, 255, .12)",
        closeColorPressed: "rgba(255, 255, 255, .08)",
        // clear
        clearColor: overlay$1(base$1.alpha4),
        clearColorHover: scaleColor(overlay$1(base$1.alpha4), { alpha: 1.25 }),
        clearColorPressed: scaleColor(overlay$1(base$1.alpha4), { alpha: 0.8 }),
        scrollbarColor: overlay$1(base$1.alphaScrollbar),
        scrollbarColorHover: overlay$1(base$1.alphaScrollbarHover),
        scrollbarWidth: "5px",
        scrollbarHeight: "5px",
        scrollbarBorderRadius: "5px",
        progressRailColor: overlay$1(base$1.alphaProgressRail),
        railColor: overlay$1(base$1.alphaRail),
        popoverColor: base$1.neutralPopover,
        tableColor: base$1.neutralCard,
        cardColor: base$1.neutralCard,
        modalColor: base$1.neutralModal,
        bodyColor: base$1.neutralBody,
        tagColor: neutral$1(base$1.alphaTag),
        avatarColor: overlay$1(base$1.alphaAvatar),
        invertedColor: base$1.neutralBase,
        inputColor: overlay$1(base$1.alphaInput),
        codeColor: overlay$1(base$1.alphaCode),
        tabColor: overlay$1(base$1.alphaTab),
        actionColor: overlay$1(base$1.alphaAction),
        tableHeaderColor: overlay$1(base$1.alphaAction),
        hoverColor: overlay$1(base$1.alphaPending),
        tableColorHover: overlay$1(base$1.alphaTablePending),
        tableColorStriped: overlay$1(base$1.alphaTableStriped),
        pressedColor: overlay$1(base$1.alphaPressed),
        opacityDisabled: base$1.alphaDisabled,
        inputColorDisabled: overlay$1(base$1.alphaDisabledInput),
        buttonColor2: "rgba(255, 255, 255, .08)",
        buttonColor2Hover: "rgba(255, 255, 255, .12)",
        buttonColor2Pressed: "rgba(255, 255, 255, .08)",
        boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
        boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
        boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
      });
      const commonDark = derived$1;
      const base = {
        neutralBase: "#FFF",
        neutralInvertBase: "#000",
        neutralTextBase: "#000",
        neutralPopover: "#fff",
        neutralCard: "#fff",
        neutralModal: "#fff",
        neutralBody: "#fff",
        alpha1: "0.82",
        alpha2: "0.72",
        alpha3: "0.38",
        alpha4: "0.24",
        alpha5: "0.18",
        alphaClose: "0.6",
        alphaDisabled: "0.5",
        alphaDisabledInput: "0.02",
        alphaPending: "0.05",
        alphaTablePending: "0.02",
        alphaPressed: "0.07",
        alphaAvatar: "0.2",
        alphaRail: "0.14",
        alphaProgressRail: ".08",
        alphaBorder: "0.12",
        alphaDivider: "0.06",
        alphaInput: "0",
        alphaAction: "0.02",
        alphaTab: "0.04",
        alphaScrollbar: "0.25",
        alphaScrollbarHover: "0.4",
        alphaCode: "0.05",
        alphaTag: "0.02",
        // primary
        primaryHover: "#36ad6a",
        primaryDefault: "#18a058",
        primaryActive: "#0c7a43",
        primarySuppl: "#36ad6a",
        // info
        infoHover: "#4098fc",
        infoDefault: "#2080f0",
        infoActive: "#1060c9",
        infoSuppl: "#4098fc",
        // error
        errorHover: "#de576d",
        errorDefault: "#d03050",
        errorActive: "#ab1f3f",
        errorSuppl: "#de576d",
        // warning
        warningHover: "#fcb040",
        warningDefault: "#f0a020",
        warningActive: "#c97c10",
        warningSuppl: "#fcb040",
        // success
        successHover: "#36ad6a",
        successDefault: "#18a058",
        successActive: "#0c7a43",
        successSuppl: "#36ad6a"
      };
      const baseBackgroundRgb = rgba(base.neutralBase);
      const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
      const overlayPrefix = "rgba(" + baseInvertBackgroundRgb.slice(0, 3).join(", ") + ", ";
      function overlay(alpha) {
        return overlayPrefix + String(alpha) + ")";
      }
      function neutral(alpha) {
        const overlayRgba = Array.from(baseInvertBackgroundRgb);
        overlayRgba[3] = Number(alpha);
        return composite(baseBackgroundRgb, overlayRgba);
      }
      const derived = Object.assign(Object.assign({ name: "common" }, commonVariables$m), {
        baseColor: base.neutralBase,
        // primary color
        primaryColor: base.primaryDefault,
        primaryColorHover: base.primaryHover,
        primaryColorPressed: base.primaryActive,
        primaryColorSuppl: base.primarySuppl,
        // info color
        infoColor: base.infoDefault,
        infoColorHover: base.infoHover,
        infoColorPressed: base.infoActive,
        infoColorSuppl: base.infoSuppl,
        // success color
        successColor: base.successDefault,
        successColorHover: base.successHover,
        successColorPressed: base.successActive,
        successColorSuppl: base.successSuppl,
        // warning color
        warningColor: base.warningDefault,
        warningColorHover: base.warningHover,
        warningColorPressed: base.warningActive,
        warningColorSuppl: base.warningSuppl,
        // error color
        errorColor: base.errorDefault,
        errorColorHover: base.errorHover,
        errorColorPressed: base.errorActive,
        errorColorSuppl: base.errorSuppl,
        // text color
        textColorBase: base.neutralTextBase,
        textColor1: "rgb(31, 34, 37)",
        textColor2: "rgb(51, 54, 57)",
        textColor3: "rgb(118, 124, 130)",
        // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
        // textColor5: neutral(base.alpha5),
        textColorDisabled: neutral(base.alpha4),
        placeholderColor: neutral(base.alpha4),
        placeholderColorDisabled: neutral(base.alpha5),
        iconColor: neutral(base.alpha4),
        iconColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }),
        iconColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }),
        iconColorDisabled: neutral(base.alpha5),
        opacity1: base.alpha1,
        opacity2: base.alpha2,
        opacity3: base.alpha3,
        opacity4: base.alpha4,
        opacity5: base.alpha5,
        dividerColor: "rgb(239, 239, 245)",
        borderColor: "rgb(224, 224, 230)",
        // close
        closeIconColor: neutral(Number(base.alphaClose)),
        closeIconColorHover: neutral(Number(base.alphaClose)),
        closeIconColorPressed: neutral(Number(base.alphaClose)),
        closeColorHover: "rgba(0, 0, 0, .09)",
        closeColorPressed: "rgba(0, 0, 0, .13)",
        // clear
        clearColor: neutral(base.alpha4),
        clearColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }),
        clearColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }),
        scrollbarColor: overlay(base.alphaScrollbar),
        scrollbarColorHover: overlay(base.alphaScrollbarHover),
        scrollbarWidth: "5px",
        scrollbarHeight: "5px",
        scrollbarBorderRadius: "5px",
        progressRailColor: neutral(base.alphaProgressRail),
        railColor: "rgb(219, 219, 223)",
        popoverColor: base.neutralPopover,
        tableColor: base.neutralCard,
        cardColor: base.neutralCard,
        modalColor: base.neutralModal,
        bodyColor: base.neutralBody,
        tagColor: "#eee",
        avatarColor: neutral(base.alphaAvatar),
        invertedColor: "rgb(0, 20, 40)",
        inputColor: neutral(base.alphaInput),
        codeColor: "rgb(244, 244, 248)",
        tabColor: "rgb(247, 247, 250)",
        actionColor: "rgb(250, 250, 252)",
        tableHeaderColor: "rgb(250, 250, 252)",
        hoverColor: "rgb(243, 243, 245)",
        // use color with alpha since it can be nested with header filter & sorter effect
        tableColorHover: "rgba(0, 0, 100, 0.03)",
        tableColorStriped: "rgba(0, 0, 100, 0.02)",
        pressedColor: "rgb(237, 237, 239)",
        opacityDisabled: base.alphaDisabled,
        inputColorDisabled: "rgb(250, 250, 252)",
        // secondary button color
        // can also be used in tertiary button & quaternary button
        buttonColor2: "rgba(46, 51, 56, .05)",
        buttonColor2Hover: "rgba(46, 51, 56, .09)",
        buttonColor2Pressed: "rgba(46, 51, 56, .13)",
        boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
        boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
        boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
      });
      const commonLight = derived;
      const commonVars$c = {
        iconSizeSmall: "34px",
        iconSizeMedium: "40px",
        iconSizeLarge: "46px",
        iconSizeHuge: "52px"
      };
      const self$1d = (vars) => {
        const { textColorDisabled, iconColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge } = vars;
        return Object.assign(Object.assign({}, commonVars$c), {
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge,
          textColor: textColorDisabled,
          iconColor,
          extraTextColor: textColor2
        });
      };
      const emptyLight = {
        name: "Empty",
        common: commonLight,
        self: self$1d
      };
      const emptyLight$1 = emptyLight;
      const emptyDark = {
        name: "Empty",
        common: commonDark,
        self: self$1d
      };
      const emptyDark$1 = emptyDark;
      const style$1v = cB("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [cE("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [c$1("+", [cE("description", `
 margin-top: 8px;
 `)])]), cE("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]);
      const emptyProps = Object.assign(Object.assign({}, useTheme.props), { description: String, showDescription: {
        type: Boolean,
        default: true
      }, showIcon: {
        type: Boolean,
        default: true
      }, size: {
        type: String,
        default: "medium"
      }, renderIcon: Function });
      const NEmpty = vue.defineComponent({
        name: "Empty",
        props: emptyProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Empty", "-empty", style$1v, emptyLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale("Empty");
          const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
          const mergedDescriptionRef = vue.computed(() => {
            var _a, _b, _c;
            return (_a = props.description) !== null && _a !== void 0 ? _a : (_c = (_b = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value) === null || _b === void 0 ? void 0 : _b.Empty) === null || _c === void 0 ? void 0 : _c.description;
          });
          const mergedRenderIconRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Empty) === null || _b === void 0 ? void 0 : _b.renderIcon) || (() => vue.h(EmptyIcon, null));
          });
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { [createKey("iconSize", size2)]: iconSize, [createKey("fontSize", size2)]: fontSize2, textColor, iconColor, extraTextColor } } = themeRef.value;
            return {
              "--n-icon-size": iconSize,
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-icon-color": iconColor,
              "--n-extra-text-color": extraTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("empty", vue.computed(() => {
            let hash = "";
            const { size: size2 } = props;
            hash += size2[0];
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedRenderIcon: mergedRenderIconRef,
            localizedDescription: vue.computed(() => {
              return mergedDescriptionRef.value || localeRef.value.description;
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-empty`, this.themeClass], style: this.cssVars },
            this.showIcon ? vue.h("div", { class: `${mergedClsPrefix}-empty__icon` }, $slots.icon ? $slots.icon() : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: this.mergedRenderIcon })) : null,
            this.showDescription ? vue.h("div", { class: `${mergedClsPrefix}-empty__description` }, $slots.default ? $slots.default() : this.localizedDescription) : null,
            $slots.extra ? vue.h("div", { class: `${mergedClsPrefix}-empty__extra` }, $slots.extra()) : null
          );
        }
      });
      const self$1c = (vars) => {
        const { scrollbarColor, scrollbarColorHover } = vars;
        return {
          color: scrollbarColor,
          colorHover: scrollbarColorHover
        };
      };
      const scrollbarLight = {
        name: "Scrollbar",
        common: commonLight,
        self: self$1c
      };
      const scrollbarLight$1 = scrollbarLight;
      const scrollbarDark = {
        name: "Scrollbar",
        common: commonDark,
        self: self$1c
      };
      const scrollbarDark$1 = scrollbarDark;
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$3
      } = commonVariables$m;
      function fadeInTransition({
        name = "fade-in",
        enterDuration = "0.2s",
        leaveDuration = "0.2s",
        enterCubicBezier = cubicBezierEaseInOut$3,
        leaveCubicBezier = cubicBezierEaseInOut$3
      } = {}) {
        return [c$1(`&.${name}-transition-enter-active`, {
          transition: `all ${enterDuration} ${enterCubicBezier}!important`
        }), c$1(`&.${name}-transition-leave-active`, {
          transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
        }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
          opacity: 0
        }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
          opacity: 1
        })];
      }
      const style$1u = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 -webkit-user-select: none;
 `, [cM("horizontal", `
 left: 2px;
 right: 2px;
 bottom: 4px;
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("vertical", `
 right: 4px;
 top: 2px;
 bottom: 2px;
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("disabled", [c$1(">", [cE("scrollbar", {
        pointerEvents: "none"
      })])]), c$1(">", [cE("scrollbar", `
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", {
        backgroundColor: "var(--n-scrollbar-color-hover)"
      })])])])])]);
      const scrollbarProps$1 = Object.assign(Object.assign({}, useTheme.props), {
        size: {
          type: Number,
          default: 5
        },
        duration: {
          type: Number,
          default: 0
        },
        scrollable: {
          type: Boolean,
          default: true
        },
        xScrollable: Boolean,
        trigger: {
          type: String,
          default: "hover"
        },
        useUnifiedContainer: Boolean,
        triggerDisplayManually: Boolean,
        // If container is set, resize observer won't not attached
        container: Function,
        content: Function,
        containerClass: String,
        containerStyle: [String, Object],
        contentClass: String,
        contentStyle: [String, Object],
        horizontalRailStyle: [String, Object],
        verticalRailStyle: [String, Object],
        onScroll: Function,
        onWheel: Function,
        onResize: Function,
        internalOnUpdateScrollLeft: Function,
        internalHoistYRail: Boolean
      });
      const Scrollbar$2 = vue.defineComponent({
        name: "Scrollbar",
        props: scrollbarProps$1,
        inheritAttrs: false,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
          const wrapperRef = vue.ref(null);
          const containerRef = vue.ref(null);
          const contentRef = vue.ref(null);
          const yRailRef = vue.ref(null);
          const xRailRef = vue.ref(null);
          const contentHeightRef = vue.ref(null);
          const contentWidthRef = vue.ref(null);
          const containerHeightRef = vue.ref(null);
          const containerWidthRef = vue.ref(null);
          const yRailSizeRef = vue.ref(null);
          const xRailSizeRef = vue.ref(null);
          const containerScrollTopRef = vue.ref(0);
          const containerScrollLeftRef = vue.ref(0);
          const isShowXBarRef = vue.ref(false);
          const isShowYBarRef = vue.ref(false);
          let yBarPressed = false;
          let xBarPressed = false;
          let xBarVanishTimerId;
          let yBarVanishTimerId;
          let memoYTop = 0;
          let memoXLeft = 0;
          let memoMouseX = 0;
          let memoMouseY = 0;
          const isIos2 = useIsIos();
          const yBarSizeRef = vue.computed(() => {
            const { value: containerHeight } = containerHeightRef;
            const { value: contentHeight } = contentHeightRef;
            const { value: yRailSize } = yRailSizeRef;
            if (containerHeight === null || contentHeight === null || yRailSize === null) {
              return 0;
            } else {
              return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + props.size * 1.5);
            }
          });
          const yBarSizePxRef = vue.computed(() => {
            return `${yBarSizeRef.value}px`;
          });
          const xBarSizeRef = vue.computed(() => {
            const { value: containerWidth } = containerWidthRef;
            const { value: contentWidth } = contentWidthRef;
            const { value: xRailSize } = xRailSizeRef;
            if (containerWidth === null || contentWidth === null || xRailSize === null) {
              return 0;
            } else {
              return xRailSize * containerWidth / contentWidth + props.size * 1.5;
            }
          });
          const xBarSizePxRef = vue.computed(() => {
            return `${xBarSizeRef.value}px`;
          });
          const yBarTopRef = vue.computed(() => {
            const { value: containerHeight } = containerHeightRef;
            const { value: containerScrollTop } = containerScrollTopRef;
            const { value: contentHeight } = contentHeightRef;
            const { value: yRailSize } = yRailSizeRef;
            if (containerHeight === null || contentHeight === null || yRailSize === null) {
              return 0;
            } else {
              const heightDiff = contentHeight - containerHeight;
              if (!heightDiff)
                return 0;
              return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
            }
          });
          const yBarTopPxRef = vue.computed(() => {
            return `${yBarTopRef.value}px`;
          });
          const xBarLeftRef = vue.computed(() => {
            const { value: containerWidth } = containerWidthRef;
            const { value: containerScrollLeft } = containerScrollLeftRef;
            const { value: contentWidth } = contentWidthRef;
            const { value: xRailSize } = xRailSizeRef;
            if (containerWidth === null || contentWidth === null || xRailSize === null) {
              return 0;
            } else {
              const widthDiff = contentWidth - containerWidth;
              if (!widthDiff)
                return 0;
              return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
            }
          });
          const xBarLeftPxRef = vue.computed(() => {
            return `${xBarLeftRef.value}px`;
          });
          const needYBarRef = vue.computed(() => {
            const { value: containerHeight } = containerHeightRef;
            const { value: contentHeight } = contentHeightRef;
            return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
          });
          const needXBarRef = vue.computed(() => {
            const { value: containerWidth } = containerWidthRef;
            const { value: contentWidth } = contentWidthRef;
            return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
          });
          const mergedShowXBarRef = vue.computed(() => {
            const { trigger: trigger2 } = props;
            return trigger2 === "none" || isShowXBarRef.value;
          });
          const mergedShowYBarRef = vue.computed(() => {
            const { trigger: trigger2 } = props;
            return trigger2 === "none" || isShowYBarRef.value;
          });
          const mergedContainerRef = vue.computed(() => {
            const { container } = props;
            if (container)
              return container();
            return containerRef.value;
          });
          const mergedContentRef = vue.computed(() => {
            const { content } = props;
            if (content)
              return content();
            return contentRef.value;
          });
          const activateState = useReactivated(() => {
            if (!props.container) {
              scrollTo({
                top: containerScrollTopRef.value,
                left: containerScrollLeftRef.value
              });
            }
          });
          const handleContentResize = () => {
            if (activateState.isDeactivated)
              return;
            sync();
          };
          const handleContainerResize = (e) => {
            if (activateState.isDeactivated)
              return;
            const { onResize } = props;
            if (onResize)
              onResize(e);
            sync();
          };
          const scrollTo = (options, y) => {
            if (!props.scrollable)
              return;
            if (typeof options === "number") {
              scrollToPosition(y !== null && y !== void 0 ? y : 0, options, 0, false, "auto");
              return;
            }
            const { left, top, index, elSize, position, behavior, el, debounce: debounce2 = true } = options;
            if (left !== void 0 || top !== void 0) {
              scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
            }
            if (el !== void 0) {
              scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
            } else if (index !== void 0 && elSize !== void 0) {
              scrollToPosition(0, index * elSize, elSize, debounce2, behavior);
            } else if (position === "bottom") {
              scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
            } else if (position === "top") {
              scrollToPosition(0, 0, 0, false, behavior);
            }
          };
          const scrollBy = (options, y) => {
            if (!props.scrollable)
              return;
            const { value: container } = mergedContainerRef;
            if (!container)
              return;
            if (typeof options === "object") {
              container.scrollBy(options);
            } else {
              container.scrollBy(options, y || 0);
            }
          };
          function scrollToPosition(left, top, elSize, debounce2, behavior) {
            const { value: container } = mergedContainerRef;
            if (!container)
              return;
            if (debounce2) {
              const { scrollTop, offsetHeight } = container;
              if (top > scrollTop) {
                if (top + elSize <= scrollTop + offsetHeight)
                  ;
                else {
                  container.scrollTo({
                    left,
                    top: top + elSize - offsetHeight,
                    behavior
                  });
                }
                return;
              }
            }
            container.scrollTo({
              left,
              top,
              behavior
            });
          }
          function handleMouseEnterWrapper() {
            showXBar();
            showYBar();
            sync();
          }
          function handleMouseLeaveWrapper() {
            hideBar();
          }
          function hideBar() {
            hideYBar();
            hideXBar();
          }
          function hideYBar() {
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            yBarVanishTimerId = window.setTimeout(() => {
              isShowYBarRef.value = false;
            }, props.duration);
          }
          function hideXBar() {
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            xBarVanishTimerId = window.setTimeout(() => {
              isShowXBarRef.value = false;
            }, props.duration);
          }
          function showXBar() {
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            isShowXBarRef.value = true;
          }
          function showYBar() {
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            isShowYBarRef.value = true;
          }
          function handleScroll(e) {
            const { onScroll } = props;
            if (onScroll)
              onScroll(e);
            syncScrollState();
          }
          function syncScrollState() {
            const { value: container } = mergedContainerRef;
            if (container) {
              containerScrollTopRef.value = container.scrollTop;
              containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            }
          }
          function syncPositionState() {
            const { value: content } = mergedContentRef;
            if (content) {
              contentHeightRef.value = content.offsetHeight;
              contentWidthRef.value = content.offsetWidth;
            }
            const { value: container } = mergedContainerRef;
            if (container) {
              containerHeightRef.value = container.offsetHeight;
              containerWidthRef.value = container.offsetWidth;
            }
            const { value: xRailEl } = xRailRef;
            const { value: yRailEl } = yRailRef;
            if (xRailEl) {
              xRailSizeRef.value = xRailEl.offsetWidth;
            }
            if (yRailEl) {
              yRailSizeRef.value = yRailEl.offsetHeight;
            }
          }
          function syncUnifiedContainer() {
            const { value: container } = mergedContainerRef;
            if (container) {
              containerScrollTopRef.value = container.scrollTop;
              containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
              containerHeightRef.value = container.offsetHeight;
              containerWidthRef.value = container.offsetWidth;
              contentHeightRef.value = container.scrollHeight;
              contentWidthRef.value = container.scrollWidth;
            }
            const { value: xRailEl } = xRailRef;
            const { value: yRailEl } = yRailRef;
            if (xRailEl) {
              xRailSizeRef.value = xRailEl.offsetWidth;
            }
            if (yRailEl) {
              yRailSizeRef.value = yRailEl.offsetHeight;
            }
          }
          function sync() {
            if (!props.scrollable)
              return;
            if (props.useUnifiedContainer) {
              syncUnifiedContainer();
            } else {
              syncPositionState();
              syncScrollState();
            }
          }
          function isMouseUpAway(e) {
            var _a;
            return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
          }
          function handleXScrollMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            xBarPressed = true;
            on("mousemove", window, handleXScrollMouseMove, true);
            on("mouseup", window, handleXScrollMouseUp, true);
            memoXLeft = containerScrollLeftRef.value;
            memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
          }
          function handleXScrollMouseMove(e) {
            if (!xBarPressed)
              return;
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            const { value: containerWidth } = containerWidthRef;
            const { value: contentWidth } = contentWidthRef;
            const { value: xBarSize } = xBarSizeRef;
            if (containerWidth === null || contentWidth === null)
              return;
            const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
            const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
            const toScrollLeftUpperBound = contentWidth - containerWidth;
            let toScrollLeft = memoXLeft + dScrollLeft;
            toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
            toScrollLeft = Math.max(toScrollLeft, 0);
            const { value: container } = mergedContainerRef;
            if (container) {
              container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
              const { internalOnUpdateScrollLeft } = props;
              if (internalOnUpdateScrollLeft)
                internalOnUpdateScrollLeft(toScrollLeft);
            }
          }
          function handleXScrollMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            off("mousemove", window, handleXScrollMouseMove, true);
            off("mouseup", window, handleXScrollMouseUp, true);
            xBarPressed = false;
            sync();
            if (isMouseUpAway(e)) {
              hideBar();
            }
          }
          function handleYScrollMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            yBarPressed = true;
            on("mousemove", window, handleYScrollMouseMove, true);
            on("mouseup", window, handleYScrollMouseUp, true);
            memoYTop = containerScrollTopRef.value;
            memoMouseY = e.clientY;
          }
          function handleYScrollMouseMove(e) {
            if (!yBarPressed)
              return;
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            const { value: containerHeight } = containerHeightRef;
            const { value: contentHeight } = contentHeightRef;
            const { value: yBarSize } = yBarSizeRef;
            if (containerHeight === null || contentHeight === null)
              return;
            const dY = e.clientY - memoMouseY;
            const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
            const toScrollTopUpperBound = contentHeight - containerHeight;
            let toScrollTop = memoYTop + dScrollTop;
            toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
            toScrollTop = Math.max(toScrollTop, 0);
            const { value: container } = mergedContainerRef;
            if (container) {
              container.scrollTop = toScrollTop;
            }
          }
          function handleYScrollMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            off("mousemove", window, handleYScrollMouseMove, true);
            off("mouseup", window, handleYScrollMouseUp, true);
            yBarPressed = false;
            sync();
            if (isMouseUpAway(e)) {
              hideBar();
            }
          }
          vue.watchEffect(() => {
            const { value: needXBar } = needXBarRef;
            const { value: needYBar } = needYBarRef;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            const { value: xRailEl } = xRailRef;
            const { value: yRailEl } = yRailRef;
            if (xRailEl) {
              if (!needXBar) {
                xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              } else {
                xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              }
            }
            if (yRailEl) {
              if (!needYBar) {
                yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              } else {
                yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              }
            }
          });
          vue.onMounted(() => {
            if (props.container)
              return;
            sync();
          });
          vue.onBeforeUnmount(() => {
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            off("mousemove", window, handleYScrollMouseMove, true);
            off("mouseup", window, handleYScrollMouseUp, true);
          });
          const themeRef = useTheme("Scrollbar", "-scrollbar", style$1u, scrollbarLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, scrollbarBorderRadius, scrollbarHeight, scrollbarWidth }, self: { color, colorHover } } = themeRef.value;
            return {
              "--n-scrollbar-bezier": cubicBezierEaseInOut2,
              "--n-scrollbar-color": color,
              "--n-scrollbar-color-hover": colorHover,
              "--n-scrollbar-border-radius": scrollbarBorderRadius,
              "--n-scrollbar-width": scrollbarWidth,
              "--n-scrollbar-height": scrollbarHeight
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
          const exposedMethods = {
            scrollTo,
            scrollBy,
            sync,
            syncUnifiedContainer,
            handleMouseEnterWrapper,
            handleMouseLeaveWrapper
          };
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            containerScrollTop: containerScrollTopRef,
            wrapperRef,
            containerRef,
            contentRef,
            yRailRef,
            xRailRef,
            needYBar: needYBarRef,
            needXBar: needXBarRef,
            yBarSizePx: yBarSizePxRef,
            xBarSizePx: xBarSizePxRef,
            yBarTopPx: yBarTopPxRef,
            xBarLeftPx: xBarLeftPxRef,
            isShowXBar: mergedShowXBarRef,
            isShowYBar: mergedShowYBarRef,
            isIos: isIos2,
            handleScroll,
            handleContentResize,
            handleContainerResize,
            handleYScrollMouseDown,
            handleXScrollMouseDown,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const { $slots, mergedClsPrefix, triggerDisplayManually, rtlEnabled, internalHoistYRail } = this;
          if (!this.scrollable)
            return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
          const triggerIsNone = this.trigger === "none";
          const createYRail = () => {
            return vue.h("div", { ref: "yRailRef", class: [
              `${mergedClsPrefix}-scrollbar-rail`,
              `${mergedClsPrefix}-scrollbar-rail--vertical`
            ], "data-scrollbar-rail": true, style: this.verticalRailStyle, "aria-hidden": true }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
              default: () => this.needYBar && this.isShowYBar && !this.isIos ? vue.h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                height: this.yBarSizePx,
                top: this.yBarTopPx
              }, onMousedown: this.handleYScrollMouseDown }) : null
            }));
          };
          const createChildren = () => {
            var _a2, _b;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return vue.h("div", vue.mergeProps(this.$attrs, {
              role: "none",
              ref: "wrapperRef",
              class: [
                `${mergedClsPrefix}-scrollbar`,
                this.themeClass,
                rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`
              ],
              style: this.cssVars,
              onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
              onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
            }), [
              this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : vue.h(
                "div",
                { role: "none", ref: "containerRef", class: [
                  `${mergedClsPrefix}-scrollbar-container`,
                  this.containerClass
                ], style: this.containerStyle, onScroll: this.handleScroll, onWheel: this.onWheel },
                vue.h(VResizeObserver, { onResize: this.handleContentResize }, {
                  default: () => vue.h("div", { ref: "contentRef", role: "none", style: [
                    {
                      width: this.xScrollable ? "fit-content" : null
                    },
                    this.contentStyle
                  ], class: [
                    `${mergedClsPrefix}-scrollbar-content`,
                    this.contentClass
                  ] }, $slots)
                })
              ),
              internalHoistYRail ? null : createYRail(),
              this.xScrollable && vue.h("div", { ref: "xRailRef", class: [
                `${mergedClsPrefix}-scrollbar-rail`,
                `${mergedClsPrefix}-scrollbar-rail--horizontal`
              ], style: this.horizontalRailStyle, "data-scrollbar-rail": true, "aria-hidden": true }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
                default: () => this.needXBar && this.isShowXBar && !this.isIos ? vue.h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                  width: this.xBarSizePx,
                  right: rtlEnabled ? this.xBarLeftPx : void 0,
                  left: rtlEnabled ? void 0 : this.xBarLeftPx
                }, onMousedown: this.handleXScrollMouseDown }) : null
              }))
            ]);
          };
          const scrollbarNode = this.container ? createChildren() : vue.h(VResizeObserver, { onResize: this.handleContainerResize }, {
            default: createChildren
          });
          if (internalHoistYRail) {
            return vue.h(
              vue.Fragment,
              null,
              scrollbarNode,
              createYRail()
            );
          } else {
            return scrollbarNode;
          }
        }
      });
      const NScrollbar = Scrollbar$2;
      const XScrollbar = Scrollbar$2;
      const commonVariables$l = {
        height: "calc(var(--n-option-height) * 7.6)",
        paddingSmall: "4px 0",
        paddingMedium: "4px 0",
        paddingLarge: "4px 0",
        paddingHuge: "4px 0",
        optionPaddingSmall: "0 12px",
        optionPaddingMedium: "0 12px",
        optionPaddingLarge: "0 12px",
        optionPaddingHuge: "0 12px",
        loadingSize: "18px"
      };
      const self$1b = (vars) => {
        const { borderRadius, popoverColor, textColor3, dividerColor, textColor2, primaryColorPressed, textColorDisabled, primaryColor, opacityDisabled, hoverColor, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge } = vars;
        return Object.assign(Object.assign({}, commonVariables$l), { optionFontSizeSmall: fontSizeSmall, optionFontSizeMedium: fontSizeMedium, optionFontSizeLarge: fontSizeLarge, optionFontSizeHuge: fontSizeHuge, optionHeightSmall: heightSmall, optionHeightMedium: heightMedium, optionHeightLarge: heightLarge, optionHeightHuge: heightHuge, borderRadius, color: popoverColor, groupHeaderTextColor: textColor3, actionDividerColor: dividerColor, optionTextColor: textColor2, optionTextColorPressed: primaryColorPressed, optionTextColorDisabled: textColorDisabled, optionTextColorActive: primaryColor, optionOpacityDisabled: opacityDisabled, optionCheckColor: primaryColor, optionColorPending: hoverColor, optionColorActive: "rgba(0, 0, 0, 0)", optionColorActivePending: hoverColor, actionTextColor: textColor2, loadingColor: primaryColor });
      };
      const internalSelectMenuLight = createTheme({
        name: "InternalSelectMenu",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1,
          Empty: emptyLight$1
        },
        self: self$1b
      });
      const internalSelectMenuLight$1 = internalSelectMenuLight;
      const internalSelectMenuDark = {
        name: "InternalSelectMenu",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1,
          Empty: emptyDark$1
        },
        self: self$1b
      };
      const internalSelectMenuDark$1 = internalSelectMenuDark;
      function renderCheckMark(show, clsPrefix) {
        return vue.h(vue.Transition, { name: "fade-in-scale-up-transition" }, {
          default: () => show ? vue.h(NBaseIcon, { clsPrefix, class: `${clsPrefix}-base-select-option__check` }, {
            default: () => vue.h(FinishedIcon)
          }) : null
        });
      }
      const NSelectOption = vue.defineComponent({
        name: "NBaseSelectOption",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const {
            valueRef,
            pendingTmNodeRef,
            multipleRef,
            valueSetRef,
            renderLabelRef,
            renderOptionRef,
            labelFieldRef,
            valueFieldRef,
            showCheckmarkRef,
            nodePropsRef,
            handleOptionClick,
            handleOptionMouseEnter
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(internalSelectionMenuInjectionKey);
          const isPendingRef = useMemo(() => {
            const { value: pendingTmNode } = pendingTmNodeRef;
            if (!pendingTmNode)
              return false;
            return props.tmNode.key === pendingTmNode.key;
          });
          function handleClick2(e) {
            const { tmNode } = props;
            if (tmNode.disabled)
              return;
            handleOptionClick(e, tmNode);
          }
          function handleMouseEnter(e) {
            const { tmNode } = props;
            if (tmNode.disabled)
              return;
            handleOptionMouseEnter(e, tmNode);
          }
          function handleMouseMove(e) {
            const { tmNode } = props;
            const { value: isPending } = isPendingRef;
            if (tmNode.disabled || isPending)
              return;
            handleOptionMouseEnter(e, tmNode);
          }
          return {
            multiple: multipleRef,
            isGrouped: useMemo(() => {
              const { tmNode } = props;
              const { parent } = tmNode;
              return parent && parent.rawNode.type === "group";
            }),
            showCheckmark: showCheckmarkRef,
            nodeProps: nodePropsRef,
            isPending: isPendingRef,
            isSelected: useMemo(() => {
              const { value } = valueRef;
              const { value: multiple } = multipleRef;
              if (value === null)
                return false;
              const optionValue = props.tmNode.rawNode[valueFieldRef.value];
              if (multiple) {
                const { value: valueSet } = valueSetRef;
                return valueSet.has(optionValue);
              } else {
                return value === optionValue;
              }
            }),
            labelField: labelFieldRef,
            renderLabel: renderLabelRef,
            renderOption: renderOptionRef,
            handleMouseMove,
            handleMouseEnter,
            handleClick: handleClick2
          };
        },
        render() {
          const { clsPrefix, tmNode: { rawNode }, isSelected, isPending, isGrouped, showCheckmark, nodeProps, renderOption, renderLabel, handleClick: handleClick2, handleMouseEnter, handleMouseMove } = this;
          const checkmark = renderCheckMark(isSelected, clsPrefix);
          const children = renderLabel ? [renderLabel(rawNode, isSelected), showCheckmark && checkmark] : [
            render$1(rawNode[this.labelField], rawNode, isSelected),
            showCheckmark && checkmark
          ];
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const node = vue.h(
            "div",
            Object.assign({}, attrs, { class: [
              `${clsPrefix}-base-select-option`,
              rawNode.class,
              attrs === null || attrs === void 0 ? void 0 : attrs.class,
              {
                [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
                [`${clsPrefix}-base-select-option--selected`]: isSelected,
                [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
                [`${clsPrefix}-base-select-option--pending`]: isPending,
                [`${clsPrefix}-base-select-option--show-checkmark`]: showCheckmark
              }
            ], style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || "", rawNode.style || ""], onClick: mergeEventHandlers([handleClick2, attrs === null || attrs === void 0 ? void 0 : attrs.onClick]), onMouseenter: mergeEventHandlers([
              handleMouseEnter,
              attrs === null || attrs === void 0 ? void 0 : attrs.onMouseenter
            ]), onMousemove: mergeEventHandlers([handleMouseMove, attrs === null || attrs === void 0 ? void 0 : attrs.onMousemove]) }),
            vue.h("div", { class: `${clsPrefix}-base-select-option__content` }, children)
          );
          return rawNode.render ? rawNode.render({ node, option: rawNode, selected: isSelected }) : renderOption ? renderOption({ node, option: rawNode, selected: isSelected }) : node;
        }
      });
      const NSelectGroupHeader = vue.defineComponent({
        name: "NBaseSelectGroupHeader",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup() {
          const {
            renderLabelRef,
            renderOptionRef,
            labelFieldRef,
            nodePropsRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(internalSelectionMenuInjectionKey);
          return {
            labelField: labelFieldRef,
            nodeProps: nodePropsRef,
            renderLabel: renderLabelRef,
            renderOption: renderOptionRef
          };
        },
        render() {
          const { clsPrefix, renderLabel, renderOption, nodeProps, tmNode: { rawNode } } = this;
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const children = renderLabel ? renderLabel(rawNode, false) : render$1(rawNode[this.labelField], rawNode, false);
          const node = vue.h("div", Object.assign({}, attrs, { class: [`${clsPrefix}-base-select-group-header`, attrs === null || attrs === void 0 ? void 0 : attrs.class] }), children);
          return rawNode.render ? rawNode.render({ node, option: rawNode }) : renderOption ? renderOption({ node, option: rawNode, selected: false }) : node;
        }
      });
      const {
        cubicBezierEaseIn: cubicBezierEaseIn$5,
        cubicBezierEaseOut: cubicBezierEaseOut$6
      } = commonVariables$m;
      function fadeInScaleUpTransition({
        transformOrigin = "inherit",
        duration = ".2s",
        enterScale = ".9",
        originalTransform = "",
        originalTransition = ""
      } = {}) {
        return [c$1("&.fade-in-scale-up-transition-leave-active", {
          transformOrigin,
          transition: `opacity ${duration} ${cubicBezierEaseIn$5}, transform ${duration} ${cubicBezierEaseIn$5} ${originalTransition && "," + originalTransition}`
        }), c$1("&.fade-in-scale-up-transition-enter-active", {
          transformOrigin,
          transition: `opacity ${duration} ${cubicBezierEaseOut$6}, transform ${duration} ${cubicBezierEaseOut$6} ${originalTransition && "," + originalTransition}`
        }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
          opacity: 0,
          transform: `${originalTransform} scale(${enterScale})`
        }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
          opacity: 1,
          transform: `${originalTransform} scale(1)`
        })];
      }
      const style$1t = cB("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [cB("scrollbar", `
 max-height: var(--n-height);
 `), cB("virtual-list", `
 max-height: var(--n-height);
 `), cB("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [cE("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), cB("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), cB("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), cE("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), cE("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cB("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), cB("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [cM("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), c$1("&:active", `
 color: var(--n-option-text-color-pressed);
 `), cM("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), cM("selected", `
 color: var(--n-option-text-color-active);
 `, [c$1("&::before", `
 background-color: var(--n-option-color-active);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cNotM("selected", `
 color: var(--n-option-text-color-disabled);
 `), cM("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), cE("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [fadeInScaleUpTransition({
        enterScale: "0.5"
      })])])]);
      const NInternalSelectMenu = vue.defineComponent({
        name: "InternalSelectMenu",
        props: Object.assign(Object.assign({}, useTheme.props), {
          clsPrefix: {
            type: String,
            required: true
          },
          scrollable: {
            type: Boolean,
            default: true
          },
          treeMate: {
            type: Object,
            required: true
          },
          multiple: Boolean,
          size: {
            type: String,
            default: "medium"
          },
          value: {
            type: [String, Number, Array],
            default: null
          },
          autoPending: Boolean,
          virtualScroll: {
            type: Boolean,
            default: true
          },
          // show is used to toggle pending state initialization
          show: {
            type: Boolean,
            default: true
          },
          labelField: {
            type: String,
            default: "label"
          },
          valueField: {
            type: String,
            default: "value"
          },
          loading: Boolean,
          focusable: Boolean,
          renderLabel: Function,
          renderOption: Function,
          nodeProps: Function,
          showCheckmark: { type: Boolean, default: true },
          onMousedown: Function,
          onScroll: Function,
          onFocus: Function,
          onBlur: Function,
          onKeyup: Function,
          onKeydown: Function,
          onTabOut: Function,
          onMouseenter: Function,
          onMouseleave: Function,
          onResize: Function,
          resetMenuOnOptionsChange: {
            type: Boolean,
            default: true
          },
          inlineThemeDisabled: Boolean,
          // deprecated
          onToggle: Function
        }),
        setup(props) {
          const themeRef = useTheme("InternalSelectMenu", "-internal-select-menu", style$1t, internalSelectMenuLight$1, props, vue.toRef(props, "clsPrefix"));
          const selfRef = vue.ref(null);
          const virtualListRef = vue.ref(null);
          const scrollbarRef = vue.ref(null);
          const flattenedNodesRef = vue.computed(() => props.treeMate.getFlattenedNodes());
          const fIndexGetterRef = vue.computed(() => createIndexGetter(flattenedNodesRef.value));
          const pendingNodeRef = vue.ref(null);
          function initPendingNode() {
            const { treeMate } = props;
            let defaultPendingNode = null;
            const { value } = props;
            if (value === null) {
              defaultPendingNode = treeMate.getFirstAvailableNode();
            } else {
              if (props.multiple) {
                defaultPendingNode = treeMate.getNode((value || [])[(value || []).length - 1]);
              } else {
                defaultPendingNode = treeMate.getNode(value);
              }
              if (!defaultPendingNode || defaultPendingNode.disabled) {
                defaultPendingNode = treeMate.getFirstAvailableNode();
              }
            }
            if (defaultPendingNode) {
              setPendingTmNode(defaultPendingNode);
            } else {
              setPendingTmNode(null);
            }
          }
          function clearPendingNodeIfInvalid() {
            const { value: pendingNode } = pendingNodeRef;
            if (pendingNode && !props.treeMate.getNode(pendingNode.key)) {
              pendingNodeRef.value = null;
            }
          }
          let initPendingNodeWatchStopHandle;
          vue.watch(() => props.show, (show) => {
            if (show) {
              initPendingNodeWatchStopHandle = vue.watch(() => props.treeMate, () => {
                if (props.resetMenuOnOptionsChange) {
                  if (props.autoPending) {
                    initPendingNode();
                  } else {
                    clearPendingNodeIfInvalid();
                  }
                  void vue.nextTick(scrollToPendingNode);
                } else {
                  clearPendingNodeIfInvalid();
                }
              }, {
                immediate: true
              });
            } else {
              initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
            }
          }, {
            immediate: true
          });
          vue.onBeforeUnmount(() => {
            initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
          });
          const itemSizeRef = vue.computed(() => {
            return depx(themeRef.value.self[createKey("optionHeight", props.size)]);
          });
          const paddingRef = vue.computed(() => {
            return getMargin(themeRef.value.self[createKey("padding", props.size)]);
          });
          const valueSetRef = vue.computed(() => {
            if (props.multiple && Array.isArray(props.value)) {
              return new Set(props.value);
            }
            return /* @__PURE__ */ new Set();
          });
          const emptyRef = vue.computed(() => {
            const tmNodes = flattenedNodesRef.value;
            return tmNodes && tmNodes.length === 0;
          });
          function doToggle(tmNode) {
            const { onToggle } = props;
            if (onToggle)
              onToggle(tmNode);
          }
          function doScroll(e) {
            const { onScroll } = props;
            if (onScroll)
              onScroll(e);
          }
          function handleVirtualListScroll(e) {
            var _a;
            (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
            doScroll(e);
          }
          function handleVirtualListResize() {
            var _a;
            (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function getPendingTmNode() {
            const { value: pendingTmNode } = pendingNodeRef;
            if (pendingTmNode)
              return pendingTmNode;
            return null;
          }
          function handleOptionMouseEnter(e, tmNode) {
            if (tmNode.disabled)
              return;
            setPendingTmNode(tmNode, false);
          }
          function handleOptionClick(e, tmNode) {
            if (tmNode.disabled)
              return;
            doToggle(tmNode);
          }
          function handleKeyUp(e) {
            var _a;
            if (happensIn(e, "action"))
              return;
            (_a = props.onKeyup) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleKeyDown(e) {
            var _a;
            if (happensIn(e, "action"))
              return;
            (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleMouseDown(e) {
            var _a;
            (_a = props.onMousedown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            if (props.focusable)
              return;
            e.preventDefault();
          }
          function next() {
            const { value: pendingTmNode } = pendingNodeRef;
            if (pendingTmNode) {
              setPendingTmNode(pendingTmNode.getNext({ loop: true }), true);
            }
          }
          function prev() {
            const { value: pendingTmNode } = pendingNodeRef;
            if (pendingTmNode) {
              setPendingTmNode(pendingTmNode.getPrev({ loop: true }), true);
            }
          }
          function setPendingTmNode(tmNode, doScroll2 = false) {
            pendingNodeRef.value = tmNode;
            if (doScroll2)
              scrollToPendingNode();
          }
          function scrollToPendingNode() {
            var _a, _b;
            const tmNode = pendingNodeRef.value;
            if (!tmNode)
              return;
            const fIndex = fIndexGetterRef.value(tmNode.key);
            if (fIndex === null)
              return;
            if (props.virtualScroll) {
              (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ index: fIndex });
            } else {
              (_b = scrollbarRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
                index: fIndex,
                elSize: itemSizeRef.value
              });
            }
          }
          function handleFocusin(e) {
            var _a, _b;
            if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
              (_b = props.onFocus) === null || _b === void 0 ? void 0 : _b.call(props, e);
            }
          }
          function handleFocusout(e) {
            var _a, _b;
            if (!((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
              (_b = props.onBlur) === null || _b === void 0 ? void 0 : _b.call(props, e);
            }
          }
          vue.provide(internalSelectionMenuInjectionKey, {
            handleOptionMouseEnter,
            handleOptionClick,
            valueSetRef,
            pendingTmNodeRef: pendingNodeRef,
            nodePropsRef: vue.toRef(props, "nodeProps"),
            showCheckmarkRef: vue.toRef(props, "showCheckmark"),
            multipleRef: vue.toRef(props, "multiple"),
            valueRef: vue.toRef(props, "value"),
            renderLabelRef: vue.toRef(props, "renderLabel"),
            renderOptionRef: vue.toRef(props, "renderOption"),
            labelFieldRef: vue.toRef(props, "labelField"),
            valueFieldRef: vue.toRef(props, "valueField")
          });
          vue.provide(internalSelectionMenuBodyInjectionKey, selfRef);
          vue.onMounted(() => {
            const { value } = scrollbarRef;
            if (value)
              value.sync();
          });
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { height, borderRadius, color, groupHeaderTextColor, actionDividerColor, optionTextColorPressed, optionTextColor, optionTextColorDisabled, optionTextColorActive, optionOpacityDisabled, optionCheckColor, actionTextColor, optionColorPending, optionColorActive, loadingColor, loadingSize, optionColorActivePending, [createKey("optionFontSize", size2)]: fontSize2, [createKey("optionHeight", size2)]: optionHeight, [createKey("optionPadding", size2)]: optionPadding } } = themeRef.value;
            return {
              "--n-height": height,
              "--n-action-divider-color": actionDividerColor,
              "--n-action-text-color": actionTextColor,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-color": color,
              "--n-option-font-size": fontSize2,
              "--n-group-header-text-color": groupHeaderTextColor,
              "--n-option-check-color": optionCheckColor,
              "--n-option-color-pending": optionColorPending,
              "--n-option-color-active": optionColorActive,
              "--n-option-color-active-pending": optionColorActivePending,
              "--n-option-height": optionHeight,
              "--n-option-opacity-disabled": optionOpacityDisabled,
              "--n-option-text-color": optionTextColor,
              "--n-option-text-color-active": optionTextColorActive,
              "--n-option-text-color-disabled": optionTextColorDisabled,
              "--n-option-text-color-pressed": optionTextColorPressed,
              "--n-option-padding": optionPadding,
              "--n-option-padding-left": getMargin(optionPadding, "left"),
              "--n-option-padding-right": getMargin(optionPadding, "right"),
              "--n-loading-color": loadingColor,
              "--n-loading-size": loadingSize
            };
          });
          const { inlineThemeDisabled } = props;
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-select-menu", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
          const exposedProps = {
            selfRef,
            next,
            prev,
            getPendingTmNode
          };
          useOnResize(selfRef, props.onResize);
          return Object.assign({
            mergedTheme: themeRef,
            virtualListRef,
            scrollbarRef,
            itemSize: itemSizeRef,
            padding: paddingRef,
            flattenedNodes: flattenedNodesRef,
            empty: emptyRef,
            virtualListContainer() {
              const { value } = virtualListRef;
              return value === null || value === void 0 ? void 0 : value.listElRef;
            },
            virtualListContent() {
              const { value } = virtualListRef;
              return value === null || value === void 0 ? void 0 : value.itemsElRef;
            },
            doScroll,
            handleFocusin,
            handleFocusout,
            handleKeyUp,
            handleKeyDown,
            handleMouseDown,
            handleVirtualListResize,
            handleVirtualListScroll,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedProps);
        },
        render() {
          const { $slots, virtualScroll, clsPrefix, mergedTheme, themeClass, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [
              `${clsPrefix}-base-select-menu`,
              themeClass,
              this.multiple && `${clsPrefix}-base-select-menu--multiple`
            ], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
            this.loading ? vue.h(
              "div",
              { class: `${clsPrefix}-base-select-menu__loading` },
              vue.h(NBaseLoading, { clsPrefix, strokeWidth: 20 })
            ) : !this.empty ? vue.h(NScrollbar, { ref: "scrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, scrollable: this.scrollable, container: virtualScroll ? this.virtualListContainer : void 0, content: virtualScroll ? this.virtualListContent : void 0, onScroll: virtualScroll ? void 0 : this.doScroll }, {
              default: () => {
                return virtualScroll ? vue.h(VVirtualList, { ref: "virtualListRef", class: `${clsPrefix}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, {
                  default: ({ item: tmNode }) => {
                    return tmNode.isGroup ? vue.h(NSelectGroupHeader, { key: tmNode.key, clsPrefix, tmNode }) : tmNode.ignored ? null : vue.h(NSelectOption, { clsPrefix, key: tmNode.key, tmNode });
                  }
                }) : vue.h("div", { class: `${clsPrefix}-base-select-menu-option-wrapper`, style: {
                  paddingTop: this.padding.top,
                  paddingBottom: this.padding.bottom
                } }, this.flattenedNodes.map((tmNode) => tmNode.isGroup ? vue.h(NSelectGroupHeader, { key: tmNode.key, clsPrefix, tmNode }) : vue.h(NSelectOption, { clsPrefix, key: tmNode.key, tmNode })));
              }
            }) : vue.h("div", { class: `${clsPrefix}-base-select-menu__empty`, "data-empty": true }, resolveSlot($slots.empty, () => [
              vue.h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
            ])),
            resolveWrappedSlot($slots.action, (children) => children && [
              vue.h("div", { class: `${clsPrefix}-base-select-menu__action`, "data-action": true, key: "action" }, children),
              vue.h(FocusDetector, { onFocus: this.onTabOut, key: "focus-detector" })
            ])
          );
        }
      });
      const style$1s = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
      const NBaseWave = vue.defineComponent({
        name: "BaseWave",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup(props) {
          useStyle("-base-wave", style$1s, vue.toRef(props, "clsPrefix"));
          const selfRef = vue.ref(null);
          const activeRef = vue.ref(false);
          let animationTimerId = null;
          vue.onBeforeUnmount(() => {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
            }
          });
          return {
            active: activeRef,
            selfRef,
            play() {
              if (animationTimerId !== null) {
                window.clearTimeout(animationTimerId);
                activeRef.value = false;
                animationTimerId = null;
              }
              void vue.nextTick(() => {
                var _a;
                void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
                activeRef.value = true;
                animationTimerId = window.setTimeout(() => {
                  activeRef.value = false;
                  animationTimerId = null;
                }, 1e3);
              });
            }
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h("div", { ref: "selfRef", "aria-hidden": true, class: [
            `${clsPrefix}-base-wave`,
            this.active && `${clsPrefix}-base-wave--active`
          ] });
        }
      });
      const style$1r = cB("base-menu-mask", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 text-align: center;
 padding: 14px;
 overflow: hidden;
`, [fadeInTransition()]);
      const NBaseMenuMask = vue.defineComponent({
        name: "BaseMenuMask",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup(props) {
          useStyle("-base-menu-mask", style$1r, vue.toRef(props, "clsPrefix"));
          const messageRef = vue.ref(null);
          let timerId = null;
          const uncontrolledShowRef = vue.ref(false);
          vue.onBeforeUnmount(() => {
            if (timerId !== null) {
              window.clearTimeout(timerId);
            }
          });
          const exposedRef = {
            showOnce(message2, duration = 1500) {
              if (timerId)
                window.clearTimeout(timerId);
              uncontrolledShowRef.value = true;
              messageRef.value = message2;
              timerId = window.setTimeout(() => {
                uncontrolledShowRef.value = false;
                messageRef.value = null;
              }, duration);
            }
          };
          return Object.assign({ message: messageRef, show: uncontrolledShowRef }, exposedRef);
        },
        render() {
          return vue.h(vue.Transition, { name: "fade-in-transition" }, {
            default: () => this.show ? vue.h("div", { class: `${this.clsPrefix}-base-menu-mask` }, this.message) : null
          });
        }
      });
      const commonVariables$k = {
        space: "6px",
        spaceArrow: "10px",
        arrowOffset: "10px",
        arrowOffsetVertical: "10px",
        arrowHeight: "6px",
        padding: "8px 14px"
      };
      const self$1a = (vars) => {
        const { boxShadow2, popoverColor, textColor2, borderRadius, fontSize: fontSize2, dividerColor } = vars;
        return Object.assign(Object.assign({}, commonVariables$k), {
          fontSize: fontSize2,
          borderRadius,
          color: popoverColor,
          dividerColor,
          textColor: textColor2,
          boxShadow: boxShadow2
        });
      };
      const popoverLight = {
        name: "Popover",
        common: commonLight,
        self: self$1a
      };
      const popoverLight$1 = popoverLight;
      const popoverDark = {
        name: "Popover",
        common: commonDark,
        self: self$1a
      };
      const popoverDark$1 = popoverDark;
      const oppositePlacement = {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      };
      const arrowSize = "var(--n-arrow-height) * 1.414";
      const style$1q = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
        cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
        // body transition
        c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
        c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
        c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
        c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
      ]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map({
        top: ["right-start", "left-start"],
        right: ["top-end", "bottom-end"],
        bottom: ["right-end", "left-end"],
        left: ["top-start", "bottom-start"]
      }, (placements, direction) => {
        const isVertical = ["right", "left"].includes(direction);
        const sizeType = isVertical ? "width" : "height";
        return placements.map((placement) => {
          const isReverse = placement.split("-")[1] === "end";
          const targetSize = `var(--v-target-${sizeType}, 0px)`;
          const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
          const offset = getArrowOffset(placement);
          return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
        });
      })]);
      function getArrowOffset(placement) {
        return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
      }
      function placementStyle(placement, arrowStyleLiteral) {
        const position = placement.split("-")[0];
        const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
        return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
      }
      const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        show: Boolean,
        trigger: String,
        showArrow: Boolean,
        delay: Number,
        duration: Number,
        raw: Boolean,
        arrowPointToCenter: Boolean,
        arrowStyle: [String, Object],
        displayDirective: String,
        x: Number,
        y: Number,
        flip: Boolean,
        overlap: Boolean,
        placement: String,
        width: [Number, String],
        keepAliveOnHover: Boolean,
        scrollable: Boolean,
        contentStyle: [Object, String],
        headerStyle: [Object, String],
        footerStyle: [Object, String],
        // private
        internalDeactivateImmediately: Boolean,
        animated: Boolean,
        onClickoutside: Function,
        internalTrapFocus: Boolean,
        internalOnAfterLeave: Function,
        // deprecated
        minWidth: Number,
        maxWidth: Number
      });
      const renderArrow = ({ arrowStyle, clsPrefix }) => {
        return vue.h(
          "div",
          { key: "__popover-arrow__", class: `${clsPrefix}-popover-arrow-wrapper` },
          vue.h("div", { class: `${clsPrefix}-popover-arrow`, style: arrowStyle })
        );
      };
      const NPopoverBody = vue.defineComponent({
        name: "PopoverBody",
        inheritAttrs: false,
        props: popoverBodyProps,
        setup(props, { slots, attrs }) {
          const { namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Popover", "-popover", style$1q, popoverLight$1, props, mergedClsPrefixRef);
          const followerRef = vue.ref(null);
          const NPopover2 = vue.inject("NPopover");
          const bodyRef = vue.ref(null);
          const followerEnabledRef = vue.ref(props.show);
          const displayedRef = vue.ref(false);
          vue.watchEffect(() => {
            const { show } = props;
            if (show && !isJsdom() && !props.internalDeactivateImmediately) {
              displayedRef.value = true;
            }
          });
          const directivesRef = vue.computed(() => {
            const { trigger: trigger2, onClickoutside } = props;
            const directives = [];
            const { positionManuallyRef: { value: positionManually } } = NPopover2;
            if (!positionManually) {
              if (trigger2 === "click" && !onClickoutside) {
                directives.push([
                  clickoutside$1,
                  handleClickOutside,
                  void 0,
                  { capture: true }
                ]);
              }
              if (trigger2 === "hover") {
                directives.push([mousemoveoutside$1, handleMouseMoveOutside]);
              }
            }
            if (onClickoutside) {
              directives.push([
                clickoutside$1,
                handleClickOutside,
                void 0,
                { capture: true }
              ]);
            }
            if (props.displayDirective === "show" || props.animated && displayedRef.value) {
              directives.push([vue.vShow, props.show]);
            }
            return directives;
          });
          const styleRef = vue.computed(() => {
            const width = props.width === "trigger" ? void 0 : formatLength(props.width);
            const style2 = [];
            if (width) {
              style2.push({ width });
            }
            const { maxWidth, minWidth } = props;
            if (maxWidth) {
              style2.push({ maxWidth: formatLength(maxWidth) });
            }
            if (minWidth) {
              style2.push({ maxWidth: formatLength(minWidth) });
            }
            if (!inlineThemeDisabled) {
              style2.push(cssVarsRef.value);
            }
            return style2;
          });
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseIn: cubicBezierEaseIn2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { space, spaceArrow, padding, fontSize: fontSize2, textColor, dividerColor, color, boxShadow, borderRadius, arrowHeight, arrowOffset, arrowOffsetVertical } } = themeRef.value;
            return {
              "--n-box-shadow": boxShadow,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-bezier-ease-in": cubicBezierEaseIn2,
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-font-size": fontSize2,
              "--n-text-color": textColor,
              "--n-color": color,
              "--n-divider-color": dividerColor,
              "--n-border-radius": borderRadius,
              "--n-arrow-height": arrowHeight,
              "--n-arrow-offset": arrowOffset,
              "--n-arrow-offset-vertical": arrowOffsetVertical,
              "--n-padding": padding,
              "--n-space": space,
              "--n-space-arrow": spaceArrow
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
          NPopover2.setBodyInstance({
            syncPosition
          });
          vue.onBeforeUnmount(() => {
            NPopover2.setBodyInstance(null);
          });
          vue.watch(vue.toRef(props, "show"), (value) => {
            if (props.animated)
              return;
            if (value) {
              followerEnabledRef.value = true;
            } else {
              followerEnabledRef.value = false;
            }
          });
          function syncPosition() {
            var _a;
            (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleMouseEnter(e) {
            if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
              NPopover2.handleMouseEnter(e);
            }
          }
          function handleMouseLeave(e) {
            if (props.trigger === "hover" && props.keepAliveOnHover) {
              NPopover2.handleMouseLeave(e);
            }
          }
          function handleMouseMoveOutside(e) {
            if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
              NPopover2.handleMouseMoveOutside(e);
            }
          }
          function handleClickOutside(e) {
            if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
              NPopover2.handleClickOutside(e);
            }
          }
          function getTriggerElement() {
            return NPopover2.getTriggerElement();
          }
          vue.provide(popoverBodyInjectionKey, bodyRef);
          vue.provide(drawerBodyInjectionKey, null);
          vue.provide(modalBodyInjectionKey, null);
          function renderContentNode() {
            themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
            const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
            if (!shouldRenderDom) {
              return null;
            }
            let contentNode;
            const renderBody = NPopover2.internalRenderBodyRef.value;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            if (!renderBody) {
              const { value: extraClass } = NPopover2.extraClassRef;
              const { internalTrapFocus } = props;
              const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
              const renderContentInnerNode = () => {
                var _a;
                const body = hasHeaderOrFooter ? vue.h(
                  vue.Fragment,
                  null,
                  resolveWrappedSlot(slots.header, (children) => {
                    return children ? vue.h("div", { class: `${mergedClsPrefix}-popover__header`, style: props.headerStyle }, children) : null;
                  }),
                  resolveWrappedSlot(slots.default, (children) => {
                    return children ? vue.h("div", { class: `${mergedClsPrefix}-popover__content`, style: props.contentStyle }, slots) : null;
                  }),
                  resolveWrappedSlot(slots.footer, (children) => {
                    return children ? vue.h("div", { class: `${mergedClsPrefix}-popover__footer`, style: props.footerStyle }, children) : null;
                  })
                ) : props.scrollable ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots) : vue.h("div", { class: `${mergedClsPrefix}-popover__content`, style: props.contentStyle }, slots);
                const maybeScrollableBody = props.scrollable ? vue.h(XScrollbar, { contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content`, contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle }, {
                  default: () => body
                }) : body;
                const arrow = props.showArrow ? renderArrow({
                  arrowStyle: props.arrowStyle,
                  clsPrefix: mergedClsPrefix
                }) : null;
                return [maybeScrollableBody, arrow];
              };
              contentNode = vue.h("div", vue.mergeProps({
                class: [
                  `${mergedClsPrefix}-popover`,
                  `${mergedClsPrefix}-popover-shared`,
                  themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
                  extraClass.map((v) => `${mergedClsPrefix}-${v}`),
                  {
                    [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
                    [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
                    [`${mergedClsPrefix}-popover--raw`]: props.raw,
                    [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
                    [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
                    [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
                  }
                ],
                ref: bodyRef,
                style: styleRef.value,
                onKeydown: NPopover2.handleKeydown,
                onMouseenter: handleMouseEnter,
                onMouseleave: handleMouseLeave
              }, attrs), internalTrapFocus ? vue.h(FocusTrap, { active: props.show, autoFocus: true }, { default: renderContentInnerNode }) : renderContentInnerNode());
            } else {
              contentNode = renderBody(
                // The popover class and overlap class must exists, they will be used
                // to place the body & transition animation.
                // Shadow class exists for reuse box-shadow.
                [
                  `${mergedClsPrefix}-popover-shared`,
                  themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
                  props.overlap && `${mergedClsPrefix}-popover-shared--overlap`,
                  props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`,
                  props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`
                ],
                bodyRef,
                styleRef.value,
                handleMouseEnter,
                handleMouseLeave
              );
            }
            return vue.withDirectives(contentNode, directivesRef.value);
          }
          return {
            displayed: displayedRef,
            namespace: namespaceRef,
            isMounted: NPopover2.isMountedRef,
            zIndex: NPopover2.zIndexRef,
            followerRef,
            adjustedTo: useAdjustedTo(props),
            followerEnabled: followerEnabledRef,
            renderContentNode
          };
        },
        render() {
          return vue.h(VFollower, { ref: "followerRef", zIndex: this.zIndex, show: this.show, enabled: this.followerEnabled, to: this.adjustedTo, x: this.x, y: this.y, flip: this.flip, placement: this.placement, containerClass: this.namespace, overlap: this.overlap, width: this.width === "trigger" ? "target" : void 0, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
            default: () => {
              return this.animated ? vue.h(vue.Transition, {
                name: "popover-transition",
                appear: this.isMounted,
                // Don't use watch to enable follower, since the transition may
                // make position sync timing very subtle and buggy.
                onEnter: () => {
                  this.followerEnabled = true;
                },
                onAfterLeave: () => {
                  var _a;
                  (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
                  this.followerEnabled = false;
                  this.displayed = false;
                }
              }, {
                default: this.renderContentNode
              }) : this.renderContentNode();
            }
          });
        }
      });
      const bodyPropKeys = Object.keys(popoverBodyProps);
      const triggerEventMap = {
        focus: ["onFocus", "onBlur"],
        click: ["onClick"],
        hover: ["onMouseenter", "onMouseleave"],
        manual: [],
        nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
      };
      function appendEvents(vNode, trigger2, events2) {
        triggerEventMap[trigger2].forEach((eventName) => {
          if (!vNode.props)
            vNode.props = {};
          else {
            vNode.props = Object.assign({}, vNode.props);
          }
          const originalHandler = vNode.props[eventName];
          const handler = events2[eventName];
          if (!originalHandler)
            vNode.props[eventName] = handler;
          else {
            vNode.props[eventName] = (...args) => {
              originalHandler(...args);
              handler(...args);
            };
          }
        });
      }
      const popoverBaseProps = {
        show: {
          type: Boolean,
          default: void 0
        },
        defaultShow: Boolean,
        showArrow: {
          type: Boolean,
          default: true
        },
        trigger: {
          type: String,
          default: "hover"
        },
        delay: {
          type: Number,
          default: 100
        },
        duration: {
          type: Number,
          default: 100
        },
        raw: Boolean,
        placement: {
          type: String,
          default: "top"
        },
        x: Number,
        y: Number,
        arrowPointToCenter: Boolean,
        disabled: Boolean,
        getDisabled: Function,
        displayDirective: {
          type: String,
          default: "if"
        },
        arrowStyle: [String, Object],
        flip: {
          type: Boolean,
          default: true
        },
        animated: {
          type: Boolean,
          default: true
        },
        width: {
          type: [Number, String],
          default: void 0
        },
        overlap: Boolean,
        keepAliveOnHover: {
          type: Boolean,
          default: true
        },
        zIndex: Number,
        to: useAdjustedTo.propTo,
        scrollable: Boolean,
        contentStyle: [Object, String],
        headerStyle: [Object, String],
        footerStyle: [Object, String],
        // events
        onClickoutside: Function,
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        // internal
        internalDeactivateImmediately: Boolean,
        internalSyncTargetWithParent: Boolean,
        internalInheritedEventHandlers: {
          type: Array,
          default: () => []
        },
        internalTrapFocus: Boolean,
        internalExtraClass: {
          type: Array,
          default: () => []
        },
        // deprecated
        onShow: [Function, Array],
        onHide: [Function, Array],
        arrow: {
          type: Boolean,
          default: void 0
        },
        minWidth: Number,
        maxWidth: Number
      };
      const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), { internalOnAfterLeave: Function, internalRenderBody: Function });
      const NPopover = vue.defineComponent({
        name: "Popover",
        inheritAttrs: false,
        props: popoverProps,
        __popover__: true,
        setup(props) {
          const isMountedRef = isMounted();
          const binderInstRef = vue.ref(null);
          const controlledShowRef = vue.computed(() => props.show);
          const uncontrolledShowRef = vue.ref(props.defaultShow);
          const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const mergedShowConsideringDisabledPropRef = useMemo(() => {
            if (props.disabled)
              return false;
            return mergedShowWithoutDisabledRef.value;
          });
          const getMergedDisabled = () => {
            if (props.disabled)
              return true;
            const { getDisabled } = props;
            if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
              return true;
            return false;
          };
          const getMergedShow = () => {
            if (getMergedDisabled())
              return false;
            return mergedShowWithoutDisabledRef.value;
          };
          const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
          const mergedShowArrowRef = vue.computed(() => {
            if (props.overlap)
              return false;
            return compatibleShowArrowRef.value;
          });
          let bodyInstance = null;
          const showTimerIdRef = vue.ref(null);
          const hideTimerIdRef = vue.ref(null);
          const positionManuallyRef = useMemo(() => {
            return props.x !== void 0 && props.y !== void 0;
          });
          function doUpdateShow(value) {
            const { "onUpdate:show": _onUpdateShow, onUpdateShow, onShow, onHide } = props;
            uncontrolledShowRef.value = value;
            if (_onUpdateShow) {
              call(_onUpdateShow, value);
            }
            if (onUpdateShow) {
              call(onUpdateShow, value);
            }
            if (value && onShow) {
              call(onShow, true);
            }
            if (value && onHide) {
              call(onHide, false);
            }
          }
          function syncPosition() {
            if (bodyInstance) {
              bodyInstance.syncPosition();
            }
          }
          function clearShowTimer() {
            const { value: showTimerId } = showTimerIdRef;
            if (showTimerId) {
              window.clearTimeout(showTimerId);
              showTimerIdRef.value = null;
            }
          }
          function clearHideTimer() {
            const { value: hideTimerId } = hideTimerIdRef;
            if (hideTimerId) {
              window.clearTimeout(hideTimerId);
              hideTimerIdRef.value = null;
            }
          }
          function handleFocus() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "focus" && !mergedDisabled) {
              if (getMergedShow())
                return;
              doUpdateShow(true);
            }
          }
          function handleBlur() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "focus" && !mergedDisabled) {
              if (!getMergedShow())
                return;
              doUpdateShow(false);
            }
          }
          function handleMouseEnter() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "hover" && !mergedDisabled) {
              clearHideTimer();
              if (showTimerIdRef.value !== null)
                return;
              if (getMergedShow())
                return;
              const delayCallback = () => {
                doUpdateShow(true);
                showTimerIdRef.value = null;
              };
              const { delay } = props;
              if (delay === 0) {
                delayCallback();
              } else {
                showTimerIdRef.value = window.setTimeout(delayCallback, delay);
              }
            }
          }
          function handleMouseLeave() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "hover" && !mergedDisabled) {
              clearShowTimer();
              if (hideTimerIdRef.value !== null)
                return;
              if (!getMergedShow())
                return;
              const delayedCallback = () => {
                doUpdateShow(false);
                hideTimerIdRef.value = null;
              };
              const { duration } = props;
              if (duration === 0) {
                delayedCallback();
              } else {
                hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
              }
            }
          }
          function handleMouseMoveOutside() {
            handleMouseLeave();
          }
          function handleClickOutside(e) {
            var _a;
            if (!getMergedShow())
              return;
            if (props.trigger === "click") {
              clearShowTimer();
              clearHideTimer();
              doUpdateShow(false);
            }
            (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleClick2() {
            if (props.trigger === "click" && !getMergedDisabled()) {
              clearShowTimer();
              clearHideTimer();
              const nextShow = !getMergedShow();
              doUpdateShow(nextShow);
            }
          }
          function handleKeydown(e) {
            if (!props.internalTrapFocus)
              return;
            if (e.key === "Escape") {
              clearShowTimer();
              clearHideTimer();
              doUpdateShow(false);
            }
          }
          function setShow(value) {
            uncontrolledShowRef.value = value;
          }
          function getTriggerElement() {
            var _a;
            return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
          }
          function setBodyInstance(value) {
            bodyInstance = value;
          }
          vue.provide("NPopover", {
            getTriggerElement,
            handleKeydown,
            handleMouseEnter,
            handleMouseLeave,
            handleClickOutside,
            handleMouseMoveOutside,
            setBodyInstance,
            positionManuallyRef,
            isMountedRef,
            zIndexRef: vue.toRef(props, "zIndex"),
            extraClassRef: vue.toRef(props, "internalExtraClass"),
            internalRenderBodyRef: vue.toRef(props, "internalRenderBody")
          });
          vue.watchEffect(() => {
            if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
              doUpdateShow(false);
            }
          });
          return {
            binderInstRef,
            positionManually: positionManuallyRef,
            mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
            // if to show popover body
            uncontrolledShow: uncontrolledShowRef,
            mergedShowArrow: mergedShowArrowRef,
            getMergedShow,
            setShow,
            handleClick: handleClick2,
            handleMouseEnter,
            handleMouseLeave,
            handleFocus,
            handleBlur,
            syncPosition
          };
        },
        render() {
          var _a;
          const { positionManually, $slots: slots } = this;
          let triggerVNode;
          let popoverInside = false;
          if (!positionManually) {
            if (slots.activator) {
              triggerVNode = getFirstSlotVNode(slots, "activator");
            } else {
              triggerVNode = getFirstSlotVNode(slots, "trigger");
            }
            if (triggerVNode) {
              triggerVNode = vue.cloneVNode(triggerVNode);
              triggerVNode = triggerVNode.type === vue.Text ? vue.h("span", [triggerVNode]) : triggerVNode;
              const handlers = {
                onClick: this.handleClick,
                onMouseenter: this.handleMouseEnter,
                onMouseleave: this.handleMouseLeave,
                onFocus: this.handleFocus,
                onBlur: this.handleBlur
              };
              if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
                popoverInside = true;
                if (!triggerVNode.props) {
                  triggerVNode.props = {
                    internalSyncTargetWithParent: true,
                    internalInheritedEventHandlers: []
                  };
                }
                triggerVNode.props.internalSyncTargetWithParent = true;
                if (!triggerVNode.props.internalInheritedEventHandlers) {
                  triggerVNode.props.internalInheritedEventHandlers = [handlers];
                } else {
                  triggerVNode.props.internalInheritedEventHandlers = [
                    handlers,
                    ...triggerVNode.props.internalInheritedEventHandlers
                  ];
                }
              } else {
                const { internalInheritedEventHandlers } = this;
                const ascendantAndCurrentHandlers = [
                  handlers,
                  ...internalInheritedEventHandlers
                ];
                const mergedHandlers = {
                  onBlur: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onBlur(e);
                    });
                  },
                  onFocus: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onFocus(e);
                    });
                  },
                  onClick: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onClick(e);
                    });
                  },
                  onMouseenter: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onMouseenter(e);
                    });
                  },
                  onMouseleave: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onMouseleave(e);
                    });
                  }
                };
                appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
              }
            }
          }
          return vue.h(VBinder, { ref: "binderInstRef", syncTarget: !popoverInside, syncTargetWithParent: this.internalSyncTargetWithParent }, {
            default: () => {
              void this.mergedShowConsideringDisabledProp;
              const mergedShow = this.getMergedShow();
              return [
                this.internalTrapFocus && mergedShow ? vue.withDirectives(vue.h("div", { style: { position: "fixed", inset: 0 } }), [
                  [
                    zindexable$1,
                    {
                      enabled: mergedShow,
                      zIndex: this.zIndex
                    }
                  ]
                ]) : null,
                positionManually ? null : vue.h(VTarget, null, {
                  default: () => triggerVNode
                }),
                vue.h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), { showArrow: this.mergedShowArrow, show: mergedShow })), {
                  default: () => {
                    var _a2, _b;
                    return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
                  },
                  header: () => {
                    var _a2, _b;
                    return (_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2);
                  },
                  footer: () => {
                    var _a2, _b;
                    return (_b = (_a2 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a2);
                  }
                })
              ];
            }
          });
        }
      });
      const commonVariables$j = {
        closeIconSizeTiny: "12px",
        closeIconSizeSmall: "12px",
        closeIconSizeMedium: "14px",
        closeIconSizeLarge: "14px",
        closeSizeTiny: "16px",
        closeSizeSmall: "16px",
        closeSizeMedium: "18px",
        closeSizeLarge: "18px",
        padding: "0 7px",
        closeMargin: "0 0 0 4px",
        closeMarginRtl: "0 4px 0 0"
      };
      const tagDark = {
        name: "Tag",
        common: commonDark,
        self(vars) {
          const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, tagColor, opacityDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
          return Object.assign(Object.assign({}, commonVariables$j), {
            closeBorderRadius: borderRadius,
            heightTiny: heightMini,
            heightSmall: heightTiny,
            heightMedium: heightSmall,
            heightLarge: heightMedium,
            borderRadius,
            opacityDisabled,
            fontSizeTiny: fontSizeMini,
            fontSizeSmall: fontSizeTiny,
            fontSizeMedium: fontSizeSmall,
            fontSizeLarge: fontSizeMedium,
            fontWeightStrong,
            // checked
            textColorCheckable: textColor2,
            textColorHoverCheckable: textColor2,
            textColorPressedCheckable: textColor2,
            textColorChecked: baseColor,
            colorCheckable: "#0000",
            colorHoverCheckable: buttonColor2Hover,
            colorPressedCheckable: buttonColor2Pressed,
            colorChecked: primaryColor,
            colorCheckedHover: primaryColorHover,
            colorCheckedPressed: primaryColorPressed,
            // default
            border: `1px solid ${borderColor}`,
            textColor: textColor2,
            color: tagColor,
            colorBordered: "#0000",
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            closeColorHover,
            closeColorPressed,
            borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`,
            textColorPrimary: primaryColor,
            colorPrimary: changeColor(primaryColor, { alpha: 0.16 }),
            colorBorderedPrimary: "#0000",
            closeIconColorPrimary: scaleColor(primaryColor, { lightness: 0.7 }),
            closeIconColorHoverPrimary: scaleColor(primaryColor, { lightness: 0.7 }),
            closeIconColorPressedPrimary: scaleColor(primaryColor, {
              lightness: 0.7
            }),
            closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.16 }),
            closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.12 }),
            borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`,
            textColorInfo: infoColor,
            colorInfo: changeColor(infoColor, { alpha: 0.16 }),
            colorBorderedInfo: "#0000",
            closeIconColorInfo: scaleColor(infoColor, { alpha: 0.7 }),
            closeIconColorHoverInfo: scaleColor(infoColor, { alpha: 0.7 }),
            closeIconColorPressedInfo: scaleColor(infoColor, { alpha: 0.7 }),
            closeColorHoverInfo: changeColor(infoColor, { alpha: 0.16 }),
            closeColorPressedInfo: changeColor(infoColor, { alpha: 0.12 }),
            borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`,
            textColorSuccess: successColor,
            colorSuccess: changeColor(successColor, { alpha: 0.16 }),
            colorBorderedSuccess: "#0000",
            closeIconColorSuccess: scaleColor(successColor, { alpha: 0.7 }),
            closeIconColorHoverSuccess: scaleColor(successColor, { alpha: 0.7 }),
            closeIconColorPressedSuccess: scaleColor(successColor, { alpha: 0.7 }),
            closeColorHoverSuccess: changeColor(successColor, { alpha: 0.16 }),
            closeColorPressedSuccess: changeColor(successColor, { alpha: 0.12 }),
            borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.3 })}`,
            textColorWarning: warningColor,
            colorWarning: changeColor(warningColor, { alpha: 0.16 }),
            colorBorderedWarning: "#0000",
            closeIconColorWarning: scaleColor(warningColor, { alpha: 0.7 }),
            closeIconColorHoverWarning: scaleColor(warningColor, { alpha: 0.7 }),
            closeIconColorPressedWarning: scaleColor(warningColor, { alpha: 0.7 }),
            closeColorHoverWarning: changeColor(warningColor, { alpha: 0.16 }),
            closeColorPressedWarning: changeColor(warningColor, { alpha: 0.11 }),
            borderError: `1px solid ${changeColor(errorColor, { alpha: 0.3 })}`,
            textColorError: errorColor,
            colorError: changeColor(errorColor, { alpha: 0.16 }),
            colorBorderedError: "#0000",
            closeIconColorError: scaleColor(errorColor, { alpha: 0.7 }),
            closeIconColorHoverError: scaleColor(errorColor, { alpha: 0.7 }),
            closeIconColorPressedError: scaleColor(errorColor, { alpha: 0.7 }),
            closeColorHoverError: changeColor(errorColor, { alpha: 0.16 }),
            closeColorPressedError: changeColor(errorColor, { alpha: 0.12 })
          });
        }
      };
      const tagDark$1 = tagDark;
      const self$19 = (vars) => {
        const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, opacityDisabled, tagColor, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, closeColorHover, closeColorPressed, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
        return Object.assign(Object.assign({}, commonVariables$j), {
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
          // checked
          textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
          // default
          border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "rgb(250, 250, 252)",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, { alpha: 0.12 }),
          colorBorderedPrimary: changeColor(primaryColor, { alpha: 0.1 }),
          closeIconColorPrimary: primaryColor,
          closeIconColorHoverPrimary: primaryColor,
          closeIconColorPressedPrimary: primaryColor,
          closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.12 }),
          closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.18 }),
          borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, { alpha: 0.12 }),
          colorBorderedInfo: changeColor(infoColor, { alpha: 0.1 }),
          closeIconColorInfo: infoColor,
          closeIconColorHoverInfo: infoColor,
          closeIconColorPressedInfo: infoColor,
          closeColorHoverInfo: changeColor(infoColor, { alpha: 0.12 }),
          closeColorPressedInfo: changeColor(infoColor, { alpha: 0.18 }),
          borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, { alpha: 0.12 }),
          colorBorderedSuccess: changeColor(successColor, { alpha: 0.1 }),
          closeIconColorSuccess: successColor,
          closeIconColorHoverSuccess: successColor,
          closeIconColorPressedSuccess: successColor,
          closeColorHoverSuccess: changeColor(successColor, { alpha: 0.12 }),
          closeColorPressedSuccess: changeColor(successColor, { alpha: 0.18 }),
          borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.35 })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, { alpha: 0.15 }),
          colorBorderedWarning: changeColor(warningColor, { alpha: 0.12 }),
          closeIconColorWarning: warningColor,
          closeIconColorHoverWarning: warningColor,
          closeIconColorPressedWarning: warningColor,
          closeColorHoverWarning: changeColor(warningColor, { alpha: 0.12 }),
          closeColorPressedWarning: changeColor(warningColor, { alpha: 0.18 }),
          borderError: `1px solid ${changeColor(errorColor, { alpha: 0.23 })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, { alpha: 0.1 }),
          colorBorderedError: changeColor(errorColor, { alpha: 0.08 }),
          closeIconColorError: errorColor,
          closeIconColorHoverError: errorColor,
          closeIconColorPressedError: errorColor,
          closeColorHoverError: changeColor(errorColor, { alpha: 0.12 }),
          closeColorPressedError: changeColor(errorColor, { alpha: 0.18 })
        });
      };
      const tagLight = {
        name: "Tag",
        common: commonLight,
        self: self$19
      };
      const tagLight$1 = tagLight;
      const commonProps = {
        color: Object,
        type: {
          type: String,
          default: "default"
        },
        round: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        closable: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        }
      };
      const style$1p = cB("tag", `
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cE("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), cE("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), cE("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cM("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [cE("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), cE("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), cM("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), cM("icon, avatar", [cM("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), cM("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), cM("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-hover-checkable);", [cNotM("checked", "color: var(--n-text-color-hover-checkable);")]), c$1("&:active", "background-color: var(--n-color-pressed-checkable);", [cNotM("checked", "color: var(--n-text-color-pressed-checkable);")])]), cM("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-checked-hover);"), c$1("&:active", "background-color: var(--n-color-checked-pressed);")])])])]);
      const tagProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), {
        bordered: {
          type: Boolean,
          default: void 0
        },
        checked: Boolean,
        checkable: Boolean,
        strong: Boolean,
        triggerClickOnClose: Boolean,
        onClose: [Array, Function],
        onMouseenter: Function,
        onMouseleave: Function,
        "onUpdate:checked": Function,
        onUpdateChecked: Function,
        // private
        internalCloseFocusable: {
          type: Boolean,
          default: true
        },
        internalCloseIsButtonTag: {
          type: Boolean,
          default: true
        },
        // deprecated
        onCheckedChange: Function
      });
      const tagInjectionKey = createInjectionKey("n-tag");
      const NTag = vue.defineComponent({
        name: "Tag",
        props: tagProps,
        setup(props) {
          const contentRef = vue.ref(null);
          const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Tag", "-tag", style$1p, tagLight$1, props, mergedClsPrefixRef);
          vue.provide(tagInjectionKey, {
            roundRef: vue.toRef(props, "round")
          });
          function handleClick2(e) {
            if (!props.disabled) {
              if (props.checkable) {
                const { checked, onCheckedChange, onUpdateChecked, "onUpdate:checked": _onUpdateChecked } = props;
                if (onUpdateChecked)
                  onUpdateChecked(!checked);
                if (_onUpdateChecked)
                  _onUpdateChecked(!checked);
                if (onCheckedChange)
                  onCheckedChange(!checked);
              }
            }
          }
          function handleCloseClick(e) {
            if (!props.triggerClickOnClose) {
              e.stopPropagation();
            }
            if (!props.disabled) {
              const { onClose } = props;
              if (onClose)
                call(onClose, e);
            }
          }
          const tagPublicMethods = {
            setTextContent(textContent) {
              const { value } = contentRef;
              if (value)
                value.textContent = textContent;
            }
          };
          const rtlEnabledRef = useRtl("Tag", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { type: type2, size: size2, color: { color, textColor } = {} } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { padding, closeMargin, closeMarginRtl, borderRadius, opacityDisabled, textColorCheckable, textColorHoverCheckable, textColorPressedCheckable, textColorChecked, colorCheckable, colorHoverCheckable, colorPressedCheckable, colorChecked, colorCheckedHover, colorCheckedPressed, closeBorderRadius, fontWeightStrong, [createKey("colorBordered", type2)]: colorBordered, [createKey("closeSize", size2)]: closeSize, [createKey("closeIconSize", size2)]: closeIconSize, [createKey("fontSize", size2)]: fontSize2, [createKey("height", size2)]: height, [createKey("color", type2)]: typedColor, [createKey("textColor", type2)]: typeTextColor, [createKey("border", type2)]: border, [createKey("closeIconColor", type2)]: closeIconColor, [createKey("closeIconColorHover", type2)]: closeIconColorHover, [createKey("closeIconColorPressed", type2)]: closeIconColorPressed, [createKey("closeColorHover", type2)]: closeColorHover, [createKey("closeColorPressed", type2)]: closeColorPressed } } = themeRef.value;
            return {
              "--n-font-weight-strong": fontWeightStrong,
              "--n-avatar-size-override": `calc(${height} - 8px)`,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-border": border,
              "--n-close-icon-size": closeIconSize,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-color-hover": closeColorHover,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-icon-color-disabled": closeIconColor,
              "--n-close-margin": closeMargin,
              "--n-close-margin-rtl": closeMarginRtl,
              "--n-close-size": closeSize,
              "--n-color": color || (mergedBorderedRef.value ? colorBordered : typedColor),
              "--n-color-checkable": colorCheckable,
              "--n-color-checked": colorChecked,
              "--n-color-checked-hover": colorCheckedHover,
              "--n-color-checked-pressed": colorCheckedPressed,
              "--n-color-hover-checkable": colorHoverCheckable,
              "--n-color-pressed-checkable": colorPressedCheckable,
              "--n-font-size": fontSize2,
              "--n-height": height,
              "--n-opacity-disabled": opacityDisabled,
              "--n-padding": padding,
              "--n-text-color": textColor || typeTextColor,
              "--n-text-color-checkable": textColorCheckable,
              "--n-text-color-checked": textColorChecked,
              "--n-text-color-hover-checkable": textColorHoverCheckable,
              "--n-text-color-pressed-checkable": textColorPressedCheckable
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("tag", vue.computed(() => {
            let hash = "";
            const { type: type2, size: size2, color: { color, textColor } = {} } = props;
            hash += type2[0];
            hash += size2[0];
            if (color) {
              hash += `a${color2Class(color)}`;
            }
            if (textColor) {
              hash += `b${color2Class(textColor)}`;
            }
            if (mergedBorderedRef.value) {
              hash += "c";
            }
            return hash;
          }), cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, tagPublicMethods), {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            contentRef,
            mergedBordered: mergedBorderedRef,
            handleClick: handleClick2,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a, _b;
          const { mergedClsPrefix, rtlEnabled, closable, color: { borderColor } = {}, round: round2, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const avatarNode = resolveWrappedSlot($slots.avatar, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-tag__avatar` }, children));
          const iconNode = resolveWrappedSlot($slots.icon, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-tag__icon` }, children));
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-tag`,
              this.themeClass,
              {
                [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
                [`${mergedClsPrefix}-tag--strong`]: this.strong,
                [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
                [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
                [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
                [`${mergedClsPrefix}-tag--round`]: round2,
                [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
                [`${mergedClsPrefix}-tag--icon`]: iconNode,
                [`${mergedClsPrefix}-tag--closable`]: closable
              }
            ], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
            iconNode || avatarNode,
            vue.h("span", { class: `${mergedClsPrefix}-tag__content`, ref: "contentRef" }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)),
            !this.checkable && closable ? vue.h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: round2, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null,
            !this.checkable && this.mergedBordered ? vue.h("div", { class: `${mergedClsPrefix}-tag__border`, style: { borderColor } }) : null
          );
        }
      });
      const style$1o = cB("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [c$1(">", [cE("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [c$1("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), c$1("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), cE("placeholder", `
 display: flex;
 `), cE("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
        originalTransform: "translateX(-50%) translateY(-50%)",
        left: "50%",
        top: "50%"
      })])])]);
      const NBaseClear = vue.defineComponent({
        name: "BaseClear",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          show: Boolean,
          onClear: Function
        },
        setup(props) {
          useStyle("-base-clear", style$1o, vue.toRef(props, "clsPrefix"));
          return {
            handleMouseDown(e) {
              e.preventDefault();
            }
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-base-clear` },
            vue.h(NIconSwitchTransition, null, {
              default: () => {
                var _a, _b;
                return this.show ? vue.h("div", { key: "dismiss", class: `${clsPrefix}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, resolveSlot(this.$slots.icon, () => [
                  vue.h(NBaseIcon, { clsPrefix }, {
                    default: () => vue.h(ClearIcon, null)
                  })
                ])) : vue.h("div", { key: "icon", class: `${clsPrefix}-base-clear__placeholder` }, (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
              }
            })
          );
        }
      });
      const NBaseSuffix = vue.defineComponent({
        name: "InternalSelectionSuffix",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          showArrow: {
            type: Boolean,
            default: void 0
          },
          showClear: {
            type: Boolean,
            default: void 0
          },
          loading: {
            type: Boolean,
            default: false
          },
          onClear: Function
        },
        setup(props, { slots }) {
          return () => {
            const { clsPrefix } = props;
            return vue.h(NBaseLoading, { clsPrefix, class: `${clsPrefix}-base-suffix`, strokeWidth: 24, scale: 0.85, show: props.loading }, {
              default: () => props.showArrow ? vue.h(NBaseClear, { clsPrefix, show: props.showClear, onClear: props.onClear }, {
                placeholder: () => vue.h(NBaseIcon, { clsPrefix, class: `${clsPrefix}-base-suffix__arrow` }, {
                  default: () => resolveSlot(slots.default, () => [
                    vue.h(ChevronDownIcon, null)
                  ])
                })
              }) : null
            });
          };
        }
      });
      const commonVars$b = {
        paddingSingle: "0 26px 0 12px",
        paddingMultiple: "3px 26px 0 12px",
        clearSize: "16px",
        arrowSize: "16px"
      };
      const self$18 = (vars) => {
        const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, borderColor, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
        return Object.assign(Object.assign({}, commonVars$b), {
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          // default
          textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: inputColor,
          border: `1px solid ${borderColor}`,
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
          // warning
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
          boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
          colorActiveWarning: inputColor,
          caretColorWarning: warningColor,
          // error
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
          boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
          colorActiveError: inputColor,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        });
      };
      const internalSelectionLight = createTheme({
        name: "InternalSelection",
        common: commonLight,
        peers: {
          Popover: popoverLight$1
        },
        self: self$18
      });
      const internalSelectionLight$1 = internalSelectionLight;
      const internalSelectionDark = {
        name: "InternalSelection",
        common: commonDark,
        peers: {
          Popover: popoverDark$1
        },
        self(vars) {
          const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
          return Object.assign(Object.assign({}, commonVars$b), {
            fontSizeTiny,
            fontSizeSmall,
            fontSizeMedium,
            fontSizeLarge,
            heightTiny,
            heightSmall,
            heightMedium,
            heightLarge,
            borderRadius,
            // default
            textColor: textColor2,
            textColorDisabled,
            placeholderColor,
            placeholderColorDisabled,
            color: inputColor,
            colorDisabled: inputColorDisabled,
            colorActive: changeColor(primaryColor, { alpha: 0.1 }),
            border: "1px solid #0000",
            borderHover: `1px solid ${primaryColorHover}`,
            borderActive: `1px solid ${primaryColor}`,
            borderFocus: `1px solid ${primaryColorHover}`,
            boxShadowHover: "none",
            boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
            boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
            caretColor: primaryColor,
            arrowColor: iconColor,
            arrowColorDisabled: iconColorDisabled,
            loadingColor: primaryColor,
            // warning
            borderWarning: `1px solid ${warningColor}`,
            borderHoverWarning: `1px solid ${warningColorHover}`,
            borderActiveWarning: `1px solid ${warningColor}`,
            borderFocusWarning: `1px solid ${warningColorHover}`,
            boxShadowHoverWarning: "none",
            boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
            boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
            colorActiveWarning: changeColor(warningColor, { alpha: 0.1 }),
            caretColorWarning: warningColor,
            // error
            borderError: `1px solid ${errorColor}`,
            borderHoverError: `1px solid ${errorColorHover}`,
            borderActiveError: `1px solid ${errorColor}`,
            borderFocusError: `1px solid ${errorColorHover}`,
            boxShadowHoverError: "none",
            boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
            boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
            colorActiveError: changeColor(errorColor, { alpha: 0.1 }),
            caretColorError: errorColor,
            clearColor,
            clearColorHover,
            clearColorPressed
          });
        }
      };
      const internalSelectionDark$1 = internalSelectionDark;
      const style$1n = c$1([cB("base-selection", `
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cB("base-loading", `
 color: var(--n-loading-color);
 `), cB("base-selection-tags", "min-height: var(--n-height);"), cE("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cE("state-border", `
 z-index: 1;
 border-color: #0000;
 `), cB("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [cE("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), cB("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [cE("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cB("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [cE("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), cB("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [cB("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [cE("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), cE("render-label", `
 color: var(--n-text-color);
 `)]), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), cB("base-selection-label", "background-color: var(--n-color-active);"), cB("base-selection-tags", "background-color: var(--n-color-active);")])]), cM("disabled", "cursor: not-allowed;", [cE("arrow", `
 color: var(--n-arrow-color-disabled);
 `), cB("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cB("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), cE("render-label", `
 color: var(--n-text-color-disabled);
 `)]), cB("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), cB("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), cB("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [cE("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), cE("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((status) => cM(`${status}-status`, [cE("state-border", `border: var(--n-border-${status});`), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover-${status});
 border: var(--n-border-hover-${status});
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active-${status});
 border: var(--n-border-active-${status});
 `), cB("base-selection-label", `background-color: var(--n-color-active-${status});`), cB("base-selection-tags", `background-color: var(--n-color-active-${status});`)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))]), cB("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), cB("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [c$1("&:last-child", "padding-right: 0;"), cB("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [cE("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]);
      const NInternalSelection = vue.defineComponent({
        name: "InternalSelection",
        props: Object.assign(Object.assign({}, useTheme.props), { clsPrefix: {
          type: String,
          required: true
        }, bordered: {
          type: Boolean,
          default: void 0
        }, active: Boolean, pattern: {
          type: String,
          default: ""
        }, placeholder: String, selectedOption: {
          type: Object,
          default: null
        }, selectedOptions: {
          type: Array,
          default: null
        }, labelField: { type: String, default: "label" }, valueField: {
          type: String,
          default: "value"
        }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: {
          type: String,
          default: "medium"
        }, loading: Boolean, autofocus: Boolean, showArrow: {
          type: Boolean,
          default: true
        }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }),
        setup(props) {
          const patternInputMirrorRef = vue.ref(null);
          const patternInputRef = vue.ref(null);
          const selfRef = vue.ref(null);
          const multipleElRef = vue.ref(null);
          const singleElRef = vue.ref(null);
          const patternInputWrapperRef = vue.ref(null);
          const counterRef = vue.ref(null);
          const counterWrapperRef = vue.ref(null);
          const overflowRef = vue.ref(null);
          const inputTagElRef = vue.ref(null);
          const showTagsPopoverRef = vue.ref(false);
          const patternInputFocusedRef = vue.ref(false);
          const hoverRef = vue.ref(false);
          const themeRef = useTheme("InternalSelection", "-internal-selection", style$1n, internalSelectionLight$1, props, vue.toRef(props, "clsPrefix"));
          const mergedClearableRef = vue.computed(() => {
            return props.clearable && !props.disabled && (hoverRef.value || props.active);
          });
          const filterablePlaceholderRef = vue.computed(() => {
            return props.selectedOption ? props.renderTag ? props.renderTag({
              option: props.selectedOption,
              handleClose: () => {
              }
            }) : props.renderLabel ? props.renderLabel(props.selectedOption, true) : render$1(props.selectedOption[props.labelField], props.selectedOption, true) : props.placeholder;
          });
          const labelRef = vue.computed(() => {
            const option = props.selectedOption;
            if (!option)
              return void 0;
            return option[props.labelField];
          });
          const selectedRef = vue.computed(() => {
            if (props.multiple) {
              return !!(Array.isArray(props.selectedOptions) && props.selectedOptions.length);
            } else {
              return props.selectedOption !== null;
            }
          });
          function syncMirrorWidth() {
            var _a;
            const { value: patternInputMirrorEl } = patternInputMirrorRef;
            if (patternInputMirrorEl) {
              const { value: patternInputEl } = patternInputRef;
              if (patternInputEl) {
                patternInputEl.style.width = `${patternInputMirrorEl.offsetWidth}px`;
                if (props.maxTagCount !== "responsive") {
                  (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync();
                }
              }
            }
          }
          function hideInputTag() {
            const { value: inputTagEl } = inputTagElRef;
            if (inputTagEl)
              inputTagEl.style.display = "none";
          }
          function showInputTag() {
            const { value: inputTagEl } = inputTagElRef;
            if (inputTagEl)
              inputTagEl.style.display = "inline-block";
          }
          vue.watch(vue.toRef(props, "active"), (value) => {
            if (!value)
              hideInputTag();
          });
          vue.watch(vue.toRef(props, "pattern"), () => {
            if (props.multiple) {
              void vue.nextTick(syncMirrorWidth);
            }
          });
          function doFocus(e) {
            const { onFocus } = props;
            if (onFocus)
              onFocus(e);
          }
          function doBlur(e) {
            const { onBlur } = props;
            if (onBlur)
              onBlur(e);
          }
          function doDeleteOption(value) {
            const { onDeleteOption } = props;
            if (onDeleteOption)
              onDeleteOption(value);
          }
          function doClear(e) {
            const { onClear } = props;
            if (onClear)
              onClear(e);
          }
          function doPatternInput(value) {
            const { onPatternInput } = props;
            if (onPatternInput)
              onPatternInput(value);
          }
          function handleFocusin(e) {
            var _a;
            if (!e.relatedTarget || !((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
              doFocus(e);
            }
          }
          function handleFocusout(e) {
            var _a;
            if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
              return;
            doBlur(e);
          }
          function handleClear(e) {
            doClear(e);
          }
          function handleMouseEnter() {
            hoverRef.value = true;
          }
          function handleMouseLeave() {
            hoverRef.value = false;
          }
          function handleMouseDown(e) {
            if (!props.active || !props.filterable)
              return;
            if (e.target === patternInputRef.value)
              return;
            e.preventDefault();
          }
          function handleDeleteOption(option) {
            doDeleteOption(option);
          }
          function handlePatternKeyDown(e) {
            if (e.key === "Backspace" && !isComposingRef2.value) {
              if (!props.pattern.length) {
                const { selectedOptions } = props;
                if (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) {
                  handleDeleteOption(selectedOptions[selectedOptions.length - 1]);
                }
              }
            }
          }
          const isComposingRef2 = vue.ref(false);
          let cachedInputEvent = null;
          function handlePatternInputInput(e) {
            const { value: patternInputMirrorEl } = patternInputMirrorRef;
            if (patternInputMirrorEl) {
              const inputText = e.target.value;
              patternInputMirrorEl.textContent = inputText;
              syncMirrorWidth();
            }
            if (props.ignoreComposition) {
              if (!isComposingRef2.value) {
                doPatternInput(e);
              } else {
                cachedInputEvent = e;
              }
            } else {
              doPatternInput(e);
            }
          }
          function handleCompositionStart() {
            isComposingRef2.value = true;
          }
          function handleCompositionEnd() {
            isComposingRef2.value = false;
            if (props.ignoreComposition) {
              doPatternInput(cachedInputEvent);
            }
            cachedInputEvent = null;
          }
          function handlePatternInputFocus(e) {
            var _a;
            patternInputFocusedRef.value = true;
            (_a = props.onPatternFocus) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handlePatternInputBlur(e) {
            var _a;
            patternInputFocusedRef.value = false;
            (_a = props.onPatternBlur) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function blur() {
            var _a, _b;
            if (props.filterable) {
              patternInputFocusedRef.value = false;
              (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              (_b = patternInputRef.value) === null || _b === void 0 ? void 0 : _b.blur();
            } else if (props.multiple) {
              const { value: multipleEl } = multipleElRef;
              multipleEl === null || multipleEl === void 0 ? void 0 : multipleEl.blur();
            } else {
              const { value: singleEl } = singleElRef;
              singleEl === null || singleEl === void 0 ? void 0 : singleEl.blur();
            }
          }
          function focus() {
            var _a, _b, _c;
            if (props.filterable) {
              patternInputFocusedRef.value = false;
              (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            } else if (props.multiple) {
              (_b = multipleElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
            } else {
              (_c = singleElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
            }
          }
          function focusInput() {
            const { value: patternInputEl } = patternInputRef;
            if (patternInputEl) {
              showInputTag();
              patternInputEl.focus();
            }
          }
          function blurInput() {
            const { value: patternInputEl } = patternInputRef;
            if (patternInputEl) {
              patternInputEl.blur();
            }
          }
          function updateCounter(count) {
            const { value } = counterRef;
            if (value) {
              value.setTextContent(`+${count}`);
            }
          }
          function getCounter() {
            const { value } = counterWrapperRef;
            return value;
          }
          function getTail() {
            return patternInputRef.value;
          }
          let enterTimerId = null;
          function clearEnterTimer() {
            if (enterTimerId !== null)
              window.clearTimeout(enterTimerId);
          }
          function handleMouseEnterCounter() {
            if (props.disabled || props.active)
              return;
            clearEnterTimer();
            enterTimerId = window.setTimeout(() => {
              if (selectedRef.value) {
                showTagsPopoverRef.value = true;
              }
            }, 100);
          }
          function handleMouseLeaveCounter() {
            clearEnterTimer();
          }
          function onPopoverUpdateShow(show) {
            if (!show) {
              clearEnterTimer();
              showTagsPopoverRef.value = false;
            }
          }
          vue.watch(selectedRef, (value) => {
            if (!value) {
              showTagsPopoverRef.value = false;
            }
          });
          vue.onMounted(() => {
            vue.watchEffect(() => {
              const patternInputWrapperEl = patternInputWrapperRef.value;
              if (!patternInputWrapperEl)
                return;
              patternInputWrapperEl.tabIndex = props.disabled || patternInputFocusedRef.value ? -1 : 0;
            });
          });
          useOnResize(selfRef, props.onResize);
          const { inlineThemeDisabled } = props;
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: {
              borderRadius,
              color,
              placeholderColor,
              textColor,
              paddingSingle,
              paddingMultiple,
              caretColor,
              colorDisabled,
              textColorDisabled,
              placeholderColorDisabled,
              colorActive,
              boxShadowFocus,
              boxShadowActive,
              boxShadowHover,
              border,
              borderFocus,
              borderHover,
              borderActive,
              arrowColor,
              arrowColorDisabled,
              loadingColor,
              // form warning
              colorActiveWarning,
              boxShadowFocusWarning,
              boxShadowActiveWarning,
              boxShadowHoverWarning,
              borderWarning,
              borderFocusWarning,
              borderHoverWarning,
              borderActiveWarning,
              // form error
              colorActiveError,
              boxShadowFocusError,
              boxShadowActiveError,
              boxShadowHoverError,
              borderError,
              borderFocusError,
              borderHoverError,
              borderActiveError,
              // clear
              clearColor,
              clearColorHover,
              clearColorPressed,
              clearSize,
              // arrow
              arrowSize: arrowSize2,
              [createKey("height", size2)]: height,
              [createKey("fontSize", size2)]: fontSize2
            } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border": border,
              "--n-border-active": borderActive,
              "--n-border-focus": borderFocus,
              "--n-border-hover": borderHover,
              "--n-border-radius": borderRadius,
              "--n-box-shadow-active": boxShadowActive,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-box-shadow-hover": boxShadowHover,
              "--n-caret-color": caretColor,
              "--n-color": color,
              "--n-color-active": colorActive,
              "--n-color-disabled": colorDisabled,
              "--n-font-size": fontSize2,
              "--n-height": height,
              "--n-padding-single": paddingSingle,
              "--n-padding-multiple": paddingMultiple,
              "--n-placeholder-color": placeholderColor,
              "--n-placeholder-color-disabled": placeholderColorDisabled,
              "--n-text-color": textColor,
              "--n-text-color-disabled": textColorDisabled,
              "--n-arrow-color": arrowColor,
              "--n-arrow-color-disabled": arrowColorDisabled,
              "--n-loading-color": loadingColor,
              // form warning
              "--n-color-active-warning": colorActiveWarning,
              "--n-box-shadow-focus-warning": boxShadowFocusWarning,
              "--n-box-shadow-active-warning": boxShadowActiveWarning,
              "--n-box-shadow-hover-warning": boxShadowHoverWarning,
              "--n-border-warning": borderWarning,
              "--n-border-focus-warning": borderFocusWarning,
              "--n-border-hover-warning": borderHoverWarning,
              "--n-border-active-warning": borderActiveWarning,
              // form error
              "--n-color-active-error": colorActiveError,
              "--n-box-shadow-focus-error": boxShadowFocusError,
              "--n-box-shadow-active-error": boxShadowActiveError,
              "--n-box-shadow-hover-error": boxShadowHoverError,
              "--n-border-error": borderError,
              "--n-border-focus-error": borderFocusError,
              "--n-border-hover-error": borderHoverError,
              "--n-border-active-error": borderActiveError,
              // clear
              "--n-clear-size": clearSize,
              "--n-clear-color": clearColor,
              "--n-clear-color-hover": clearColorHover,
              "--n-clear-color-pressed": clearColorPressed,
              // arrow-size
              "--n-arrow-size": arrowSize2
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-selection", vue.computed(() => {
            return props.size[0];
          }), cssVarsRef, props) : void 0;
          return {
            mergedTheme: themeRef,
            mergedClearable: mergedClearableRef,
            patternInputFocused: patternInputFocusedRef,
            filterablePlaceholder: filterablePlaceholderRef,
            label: labelRef,
            selected: selectedRef,
            showTagsPanel: showTagsPopoverRef,
            isComposing: isComposingRef2,
            // dom ref
            counterRef,
            counterWrapperRef,
            patternInputMirrorRef,
            patternInputRef,
            selfRef,
            multipleElRef,
            singleElRef,
            patternInputWrapperRef,
            overflowRef,
            inputTagElRef,
            handleMouseDown,
            handleFocusin,
            handleClear,
            handleMouseEnter,
            handleMouseLeave,
            handleDeleteOption,
            handlePatternKeyDown,
            handlePatternInputInput,
            handlePatternInputBlur,
            handlePatternInputFocus,
            handleMouseEnterCounter,
            handleMouseLeaveCounter,
            handleFocusout,
            handleCompositionEnd,
            handleCompositionStart,
            onPopoverUpdateShow,
            focus,
            focusInput,
            blur,
            blurInput,
            updateCounter,
            getCounter,
            getTail,
            renderLabel: props.renderLabel,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { status, multiple, size: size2, disabled, filterable, maxTagCount, bordered, clsPrefix, onRender, renderTag, renderLabel } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const maxTagCountResponsive = maxTagCount === "responsive";
          const maxTagCountNumeric = typeof maxTagCount === "number";
          const useMaxTagCount = maxTagCountResponsive || maxTagCountNumeric;
          const suffix2 = vue.h(Wrapper, null, {
            default: () => vue.h(NBaseSuffix, { clsPrefix, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, {
              default: () => {
                var _a, _b;
                return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a);
              }
            })
          });
          let body;
          if (multiple) {
            const { labelField } = this;
            const createTag = (option) => vue.h("div", { class: `${clsPrefix}-base-selection-tag-wrapper`, key: option.value }, renderTag ? renderTag({
              option,
              handleClose: () => {
                this.handleDeleteOption(option);
              }
            }) : vue.h(NTag, { size: size2, closable: !option.disabled, disabled, onClose: () => {
              this.handleDeleteOption(option);
            }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, {
              default: () => renderLabel ? renderLabel(option, true) : render$1(option[labelField], option, true)
            }));
            const createOriginalTagNodes = () => (maxTagCountNumeric ? this.selectedOptions.slice(0, maxTagCount) : this.selectedOptions).map(createTag);
            const input = filterable ? vue.h(
              "div",
              { class: `${clsPrefix}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" },
              vue.h("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled, value: this.pattern, autofocus: this.autofocus, class: `${clsPrefix}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })),
              vue.h("span", { ref: "patternInputMirrorRef", class: `${clsPrefix}-base-selection-input-tag__mirror` }, this.pattern)
            ) : null;
            const renderCounter = maxTagCountResponsive ? () => vue.h(
              "div",
              { class: `${clsPrefix}-base-selection-tag-wrapper`, ref: "counterWrapperRef" },
              vue.h(NTag, { size: size2, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled })
            ) : void 0;
            let counter;
            if (maxTagCountNumeric) {
              const rest = this.selectedOptions.length - maxTagCount;
              if (rest > 0) {
                counter = vue.h(
                  "div",
                  { class: `${clsPrefix}-base-selection-tag-wrapper`, key: "__counter__" },
                  vue.h(NTag, { size: size2, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled }, {
                    default: () => `+${rest}`
                  })
                );
              }
            }
            const tags = maxTagCountResponsive ? filterable ? vue.h(VOverflow, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: {
              width: "100%",
              display: "flex",
              overflow: "hidden"
            } }, {
              default: createOriginalTagNodes,
              counter: renderCounter,
              tail: () => input
            }) : vue.h(VOverflow, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: {
              width: "100%",
              display: "flex",
              overflow: "hidden"
            } }, {
              default: createOriginalTagNodes,
              counter: renderCounter
            }) : maxTagCountNumeric ? createOriginalTagNodes().concat(counter) : createOriginalTagNodes();
            const renderPopover = useMaxTagCount ? () => vue.h("div", { class: `${clsPrefix}-base-selection-popover` }, maxTagCountResponsive ? createOriginalTagNodes() : this.selectedOptions.map(createTag)) : void 0;
            const popoverProps2 = useMaxTagCount ? {
              show: this.showTagsPanel,
              trigger: "hover",
              overlap: true,
              placement: "top",
              width: "trigger",
              onUpdateShow: this.onPopoverUpdateShow,
              theme: this.mergedTheme.peers.Popover,
              themeOverrides: this.mergedTheme.peerOverrides.Popover
            } : null;
            const showPlaceholder = this.selected ? false : this.active ? !this.pattern && !this.isComposing : true;
            const placeholder = showPlaceholder ? vue.h(
              "div",
              { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay` },
              vue.h("div", { class: `${clsPrefix}-base-selection-placeholder__inner` }, this.placeholder)
            ) : null;
            const popoverTrigger = filterable ? vue.h(
              "div",
              { ref: "patternInputWrapperRef", class: `${clsPrefix}-base-selection-tags` },
              tags,
              maxTagCountResponsive ? null : input,
              suffix2
            ) : vue.h(
              "div",
              { ref: "multipleElRef", class: `${clsPrefix}-base-selection-tags`, tabindex: disabled ? void 0 : 0 },
              tags,
              suffix2
            );
            body = vue.h(
              vue.Fragment,
              null,
              useMaxTagCount ? vue.h(NPopover, Object.assign({}, popoverProps2, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), {
                trigger: () => popoverTrigger,
                default: renderPopover
              }) : popoverTrigger,
              placeholder
            );
          } else {
            if (filterable) {
              const hasInput = this.pattern || this.isComposing;
              const showPlaceholder = this.active ? !hasInput : !this.selected;
              const showSelectedLabel = this.active ? false : this.selected;
              body = vue.h(
                "div",
                { ref: "patternInputWrapperRef", class: `${clsPrefix}-base-selection-label` },
                vue.h("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${clsPrefix}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: disabled, disabled, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })),
                showSelectedLabel ? vue.h(
                  "div",
                  { class: `${clsPrefix}-base-selection-label__render-label ${clsPrefix}-base-selection-overlay`, key: "input" },
                  vue.h("div", { class: `${clsPrefix}-base-selection-overlay__wrapper` }, renderTag ? renderTag({
                    option: this.selectedOption,
                    handleClose: () => {
                    }
                  }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))
                ) : null,
                showPlaceholder ? vue.h(
                  "div",
                  { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`, key: "placeholder" },
                  vue.h("div", { class: `${clsPrefix}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)
                ) : null,
                suffix2
              );
            } else {
              body = vue.h(
                "div",
                { ref: "singleElRef", class: `${clsPrefix}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 },
                this.label !== void 0 ? vue.h(
                  "div",
                  { class: `${clsPrefix}-base-selection-input`, title: getTitleAttribute(this.label), key: "input" },
                  vue.h("div", { class: `${clsPrefix}-base-selection-input__content` }, renderTag ? renderTag({
                    option: this.selectedOption,
                    handleClose: () => {
                    }
                  }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))
                ) : vue.h(
                  "div",
                  { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`, key: "placeholder" },
                  vue.h("div", { class: `${clsPrefix}-base-selection-placeholder__inner` }, this.placeholder)
                ),
                suffix2
              );
            }
          }
          return vue.h(
            "div",
            { ref: "selfRef", class: [
              `${clsPrefix}-base-selection`,
              this.themeClass,
              status && `${clsPrefix}-base-selection--${status}-status`,
              {
                [`${clsPrefix}-base-selection--active`]: this.active,
                [`${clsPrefix}-base-selection--selected`]: this.selected || this.active && this.pattern,
                [`${clsPrefix}-base-selection--disabled`]: this.disabled,
                [`${clsPrefix}-base-selection--multiple`]: this.multiple,
                // focus is not controlled by selection itself since it always need
                // to be managed together with menu. provide :focus style will cause
                // many redundant codes.
                [`${clsPrefix}-base-selection--focus`]: this.focused
              }
            ], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown },
            body,
            bordered ? vue.h("div", { class: `${clsPrefix}-base-selection__border` }) : null,
            bordered ? vue.h("div", { class: `${clsPrefix}-base-selection__state-border` }) : null
          );
        }
      });
      const SlotMachineNumber = vue.defineComponent({
        name: "SlotMachineNumber",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          value: {
            // could be '+', 1, 2, ...
            type: [Number, String],
            required: true
          },
          oldOriginalNumber: {
            type: Number,
            default: void 0
          },
          newOriginalNumber: {
            type: Number,
            default: void 0
          }
        },
        setup(props) {
          const numberRef = vue.ref(null);
          const oldNumberRef = vue.ref(props.value);
          const newNumberRef = vue.ref(props.value);
          const scrollAnimationDirectionRef = vue.ref("up");
          const activeRef = vue.ref(false);
          const newNumberScrollAnimationClassRef = vue.computed(() => {
            return activeRef.value ? `${props.clsPrefix}-base-slot-machine-current-number--${scrollAnimationDirectionRef.value}-scroll` : null;
          });
          const oldNumberScrollAnimationClassRef = vue.computed(() => {
            return activeRef.value ? `${props.clsPrefix}-base-slot-machine-old-number--${scrollAnimationDirectionRef.value}-scroll` : null;
          });
          vue.watch(vue.toRef(props, "value"), (value, oldValue) => {
            oldNumberRef.value = oldValue;
            newNumberRef.value = value;
            void vue.nextTick(scroll);
          });
          function scroll() {
            const newOriginalNumber = props.newOriginalNumber;
            const oldOriginalNumber = props.oldOriginalNumber;
            if (oldOriginalNumber === void 0 || newOriginalNumber === void 0) {
              return;
            }
            if (newOriginalNumber > oldOriginalNumber) {
              scrollByDir("up");
            } else if (oldOriginalNumber > newOriginalNumber) {
              scrollByDir("down");
            }
          }
          function scrollByDir(dir) {
            scrollAnimationDirectionRef.value = dir;
            activeRef.value = false;
            void vue.nextTick(() => {
              var _a;
              void ((_a = numberRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
              activeRef.value = true;
            });
          }
          return () => {
            const { clsPrefix } = props;
            return vue.h(
              "span",
              { ref: numberRef, class: `${clsPrefix}-base-slot-machine-number` },
              oldNumberRef.value !== null ? vue.h("span", { class: [
                `${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--top`,
                oldNumberScrollAnimationClassRef.value
              ] }, oldNumberRef.value) : null,
              vue.h(
                "span",
                { class: [
                  `${clsPrefix}-base-slot-machine-current-number`,
                  newNumberScrollAnimationClassRef.value
                ] },
                vue.h("span", { ref: "numberWrapper", class: [
                  `${clsPrefix}-base-slot-machine-current-number__inner`,
                  typeof props.value !== "number" && `${clsPrefix}-base-slot-machine-current-number__inner--not-number`
                ] }, newNumberRef.value)
              ),
              oldNumberRef.value !== null ? vue.h("span", { class: [
                `${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--bottom`,
                oldNumberScrollAnimationClassRef.value
              ] }, oldNumberRef.value) : null
            );
          };
        }
      });
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$2
      } = commonVariables$m;
      function fadeInWidthExpandTransition({
        duration = ".2s",
        delay = ".1s"
      } = {}) {
        return [c$1("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
          opacity: 1
        }), c$1("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c$1("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$2},
 max-width ${duration} ${cubicBezierEaseInOut$2} ${delay},
 margin-left ${duration} ${cubicBezierEaseInOut$2} ${delay},
 margin-right ${duration} ${cubicBezierEaseInOut$2} ${delay};
 `), c$1("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$2} ${delay},
 max-width ${duration} ${cubicBezierEaseInOut$2},
 margin-left ${duration} ${cubicBezierEaseInOut$2},
 margin-right ${duration} ${cubicBezierEaseInOut$2};
 `)];
      }
      const {
        cubicBezierEaseOut: cubicBezierEaseOut$5
      } = commonVariables$m;
      function fadeUpWidthExpandTransition({
        duration = ".2s"
      } = {}) {
        return [c$1("&.fade-up-width-expand-transition-leave-active", {
          transition: `
 opacity ${duration} ${cubicBezierEaseOut$5},
 max-width ${duration} ${cubicBezierEaseOut$5},
 transform ${duration} ${cubicBezierEaseOut$5}
 `
        }), c$1("&.fade-up-width-expand-transition-enter-active", {
          transition: `
 opacity ${duration} ${cubicBezierEaseOut$5},
 max-width ${duration} ${cubicBezierEaseOut$5},
 transform ${duration} ${cubicBezierEaseOut$5}
 `
        }), c$1("&.fade-up-width-expand-transition-enter-to", {
          opacity: 1,
          transform: "translateX(0) translateY(0)"
        }), c$1("&.fade-up-width-expand-transition-enter-from", {
          maxWidth: "0 !important",
          opacity: 0,
          transform: "translateY(60%)"
        }), c$1("&.fade-up-width-expand-transition-leave-from", {
          opacity: 1,
          transform: "translateY(0)"
        }), c$1("&.fade-up-width-expand-transition-leave-to", {
          maxWidth: "0 !important",
          opacity: 0,
          transform: "translateY(60%)"
        })];
      }
      const style$1m = c$1([c$1("@keyframes n-base-slot-machine-fade-up-in", `
 from {
 transform: translateY(60%);
 opacity: 0;
 }
 to {
 transform: translateY(0);
 opacity: 1;
 }
 `), c$1("@keyframes n-base-slot-machine-fade-down-in", `
 from {
 transform: translateY(-60%);
 opacity: 0;
 }
 to {
 transform: translateY(0);
 opacity: 1;
 }
 `), c$1("@keyframes n-base-slot-machine-fade-up-out", `
 from {
 transform: translateY(0%);
 opacity: 1;
 }
 to {
 transform: translateY(-60%);
 opacity: 0;
 }
 `), c$1("@keyframes n-base-slot-machine-fade-down-out", `
 from {
 transform: translateY(0%);
 opacity: 1;
 }
 to {
 transform: translateY(60%);
 opacity: 0;
 }
 `), cB("base-slot-machine", `
 overflow: hidden;
 white-space: nowrap;
 display: inline-block;
 height: 18px;
 line-height: 18px;
 `, [cB("base-slot-machine-number", `
 display: inline-block;
 position: relative;
 height: 18px;
 width: .6em;
 max-width: .6em;
 `, [
        fadeUpWidthExpandTransition({
          duration: ".2s"
        }),
        // use 0s, not 0
        fadeInWidthExpandTransition({
          duration: ".2s",
          delay: "0s"
        }),
        cB("base-slot-machine-old-number", `
 display: inline-block;
 opacity: 0;
 position: absolute;
 left: 0;
 right: 0;
 `, [cM("top", {
          transform: "translateY(-100%)"
        }), cM("bottom", {
          transform: "translateY(100%)"
        }), cM("down-scroll", {
          animation: "n-base-slot-machine-fade-down-out .2s cubic-bezier(0, 0, .2, 1)",
          animationIterationCount: 1
        }), cM("up-scroll", {
          animation: "n-base-slot-machine-fade-up-out .2s cubic-bezier(0, 0, .2, 1)",
          animationIterationCount: 1
        })]),
        cB("base-slot-machine-current-number", `
 display: inline-block;
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 1;
 transform: translateY(0);
 width: .6em;
 `, [cM("down-scroll", {
          animation: "n-base-slot-machine-fade-down-in .2s cubic-bezier(0, 0, .2, 1)",
          animationIterationCount: 1
        }), cM("up-scroll", {
          animation: "n-base-slot-machine-fade-up-in .2s cubic-bezier(0, 0, .2, 1)",
          animationIterationCount: 1
        }), cE("inner", `
 display: inline-block;
 position: absolute;
 right: 0;
 top: 0;
 width: .6em;
 `, [cM("not-number", `
 right: unset;
 left: 0;
 `)])])
      ])])]);
      const NBaseSlotMachine = vue.defineComponent({
        name: "BaseSlotMachine",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          value: {
            type: [Number, String],
            default: 0
          },
          max: {
            type: Number,
            default: void 0
          },
          appeared: {
            type: Boolean,
            required: true
          }
        },
        setup(props) {
          useStyle("-base-slot-machine", style$1m, vue.toRef(props, "clsPrefix"));
          const oldValueRef = vue.ref();
          const newValueRef = vue.ref();
          const numbersRef = vue.computed(() => {
            if (typeof props.value === "string")
              return [];
            if (props.value < 1)
              return [0];
            const numbers = [];
            let value = props.value;
            if (props.max !== void 0) {
              value = Math.min(props.max, value);
            }
            while (value >= 1) {
              numbers.push(value % 10);
              value /= 10;
              value = Math.floor(value);
            }
            numbers.reverse();
            return numbers;
          });
          vue.watch(vue.toRef(props, "value"), (value, oldValue) => {
            if (typeof value === "string") {
              newValueRef.value = void 0;
              oldValueRef.value = void 0;
            } else {
              if (typeof oldValue === "string") {
                newValueRef.value = value;
                oldValueRef.value = void 0;
              } else {
                newValueRef.value = value;
                oldValueRef.value = oldValue;
              }
            }
          });
          return () => {
            const { value, clsPrefix } = props;
            return typeof value === "number" ? vue.h(
              "span",
              { class: `${clsPrefix}-base-slot-machine` },
              vue.h(vue.TransitionGroup, { name: "fade-up-width-expand-transition", tag: "span" }, {
                default: () => numbersRef.value.map((number2, i) => vue.h(SlotMachineNumber, { clsPrefix, key: numbersRef.value.length - i - 1, oldOriginalNumber: oldValueRef.value, newOriginalNumber: newValueRef.value, value: number2 }))
              }),
              vue.h(NFadeInExpandTransition, { key: "+", width: true }, {
                default: () => props.max !== void 0 && props.max < value ? vue.h(SlotMachineNumber, { clsPrefix, value: "+" }) : null
              })
            ) : vue.h("span", { class: `${clsPrefix}-base-slot-machine` }, value);
          };
        }
      });
      const commonVars$a = {
        iconMargin: "11px 8px 0 12px",
        iconMarginRtl: "11px 12px 0 8px",
        iconSize: "24px",
        closeIconSize: "16px",
        closeSize: "20px",
        closeMargin: "13px 14px 0 0",
        closeMarginRtl: "13px 0 0 14px",
        padding: "13px"
      };
      const alertDark = {
        name: "Alert",
        common: commonDark,
        self(vars) {
          const { lineHeight: lineHeight2, borderRadius, fontWeightStrong, dividerColor, inputColor, textColor1, textColor2, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColorSuppl, successColorSuppl, warningColorSuppl, errorColorSuppl, fontSize: fontSize2 } = vars;
          return Object.assign(Object.assign({}, commonVars$a), {
            fontSize: fontSize2,
            lineHeight: lineHeight2,
            titleFontWeight: fontWeightStrong,
            borderRadius,
            border: `1px solid ${dividerColor}`,
            color: inputColor,
            titleTextColor: textColor1,
            iconColor: textColor2,
            contentTextColor: textColor2,
            closeBorderRadius: borderRadius,
            closeColorHover,
            closeColorPressed,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            borderInfo: `1px solid ${changeColor(infoColorSuppl, { alpha: 0.35 })}`,
            colorInfo: changeColor(infoColorSuppl, { alpha: 0.25 }),
            titleTextColorInfo: textColor1,
            iconColorInfo: infoColorSuppl,
            contentTextColorInfo: textColor2,
            closeColorHoverInfo: closeColorHover,
            closeColorPressedInfo: closeColorPressed,
            closeIconColorInfo: closeIconColor,
            closeIconColorHoverInfo: closeIconColorHover,
            closeIconColorPressedInfo: closeIconColorPressed,
            borderSuccess: `1px solid ${changeColor(successColorSuppl, {
            alpha: 0.35
          })}`,
            colorSuccess: changeColor(successColorSuppl, { alpha: 0.25 }),
            titleTextColorSuccess: textColor1,
            iconColorSuccess: successColorSuppl,
            contentTextColorSuccess: textColor2,
            closeColorHoverSuccess: closeColorHover,
            closeColorPressedSuccess: closeColorPressed,
            closeIconColorSuccess: closeIconColor,
            closeIconColorHoverSuccess: closeIconColorHover,
            closeIconColorPressedSuccess: closeIconColorPressed,
            borderWarning: `1px solid ${changeColor(warningColorSuppl, {
            alpha: 0.35
          })}`,
            colorWarning: changeColor(warningColorSuppl, { alpha: 0.25 }),
            titleTextColorWarning: textColor1,
            iconColorWarning: warningColorSuppl,
            contentTextColorWarning: textColor2,
            closeColorHoverWarning: closeColorHover,
            closeColorPressedWarning: closeColorPressed,
            closeIconColorWarning: closeIconColor,
            closeIconColorHoverWarning: closeIconColorHover,
            closeIconColorPressedWarning: closeIconColorPressed,
            borderError: `1px solid ${changeColor(errorColorSuppl, { alpha: 0.35 })}`,
            colorError: changeColor(errorColorSuppl, { alpha: 0.25 }),
            titleTextColorError: textColor1,
            iconColorError: errorColorSuppl,
            contentTextColorError: textColor2,
            closeColorHoverError: closeColorHover,
            closeColorPressedError: closeColorPressed,
            closeIconColorError: closeIconColor,
            closeIconColorHoverError: closeIconColorHover,
            closeIconColorPressedError: closeIconColorPressed
          });
        }
      };
      const alertDark$1 = alertDark;
      const self$17 = (vars) => {
        const { lineHeight: lineHeight2, borderRadius, fontWeightStrong, baseColor, dividerColor, actionColor, textColor1, textColor2, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, warningColor, errorColor, fontSize: fontSize2 } = vars;
        return Object.assign(Object.assign({}, commonVars$a), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          titleFontWeight: fontWeightStrong,
          borderRadius,
          border: `1px solid ${dividerColor}`,
          color: actionColor,
          titleTextColor: textColor1,
          iconColor: textColor2,
          contentTextColor: textColor2,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderInfo: `1px solid ${composite(baseColor, changeColor(infoColor, { alpha: 0.25 }))}`,
          colorInfo: composite(baseColor, changeColor(infoColor, { alpha: 0.08 })),
          titleTextColorInfo: textColor1,
          iconColorInfo: infoColor,
          contentTextColorInfo: textColor2,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          borderSuccess: `1px solid ${composite(baseColor, changeColor(successColor, { alpha: 0.25 }))}`,
          colorSuccess: composite(baseColor, changeColor(successColor, { alpha: 0.08 })),
          titleTextColorSuccess: textColor1,
          iconColorSuccess: successColor,
          contentTextColorSuccess: textColor2,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          borderWarning: `1px solid ${composite(baseColor, changeColor(warningColor, { alpha: 0.33 }))}`,
          colorWarning: composite(baseColor, changeColor(warningColor, { alpha: 0.08 })),
          titleTextColorWarning: textColor1,
          iconColorWarning: warningColor,
          contentTextColorWarning: textColor2,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          borderError: `1px solid ${composite(baseColor, changeColor(errorColor, { alpha: 0.25 }))}`,
          colorError: composite(baseColor, changeColor(errorColor, { alpha: 0.08 })),
          titleTextColorError: textColor1,
          iconColorError: errorColor,
          contentTextColorError: textColor2,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed
        });
      };
      const alertLight = {
        name: "Alert",
        common: commonLight,
        self: self$17
      };
      const alertLight$1 = alertLight;
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$1,
        cubicBezierEaseOut: cubicBezierEaseOut$4,
        cubicBezierEaseIn: cubicBezierEaseIn$4
      } = commonVariables$m;
      function fadeInHeightExpandTransition({
        overflow = "hidden",
        duration = ".3s",
        originalTransition = "",
        leavingDelay = "0s",
        foldPadding = false,
        enterToProps = void 0,
        leaveToProps = void 0,
        reverse = false
      } = {}) {
        const enterClass = reverse ? "leave" : "enter";
        const leaveClass = reverse ? "enter" : "leave";
        return [c$1(`&.fade-in-height-expand-transition-${leaveClass}-from,
 &.fade-in-height-expand-transition-${enterClass}-to`, Object.assign(Object.assign({}, enterToProps), {
          opacity: 1
        })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-to,
 &.fade-in-height-expand-transition-${enterClass}-from`, Object.assign(Object.assign({}, leaveToProps), {
          opacity: 0,
          marginTop: "0 !important",
          marginBottom: "0 !important",
          paddingTop: foldPadding ? "0 !important" : void 0,
          paddingBottom: foldPadding ? "0 !important" : void 0
        })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 opacity ${duration} ${cubicBezierEaseOut$4} ${leavingDelay},
 margin-top ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 margin-bottom ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-top ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-bottom ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay}
 ${originalTransition ? "," + originalTransition : ""}
 `), c$1(`&.fade-in-height-expand-transition-${enterClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration} ${cubicBezierEaseInOut$1},
 opacity ${duration} ${cubicBezierEaseIn$4},
 margin-top ${duration} ${cubicBezierEaseInOut$1},
 margin-bottom ${duration} ${cubicBezierEaseInOut$1},
 padding-top ${duration} ${cubicBezierEaseInOut$1},
 padding-bottom ${duration} ${cubicBezierEaseInOut$1}
 ${originalTransition ? "," + originalTransition : ""}
 `)];
      }
      const style$1l = cB("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [cE("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), cM("closable", [cB("alert-body", [cE("title", `
 padding-right: 24px;
 `)])]), cE("icon", {
        color: "var(--n-icon-color)"
      }), cB("alert-body", {
        padding: "var(--n-padding)"
      }, [cE("title", {
        color: "var(--n-title-text-color)"
      }), cE("content", {
        color: "var(--n-content-text-color)"
      })]), fadeInHeightExpandTransition({
        originalTransition: "transform .3s var(--n-bezier)",
        enterToProps: {
          transform: "scale(1)"
        },
        leaveToProps: {
          transform: "scale(0.9)"
        }
      }), cE("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), cE("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), cM("show-icon", [cB("alert-body", {
        paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))"
      })]), cB("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [cE("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [c$1("& +", [cE("content", {
        marginTop: "9px"
      })])]), cE("content", {
        transition: "color .3s var(--n-bezier)",
        fontSize: "var(--n-font-size)"
      })]), cE("icon", {
        transition: "color .3s var(--n-bezier)"
      })]);
      const alertProps = Object.assign(Object.assign({}, useTheme.props), {
        title: String,
        showIcon: {
          type: Boolean,
          default: true
        },
        type: {
          type: String,
          default: "default"
        },
        bordered: {
          type: Boolean,
          default: true
        },
        closable: Boolean,
        onClose: Function,
        onAfterLeave: Function,
        /** @deprecated */
        onAfterHide: Function
      });
      const Alert = vue.defineComponent({
        name: "Alert",
        inheritAttrs: false,
        props: alertProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Alert", "-alert", style$1l, alertLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Alert", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const { fontSize: fontSize2, borderRadius, titleFontWeight, lineHeight: lineHeight2, iconSize, iconMargin, iconMarginRtl, closeIconSize, closeBorderRadius, closeSize, closeMargin, closeMarginRtl, padding } = self2;
            const { type: type2 } = props;
            const { left, right } = getMargin(iconMargin);
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": self2[createKey("color", type2)],
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-color-hover": self2[createKey("closeColorHover", type2)],
              "--n-close-color-pressed": self2[createKey("closeColorPressed", type2)],
              "--n-close-icon-color": self2[createKey("closeIconColor", type2)],
              "--n-close-icon-color-hover": self2[createKey("closeIconColorHover", type2)],
              "--n-close-icon-color-pressed": self2[createKey("closeIconColorPressed", type2)],
              "--n-icon-color": self2[createKey("iconColor", type2)],
              "--n-border": self2[createKey("border", type2)],
              "--n-title-text-color": self2[createKey("titleTextColor", type2)],
              "--n-content-text-color": self2[createKey("contentTextColor", type2)],
              "--n-line-height": lineHeight2,
              "--n-border-radius": borderRadius,
              "--n-font-size": fontSize2,
              "--n-title-font-weight": titleFontWeight,
              "--n-icon-size": iconSize,
              "--n-icon-margin": iconMargin,
              "--n-icon-margin-rtl": iconMarginRtl,
              "--n-close-size": closeSize,
              "--n-close-margin": closeMargin,
              "--n-close-margin-rtl": closeMarginRtl,
              "--n-padding": padding,
              "--n-icon-margin-left": left,
              "--n-icon-margin-right": right
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("alert", vue.computed(() => {
            return props.type[0];
          }), cssVarsRef, props) : void 0;
          const visibleRef = vue.ref(true);
          const doAfterLeave = () => {
            const {
              onAfterLeave,
              onAfterHide
              // deprecated
            } = props;
            if (onAfterLeave)
              onAfterLeave();
            if (onAfterHide)
              onAfterHide();
          };
          const handleCloseClick = () => {
            var _a;
            void Promise.resolve((_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props)).then((result) => {
              if (result === false)
                return;
              visibleRef.value = false;
            });
          };
          const handleAfterLeave = () => {
            doAfterLeave();
          };
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            visible: visibleRef,
            handleCloseClick,
            handleAfterLeave,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(NFadeInExpandTransition, { onAfterLeave: this.handleAfterLeave }, {
            default: () => {
              const { mergedClsPrefix, $slots } = this;
              const attrs = {
                class: [
                  `${mergedClsPrefix}-alert`,
                  this.themeClass,
                  this.closable && `${mergedClsPrefix}-alert--closable`,
                  this.showIcon && `${mergedClsPrefix}-alert--show-icon`,
                  this.rtlEnabled && `${mergedClsPrefix}-alert--rtl`
                ],
                style: this.cssVars,
                role: "alert"
              };
              return this.visible ? vue.h(
                "div",
                Object.assign({}, vue.mergeProps(this.$attrs, attrs)),
                this.closable && vue.h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-alert__close`, onClick: this.handleCloseClick }),
                this.bordered && vue.h("div", { class: `${mergedClsPrefix}-alert__border` }),
                this.showIcon && vue.h("div", { class: `${mergedClsPrefix}-alert__icon`, "aria-hidden": "true" }, resolveSlot($slots.icon, () => [
                  vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                    default: () => {
                      switch (this.type) {
                        case "success":
                          return vue.h(SuccessIcon, null);
                        case "info":
                          return vue.h(InfoIcon, null);
                        case "warning":
                          return vue.h(WarningIcon, null);
                        case "error":
                          return vue.h(ErrorIcon, null);
                        default:
                          return null;
                      }
                    }
                  })
                ])),
                vue.h(
                  "div",
                  { class: [
                    `${mergedClsPrefix}-alert-body`,
                    this.mergedBordered && `${mergedClsPrefix}-alert-body--bordered`
                  ] },
                  resolveWrappedSlot($slots.header, (children) => {
                    const mergedChildren = children || this.title;
                    return mergedChildren ? vue.h("div", { class: `${mergedClsPrefix}-alert-body__title` }, mergedChildren) : null;
                  }),
                  $slots.default && vue.h("div", { class: `${mergedClsPrefix}-alert-body__content` }, $slots)
                )
              ) : null;
            }
          });
        }
      });
      const commonVars$9 = {
        linkFontSize: "13px",
        linkPadding: "0 0 0 16px",
        railWidth: "4px"
      };
      const self$16 = (vars) => {
        const { borderRadius, railColor, primaryColor, primaryColorHover, primaryColorPressed, textColor2 } = vars;
        return Object.assign(Object.assign({}, commonVars$9), {
          borderRadius,
          railColor,
          railColorActive: primaryColor,
          linkColor: changeColor(primaryColor, { alpha: 0.15 }),
          linkTextColor: textColor2,
          linkTextColorHover: primaryColorHover,
          linkTextColorPressed: primaryColorPressed,
          linkTextColorActive: primaryColor
        });
      };
      const anchorLight = {
        name: "Anchor",
        common: commonLight,
        self: self$16
      };
      const anchorLight$1 = anchorLight;
      const anchorDark = {
        name: "Anchor",
        common: commonDark,
        self: self$16
      };
      const anchorDark$1 = anchorDark;
      const style$1k = cB("anchor", `
 position: relative;
`, [cNotM("block", `
 padding-left: var(--n-rail-width);
 `, [cB("anchor-link", [c$1("+, >", [cB("anchor-link", `
 margin-top: .5em;
 `)])]), cB("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), cNotM("show-rail", [c$1(">", [cB("anchor-link", "padding-left: 0;")])])]), cM("block", [cB("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [cM("active", `
 background-color: var(--n-link-color);
 `)])]), cB("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cM("active", {
        backgroundColor: "var(--n-rail-color-active)"
      })])]), cB("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [cM("active", [c$1(">", [cE("title", `
 color: var(--n-link-text-color-active);
 `)])]), cE("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [c$1("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), c$1("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]);
      const anchorInjectionKey = createInjectionKey("n-anchor");
      const anchorLinkProps = {
        title: String,
        href: String
      };
      const Link = vue.defineComponent({
        name: "AnchorLink",
        props: anchorLinkProps,
        setup(props, { slots }) {
          const titleRef = vue.ref(null);
          const NAnchor = vue.inject(anchorInjectionKey);
          const hrefRef = vue.toRef(props, "href");
          const activeRef = useMemo(() => {
            return hrefRef.value && hrefRef.value === NAnchor.activeHref.value;
          });
          useInjectionCollection(anchorInjectionKey, "collectedLinkHrefs", hrefRef);
          useInjectionElementCollection(anchorInjectionKey, "titleEls", () => titleRef.value);
          vue.watch(activeRef, (value) => {
            if (value && titleRef.value) {
              NAnchor.updateBarPosition(titleRef.value);
            }
          });
          function handleClick2() {
            if (props.href !== void 0) {
              NAnchor.setActiveHref(props.href);
            }
          }
          return () => {
            var _a;
            const { value: mergedClsPrefix } = NAnchor.mergedClsPrefix;
            return vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-anchor-link`,
                activeRef.value && `${mergedClsPrefix}-anchor-link--active`
              ] },
              vue.h("a", { ref: titleRef, class: [`${mergedClsPrefix}-anchor-link__title`], href: props.href, title: getTitleAttribute(props.title), onClick: handleClick2 }, props.title),
              (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)
            );
          };
        }
      });
      function getOffset(el, scrollTarget) {
        const { top: elTop, height } = el.getBoundingClientRect();
        const scrollTargetTop = scrollTarget instanceof HTMLElement ? scrollTarget.getBoundingClientRect().top : 0;
        return {
          top: elTop - scrollTargetTop,
          height
        };
      }
      const baseAnchorProps = {
        type: {
          type: String,
          default: "rail"
        },
        showRail: {
          type: Boolean,
          default: true
        },
        showBackground: {
          type: Boolean,
          default: true
        },
        bound: {
          type: Number,
          default: 12
        },
        internalScrollable: Boolean,
        ignoreGap: Boolean,
        offsetTarget: [String, Object, Function]
      };
      const baseAnchorPropKeys = keysOf(baseAnchorProps);
      const NBaseAnchor = vue.defineComponent({
        name: "BaseAnchor",
        props: Object.assign(Object.assign({}, baseAnchorProps), { mergedClsPrefix: {
          type: String,
          required: true
        } }),
        setup(props) {
          const collectedLinkHrefs = [];
          const titleEls = [];
          const activeHrefRef = vue.ref(null);
          const slotRef = vue.ref(null);
          const barRef = vue.ref(null);
          const selfRef = vue.ref(null);
          const isBlockTypeRef = vue.computed(() => {
            return props.type === "block";
          });
          const mergedShowRailRef = vue.computed(() => {
            return !isBlockTypeRef.value && props.showRail;
          });
          function disableTransitionOneTick() {
            const { value: barEl } = barRef;
            const { value: slotEl } = slotRef;
            if (barEl) {
              barEl.style.transition = "none";
            }
            if (slotEl) {
              slotEl.style.transition = "none";
            }
            if (titleEls) {
              titleEls.forEach((titleEl) => {
                titleEl.style.transition = "none";
              });
            }
            void vue.nextTick(() => {
              const { value: nextBarEl } = barRef;
              const { value: nextSlotEl } = slotRef;
              if (nextBarEl) {
                void nextBarEl.offsetWidth;
                nextBarEl.style.transition = "";
              }
              if (nextSlotEl) {
                void nextSlotEl.offsetWidth;
                nextSlotEl.style.transition = "";
              }
              if (titleEls) {
                titleEls.forEach((titleEl) => {
                  void titleEl.offsetWidth;
                  titleEl.style.transition = "";
                });
              }
            });
          }
          function updateBarPosition(linkTitleEl, transition = true) {
            const { value: barEl } = barRef;
            const { value: slotEl } = slotRef;
            const { value: selfEl } = selfRef;
            if (!selfEl || !barEl)
              return;
            if (!transition) {
              barEl.style.transition = "none";
              if (slotEl)
                slotEl.style.transition = "none";
            }
            const { offsetHeight, offsetWidth } = linkTitleEl;
            const { top: linkTitleClientTop, left: linkTitleClientLeft } = linkTitleEl.getBoundingClientRect();
            const { top: anchorClientTop, left: anchorClientLeft } = selfEl.getBoundingClientRect();
            const offsetTop = linkTitleClientTop - anchorClientTop;
            const offsetLeft = linkTitleClientLeft - anchorClientLeft;
            barEl.style.top = `${offsetTop}px`;
            barEl.style.height = `${offsetHeight}px`;
            if (slotEl) {
              slotEl.style.top = `${offsetTop}px`;
              slotEl.style.height = `${offsetHeight}px`;
              slotEl.style.maxWidth = `${offsetWidth + offsetLeft}px`;
            }
            void barEl.offsetHeight;
            if (slotEl)
              void slotEl.offsetHeight;
            if (!transition) {
              barEl.style.transition = "";
              if (slotEl)
                slotEl.style.transition = "";
            }
          }
          function setActiveHref(href, transition = true) {
            const idMatchResult = /^#([^#]+)$/.exec(href);
            if (!idMatchResult)
              return;
            const linkEl = document.getElementById(idMatchResult[1]);
            if (!linkEl)
              return;
            activeHrefRef.value = href;
            linkEl.scrollIntoView();
            if (!transition) {
              disableTransitionOneTick();
            }
            handleScroll();
          }
          const handleScroll = throttle(() => {
            _handleScroll(true);
          }, 128);
          function _handleScroll(transition = true) {
            var _a;
            const links = [];
            const offsetTarget = unwrapElement((_a = props.offsetTarget) !== null && _a !== void 0 ? _a : document);
            collectedLinkHrefs.forEach((href) => {
              const idMatchResult = /#([^#]+)$/.exec(href);
              if (!idMatchResult)
                return;
              const linkEl = document.getElementById(idMatchResult[1]);
              if (linkEl && offsetTarget) {
                const { top, height } = getOffset(linkEl, offsetTarget);
                links.push({
                  top,
                  height,
                  href
                });
              }
            });
            links.sort((a2, b) => {
              if (a2.top > b.top) {
                return 1;
              } else if (a2.top === b.top && a2.height < b.height) {
                return -1;
              }
              return -1;
            });
            const currentActiveHref = activeHrefRef.value;
            const { bound, ignoreGap } = props;
            const activeLink = links.reduce((prevLink, link) => {
              if (link.top + link.height < 0) {
                if (ignoreGap) {
                  return link;
                } else {
                  return prevLink;
                }
              }
              if (link.top <= bound) {
                if (prevLink === null) {
                  return link;
                } else if (link.top === prevLink.top) {
                  if (link.href === currentActiveHref) {
                    return link;
                  } else
                    return prevLink;
                } else if (link.top > prevLink.top) {
                  return link;
                } else {
                  return prevLink;
                }
              }
              return prevLink;
            }, null);
            if (!transition)
              disableTransitionOneTick();
            if (activeLink) {
              activeHrefRef.value = activeLink.href;
            } else {
              activeHrefRef.value = null;
            }
          }
          vue.provide(anchorInjectionKey, {
            activeHref: activeHrefRef,
            mergedClsPrefix: vue.toRef(props, "mergedClsPrefix"),
            updateBarPosition,
            setActiveHref,
            collectedLinkHrefs,
            titleEls
          });
          vue.onMounted(() => {
            document.addEventListener("scroll", handleScroll, true);
            setActiveHref(window.location.hash);
            _handleScroll(false);
          });
          onFontsReady(() => {
            setActiveHref(window.location.hash);
            _handleScroll(false);
          });
          vue.onBeforeUnmount(() => {
            document.removeEventListener("scroll", handleScroll, true);
          });
          vue.watch(activeHrefRef, (value) => {
            if (value === null) {
              const { value: slotEl } = slotRef;
              if (slotEl && !isBlockTypeRef.value) {
                slotEl.style.maxWidth = "0";
              }
            }
          });
          return {
            selfRef,
            barRef,
            slotRef,
            setActiveHref,
            activeHref: activeHrefRef,
            isBlockType: isBlockTypeRef,
            mergedShowRail: mergedShowRailRef
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix, mergedShowRail, isBlockType, $slots } = this;
          const Anchor = vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-anchor`,
              isBlockType && `${mergedClsPrefix}-anchor--block`,
              mergedShowRail && `${mergedClsPrefix}-anchor--show-rail`
            ], ref: "selfRef" },
            mergedShowRail && this.showBackground ? vue.h("div", { ref: "slotRef", class: `${mergedClsPrefix}-anchor-link-background` }) : null,
            mergedShowRail ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-anchor-rail` },
              vue.h("div", { ref: "barRef", class: [
                `${mergedClsPrefix}-anchor-rail__bar`,
                this.activeHref !== null && `${mergedClsPrefix}-anchor-rail__bar--active`
              ] })
            ) : null,
            (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots)
          );
          return this.internalScrollable ? vue.h(NScrollbar, null, {
            default: () => Anchor
          }) : Anchor;
        }
      });
      const anchorProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { affix: Boolean }), affixProps), baseAnchorProps);
      const AnchorAdapter = vue.defineComponent({
        name: "Anchor",
        props: anchorProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Anchor", "-anchor", style$1k, anchorLight$1, props, mergedClsPrefixRef);
          const anchorRef = vue.ref(null);
          const cssVarsRef = vue.computed(() => {
            const { self: { railColor, linkColor, railColorActive, linkTextColor, linkTextColorHover, linkTextColorPressed, linkTextColorActive, linkFontSize, railWidth, linkPadding, borderRadius }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-link-border-radius": borderRadius,
              "--n-link-color": linkColor,
              "--n-link-font-size": linkFontSize,
              "--n-link-text-color": linkTextColor,
              "--n-link-text-color-hover": linkTextColorHover,
              "--n-link-text-color-active": linkTextColorActive,
              "--n-link-text-color-pressed": linkTextColorPressed,
              "--n-link-padding": linkPadding,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-rail-color": railColor,
              "--n-rail-color-active": railColorActive,
              "--n-rail-width": railWidth
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("anchor", void 0, cssVarsRef, props) : void 0;
          return {
            scrollTo(href) {
              var _a;
              (_a = anchorRef.value) === null || _a === void 0 ? void 0 : _a.setActiveHref(href);
            },
            renderAnchor: () => {
              themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
              return vue.h(NBaseAnchor, Object.assign({ ref: anchorRef, style: inlineThemeDisabled ? void 0 : cssVarsRef.value, class: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value }, keep(props, baseAnchorPropKeys), { mergedClsPrefix: mergedClsPrefixRef.value }), slots);
            }
          };
        },
        render() {
          return !this.affix ? this.renderAnchor() : vue.h(NAffix, Object.assign({}, keep(this, affixPropKeys)), { default: this.renderAnchor });
        }
      });
      function getIsGroup(option) {
        return option.type === "group";
      }
      function getIgnored(option) {
        return option.type === "ignored";
      }
      function patternMatched(pattern2, value) {
        try {
          return !!(1 + value.toString().toLowerCase().indexOf(pattern2.trim().toLowerCase()));
        } catch (err) {
          return false;
        }
      }
      function createTmOptions(valueField, childrenField) {
        const options = {
          getIsGroup,
          getIgnored,
          getKey(option) {
            if (getIsGroup(option)) {
              return option.name || option.key || "key-required";
            }
            return option[valueField];
          },
          getChildren(option) {
            return option[childrenField];
          }
        };
        return options;
      }
      function filterOptions(originalOpts, filter, pattern2, childrenField) {
        if (!filter)
          return originalOpts;
        function traverse2(options) {
          if (!Array.isArray(options))
            return [];
          const filteredOptions = [];
          for (const option of options) {
            if (getIsGroup(option)) {
              const children = traverse2(option[childrenField]);
              if (children.length) {
                filteredOptions.push(Object.assign({}, option, {
                  [childrenField]: children
                }));
              }
            } else if (getIgnored(option)) {
              continue;
            } else if (filter(pattern2, option)) {
              filteredOptions.push(option);
            }
          }
          return filteredOptions;
        }
        return traverse2(originalOpts);
      }
      function createValOptMap(options, valueField, childrenField) {
        const valOptMap = /* @__PURE__ */ new Map();
        options.forEach((option) => {
          if (getIsGroup(option)) {
            option[childrenField].forEach((selectGroupOption) => {
              valOptMap.set(selectGroupOption[valueField], selectGroupOption);
            });
          } else {
            valOptMap.set(option[valueField], option);
          }
        });
        return valOptMap;
      }
      const isChrome = isBrowser$2 && "chrome" in window;
      isBrowser$2 && navigator.userAgent.includes("Firefox");
      const isSafari = isBrowser$2 && navigator.userAgent.includes("Safari") && !isChrome;
      const commonVariables$i = {
        paddingTiny: "0 8px",
        paddingSmall: "0 10px",
        paddingMedium: "0 12px",
        paddingLarge: "0 14px",
        clearSize: "16px"
      };
      const inputDark = {
        name: "Input",
        common: commonDark,
        self(vars) {
          const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight: lineHeight2, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
          return Object.assign(Object.assign({}, commonVariables$i), {
            countTextColorDisabled: textColorDisabled,
            countTextColor: textColor3,
            heightTiny,
            heightSmall,
            heightMedium,
            heightLarge,
            fontSizeTiny,
            fontSizeSmall,
            fontSizeMedium,
            fontSizeLarge,
            lineHeight: lineHeight2,
            lineHeightTextarea: lineHeight2,
            borderRadius,
            iconSize: "16px",
            groupLabelColor: inputColor,
            textColor: textColor2,
            textColorDisabled,
            textDecorationColor: textColor2,
            groupLabelTextColor: textColor2,
            caretColor: primaryColor,
            placeholderColor,
            placeholderColorDisabled,
            color: inputColor,
            colorDisabled: inputColorDisabled,
            colorFocus: changeColor(primaryColor, { alpha: 0.1 }),
            groupLabelBorder: "1px solid #0000",
            border: "1px solid #0000",
            borderHover: `1px solid ${primaryColorHover}`,
            borderDisabled: "1px solid #0000",
            borderFocus: `1px solid ${primaryColorHover}`,
            boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, { alpha: 0.3 })}`,
            loadingColor: primaryColor,
            // warning
            loadingColorWarning: warningColor,
            borderWarning: `1px solid ${warningColor}`,
            borderHoverWarning: `1px solid ${warningColorHover}`,
            colorFocusWarning: changeColor(warningColor, { alpha: 0.1 }),
            borderFocusWarning: `1px solid ${warningColorHover}`,
            boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
            caretColorWarning: warningColor,
            // error
            loadingColorError: errorColor,
            borderError: `1px solid ${errorColor}`,
            borderHoverError: `1px solid ${errorColorHover}`,
            colorFocusError: changeColor(errorColor, { alpha: 0.1 }),
            borderFocusError: `1px solid ${errorColorHover}`,
            boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
            caretColorError: errorColor,
            clearColor,
            clearColorHover,
            clearColorPressed,
            iconColor,
            iconColorDisabled,
            iconColorHover,
            iconColorPressed,
            suffixTextColor: textColor2
          });
        }
      };
      const inputDark$1 = inputDark;
      const self$15 = (vars) => {
        const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, borderColor, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight: lineHeight2, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, actionColor, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$i), {
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          lineHeightTextarea: lineHeight2,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: actionColor,
          groupLabelTextColor: textColor2,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: inputColor,
          groupLabelBorder: `1px solid ${borderColor}`,
          border: `1px solid ${borderColor}`,
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: `1px solid ${borderColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
          loadingColor: primaryColor,
          // warning
          loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: inputColor,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
          caretColorWarning: warningColor,
          // error
          loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: inputColor,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        });
      };
      const inputLight = {
        name: "Input",
        common: commonLight,
        self: self$15
      };
      const inputLight$1 = inputLight;
      const inputInjectionKey = createInjectionKey("n-input");
      function len(s) {
        let count = 0;
        for (const _ of s) {
          count++;
        }
        return count;
      }
      function isEmptyInputValue(value) {
        return value === "" || value == null;
      }
      function useCursor(inputElRef) {
        const selectionRef = vue.ref(null);
        function recordCursor() {
          const { value: input } = inputElRef;
          if (!(input === null || input === void 0 ? void 0 : input.focus)) {
            reset();
            return;
          }
          const { selectionStart, selectionEnd, value } = input;
          if (selectionStart == null || selectionEnd == null) {
            reset();
            return;
          }
          selectionRef.value = {
            start: selectionStart,
            end: selectionEnd,
            beforeText: value.slice(0, selectionStart),
            afterText: value.slice(selectionEnd)
          };
        }
        function restoreCursor() {
          var _a;
          const { value: selection } = selectionRef;
          const { value: inputEl } = inputElRef;
          if (!selection || !inputEl) {
            return;
          }
          const { value } = inputEl;
          const { start, beforeText, afterText } = selection;
          let startPos = value.length;
          if (value.endsWith(afterText)) {
            startPos = value.length - afterText.length;
          } else if (value.startsWith(beforeText)) {
            startPos = beforeText.length;
          } else {
            const beforeLastChar = beforeText[start - 1];
            const newIndex = value.indexOf(beforeLastChar, start - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          (_a = inputEl.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(inputEl, startPos, startPos);
        }
        function reset() {
          selectionRef.value = null;
        }
        vue.watch(inputElRef, reset);
        return {
          recordCursor,
          restoreCursor
        };
      }
      const WordCount = vue.defineComponent({
        name: "InputWordCount",
        setup(_, { slots }) {
          const { mergedValueRef, maxlengthRef, mergedClsPrefixRef, countGraphemesRef } = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            vue.inject(inputInjectionKey)
          );
          const wordCountRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (mergedValue === null || Array.isArray(mergedValue))
              return 0;
            return (countGraphemesRef.value || len)(mergedValue);
          });
          return () => {
            const { value: maxlength } = maxlengthRef;
            const { value: mergedValue } = mergedValueRef;
            return vue.h("span", { class: `${mergedClsPrefixRef.value}-input-word-count` }, resolveSlotWithProps(slots.default, {
              value: mergedValue === null || Array.isArray(mergedValue) ? "" : mergedValue
            }, () => [
              maxlength === void 0 ? wordCountRef.value : `${wordCountRef.value} / ${maxlength}`
            ]));
          };
        }
      });
      const style$1j = cB("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [
        // common
        cE("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `),
        cE("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `),
        cE("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), c$1("&:-webkit-autofill ~", [cE("placeholder", "display: none;")])]),
        cM("round", [cNotM("textarea", "border-radius: calc(var(--n-height) / 2);")]),
        cE("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [c$1("span", `
 width: 100%;
 display: inline-block;
 `)]),
        cM("textarea", [cE("placeholder", "overflow: visible;")]),
        cNotM("autosize", "width: 100%;"),
        cM("autosize", [cE("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]),
        // input
        cB("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `),
        cE("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `),
        cE("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [c$1("+", [cE("placeholder", `
 display: flex;
 align-items: center; 
 `)])]),
        cNotM("textarea", [cE("placeholder", "white-space: nowrap;")]),
        cE("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `),
        // textarea
        cM("textarea", "width: 100%;", [cB("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), cM("resizable", [cB("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), cE("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 `), cE("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]),
        // pair
        cM("pair", [cE("input-el, placeholder", "text-align: center;"), cE("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)])]),
        cM("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cE("border", "border: var(--n-border-disabled);"), cE("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), cE("placeholder", "color: var(--n-placeholder-color-disabled);"), cE("separator", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), cB("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), cE("suffix, prefix", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]),
        cNotM("disabled", [cE("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [c$1("&:hover", `
 color: var(--n-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), c$1("&:hover", [cE("state-border", "border: var(--n-border-hover);")]), cM("focus", "background-color: var(--n-color-focus);", [cE("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]),
        cE("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `),
        cE("state-border", `
 border-color: #0000;
 z-index: 1;
 `),
        cE("prefix", "margin-right: 4px;"),
        cE("suffix", `
 margin-left: 4px;
 `),
        cE("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [cB("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), cB("base-clear", `
 font-size: var(--n-icon-size);
 `, [cE("placeholder", [cB("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), c$1(">", [cB("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("base-icon", `
 font-size: var(--n-icon-size);
 `)]),
        cB("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `),
        ["warning", "error"].map((status) => cM(`${status}-status`, [cNotM("disabled", [cB("base-loading", `
 color: var(--n-loading-color-${status})
 `), cE("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${status});
 `), cE("state-border", `
 border: var(--n-border-${status});
 `), c$1("&:hover", [cE("state-border", `
 border: var(--n-border-hover-${status});
 `)]), c$1("&:focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)]), cM("focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))
      ]);
      const safariStyle = cB("input", [cM("disabled", [cE("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
      const inputProps = Object.assign(Object.assign({}, useTheme.props), {
        bordered: {
          type: Boolean,
          default: void 0
        },
        type: {
          type: String,
          default: "text"
        },
        placeholder: [Array, String],
        defaultValue: {
          type: [String, Array],
          default: null
        },
        value: [String, Array],
        disabled: {
          type: Boolean,
          default: void 0
        },
        size: String,
        rows: {
          type: [Number, String],
          default: 3
        },
        round: Boolean,
        minlength: [String, Number],
        maxlength: [String, Number],
        clearable: Boolean,
        autosize: {
          type: [Boolean, Object],
          default: false
        },
        pair: Boolean,
        separator: String,
        readonly: {
          type: [String, Boolean],
          default: false
        },
        passivelyActivated: Boolean,
        showPasswordOn: String,
        stateful: {
          type: Boolean,
          default: true
        },
        autofocus: Boolean,
        inputProps: Object,
        resizable: {
          type: Boolean,
          default: true
        },
        showCount: Boolean,
        loading: {
          type: Boolean,
          default: void 0
        },
        allowInput: Function,
        renderCount: Function,
        onMousedown: Function,
        onKeydown: Function,
        onKeyup: Function,
        onInput: [Function, Array],
        onFocus: [Function, Array],
        onBlur: [Function, Array],
        onClick: [Function, Array],
        onChange: [Function, Array],
        onClear: [Function, Array],
        countGraphemes: Function,
        status: String,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        /** private */
        textDecoration: [String, Array],
        attrSize: {
          type: Number,
          default: 20
        },
        onInputBlur: [Function, Array],
        onInputFocus: [Function, Array],
        onDeactivate: [Function, Array],
        onActivate: [Function, Array],
        onWrapperFocus: [Function, Array],
        onWrapperBlur: [Function, Array],
        internalDeactivateOnEnter: Boolean,
        internalForceFocus: Boolean,
        internalLoadingBeforeSuffix: Boolean,
        /** deprecated */
        showPasswordToggle: Boolean
      });
      const NInput = vue.defineComponent({
        name: "Input",
        props: inputProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Input", "-input", style$1j, inputLight$1, props, mergedClsPrefixRef);
          if (isSafari) {
            useStyle("-input-safari", safariStyle, mergedClsPrefixRef);
          }
          const wrapperElRef = vue.ref(null);
          const textareaElRef = vue.ref(null);
          const textareaMirrorElRef = vue.ref(null);
          const inputMirrorElRef = vue.ref(null);
          const inputElRef = vue.ref(null);
          const inputEl2Ref = vue.ref(null);
          const currentFocusedInputRef = vue.ref(null);
          const focusedInputCursorControl = useCursor(currentFocusedInputRef);
          const textareaScrollbarInstRef = vue.ref(null);
          const { localeRef } = useLocale("Input");
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const focusedRef = vue.ref(false);
          const hoverRef = vue.ref(false);
          const isComposingRef2 = vue.ref(false);
          const activatedRef = vue.ref(false);
          let syncSource = null;
          const mergedPlaceholderRef = vue.computed(() => {
            const { placeholder, pair } = props;
            if (pair) {
              if (Array.isArray(placeholder)) {
                return placeholder;
              } else if (placeholder === void 0) {
                return ["", ""];
              }
              return [placeholder, placeholder];
            } else if (placeholder === void 0) {
              return [localeRef.value.placeholder];
            } else {
              return [placeholder];
            }
          });
          const showPlaceholder1Ref = vue.computed(() => {
            const { value: isComposing } = isComposingRef2;
            const { value: mergedValue } = mergedValueRef;
            const { value: mergedPlaceholder } = mergedPlaceholderRef;
            return !isComposing && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0])) && mergedPlaceholder[0];
          });
          const showPlaceholder2Ref = vue.computed(() => {
            const { value: isComposing } = isComposingRef2;
            const { value: mergedValue } = mergedValueRef;
            const { value: mergedPlaceholder } = mergedPlaceholderRef;
            return !isComposing && mergedPlaceholder[1] && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]));
          });
          const mergedFocusRef = useMemo(() => {
            return props.internalForceFocus || focusedRef.value;
          });
          const showClearButton = useMemo(() => {
            if (mergedDisabledRef.value || props.readonly || !props.clearable || !mergedFocusRef.value && !hoverRef.value) {
              return false;
            }
            const { value: mergedValue } = mergedValueRef;
            const { value: mergedFocus } = mergedFocusRef;
            if (props.pair) {
              return !!(Array.isArray(mergedValue) && (mergedValue[0] || mergedValue[1])) && (hoverRef.value || mergedFocus);
            } else {
              return !!mergedValue && (hoverRef.value || mergedFocus);
            }
          });
          const mergedShowPasswordOnRef = vue.computed(() => {
            const { showPasswordOn } = props;
            if (showPasswordOn) {
              return showPasswordOn;
            }
            if (props.showPasswordToggle)
              return "click";
            return void 0;
          });
          const passwordVisibleRef = vue.ref(false);
          const textDecorationStyleRef = vue.computed(() => {
            const { textDecoration } = props;
            if (!textDecoration)
              return ["", ""];
            if (Array.isArray(textDecoration)) {
              return textDecoration.map((v) => ({
                textDecoration: v
              }));
            }
            return [
              {
                textDecoration
              }
            ];
          });
          const textAreaScrollContainerWidthRef = vue.ref(void 0);
          const updateTextAreaStyle = () => {
            var _a, _b;
            if (props.type === "textarea") {
              const { autosize } = props;
              if (autosize) {
                textAreaScrollContainerWidthRef.value = (_b = (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) === null || _b === void 0 ? void 0 : _b.offsetWidth;
              }
              if (!textareaElRef.value)
                return;
              if (typeof autosize === "boolean")
                return;
              const { paddingTop: stylePaddingTop, paddingBottom: stylePaddingBottom, lineHeight: styleLineHeight } = window.getComputedStyle(textareaElRef.value);
              const paddingTop = Number(stylePaddingTop.slice(0, -2));
              const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
              const lineHeight2 = Number(styleLineHeight.slice(0, -2));
              const { value: textareaMirrorEl } = textareaMirrorElRef;
              if (!textareaMirrorEl)
                return;
              if (autosize.minRows) {
                const minRows = Math.max(autosize.minRows, 1);
                const styleMinHeight = `${paddingTop + paddingBottom + lineHeight2 * minRows}px`;
                textareaMirrorEl.style.minHeight = styleMinHeight;
              }
              if (autosize.maxRows) {
                const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight2 * autosize.maxRows}px`;
                textareaMirrorEl.style.maxHeight = styleMaxHeight;
              }
            }
          };
          const maxlengthRef = vue.computed(() => {
            const { maxlength } = props;
            return maxlength === void 0 ? void 0 : Number(maxlength);
          });
          vue.onMounted(() => {
            const { value } = mergedValueRef;
            if (!Array.isArray(value)) {
              syncMirror(value);
            }
          });
          const vm = vue.getCurrentInstance().proxy;
          function doUpdateValue(value) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue, onInput } = props;
            const { nTriggerFormInput } = formItem;
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            if (onInput)
              call(onInput, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
          }
          function doChange(value) {
            const { onChange } = props;
            const { nTriggerFormChange } = formItem;
            if (onChange)
              call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
          }
          function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
          }
          function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
          }
          function doClear(e) {
            const { onClear } = props;
            if (onClear)
              call(onClear, e);
          }
          function doUpdateValueBlur(e) {
            const { onInputBlur } = props;
            if (onInputBlur)
              call(onInputBlur, e);
          }
          function doUpdateValueFocus(e) {
            const { onInputFocus } = props;
            if (onInputFocus)
              call(onInputFocus, e);
          }
          function doDeactivate() {
            const { onDeactivate } = props;
            if (onDeactivate)
              call(onDeactivate);
          }
          function doActivate() {
            const { onActivate } = props;
            if (onActivate)
              call(onActivate);
          }
          function doClick(e) {
            const { onClick } = props;
            if (onClick)
              call(onClick, e);
          }
          function doWrapperFocus(e) {
            const { onWrapperFocus } = props;
            if (onWrapperFocus)
              call(onWrapperFocus, e);
          }
          function doWrapperBlur(e) {
            const { onWrapperBlur } = props;
            if (onWrapperBlur)
              call(onWrapperBlur, e);
          }
          function handleCompositionStart() {
            isComposingRef2.value = true;
          }
          function handleCompositionEnd(e) {
            isComposingRef2.value = false;
            if (e.target === inputEl2Ref.value) {
              handleInput(e, 1);
            } else {
              handleInput(e, 0);
            }
          }
          function handleInput(e, index = 0, event = "input") {
            const targetValue = e.target.value;
            syncMirror(targetValue);
            if (e instanceof InputEvent && !e.isComposing) {
              isComposingRef2.value = false;
            }
            if (props.type === "textarea") {
              const { value: textareaScrollbarInst } = textareaScrollbarInstRef;
              if (textareaScrollbarInst) {
                textareaScrollbarInst.syncUnifiedContainer();
              }
            }
            syncSource = targetValue;
            if (isComposingRef2.value)
              return;
            focusedInputCursorControl.recordCursor();
            const isIncomingValueValid = allowInput(targetValue);
            if (isIncomingValueValid) {
              if (!props.pair) {
                event === "input" ? doUpdateValue(targetValue) : doChange(targetValue);
              } else {
                let { value } = mergedValueRef;
                if (!Array.isArray(value)) {
                  value = ["", ""];
                } else {
                  value = [value[0], value[1]];
                }
                value[index] = targetValue;
                event === "input" ? doUpdateValue(value) : doChange(value);
              }
            }
            vm.$forceUpdate();
            if (!isIncomingValueValid) {
              void vue.nextTick(focusedInputCursorControl.restoreCursor);
            }
          }
          function allowInput(value) {
            const { countGraphemes, maxlength, minlength } = props;
            if (countGraphemes) {
              let graphemesCount;
              if (maxlength !== void 0) {
                if (graphemesCount === void 0) {
                  graphemesCount = countGraphemes(value);
                }
                if (graphemesCount > Number(maxlength))
                  return false;
              }
              if (minlength !== void 0) {
                if (graphemesCount === void 0) {
                  graphemesCount = countGraphemes(value);
                }
                if (graphemesCount < Number(maxlength))
                  return false;
              }
            }
            const { allowInput: allowInput2 } = props;
            if (typeof allowInput2 === "function") {
              return allowInput2(value);
            }
            return true;
          }
          function handleInputBlur(e) {
            doUpdateValueBlur(e);
            if (e.relatedTarget === wrapperElRef.value) {
              doDeactivate();
            }
            if (!(e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value))) {
              activatedRef.value = false;
            }
            dealWithEvent(e, "blur");
            currentFocusedInputRef.value = null;
          }
          function handleInputFocus(e, index) {
            doUpdateValueFocus(e);
            focusedRef.value = true;
            activatedRef.value = true;
            doActivate();
            dealWithEvent(e, "focus");
            if (index === 0) {
              currentFocusedInputRef.value = inputElRef.value;
            } else if (index === 1) {
              currentFocusedInputRef.value = inputEl2Ref.value;
            } else if (index === 2) {
              currentFocusedInputRef.value = textareaElRef.value;
            }
          }
          function handleWrapperBlur(e) {
            if (props.passivelyActivated) {
              doWrapperBlur(e);
              dealWithEvent(e, "blur");
            }
          }
          function handleWrapperFocus(e) {
            if (props.passivelyActivated) {
              focusedRef.value = true;
              doWrapperFocus(e);
              dealWithEvent(e, "focus");
            }
          }
          function dealWithEvent(e, type2) {
            if (e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value || e.relatedTarget === wrapperElRef.value))
              ;
            else {
              if (type2 === "focus") {
                doFocus(e);
                focusedRef.value = true;
              } else if (type2 === "blur") {
                doBlur(e);
                focusedRef.value = false;
              }
            }
          }
          function handleChange(e, index) {
            handleInput(e, index, "change");
          }
          function handleClick2(e) {
            doClick(e);
          }
          function handleClear(e) {
            doClear(e);
            if (props.pair) {
              doUpdateValue(["", ""]);
              doChange(["", ""]);
            } else {
              doUpdateValue("");
              doChange("");
            }
          }
          function handleMouseDown(e) {
            const { onMousedown } = props;
            if (onMousedown)
              onMousedown(e);
            const { tagName } = e.target;
            if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
              if (props.resizable) {
                const { value: wrapperEl } = wrapperElRef;
                if (wrapperEl) {
                  const { left, top, width, height } = wrapperEl.getBoundingClientRect();
                  const resizeHandleSize = 14;
                  if (left + width - resizeHandleSize < e.clientX && e.clientX < left + width && top + height - resizeHandleSize < e.clientY && e.clientY < top + height) {
                    return;
                  }
                }
              }
              e.preventDefault();
              if (!focusedRef.value) {
                focus();
              }
            }
          }
          function handleMouseEnter() {
            var _a;
            hoverRef.value = true;
            if (props.type === "textarea") {
              (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseEnterWrapper();
            }
          }
          function handleMouseLeave() {
            var _a;
            hoverRef.value = false;
            if (props.type === "textarea") {
              (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseLeaveWrapper();
            }
          }
          function handlePasswordToggleClick() {
            if (mergedDisabledRef.value)
              return;
            if (mergedShowPasswordOnRef.value !== "click")
              return;
            passwordVisibleRef.value = !passwordVisibleRef.value;
          }
          function handlePasswordToggleMousedown(e) {
            if (mergedDisabledRef.value)
              return;
            e.preventDefault();
            const preventDefaultOnce = (e2) => {
              e2.preventDefault();
              off("mouseup", document, preventDefaultOnce);
            };
            on("mouseup", document, preventDefaultOnce);
            if (mergedShowPasswordOnRef.value !== "mousedown")
              return;
            passwordVisibleRef.value = true;
            const hidePassword = () => {
              passwordVisibleRef.value = false;
              off("mouseup", document, hidePassword);
            };
            on("mouseup", document, hidePassword);
          }
          function handleWrapperKeydown(e) {
            var _a;
            (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            switch (e.key) {
              case "Escape":
                handleWrapperKeydownEsc();
                break;
              case "Enter":
                handleWrapperKeydownEnter(e);
                break;
            }
          }
          function handleWrapperKeydownEnter(e) {
            var _a, _b;
            if (props.passivelyActivated) {
              const { value: focused } = activatedRef;
              if (focused) {
                if (props.internalDeactivateOnEnter) {
                  handleWrapperKeydownEsc();
                }
                return;
              }
              e.preventDefault();
              if (props.type === "textarea") {
                (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              } else {
                (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
              }
            }
          }
          function handleWrapperKeydownEsc() {
            if (props.passivelyActivated) {
              activatedRef.value = false;
              void vue.nextTick(() => {
                var _a;
                (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              });
            }
          }
          function focus() {
            var _a, _b, _c;
            if (mergedDisabledRef.value)
              return;
            if (props.passivelyActivated) {
              (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            } else {
              (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
              (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
            }
          }
          function blur() {
            var _a;
            if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
              document.activeElement.blur();
            }
          }
          function select() {
            var _a, _b;
            (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
            (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
          }
          function activate() {
            if (mergedDisabledRef.value)
              return;
            if (textareaElRef.value)
              textareaElRef.value.focus();
            else if (inputElRef.value)
              inputElRef.value.focus();
          }
          function deactivate() {
            const { value: wrapperEl } = wrapperElRef;
            if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) && wrapperEl !== document.activeElement) {
              handleWrapperKeydownEsc();
            }
          }
          function scrollTo(options) {
            if (props.type === "textarea") {
              const { value: textareaEl } = textareaElRef;
              textareaEl === null || textareaEl === void 0 ? void 0 : textareaEl.scrollTo(options);
            } else {
              const { value: inputEl } = inputElRef;
              inputEl === null || inputEl === void 0 ? void 0 : inputEl.scrollTo(options);
            }
          }
          function syncMirror(value) {
            const { type: type2, pair, autosize } = props;
            if (!pair && autosize) {
              if (type2 === "textarea") {
                const { value: textareaMirrorEl } = textareaMirrorElRef;
                if (textareaMirrorEl) {
                  textareaMirrorEl.textContent = (value !== null && value !== void 0 ? value : "") + "\r\n";
                }
              } else {
                const { value: inputMirrorEl } = inputMirrorElRef;
                if (inputMirrorEl) {
                  if (value) {
                    inputMirrorEl.textContent = value;
                  } else {
                    inputMirrorEl.innerHTML = "&nbsp;";
                  }
                }
              }
            }
          }
          function handleTextAreaMirrorResize() {
            updateTextAreaStyle();
          }
          const placeholderStyleRef = vue.ref({
            top: "0"
          });
          function handleTextAreaScroll(e) {
            var _a;
            const { scrollTop } = e.target;
            placeholderStyleRef.value.top = `${-scrollTop}px`;
            (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
          }
          let stopWatchMergedValue1 = null;
          vue.watchEffect(() => {
            const { autosize, type: type2 } = props;
            if (autosize && type2 === "textarea") {
              stopWatchMergedValue1 = vue.watch(mergedValueRef, (value) => {
                if (!Array.isArray(value) && value !== syncSource) {
                  syncMirror(value);
                }
              });
            } else {
              stopWatchMergedValue1 === null || stopWatchMergedValue1 === void 0 ? void 0 : stopWatchMergedValue1();
            }
          });
          let stopWatchMergedValue2 = null;
          vue.watchEffect(() => {
            if (props.type === "textarea") {
              stopWatchMergedValue2 = vue.watch(mergedValueRef, (value) => {
                var _a;
                if (!Array.isArray(value) && value !== syncSource) {
                  (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
                }
              });
            } else {
              stopWatchMergedValue2 === null || stopWatchMergedValue2 === void 0 ? void 0 : stopWatchMergedValue2();
            }
          });
          vue.provide(inputInjectionKey, {
            mergedValueRef,
            maxlengthRef,
            mergedClsPrefixRef,
            countGraphemesRef: vue.toRef(props, "countGraphemes")
          });
          const exposedProps = {
            wrapperElRef,
            inputElRef,
            textareaElRef,
            isCompositing: isComposingRef2,
            focus,
            blur,
            select,
            deactivate,
            activate,
            scrollTo
          };
          const rtlEnabledRef = useRtl("Input", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { value: size2 } = mergedSizeRef;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { color, borderRadius, textColor, caretColor, caretColorError, caretColorWarning, textDecorationColor, border, borderDisabled, borderHover, borderFocus, placeholderColor, placeholderColorDisabled, lineHeightTextarea, colorDisabled, colorFocus, textColorDisabled, boxShadowFocus, iconSize, colorFocusWarning, boxShadowFocusWarning, borderWarning, borderFocusWarning, borderHoverWarning, colorFocusError, boxShadowFocusError, borderError, borderFocusError, borderHoverError, clearSize, clearColor, clearColorHover, clearColorPressed, iconColor, iconColorDisabled, suffixTextColor, countTextColor, countTextColorDisabled, iconColorHover, iconColorPressed, loadingColor, loadingColorError, loadingColorWarning, [createKey("padding", size2)]: padding, [createKey("fontSize", size2)]: fontSize2, [createKey("height", size2)]: height } } = themeRef.value;
            const { left: paddingLeft, right: paddingRight } = getMargin(padding);
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-count-text-color": countTextColor,
              "--n-count-text-color-disabled": countTextColorDisabled,
              "--n-color": color,
              "--n-font-size": fontSize2,
              "--n-border-radius": borderRadius,
              "--n-height": height,
              "--n-padding-left": paddingLeft,
              "--n-padding-right": paddingRight,
              "--n-text-color": textColor,
              "--n-caret-color": caretColor,
              "--n-text-decoration-color": textDecorationColor,
              "--n-border": border,
              "--n-border-disabled": borderDisabled,
              "--n-border-hover": borderHover,
              "--n-border-focus": borderFocus,
              "--n-placeholder-color": placeholderColor,
              "--n-placeholder-color-disabled": placeholderColorDisabled,
              "--n-icon-size": iconSize,
              "--n-line-height-textarea": lineHeightTextarea,
              "--n-color-disabled": colorDisabled,
              "--n-color-focus": colorFocus,
              "--n-text-color-disabled": textColorDisabled,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-loading-color": loadingColor,
              // form warning
              "--n-caret-color-warning": caretColorWarning,
              "--n-color-focus-warning": colorFocusWarning,
              "--n-box-shadow-focus-warning": boxShadowFocusWarning,
              "--n-border-warning": borderWarning,
              "--n-border-focus-warning": borderFocusWarning,
              "--n-border-hover-warning": borderHoverWarning,
              "--n-loading-color-warning": loadingColorWarning,
              // form error
              "--n-caret-color-error": caretColorError,
              "--n-color-focus-error": colorFocusError,
              "--n-box-shadow-focus-error": boxShadowFocusError,
              "--n-border-error": borderError,
              "--n-border-focus-error": borderFocusError,
              "--n-border-hover-error": borderHoverError,
              "--n-loading-color-error": loadingColorError,
              // clear-button
              "--n-clear-color": clearColor,
              "--n-clear-size": clearSize,
              "--n-clear-color-hover": clearColorHover,
              "--n-clear-color-pressed": clearColorPressed,
              "--n-icon-color": iconColor,
              "--n-icon-color-hover": iconColorHover,
              "--n-icon-color-pressed": iconColorPressed,
              "--n-icon-color-disabled": iconColorDisabled,
              "--n-suffix-text-color": suffixTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("input", vue.computed(() => {
            const { value: size2 } = mergedSizeRef;
            return size2[0];
          }), cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedProps), {
            // DOM ref
            wrapperElRef,
            inputElRef,
            inputMirrorElRef,
            inputEl2Ref,
            textareaElRef,
            textareaMirrorElRef,
            textareaScrollbarInstRef,
            // value
            rtlEnabled: rtlEnabledRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            passwordVisible: passwordVisibleRef,
            mergedPlaceholder: mergedPlaceholderRef,
            showPlaceholder1: showPlaceholder1Ref,
            showPlaceholder2: showPlaceholder2Ref,
            mergedFocus: mergedFocusRef,
            isComposing: isComposingRef2,
            activated: activatedRef,
            showClearButton,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            textDecorationStyle: textDecorationStyleRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            mergedShowPasswordOn: mergedShowPasswordOnRef,
            placeholderStyle: placeholderStyleRef,
            mergedStatus: mergedStatusRef,
            textAreaScrollContainerWidth: textAreaScrollContainerWidthRef,
            // methods
            handleTextAreaScroll,
            handleCompositionStart,
            handleCompositionEnd,
            handleInput,
            handleInputBlur,
            handleInputFocus,
            handleWrapperBlur,
            handleWrapperFocus,
            handleMouseEnter,
            handleMouseLeave,
            handleMouseDown,
            handleChange,
            handleClick: handleClick2,
            handleClear,
            handlePasswordToggleClick,
            handlePasswordToggleMousedown,
            handleWrapperKeydown,
            handleTextAreaMirrorResize,
            getTextareaScrollContainer: () => {
              return textareaElRef.value;
            },
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a, _b;
          const { mergedClsPrefix, mergedStatus, themeClass, type: type2, countGraphemes, onRender } = this;
          const $slots = this.$slots;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "wrapperElRef", class: [
              `${mergedClsPrefix}-input`,
              themeClass,
              mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`,
              {
                [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
                [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
                [`${mergedClsPrefix}-input--textarea`]: type2 === "textarea",
                [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
                [`${mergedClsPrefix}-input--autosize`]: this.autosize,
                [`${mergedClsPrefix}-input--round`]: this.round && !(type2 === "textarea"),
                [`${mergedClsPrefix}-input--pair`]: this.pair,
                [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
                [`${mergedClsPrefix}-input--stateful`]: this.stateful
              }
            ], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.onKeyup, onKeydown: this.handleWrapperKeydown },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-input-wrapper` },
              resolveWrappedSlot($slots.prefix, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-input__prefix` }, children)),
              type2 === "textarea" ? vue.h(NScrollbar, { ref: "textareaScrollbarInstRef", class: `${mergedClsPrefix}-input__textarea`, container: this.getTextareaScrollContainer, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, {
                default: () => {
                  var _a2, _b2;
                  const { textAreaScrollContainerWidth } = this;
                  const scrollContainerWidthStyle = {
                    width: this.autosize && textAreaScrollContainerWidth && `${textAreaScrollContainerWidth}px`
                  };
                  return vue.h(
                    vue.Fragment,
                    null,
                    vue.h("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [
                      `${mergedClsPrefix}-input__textarea-el`,
                      (_a2 = this.inputProps) === null || _a2 === void 0 ? void 0 : _a2.class
                    ], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: countGraphemes ? void 0 : this.maxlength, minlength: countGraphemes ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [
                      this.textDecorationStyle[0],
                      (_b2 = this.inputProps) === null || _b2 === void 0 ? void 0 : _b2.style,
                      scrollContainerWidthStyle
                    ], onBlur: this.handleInputBlur, onFocus: (e) => {
                      this.handleInputFocus(e, 2);
                    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })),
                    this.showPlaceholder1 ? vue.h("div", { class: `${mergedClsPrefix}-input__placeholder`, style: [
                      this.placeholderStyle,
                      scrollContainerWidthStyle
                    ], key: "placeholder" }, this.mergedPlaceholder[0]) : null,
                    this.autosize ? vue.h(VResizeObserver, { onResize: this.handleTextAreaMirrorResize }, {
                      default: () => vue.h("div", { ref: "textareaMirrorElRef", class: `${mergedClsPrefix}-input__textarea-mirror`, key: "mirror" })
                    }) : null
                  );
                }
              }) : vue.h(
                "div",
                { class: `${mergedClsPrefix}-input__input` },
                vue.h("input", Object.assign({ type: type2 === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : type2 }, this.inputProps, { ref: "inputElRef", class: [
                  `${mergedClsPrefix}-input__input-el`,
                  (_a = this.inputProps) === null || _a === void 0 ? void 0 : _a.class
                ], style: [
                  this.textDecorationStyle[0],
                  (_b = this.inputProps) === null || _b === void 0 ? void 0 : _b.style
                ], tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: countGraphemes ? void 0 : this.maxlength, minlength: countGraphemes ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (e) => {
                  this.handleInputFocus(e, 0);
                }, onInput: (e) => {
                  this.handleInput(e, 0);
                }, onChange: (e) => {
                  this.handleChange(e, 0);
                } })),
                this.showPlaceholder1 ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-input__placeholder` },
                  vue.h("span", null, this.mergedPlaceholder[0])
                ) : null,
                this.autosize ? vue.h("div", { class: `${mergedClsPrefix}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "") : null
              ),
              !this.pair && resolveWrappedSlot($slots.suffix, (children) => {
                return children || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? vue.h("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                  resolveWrappedSlot($slots["clear-icon-placeholder"], (children2) => {
                    return (this.clearable || children2) && vue.h(NBaseClear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, {
                      placeholder: () => children2,
                      icon: () => {
                        var _a2, _b2;
                        return (_b2 = (_a2 = this.$slots)["clear-icon"]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
                      }
                    });
                  }),
                  !this.internalLoadingBeforeSuffix ? children : null,
                  this.loading !== void 0 ? vue.h(NBaseSuffix, { clsPrefix: mergedClsPrefix, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null,
                  this.internalLoadingBeforeSuffix ? children : null,
                  this.showCount && this.type !== "textarea" ? vue.h(WordCount, null, {
                    default: (props) => {
                      var _a2;
                      return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
                    }
                  }) : null,
                  this.mergedShowPasswordOn && this.type === "password" ? vue.h("div", { class: `${mergedClsPrefix}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? resolveSlot($slots["password-visible-icon"], () => [
                    vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(EyeIcon, null) })
                  ]) : resolveSlot($slots["password-invisible-icon"], () => [
                    vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(EyeOffIcon, null) })
                  ])) : null
                ]) : null;
              })
            ),
            this.pair ? vue.h("span", { class: `${mergedClsPrefix}-input__separator` }, resolveSlot($slots.separator, () => [this.separator])) : null,
            this.pair ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-input-wrapper` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-input__input` },
                vue.h("input", { ref: "inputEl2Ref", type: this.type, class: `${mergedClsPrefix}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: countGraphemes ? void 0 : this.maxlength, minlength: countGraphemes ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (e) => {
                  this.handleInputFocus(e, 1);
                }, onInput: (e) => {
                  this.handleInput(e, 1);
                }, onChange: (e) => {
                  this.handleChange(e, 1);
                } }),
                this.showPlaceholder2 ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-input__placeholder` },
                  vue.h("span", null, this.mergedPlaceholder[1])
                ) : null
              ),
              resolveWrappedSlot($slots.suffix, (children) => {
                return (this.clearable || children) && vue.h("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                  this.clearable && vue.h(NBaseClear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, {
                    icon: () => {
                      var _a2;
                      return (_a2 = $slots["clear-icon"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
                    },
                    placeholder: () => {
                      var _a2;
                      return (_a2 = $slots["clear-icon-placeholder"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
                    }
                  }),
                  children
                ]);
              })
            ) : null,
            this.mergedBordered ? vue.h("div", { class: `${mergedClsPrefix}-input__border` }) : null,
            this.mergedBordered ? vue.h("div", { class: `${mergedClsPrefix}-input__state-border` }) : null,
            this.showCount && type2 === "textarea" ? vue.h(WordCount, null, {
              default: (props) => {
                var _a2;
                const { renderCount } = this;
                if (renderCount) {
                  return renderCount(props);
                }
                return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
              }
            }) : null
          );
        }
      });
      const style$1i = cB("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [c$1(">", [cB("input", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), c$1("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), cB("button", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [cE("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), c$1("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [cE("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), c$1("*", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [c$1(">", [cB("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB("base-selection", [cB("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cE("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), c$1("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [c$1(">", [cB("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB("base-selection", [cB("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cE("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]);
      const inputGroupProps = {};
      const NInputGroup = vue.defineComponent({
        name: "InputGroup",
        props: inputGroupProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          useStyle("-input-group", style$1i, mergedClsPrefixRef);
          return {
            mergedClsPrefix: mergedClsPrefixRef
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h("div", { class: `${mergedClsPrefix}-input-group` }, this.$slots);
        }
      });
      const style$1h = cB("input-group-label", `
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 box-sizing: border-box;
 padding: 0 12px;
 display: inline-block;
 border-radius: var(--n-border-radius);
 background-color: var(--n-group-label-color);
 color: var(--n-group-label-text-color);
 font-size: var(--n-font-size);
 line-height: var(--n-height);
 height: var(--n-height);
 flex-shrink: 0;
 white-space: nowrap;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [cE("border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-group-label-border);
 transition: border-color .3s var(--n-bezier);
 `)]);
      const inputGroupLabelProps = Object.assign(Object.assign({}, useTheme.props), { size: {
        type: String,
        default: "medium"
      }, bordered: {
        type: Boolean,
        default: void 0
      } });
      const InputGroupLabel = vue.defineComponent({
        name: "InputGroupLabel",
        props: inputGroupLabelProps,
        setup(props) {
          const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Input", "-input-group-label", style$1h, inputLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { groupLabelColor, borderRadius, groupLabelTextColor, lineHeight: lineHeight2, groupLabelBorder, [createKey("fontSize", size2)]: fontSize2, [createKey("height", size2)]: height } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-group-label-color": groupLabelColor,
              "--n-group-label-border": groupLabelBorder,
              "--n-border-radius": borderRadius,
              "--n-group-label-text-color": groupLabelTextColor,
              "--n-font-size": fontSize2,
              "--n-line-height": lineHeight2,
              "--n-height": height
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("input-group-label", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-input-group-label`, this.themeClass], style: this.cssVars },
            (_c = (_b = this.$slots).default) === null || _c === void 0 ? void 0 : _c.call(_b),
            this.mergedBordered ? vue.h("div", { class: `${mergedClsPrefix}-input-group-label__border` }) : null
          );
        }
      });
      function self$14(vars) {
        const { boxShadow2 } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
      const autoCompleteLight = createTheme({
        name: "AutoComplete",
        common: commonLight,
        peers: {
          InternalSelectMenu: internalSelectMenuLight$1,
          Input: inputLight$1
        },
        self: self$14
      });
      const autoCompleteLight$1 = autoCompleteLight;
      const autoCompleteDark = {
        name: "AutoComplete",
        common: commonDark,
        peers: {
          InternalSelectMenu: internalSelectMenuDark$1,
          Input: inputDark$1
        },
        self: self$14
      };
      const autoCompleteDark$1 = autoCompleteDark;
      function mapAutoCompleteOptionsToSelectOptions(options) {
        return options.map(convertAutoCompleteOptionToSelectOption);
      }
      function convertAutoCompleteOptionToSelectOption(option) {
        var _a, _b;
        if (typeof option === "string") {
          return {
            label: option,
            value: option
          };
        } else if (option.type === "group") {
          const groupOption = {
            type: "group",
            label: (_a = option.label) !== null && _a !== void 0 ? _a : option.name,
            value: (_b = option.value) !== null && _b !== void 0 ? _b : option.name,
            key: option.key || option.name,
            children: option.children.map((groupOption2) => convertAutoCompleteOptionToSelectOption(groupOption2))
          };
          return groupOption;
        } else {
          return option;
        }
      }
      const style$1g = c$1([cB("auto-complete", `
 z-index: auto;
 position: relative;
 display: inline-flex;
 width: 100%;
 `), cB("auto-complete-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
        originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
      })])]);
      const autoCompleteProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        menuProps: Object,
        bordered: {
          type: Boolean,
          default: void 0
        },
        clearable: {
          type: Boolean,
          default: void 0
        },
        defaultValue: {
          type: String,
          default: null
        },
        loading: {
          type: Boolean,
          default: void 0
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        placeholder: String,
        placement: {
          type: String,
          default: "bottom-start"
        },
        value: String,
        blurAfterSelect: Boolean,
        clearAfterSelect: Boolean,
        getShow: Function,
        inputProps: Object,
        renderOption: Function,
        renderLabel: Function,
        size: String,
        options: {
          type: Array,
          default: () => []
        },
        zIndex: Number,
        status: String,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onSelect: [Function, Array],
        onBlur: [Function, Array],
        onFocus: [Function, Array],
        // deprecated
        onInput: [Function, Array]
      });
      const AutoComplete = vue.defineComponent({
        name: "AutoComplete",
        props: autoCompleteProps,
        setup(props) {
          const { mergedBorderedRef, namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const triggerElRef = vue.ref(null);
          const menuInstRef = vue.ref(null);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const canBeActivatedRef = vue.ref(false);
          const isComposingRef2 = vue.ref(false);
          const themeRef = useTheme("AutoComplete", "-auto-complete", style$1g, autoCompleteLight$1, props, mergedClsPrefixRef);
          const selectOptionsRef = vue.computed(() => {
            return mapAutoCompleteOptionsToSelectOptions(props.options);
          });
          const mergedShowOptionsRef = vue.computed(() => {
            const { getShow } = props;
            if (getShow) {
              return getShow(mergedValueRef.value || "");
            }
            return !!mergedValueRef.value;
          });
          const activeRef = vue.computed(() => {
            return mergedShowOptionsRef.value && canBeActivatedRef.value && !!selectOptionsRef.value.length;
          });
          const treeMateRef = vue.computed(() => createTreeMate(selectOptionsRef.value, createTmOptions("value", "children")));
          function doUpdateValue(value) {
            const { "onUpdate:value": _onUpdateValue, onUpdateValue, onInput } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            if (onInput)
              call(onInput, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function doSelect(value) {
            const { onSelect } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onSelect)
              call(onSelect, value);
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
          }
          function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
          }
          function handleCompositionStart() {
            isComposingRef2.value = true;
          }
          function handleCompositionEnd() {
            window.setTimeout(() => {
              isComposingRef2.value = false;
            }, 0);
          }
          function handleKeyDown(e) {
            var _a, _b, _c;
            switch (e.key) {
              case "Enter":
                if (!isComposingRef2.value) {
                  const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();
                  if (pendingOptionTmNode) {
                    select(pendingOptionTmNode.rawNode);
                    e.preventDefault();
                  }
                }
                break;
              case "ArrowDown":
                (_b = menuInstRef.value) === null || _b === void 0 ? void 0 : _b.next();
                break;
              case "ArrowUp":
                (_c = menuInstRef.value) === null || _c === void 0 ? void 0 : _c.prev();
                break;
            }
          }
          function select(option) {
            if ((option === null || option === void 0 ? void 0 : option.value) !== void 0) {
              doSelect(option.value);
              if (props.clearAfterSelect) {
                doUpdateValue(null);
              } else if (option.label !== void 0) {
                doUpdateValue(option.label);
              }
              canBeActivatedRef.value = false;
              if (props.blurAfterSelect) {
                blur();
              }
            }
          }
          function handleClear() {
            doUpdateValue(null);
          }
          function handleFocus(e) {
            canBeActivatedRef.value = true;
            doFocus(e);
          }
          function handleBlur(e) {
            canBeActivatedRef.value = false;
            doBlur(e);
          }
          function handleInput(value) {
            canBeActivatedRef.value = true;
            doUpdateValue(value);
          }
          function handleToggle(option) {
            select(option.rawNode);
          }
          function handleClickOutsideMenu(e) {
            var _a;
            if (!((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
              canBeActivatedRef.value = false;
            }
          }
          function blur() {
            var _a, _b;
            if ((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
              (_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.blur();
            }
          }
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { menuBoxShadow } } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow,
              "--n-bezier": cubicBezierEaseInOut2
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("auto-complete", void 0, cssVarsRef, props) : void 0;
          const inputInstRef = vue.ref(null);
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          return {
            focus: exposedMethods.focus,
            blur: exposedMethods.blur,
            inputInstRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            isMounted: isMounted(),
            adjustedTo: useAdjustedTo(props),
            menuInstRef,
            triggerElRef,
            treeMate: treeMateRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            active: activeRef,
            mergedStatus: mergedStatusRef,
            handleClear,
            handleFocus,
            handleBlur,
            handleInput,
            handleToggle,
            handleClickOutsideMenu,
            handleCompositionStart,
            handleCompositionEnd,
            handleKeyDown,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            mergedBordered: mergedBorderedRef,
            namespace: namespaceRef,
            mergedClsPrefix: mergedClsPrefixRef
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-auto-complete`, ref: "triggerElRef", onKeydown: this.handleKeyDown, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => {
                    const defaultSlot = this.$slots.default;
                    if (defaultSlot) {
                      return getFirstSlotVNode(this.$slots, "default", {
                        handleInput: this.handleInput,
                        handleFocus: this.handleFocus,
                        handleBlur: this.handleBlur,
                        value: this.mergedValue
                      });
                    }
                    const { mergedTheme } = this;
                    return vue.h(NInput, { ref: "inputInstRef", status: this.mergedStatus, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, bordered: this.mergedBordered, value: this.mergedValue, placeholder: this.placeholder, size: this.mergedSize, disabled: this.mergedDisabled, clearable: this.clearable, loading: this.loading, inputProps: this.inputProps, onClear: this.handleClear, onFocus: this.handleFocus, onUpdateValue: this.handleInput, onBlur: this.handleBlur }, {
                      suffix: () => {
                        var _a, _b;
                        return (_b = (_a = this.$slots).suffix) === null || _b === void 0 ? void 0 : _b.call(_a);
                      },
                      prefix: () => {
                        var _a, _b;
                        return (_b = (_a = this.$slots).prefix) === null || _b === void 0 ? void 0 : _b.call(_a);
                      }
                    });
                  }
                }),
                vue.h(VFollower, { show: this.active, to: this.adjustedTo, containerClass: this.namespace, zIndex: this.zIndex, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, placement: this.placement, width: "target" }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                    default: () => {
                      var _a;
                      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                      if (!this.active)
                        return null;
                      const { menuProps: menuProps2 } = this;
                      return vue.withDirectives(vue.h(NInternalSelectMenu, Object.assign({}, menuProps2, { clsPrefix: mergedClsPrefix, ref: "menuInstRef", theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, "auto-pending": true, class: [
                        `${mergedClsPrefix}-auto-complete-menu`,
                        this.themeClass,
                        menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.class
                      ], style: [
                        menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.style,
                        this.cssVars
                      ], treeMate: this.treeMate, multiple: false, renderLabel: this.renderLabel, renderOption: this.renderOption, size: "medium", onToggle: this.handleToggle })), [
                        [
                          clickoutside$1,
                          this.handleClickOutsideMenu,
                          void 0,
                          { capture: true }
                        ]
                      ]);
                    }
                  })
                })
              ]
            })
          );
        }
      });
      const isImageSupportNativeLazy = isBrowser$2 && "loading" in document.createElement("img");
      const resolveOptionsAndHash = (options = {}) => {
        var _a;
        const { root: root2 = null } = options;
        return {
          hash: `${options.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(options.threshold) ? options.threshold.join(",") : (_a = options.threshold) !== null && _a !== void 0 ? _a : "0"}`,
          options: Object.assign(Object.assign({}, options), { root: (typeof root2 === "string" ? document.querySelector(root2) : root2) || document.documentElement })
        };
      };
      const observers = /* @__PURE__ */ new WeakMap();
      const unobserveHandleMap = /* @__PURE__ */ new WeakMap();
      const shouldStartLoadingRefMap = /* @__PURE__ */ new WeakMap();
      const observeIntersection = (el, options, shouldStartLoadingRef) => {
        if (!el)
          return () => {
          };
        const resolvedOptionsAndHash = resolveOptionsAndHash(options);
        const { root: root2 } = resolvedOptionsAndHash.options;
        let rootObservers;
        const _rootObservers = observers.get(root2);
        if (_rootObservers) {
          rootObservers = _rootObservers;
        } else {
          rootObservers = /* @__PURE__ */ new Map();
          observers.set(root2, rootObservers);
        }
        let observer;
        let observerAndObservedElements;
        if (rootObservers.has(resolvedOptionsAndHash.hash)) {
          observerAndObservedElements = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          rootObservers.get(resolvedOptionsAndHash.hash);
          if (!observerAndObservedElements[1].has(el)) {
            observer = observerAndObservedElements[0];
            observerAndObservedElements[1].add(el);
            observer.observe(el);
          }
        } else {
          observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                const _unobserve = unobserveHandleMap.get(entry.target);
                const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);
                if (_unobserve)
                  _unobserve();
                if (_shouldStartLoadingRef) {
                  _shouldStartLoadingRef.value = true;
                }
              }
            });
          }, resolvedOptionsAndHash.options);
          observer.observe(el);
          observerAndObservedElements = [observer, /* @__PURE__ */ new Set([el])];
          rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);
        }
        let unobservered = false;
        const unobserve = () => {
          if (unobservered)
            return;
          unobserveHandleMap.delete(el);
          shouldStartLoadingRefMap.delete(el);
          unobservered = true;
          if (observerAndObservedElements[1].has(el)) {
            observerAndObservedElements[0].unobserve(el);
            observerAndObservedElements[1].delete(el);
          }
          if (observerAndObservedElements[1].size <= 0) {
            rootObservers.delete(resolvedOptionsAndHash.hash);
          }
          if (!rootObservers.size) {
            observers.delete(root2);
          }
        };
        unobserveHandleMap.set(el, unobserve);
        shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);
        return unobserve;
      };
      const self$13 = (vars) => {
        const { borderRadius, avatarColor, cardColor, fontSize: fontSize2, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, modalColor, popoverColor } = vars;
        return {
          borderRadius,
          fontSize: fontSize2,
          border: `2px solid ${cardColor}`,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          heightHuge,
          color: composite(cardColor, avatarColor),
          colorModal: composite(modalColor, avatarColor),
          colorPopover: composite(popoverColor, avatarColor)
        };
      };
      const avatarLight = {
        name: "Avatar",
        common: commonLight,
        self: self$13
      };
      const avatarLight$1 = avatarLight;
      const avatarDark = {
        name: "Avatar",
        common: commonDark,
        self: self$13
      };
      const avatarDark$1 = avatarDark;
      const avatarGroupInjectionKey = createInjectionKey("n-avatar-group");
      const style$1f = cB("avatar", `
 width: var(--n-merged-size);
 height: var(--n-merged-size);
 color: #FFF;
 font-size: var(--n-font-size);
 display: inline-flex;
 position: relative;
 overflow: hidden;
 text-align: center;
 border: var(--n-border);
 border-radius: var(--n-border-radius);
 --n-merged-color: var(--n-color);
 background-color: var(--n-merged-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
`, [insideModal(c$1("&", "--n-merged-color: var(--n-color-modal);")), insidePopover(c$1("&", "--n-merged-color: var(--n-color-popover);")), c$1("img", `
 width: 100%;
 height: 100%;
 `), cE("text", `
 white-space: nowrap;
 display: inline-block;
 position: absolute;
 left: 50%;
 top: 50%;
 `), cB("icon", `
 vertical-align: bottom;
 font-size: calc(var(--n-merged-size) - 6px);
 `), cE("text", "line-height: 1.25")]);
      const avatarProps = Object.assign(Object.assign({}, useTheme.props), {
        size: [String, Number],
        src: String,
        circle: {
          type: Boolean,
          default: void 0
        },
        objectFit: String,
        round: {
          type: Boolean,
          default: void 0
        },
        bordered: {
          type: Boolean,
          default: void 0
        },
        onError: Function,
        fallbackSrc: String,
        intersectionObserverOptions: Object,
        lazy: Boolean,
        onLoad: Function,
        renderPlaceholder: Function,
        renderFallback: Function,
        imgProps: Object,
        /** @deprecated */
        color: String
      });
      const NAvatar = vue.defineComponent({
        name: "Avatar",
        props: avatarProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const hasLoadErrorRef = vue.ref(false);
          let memoedTextHtml = null;
          const textRef = vue.ref(null);
          const selfRef = vue.ref(null);
          const fitTextTransform = () => {
            const { value: textEl } = textRef;
            if (textEl) {
              if (memoedTextHtml === null || memoedTextHtml !== textEl.innerHTML) {
                memoedTextHtml = textEl.innerHTML;
                const { value: selfEl } = selfRef;
                if (selfEl) {
                  const { offsetWidth: elWidth, offsetHeight: elHeight } = selfEl;
                  const { offsetWidth: textWidth, offsetHeight: textHeight } = textEl;
                  const radix = 0.9;
                  const ratio = Math.min(elWidth / textWidth * radix, elHeight / textHeight * radix, 1);
                  textEl.style.transform = `translateX(-50%) translateY(-50%) scale(${ratio})`;
                }
              }
            }
          };
          const NAvatarGroup = vue.inject(avatarGroupInjectionKey, null);
          const mergedSizeRef = vue.computed(() => {
            const { size: size2 } = props;
            if (size2)
              return size2;
            const { size: avatarGroupSize } = NAvatarGroup || {};
            if (avatarGroupSize)
              return avatarGroupSize;
            return "medium";
          });
          const themeRef = useTheme("Avatar", "-avatar", style$1f, avatarLight$1, props, mergedClsPrefixRef);
          const TagInjection = vue.inject(tagInjectionKey, null);
          const mergedRoundRef = vue.computed(() => {
            if (NAvatarGroup)
              return true;
            const { round: round2, circle } = props;
            if (round2 !== void 0 || circle !== void 0)
              return round2 || circle;
            if (TagInjection) {
              return TagInjection.roundRef.value;
            }
            return false;
          });
          const mergedBorderedRef = vue.computed(() => {
            if (NAvatarGroup)
              return true;
            return props.bordered || false;
          });
          const handleError = (e) => {
            var _a;
            if (!shouldStartLoadingRef.value)
              return;
            hasLoadErrorRef.value = true;
            const { onError, imgProps } = props;
            (_a = imgProps === null || imgProps === void 0 ? void 0 : imgProps.onError) === null || _a === void 0 ? void 0 : _a.call(imgProps, e);
            if (onError) {
              onError(e);
            }
          };
          vue.watch(() => props.src, () => hasLoadErrorRef.value = false);
          const cssVarsRef = vue.computed(() => {
            const size2 = mergedSizeRef.value;
            const round2 = mergedRoundRef.value;
            const bordered = mergedBorderedRef.value;
            const { color: propColor } = props;
            const { self: { borderRadius, fontSize: fontSize2, color, border, colorModal, colorPopover }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            let height;
            if (typeof size2 === "number") {
              height = `${size2}px`;
            } else {
              height = themeRef.value.self[createKey("height", size2)];
            }
            return {
              "--n-font-size": fontSize2,
              "--n-border": bordered ? border : "none",
              "--n-border-radius": round2 ? "50%" : borderRadius,
              "--n-color": propColor || color,
              "--n-color-modal": propColor || colorModal,
              "--n-color-popover": propColor || colorPopover,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-merged-size": `var(--n-avatar-size-override, ${height})`
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("avatar", vue.computed(() => {
            const size2 = mergedSizeRef.value;
            const round2 = mergedRoundRef.value;
            const bordered = mergedBorderedRef.value;
            const { color } = props;
            let hash = "";
            if (size2) {
              if (typeof size2 === "number") {
                hash += `a${size2}`;
              } else {
                hash += size2[0];
              }
            }
            if (round2) {
              hash += "b";
            }
            if (bordered) {
              hash += "c";
            }
            if (color) {
              hash += color2Class(color);
            }
            return hash;
          }), cssVarsRef, props) : void 0;
          const shouldStartLoadingRef = vue.ref(!props.lazy);
          vue.onMounted(() => {
            if (isImageSupportNativeLazy) {
              return;
            }
            let unobserve;
            const stopWatchHandle = vue.watchEffect(() => {
              unobserve === null || unobserve === void 0 ? void 0 : unobserve();
              unobserve = void 0;
              if (props.lazy) {
                unobserve = observeIntersection(selfRef.value, props.intersectionObserverOptions, shouldStartLoadingRef);
              }
            });
            vue.onBeforeUnmount(() => {
              stopWatchHandle();
              unobserve === null || unobserve === void 0 ? void 0 : unobserve();
            });
          });
          const loadedRef = vue.ref(!props.lazy);
          return {
            textRef,
            selfRef,
            mergedRoundRef,
            mergedClsPrefix: mergedClsPrefixRef,
            fitTextTransform,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            hasLoadError: hasLoadErrorRef,
            handleError,
            shouldStartLoading: shouldStartLoadingRef,
            loaded: loadedRef,
            mergedOnLoad: (e) => {
              var _a;
              const { onLoad, imgProps } = props;
              onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);
              (_a = imgProps === null || imgProps === void 0 ? void 0 : imgProps.onLoad) === null || _a === void 0 ? void 0 : _a.call(imgProps, e);
              loadedRef.value = true;
            }
          };
        },
        render() {
          var _a, _b;
          const { $slots, src, mergedClsPrefix, lazy, onRender, mergedOnLoad, shouldStartLoading, loaded, hasLoadError } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          let img;
          const placeholderNode = !loaded && !hasLoadError && (this.renderPlaceholder ? this.renderPlaceholder() : (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
          if (this.hasLoadError) {
            img = this.renderFallback ? this.renderFallback() : resolveSlot($slots.fallback, () => [
              vue.h("img", { src: this.fallbackSrc, style: { objectFit: this.objectFit } })
            ]);
          } else {
            img = resolveWrappedSlot($slots.default, (children) => {
              if (children) {
                return vue.h(VResizeObserver, { onResize: this.fitTextTransform }, {
                  default: () => vue.h("span", { ref: "textRef", class: `${mergedClsPrefix}-avatar__text` }, children)
                });
              } else if (src) {
                const { imgProps } = this;
                return vue.h("img", Object.assign(Object.assign({}, imgProps), { loading: (
                  // If interseciton observer options is set, do not use native lazy
                  isImageSupportNativeLazy && !this.intersectionObserverOptions && lazy ? "lazy" : "eager"
                ), src: isImageSupportNativeLazy ? src : shouldStartLoading || loaded ? src : void 0, onLoad: mergedOnLoad, "data-image-src": src, onError: this.handleError, style: [
                  imgProps === null || imgProps === void 0 ? void 0 : imgProps.style,
                  { objectFit: this.objectFit },
                  placeholderNode ? {
                    height: "0",
                    width: "0",
                    visibility: "hidden",
                    position: "absolute"
                  } : ""
                ] }));
              }
            });
          }
          return vue.h(
            "span",
            { ref: "selfRef", class: [`${mergedClsPrefix}-avatar`, this.themeClass], style: this.cssVars },
            img,
            lazy && placeholderNode
          );
        }
      });
      const style$1e = cB("avatar-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM("vertical", {
        flexDirection: "row"
      }, [cB("avatar", [c$1("&:not(:first-child)", `
 margin-left: var(--n-gap);
 `)])]), cM("vertical", {
        flexDirection: "column"
      }, [cB("avatar", [c$1("&:not(:first-child)", `
 margin-top: var(--n-gap);
 `)])])]);
      const self$12 = () => {
        return {
          gap: "-12px"
        };
      };
      const avatarGroupLight = createTheme({
        name: "AvatarGroup",
        common: commonLight,
        peers: {
          Avatar: avatarLight$1
        },
        self: self$12
      });
      const avatarGroupLight$1 = avatarGroupLight;
      const avatarGroupDark = {
        name: "AvatarGroup",
        common: commonDark,
        peers: {
          Avatar: avatarDark$1
        },
        self: self$12
      };
      const avatarGroupDark$1 = avatarGroupDark;
      const avatarGroupProps = Object.assign(Object.assign({}, useTheme.props), { max: Number, maxStyle: [Object, String], options: {
        type: Array,
        default: () => []
      }, vertical: Boolean, size: [String, Number] });
      const AvatarGroup = vue.defineComponent({
        name: "AvatarGroup",
        props: avatarGroupProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const mergedThemeRef = useTheme("AvatarGroup", "-avatar-group", style$1e, avatarGroupLight$1, props, mergedClsPrefixRef);
          vue.provide(avatarGroupInjectionKey, props);
          const rtlEnabledRef = useRtl("AvatarGroup", mergedRtlRef, mergedClsPrefixRef);
          const restOptionsRef = vue.computed(() => {
            const { max } = props;
            if (max === void 0)
              return void 0;
            const { options } = props;
            if (options.length > max)
              return options.slice(max - 1, options.length);
            return [];
          });
          const displayedOptionsRef = vue.computed(() => {
            const { options, max } = props;
            if (max === void 0)
              return options;
            if (options.length > max)
              return options.slice(0, max - 1);
            if (options.length === max)
              return options.slice(0, max);
            return options;
          });
          return {
            mergedTheme: mergedThemeRef,
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            restOptions: restOptionsRef,
            displayedOptions: displayedOptionsRef,
            cssVars: vue.computed(() => {
              return {
                "--n-gap": mergedThemeRef.value.self.gap
              };
            })
          };
        },
        render() {
          const { mergedClsPrefix, displayedOptions, restOptions, mergedTheme, $slots } = this;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-avatar-group`,
              this.rtlEnabled && `${mergedClsPrefix}-avatar-group--rtl`,
              this.vertical && `${mergedClsPrefix}-avatar-group--vertical`
            ], style: this.cssVars, role: "group" },
            displayedOptions.map((option) => {
              return $slots.avatar ? $slots.avatar({ option }) : vue.h(NAvatar, { src: option.src, theme: mergedTheme.peers.Avatar, themeOverrides: mergedTheme.peerOverrides.Avatar });
            }),
            restOptions !== void 0 && restOptions.length > 0 && ($slots.rest ? $slots.rest({ options: restOptions, rest: restOptions.length }) : vue.h(NAvatar, { style: this.maxStyle, theme: mergedTheme.peers.Avatar, themeOverrides: mergedTheme.peerOverrides.Avatar }, {
              default: () => `+${restOptions.length}`
            }))
          );
        }
      });
      const commonVariables$h = {
        width: "44px",
        height: "44px",
        borderRadius: "22px",
        iconSize: "26px"
      };
      const backTopDark = {
        name: "BackTop",
        common: commonDark,
        self(vars) {
          const { popoverColor, textColor2, primaryColorHover, primaryColorPressed } = vars;
          return Object.assign(Object.assign({}, commonVariables$h), { color: popoverColor, textColor: textColor2, iconColor: textColor2, iconColorHover: primaryColorHover, iconColorPressed: primaryColorPressed, boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)", boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)", boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)" });
        }
      };
      const backTopDark$1 = backTopDark;
      const self$11 = (vars) => {
        const { popoverColor, textColor2, primaryColorHover, primaryColorPressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$h), { color: popoverColor, textColor: textColor2, iconColor: textColor2, iconColorHover: primaryColorHover, iconColorPressed: primaryColorPressed, boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)", boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)", boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)" });
      };
      const backTopLight = {
        name: "BackTop",
        common: commonLight,
        self: self$11
      };
      const backTopLight$1 = backTopLight;
      const BackTopIcon = vue.h(
        "svg",
        { viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg", xlinkHref: "http://www.w3.org/1999/xlink" },
        vue.h(
          "g",
          { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          vue.h(
            "g",
            { transform: "translate(-139.000000, -4423.000000)", "fill-rule": "nonzero" },
            vue.h(
              "g",
              { transform: "translate(120.000000, 4285.000000)" },
              vue.h(
                "g",
                { transform: "translate(7.000000, 126.000000)" },
                vue.h(
                  "g",
                  { transform: "translate(24.000000, 24.000000) scale(1, -1) translate(-24.000000, -24.000000) translate(12.000000, 12.000000)" },
                  vue.h(
                    "g",
                    { transform: "translate(4.000000, 2.000000)" },
                    vue.h("path", { d: "M8,0 C8.51283584,0 8.93550716,0.38604019 8.99327227,0.883378875 L9,1 L9,10.584 L12.2928932,7.29289322 C12.6834175,6.90236893 13.3165825,6.90236893 13.7071068,7.29289322 C14.0675907,7.65337718 14.0953203,8.22060824 13.7902954,8.61289944 L13.7071068,8.70710678 L8.70710678,13.7071068 L8.62544899,13.7803112 L8.618,13.784 L8.59530661,13.8036654 L8.4840621,13.8753288 L8.37133602,13.9287745 L8.22929083,13.9735893 L8.14346259,13.9897165 L8.03324678,13.9994506 L7.9137692,13.9962979 L7.77070917,13.9735893 L7.6583843,13.9401293 L7.57677845,13.9063266 L7.47929125,13.8540045 L7.4048407,13.8036865 L7.38131006,13.7856883 C7.35030318,13.7612383 7.32077858,13.7349921 7.29289322,13.7071068 L2.29289322,8.70710678 L2.20970461,8.61289944 C1.90467972,8.22060824 1.93240926,7.65337718 2.29289322,7.29289322 C2.65337718,6.93240926 3.22060824,6.90467972 3.61289944,7.20970461 L3.70710678,7.29289322 L7,10.585 L7,1 L7.00672773,0.883378875 C7.06449284,0.38604019 7.48716416,0 8,0 Z" }),
                    vue.h("path", { d: "M14.9333333,15.9994506 C15.5224371,15.9994506 16,16.4471659 16,16.9994506 C16,17.5122865 15.5882238,17.9349578 15.0577292,17.9927229 L14.9333333,17.9994506 L1.06666667,17.9994506 C0.477562934,17.9994506 0,17.5517354 0,16.9994506 C0,16.4866148 0.411776203,16.0639435 0.9422708,16.0061783 L1.06666667,15.9994506 L14.9333333,15.9994506 Z" })
                  )
                )
              )
            )
          )
        )
      );
      const style$1d = cB("back-top", `
 position: fixed;
 right: 40px;
 bottom: 40px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 height: var(--n-height);
 min-width: var(--n-width);
 box-shadow: var(--n-box-shadow);
 background-color: var(--n-color);
`, [fadeInScaleUpTransition(), cM("transition-disabled", {
        transition: "none !important"
      }), cB("base-icon", `
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), c$1("svg", {
        pointerEvents: "none"
      }), c$1("&:hover", {
        boxShadow: "var(--n-box-shadow-hover)"
      }, [cB("base-icon", {
        color: "var(--n-icon-color-hover)"
      })]), c$1("&:active", {
        boxShadow: "var(--n-box-shadow-pressed)"
      }, [cB("base-icon", {
        color: "var(--n-icon-color-pressed)"
      })])]);
      const backTopProps = Object.assign(Object.assign({}, useTheme.props), {
        show: {
          type: Boolean,
          default: void 0
        },
        right: {
          type: [Number, String],
          default: 40
        },
        bottom: {
          type: [Number, String],
          default: 40
        },
        to: {
          type: [String, Object],
          default: "body"
        },
        visibilityHeight: {
          type: Number,
          default: 180
        },
        listenTo: [String, Object, Function],
        "onUpdate:show": {
          type: Function,
          default: () => {
          }
        },
        // deprecated
        target: Function,
        onShow: Function,
        onHide: Function
      });
      const BackTop = vue.defineComponent({
        name: "BackTop",
        // make style applied to back-top button
        inheritAttrs: false,
        props: backTopProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const scrollTopRef = vue.ref(null);
          const uncontrolledShowRef = vue.ref(false);
          vue.watchEffect(() => {
            const { value: scrollTop } = scrollTopRef;
            if (scrollTop === null) {
              uncontrolledShowRef.value = false;
              return;
            }
            uncontrolledShowRef.value = scrollTop >= props.visibilityHeight;
          });
          const DomInfoReadyRef = vue.ref(false);
          vue.watch(uncontrolledShowRef, (value) => {
            var _a;
            if (DomInfoReadyRef.value) {
              (_a = props["onUpdate:show"]) === null || _a === void 0 ? void 0 : _a.call(props, value);
            }
          });
          const controlledShowRef = vue.toRef(props, "show");
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const transitionDisabledRef = vue.ref(true);
          const placeholderRef = vue.ref(null);
          const styleRef = vue.computed(() => {
            return {
              right: `calc(${formatLength(props.right)} + ${lockHtmlScrollRightCompensationRef.value})`,
              bottom: formatLength(props.bottom)
            };
          });
          let scrollElement;
          let scrollListenerRegistered;
          vue.watch(mergedShowRef, (value) => {
            var _a, _b;
            if (DomInfoReadyRef.value) {
              if (value) {
                (_a = props.onShow) === null || _a === void 0 ? void 0 : _a.call(props);
              }
              (_b = props.onHide) === null || _b === void 0 ? void 0 : _b.call(props);
            }
          });
          const themeRef = useTheme("BackTop", "-back-top", style$1d, backTopLight$1, props, mergedClsPrefixRef);
          function init2() {
            var _a;
            if (scrollListenerRegistered)
              return;
            scrollListenerRegistered = true;
            const scrollEl = ((_a = props.target) === null || _a === void 0 ? void 0 : _a.call(props)) || unwrapElement(props.listenTo) || getScrollParent$1(placeholderRef.value);
            if (!scrollEl) {
              return;
            }
            scrollElement = scrollEl === document.documentElement ? document : scrollEl;
            const { to } = props;
            typeof to === "string" ? document.querySelector(to) : to;
            scrollElement.addEventListener("scroll", handleScroll);
            handleScroll();
          }
          function handleClick2() {
            (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          function handleScroll() {
            scrollTopRef.value = (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTop;
            if (!DomInfoReadyRef.value) {
              void vue.nextTick(() => {
                DomInfoReadyRef.value = true;
              });
            }
          }
          function handleAfterEnter() {
            transitionDisabledRef.value = false;
          }
          vue.onMounted(() => {
            init2();
            transitionDisabledRef.value = mergedShowRef.value;
          });
          vue.onBeforeUnmount(() => {
            if (scrollElement) {
              scrollElement.removeEventListener("scroll", handleScroll);
            }
          });
          const cssVarsRef = vue.computed(() => {
            const { self: { color, boxShadow, boxShadowHover, boxShadowPressed, iconColor, iconColorHover, iconColorPressed, width, height, iconSize, borderRadius, textColor }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-height": height,
              "--n-width": width,
              "--n-box-shadow": boxShadow,
              "--n-box-shadow-hover": boxShadowHover,
              "--n-box-shadow-pressed": boxShadowPressed,
              "--n-color": color,
              "--n-icon-size": iconSize,
              "--n-icon-color": iconColor,
              "--n-icon-color-hover": iconColorHover,
              "--n-icon-color-pressed": iconColorPressed,
              "--n-text-color": textColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("back-top", void 0, cssVarsRef, props) : void 0;
          return {
            placeholderRef,
            style: styleRef,
            mergedShow: mergedShowRef,
            isMounted: isMounted(),
            scrollElement: vue.ref(null),
            scrollTop: scrollTopRef,
            DomInfoReady: DomInfoReadyRef,
            transitionDisabled: transitionDisabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            handleAfterEnter,
            handleScroll,
            handleClick: handleClick2,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(
            "div",
            { ref: "placeholderRef", class: `${mergedClsPrefix}-back-top-placeholder`, style: "display: none", "aria-hidden": true },
            vue.h(LazyTeleport, { to: this.to, show: this.mergedShow }, {
              default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterEnter: this.handleAfterEnter }, {
                default: () => {
                  var _a;
                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                  return this.mergedShow ? vue.h("div", vue.mergeProps(this.$attrs, {
                    class: [
                      `${mergedClsPrefix}-back-top`,
                      this.themeClass,
                      this.transitionDisabled && `${mergedClsPrefix}-back-top--transition-disabled`
                    ],
                    style: [this.style, this.cssVars],
                    onClick: this.handleClick
                  }), resolveSlot(this.$slots.default, () => [
                    vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => BackTopIcon })
                  ])) : null;
                }
              })
            })
          );
        }
      });
      const badgeDark = {
        name: "Badge",
        common: commonDark,
        self(vars) {
          const { errorColorSuppl, infoColorSuppl, successColorSuppl, warningColorSuppl, fontFamily: fontFamily2 } = vars;
          return {
            color: errorColorSuppl,
            colorInfo: infoColorSuppl,
            colorSuccess: successColorSuppl,
            colorError: errorColorSuppl,
            colorWarning: warningColorSuppl,
            fontSize: "12px",
            fontFamily: fontFamily2
          };
        }
      };
      const badgeDark$1 = badgeDark;
      const self$10 = (vars) => {
        const { errorColor, infoColor, successColor, warningColor, fontFamily: fontFamily2 } = vars;
        return {
          color: errorColor,
          colorInfo: infoColor,
          colorSuccess: successColor,
          colorError: errorColor,
          colorWarning: warningColor,
          fontSize: "12px",
          fontFamily: fontFamily2
        };
      };
      const badgeLight = {
        name: "Badge",
        common: commonLight,
        self: self$10
      };
      const badgeLight$1 = badgeLight;
      const style$1c = c$1([c$1("@keyframes badge-wave-spread", {
        from: {
          boxShadow: "0 0 0.5px 0px var(--n-ripple-color)",
          opacity: 0.6
        },
        to: {
          // don't use exact 5px since chrome will display the animation with glitches
          boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)",
          opacity: 0
        }
      }), cB("badge", `
 display: inline-flex;
 position: relative;
 vertical-align: middle;
 color: var(--n-color);
 font-family: var(--n-font-family);
 `, [cM("as-is", [cB("badge-sup", {
        position: "static",
        transform: "translateX(0)"
      }, [fadeInScaleUpTransition({
        transformOrigin: "left bottom",
        originalTransform: "translateX(0)"
      })])]), cM("dot", [cB("badge-sup", `
 height: 8px;
 width: 8px;
 padding: 0;
 min-width: 8px;
 left: 100%;
 bottom: calc(100% - 4px);
 `, [c$1("::before", "border-radius: 4px;")])]), cB("badge-sup", `
 background: var(--n-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: #FFF;
 position: absolute;
 height: 18px;
 line-height: 18px;
 border-radius: 9px;
 padding: 0 6px;
 text-align: center;
 font-size: var(--n-font-size);
 transform: translateX(-50%);
 left: 100%;
 bottom: calc(100% - 9px);
 font-variant-numeric: tabular-nums;
 z-index: 1;
 display: flex;
 align-items: center;
 `, [fadeInScaleUpTransition({
        transformOrigin: "left bottom",
        originalTransform: "translateX(-50%)"
      }), cB("base-wave", {
        zIndex: 1,
        animationDuration: "2s",
        animationIterationCount: "infinite",
        animationDelay: "1s",
        animationTimingFunction: "var(--n-ripple-bezier)",
        animationName: "badge-wave-spread"
      }), c$1("&::before", `
 opacity: 0;
 transform: scale(1);
 border-radius: 9px;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)])])]);
      const badgeProps = Object.assign(Object.assign({}, useTheme.props), { value: [String, Number], max: Number, dot: Boolean, type: {
        type: String,
        default: "default"
      }, show: {
        type: Boolean,
        default: true
      }, showZero: Boolean, processing: Boolean, color: String, offset: Array });
      const Badge = vue.defineComponent({
        name: "Badge",
        props: badgeProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Badge", "-badge", style$1c, badgeLight$1, props, mergedClsPrefixRef);
          const appearedRef = vue.ref(false);
          const handleAfterEnter = () => {
            appearedRef.value = true;
          };
          const handleAfterLeave = () => {
            appearedRef.value = false;
          };
          const showBadgeRef = vue.computed(() => {
            return props.show && (props.dot || props.value !== void 0 && !(!props.showZero && Number(props.value) <= 0) || !isSlotEmpty(slots.value));
          });
          vue.onMounted(() => {
            if (showBadgeRef.value)
              appearedRef.value = true;
          });
          const rtlEnabledRef = useRtl("Badge", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { type: type2, color: propColor } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { [createKey("color", type2)]: color, fontFamily: fontFamily2, fontSize: fontSize2 } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-font-family": fontFamily2,
              "--n-color": propColor || color,
              "--n-ripple-color": propColor || color,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-ripple-bezier": cubicBezierEaseOut2
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("badge", vue.computed(() => {
            let hash = "";
            const { type: type2, color } = props;
            if (type2) {
              hash += type2[0];
            }
            if (color) {
              hash += color2Class(color);
            }
            return hash;
          }), cssVarsRef, props) : void 0;
          const offsetStyleRef = vue.computed(() => {
            const { offset } = props;
            if (!offset)
              return void 0;
            const [x, y] = offset;
            const reslovedOffsetX = typeof x === "number" ? `${x}px` : x;
            const reslovedOffsetY = typeof y === "number" ? `${y}px` : y;
            return {
              transform: `translate(calc(${(rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? "50%" : "-50%"} + ${reslovedOffsetX}), ${reslovedOffsetY})`
            };
          });
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            appeared: appearedRef,
            showBadge: showBadgeRef,
            handleAfterEnter,
            handleAfterLeave,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            offsetStyle: offsetStyleRef
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix, onRender, themeClass, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const children = (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-badge`,
              this.rtlEnabled && `${mergedClsPrefix}-badge--rtl`,
              themeClass,
              {
                [`${mergedClsPrefix}-badge--dot`]: this.dot,
                [`${mergedClsPrefix}-badge--as-is`]: !children
              }
            ], style: this.cssVars },
            children,
            vue.h(vue.Transition, { name: "fade-in-scale-up-transition", onAfterEnter: this.handleAfterEnter, onAfterLeave: this.handleAfterLeave }, {
              default: () => this.showBadge ? vue.h(
                "sup",
                { class: `${mergedClsPrefix}-badge-sup`, title: getTitleAttribute(this.value), style: this.offsetStyle },
                resolveSlot($slots.value, () => [
                  !this.dot ? vue.h(NBaseSlotMachine, { clsPrefix: mergedClsPrefix, appeared: this.appeared, max: this.max, value: this.value }) : null
                ]),
                this.processing ? vue.h(NBaseWave, { clsPrefix: mergedClsPrefix }) : null
              ) : null
            })
          );
        }
      });
      const commonVariables$g = {
        fontWeightActive: "400"
      };
      const self$$ = (vars) => {
        const { fontSize: fontSize2, textColor3, textColor2, borderRadius, buttonColor2Hover, buttonColor2Pressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$g), { fontSize: fontSize2, itemLineHeight: "1.25", itemTextColor: textColor3, itemTextColorHover: textColor2, itemTextColorPressed: textColor2, itemTextColorActive: textColor2, itemBorderRadius: borderRadius, itemColorHover: buttonColor2Hover, itemColorPressed: buttonColor2Pressed, separatorColor: textColor3 });
      };
      const breadcrumbLight = {
        name: "Breadcrumb",
        common: commonLight,
        self: self$$
      };
      const breadcrumbLight$1 = breadcrumbLight;
      const breadcrumbDark = {
        name: "Breadcrumb",
        common: commonDark,
        self: self$$
      };
      const breadcrumbDark$1 = breadcrumbDark;
      const style$1b = cB("breadcrumb", `
 white-space: nowrap;
 cursor: default;
 line-height: var(--n-item-line-height);
`, [c$1("ul", `
 list-style: none;
 padding: 0;
 margin: 0;
 `), c$1("a", `
 color: inherit;
 text-decoration: inherit;
 `), cB("breadcrumb-item", `
 font-size: var(--n-font-size);
 transition: color .3s var(--n-bezier);
 display: inline-flex;
 align-items: center;
 `, [cB("icon", `
 font-size: 18px;
 vertical-align: -.2em;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `), c$1("&:not(:last-child)", [cM("clickable", [cE("link", `
 cursor: pointer;
 `, [c$1("&:hover", `
 background-color: var(--n-item-color-hover);
 `), c$1("&:active", `
 background-color: var(--n-item-color-pressed); 
 `)])])]), cE("link", `
 padding: 4px;
 border-radius: var(--n-item-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 position: relative;
 `, [c$1("&:hover", `
 color: var(--n-item-text-color-hover);
 `, [cB("icon", `
 color: var(--n-item-text-color-hover);
 `)]), c$1("&:active", `
 color: var(--n-item-text-color-pressed);
 `, [cB("icon", `
 color: var(--n-item-text-color-pressed);
 `)])]), cE("separator", `
 margin: 0 8px;
 color: var(--n-separator-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 `), c$1("&:last-child", [cE("link", `
 font-weight: var(--n-font-weight-active);
 cursor: unset;
 color: var(--n-item-text-color-active);
 `, [cB("icon", `
 color: var(--n-item-text-color-active);
 `)]), cE("separator", `
 display: none;
 `)])])]);
      const breadcrumbInjectionKey = createInjectionKey("n-breadcrumb");
      const breadcrumbProps = Object.assign(Object.assign({}, useTheme.props), { separator: {
        type: String,
        default: "/"
      } });
      const Breadcrumb = vue.defineComponent({
        name: "Breadcrumb",
        props: breadcrumbProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Breadcrumb", "-breadcrumb", style$1b, breadcrumbLight$1, props, mergedClsPrefixRef);
          vue.provide(breadcrumbInjectionKey, {
            separatorRef: vue.toRef(props, "separator"),
            mergedClsPrefixRef
          });
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { separatorColor, itemTextColor, itemTextColorHover, itemTextColorPressed, itemTextColorActive, fontSize: fontSize2, fontWeightActive, itemBorderRadius, itemColorHover, itemColorPressed, itemLineHeight } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-hover": itemTextColorHover,
              "--n-item-text-color-pressed": itemTextColorPressed,
              "--n-item-text-color-active": itemTextColorActive,
              "--n-separator-color": separatorColor,
              "--n-item-color-hover": itemColorHover,
              "--n-item-color-pressed": itemColorPressed,
              "--n-item-border-radius": itemBorderRadius,
              "--n-font-weight-active": fontWeightActive,
              "--n-item-line-height": itemLineHeight
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("breadcrumb", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "nav",
            { class: [`${this.mergedClsPrefix}-breadcrumb`, this.themeClass], style: this.cssVars, "aria-label": "Breadcrumb" },
            vue.h("ul", null, this.$slots)
          );
        }
      });
      const useBrowserLocation = (customWindow = isBrowser$2 ? window : null) => {
        const getWindowLocation = () => {
          const { hash, host, hostname, href, origin, pathname, port, protocol: protocol2, search } = (customWindow === null || customWindow === void 0 ? void 0 : customWindow.location) || {};
          return {
            hash,
            host,
            hostname,
            href,
            origin,
            pathname,
            port,
            protocol: protocol2,
            search
          };
        };
        const updateLocation = () => {
          locationState.value = getWindowLocation();
        };
        const locationState = vue.ref(getWindowLocation());
        vue.onMounted(() => {
          if (customWindow) {
            customWindow.addEventListener("popstate", updateLocation);
            customWindow.addEventListener("hashchange", updateLocation);
          }
        });
        vue.onUnmounted(() => {
          if (customWindow) {
            customWindow.removeEventListener("popstate", updateLocation);
            customWindow.removeEventListener("hashchange", updateLocation);
          }
        });
        return locationState;
      };
      const breadcrumbItemProps = {
        separator: String,
        href: String,
        clickable: {
          type: Boolean,
          default: true
        },
        onClick: Function
      };
      const BreadcrumbItem = vue.defineComponent({
        name: "BreadcrumbItem",
        props: breadcrumbItemProps,
        setup(props, { slots }) {
          const NBreadcrumb = vue.inject(breadcrumbInjectionKey, null);
          if (!NBreadcrumb) {
            return () => null;
          }
          const { separatorRef, mergedClsPrefixRef } = NBreadcrumb;
          const browserLocationRef = useBrowserLocation();
          const htmlTagRef = vue.computed(() => props.href ? "a" : "span");
          const ariaCurrentRef = vue.computed(() => browserLocationRef.value.href === props.href ? "location" : null);
          return () => {
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            return vue.h(
              "li",
              { class: [
                `${mergedClsPrefix}-breadcrumb-item`,
                props.clickable && `${mergedClsPrefix}-breadcrumb-item--clickable`
              ] },
              vue.h(htmlTagRef.value, {
                class: `${mergedClsPrefix}-breadcrumb-item__link`,
                "aria-current": ariaCurrentRef.value,
                href: props.href,
                onClick: props.onClick
              }, slots),
              vue.h("span", { class: `${mergedClsPrefix}-breadcrumb-item__separator`, "aria-hidden": "true" }, resolveSlot(slots.separator, () => {
                var _a;
                return [
                  (_a = props.separator) !== null && _a !== void 0 ? _a : separatorRef.value
                ];
              }))
            );
          };
        }
      });
      function createHoverColor(rgb) {
        return composite(rgb, [255, 255, 255, 0.16]);
      }
      function createPressedColor(rgb) {
        return composite(rgb, [0, 0, 0, 0.12]);
      }
      const buttonGroupInjectionKey = createInjectionKey("n-button-group");
      const commonVariables$f = {
        paddingTiny: "0 6px",
        paddingSmall: "0 10px",
        paddingMedium: "0 14px",
        paddingLarge: "0 18px",
        paddingRoundTiny: "0 10px",
        paddingRoundSmall: "0 14px",
        paddingRoundMedium: "0 18px",
        paddingRoundLarge: "0 22px",
        iconMarginTiny: "6px",
        iconMarginSmall: "6px",
        iconMarginMedium: "6px",
        iconMarginLarge: "6px",
        iconSizeTiny: "14px",
        iconSizeSmall: "18px",
        iconSizeMedium: "18px",
        iconSizeLarge: "20px",
        rippleDuration: ".6s"
      };
      const self$_ = (vars) => {
        const { heightTiny, heightSmall, heightMedium, heightLarge, borderRadius, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, opacityDisabled, textColor2, textColor3, primaryColorHover, primaryColorPressed, borderColor, primaryColor, baseColor, infoColor, infoColorHover, infoColorPressed, successColor, successColorHover, successColorPressed, warningColor, warningColorHover, warningColorPressed, errorColor, errorColorHover, errorColorPressed, fontWeight, buttonColor2, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
        return Object.assign(Object.assign({}, commonVariables$f), {
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadiusTiny: borderRadius,
          borderRadiusSmall: borderRadius,
          borderRadiusMedium: borderRadius,
          borderRadiusLarge: borderRadius,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          opacityDisabled,
          // secondary
          colorOpacitySecondary: "0.16",
          colorOpacitySecondaryHover: "0.22",
          colorOpacitySecondaryPressed: "0.28",
          colorSecondary: buttonColor2,
          colorSecondaryHover: buttonColor2Hover,
          colorSecondaryPressed: buttonColor2Pressed,
          // tertiary
          colorTertiary: buttonColor2,
          colorTertiaryHover: buttonColor2Hover,
          colorTertiaryPressed: buttonColor2Pressed,
          // quaternary
          colorQuaternary: "#0000",
          colorQuaternaryHover: buttonColor2Hover,
          colorQuaternaryPressed: buttonColor2Pressed,
          // default type
          color: "#0000",
          colorHover: "#0000",
          colorPressed: "#0000",
          colorFocus: "#0000",
          colorDisabled: "#0000",
          textColor: textColor2,
          textColorTertiary: textColor3,
          textColorHover: primaryColorHover,
          textColorPressed: primaryColorPressed,
          textColorFocus: primaryColorHover,
          textColorDisabled: textColor2,
          textColorText: textColor2,
          textColorTextHover: primaryColorHover,
          textColorTextPressed: primaryColorPressed,
          textColorTextFocus: primaryColorHover,
          textColorTextDisabled: textColor2,
          textColorGhost: textColor2,
          textColorGhostHover: primaryColorHover,
          textColorGhostPressed: primaryColorPressed,
          textColorGhostFocus: primaryColorHover,
          textColorGhostDisabled: textColor2,
          border: `1px solid ${borderColor}`,
          borderHover: `1px solid ${primaryColorHover}`,
          borderPressed: `1px solid ${primaryColorPressed}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          borderDisabled: `1px solid ${borderColor}`,
          rippleColor: primaryColor,
          // primary
          colorPrimary: primaryColor,
          colorHoverPrimary: primaryColorHover,
          colorPressedPrimary: primaryColorPressed,
          colorFocusPrimary: primaryColorHover,
          colorDisabledPrimary: primaryColor,
          textColorPrimary: baseColor,
          textColorHoverPrimary: baseColor,
          textColorPressedPrimary: baseColor,
          textColorFocusPrimary: baseColor,
          textColorDisabledPrimary: baseColor,
          textColorTextPrimary: primaryColor,
          textColorTextHoverPrimary: primaryColorHover,
          textColorTextPressedPrimary: primaryColorPressed,
          textColorTextFocusPrimary: primaryColorHover,
          textColorTextDisabledPrimary: textColor2,
          textColorGhostPrimary: primaryColor,
          textColorGhostHoverPrimary: primaryColorHover,
          textColorGhostPressedPrimary: primaryColorPressed,
          textColorGhostFocusPrimary: primaryColorHover,
          textColorGhostDisabledPrimary: primaryColor,
          borderPrimary: `1px solid ${primaryColor}`,
          borderHoverPrimary: `1px solid ${primaryColorHover}`,
          borderPressedPrimary: `1px solid ${primaryColorPressed}`,
          borderFocusPrimary: `1px solid ${primaryColorHover}`,
          borderDisabledPrimary: `1px solid ${primaryColor}`,
          rippleColorPrimary: primaryColor,
          // info
          colorInfo: infoColor,
          colorHoverInfo: infoColorHover,
          colorPressedInfo: infoColorPressed,
          colorFocusInfo: infoColorHover,
          colorDisabledInfo: infoColor,
          textColorInfo: baseColor,
          textColorHoverInfo: baseColor,
          textColorPressedInfo: baseColor,
          textColorFocusInfo: baseColor,
          textColorDisabledInfo: baseColor,
          textColorTextInfo: infoColor,
          textColorTextHoverInfo: infoColorHover,
          textColorTextPressedInfo: infoColorPressed,
          textColorTextFocusInfo: infoColorHover,
          textColorTextDisabledInfo: textColor2,
          textColorGhostInfo: infoColor,
          textColorGhostHoverInfo: infoColorHover,
          textColorGhostPressedInfo: infoColorPressed,
          textColorGhostFocusInfo: infoColorHover,
          textColorGhostDisabledInfo: infoColor,
          borderInfo: `1px solid ${infoColor}`,
          borderHoverInfo: `1px solid ${infoColorHover}`,
          borderPressedInfo: `1px solid ${infoColorPressed}`,
          borderFocusInfo: `1px solid ${infoColorHover}`,
          borderDisabledInfo: `1px solid ${infoColor}`,
          rippleColorInfo: infoColor,
          // success
          colorSuccess: successColor,
          colorHoverSuccess: successColorHover,
          colorPressedSuccess: successColorPressed,
          colorFocusSuccess: successColorHover,
          colorDisabledSuccess: successColor,
          textColorSuccess: baseColor,
          textColorHoverSuccess: baseColor,
          textColorPressedSuccess: baseColor,
          textColorFocusSuccess: baseColor,
          textColorDisabledSuccess: baseColor,
          textColorTextSuccess: successColor,
          textColorTextHoverSuccess: successColorHover,
          textColorTextPressedSuccess: successColorPressed,
          textColorTextFocusSuccess: successColorHover,
          textColorTextDisabledSuccess: textColor2,
          textColorGhostSuccess: successColor,
          textColorGhostHoverSuccess: successColorHover,
          textColorGhostPressedSuccess: successColorPressed,
          textColorGhostFocusSuccess: successColorHover,
          textColorGhostDisabledSuccess: successColor,
          borderSuccess: `1px solid ${successColor}`,
          borderHoverSuccess: `1px solid ${successColorHover}`,
          borderPressedSuccess: `1px solid ${successColorPressed}`,
          borderFocusSuccess: `1px solid ${successColorHover}`,
          borderDisabledSuccess: `1px solid ${successColor}`,
          rippleColorSuccess: successColor,
          // warning
          colorWarning: warningColor,
          colorHoverWarning: warningColorHover,
          colorPressedWarning: warningColorPressed,
          colorFocusWarning: warningColorHover,
          colorDisabledWarning: warningColor,
          textColorWarning: baseColor,
          textColorHoverWarning: baseColor,
          textColorPressedWarning: baseColor,
          textColorFocusWarning: baseColor,
          textColorDisabledWarning: baseColor,
          textColorTextWarning: warningColor,
          textColorTextHoverWarning: warningColorHover,
          textColorTextPressedWarning: warningColorPressed,
          textColorTextFocusWarning: warningColorHover,
          textColorTextDisabledWarning: textColor2,
          textColorGhostWarning: warningColor,
          textColorGhostHoverWarning: warningColorHover,
          textColorGhostPressedWarning: warningColorPressed,
          textColorGhostFocusWarning: warningColorHover,
          textColorGhostDisabledWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderPressedWarning: `1px solid ${warningColorPressed}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          borderDisabledWarning: `1px solid ${warningColor}`,
          rippleColorWarning: warningColor,
          // error
          colorError: errorColor,
          colorHoverError: errorColorHover,
          colorPressedError: errorColorPressed,
          colorFocusError: errorColorHover,
          colorDisabledError: errorColor,
          textColorError: baseColor,
          textColorHoverError: baseColor,
          textColorPressedError: baseColor,
          textColorFocusError: baseColor,
          textColorDisabledError: baseColor,
          textColorTextError: errorColor,
          textColorTextHoverError: errorColorHover,
          textColorTextPressedError: errorColorPressed,
          textColorTextFocusError: errorColorHover,
          textColorTextDisabledError: textColor2,
          textColorGhostError: errorColor,
          textColorGhostHoverError: errorColorHover,
          textColorGhostPressedError: errorColorPressed,
          textColorGhostFocusError: errorColorHover,
          textColorGhostDisabledError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderPressedError: `1px solid ${errorColorPressed}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          borderDisabledError: `1px solid ${errorColor}`,
          rippleColorError: errorColor,
          waveOpacity: "0.6",
          fontWeight,
          fontWeightStrong
        });
      };
      const buttonLight = {
        name: "Button",
        common: commonLight,
        self: self$_
      };
      const buttonLight$1 = buttonLight;
      const buttonDark = {
        name: "Button",
        common: commonDark,
        self(vars) {
          const commonSelf = self$_(vars);
          commonSelf.waveOpacity = "0.8";
          commonSelf.colorOpacitySecondary = "0.16";
          commonSelf.colorOpacitySecondaryHover = "0.2";
          commonSelf.colorOpacitySecondaryPressed = "0.12";
          return commonSelf;
        }
      };
      const buttonDark$1 = buttonDark;
      const style$1a = c$1([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE("border", {
        borderColor: "var(--n-border-color)"
      }), cM("disabled", [cE("border", {
        borderColor: "var(--n-border-color-disabled)"
      })]), cNotM("disabled", [c$1("&:focus", [cE("state-border", {
        borderColor: "var(--n-border-color-focus)"
      })]), c$1("&:hover", [cE("state-border", {
        borderColor: "var(--n-border-color-hover)"
      })]), c$1("&:active", [cE("state-border", {
        borderColor: "var(--n-border-color-pressed)"
      })]), cM("pressed", [cE("state-border", {
        borderColor: "var(--n-border-color-pressed)"
      })])])]), cM("disabled", {
        backgroundColor: "var(--n-color-disabled)",
        color: "var(--n-text-color-disabled)"
      }, [cE("border", {
        border: "var(--n-border-disabled)"
      })]), cNotM("disabled", [c$1("&:focus", {
        backgroundColor: "var(--n-color-focus)",
        color: "var(--n-text-color-focus)"
      }, [cE("state-border", {
        border: "var(--n-border-focus)"
      })]), c$1("&:hover", {
        backgroundColor: "var(--n-color-hover)",
        color: "var(--n-text-color-hover)"
      }, [cE("state-border", {
        border: "var(--n-border-hover)"
      })]), c$1("&:active", {
        backgroundColor: "var(--n-color-pressed)",
        color: "var(--n-text-color-pressed)"
      }, [cE("state-border", {
        border: "var(--n-border-pressed)"
      })]), cM("pressed", {
        backgroundColor: "var(--n-color-pressed)",
        color: "var(--n-text-color-pressed)"
      }, [cE("state-border", {
        border: "var(--n-border-pressed)"
      })])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
        zIndex: 1,
        animationName: "button-wave-spread, button-wave-opacity"
      })]), isBrowser$2 && "MozBoxSizing" in document.createElement("div").style ? c$1("&::moz-focus-inner", {
        border: 0
      }) : null, cE("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE("border", {
        border: "var(--n-border)"
      }), cE("state-border", {
        border: "var(--n-border)",
        borderColor: "#0000",
        zIndex: 1
      }), cE("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
        top: "50%",
        originalTransform: "translateY(-50%)"
      })]), fadeInWidthExpandTransition()]), cE("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c$1("~", [cE("icon", {
        margin: "var(--n-icon-margin)",
        marginRight: 0
      })])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE("border, state-border", {
        borderStyle: "dashed !important"
      })]), cM("disabled", {
        cursor: "not-allowed",
        opacity: "var(--n-opacity-disabled)"
      })]), c$1("@keyframes button-wave-spread", {
        from: {
          boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
        },
        to: {
          // don't use exact 5px since chrome will display the animation with glitches
          boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
        }
      }), c$1("@keyframes button-wave-opacity", {
        from: {
          opacity: "var(--n-wave-opacity)"
        },
        to: {
          opacity: 0
        }
      })]);
      const buttonProps = Object.assign(Object.assign({}, useTheme.props), { color: String, textColor: String, text: Boolean, block: Boolean, loading: Boolean, disabled: Boolean, circle: Boolean, size: String, ghost: Boolean, round: Boolean, secondary: Boolean, tertiary: Boolean, quaternary: Boolean, strong: Boolean, focusable: {
        type: Boolean,
        default: true
      }, keyboard: {
        type: Boolean,
        default: true
      }, tag: {
        type: String,
        default: "button"
      }, type: {
        type: String,
        default: "default"
      }, dashed: Boolean, renderIcon: Function, iconPlacement: {
        type: String,
        default: "left"
      }, attrType: {
        type: String,
        default: "button"
      }, bordered: {
        type: Boolean,
        default: true
      }, onClick: [Function, Array], nativeFocusBehavior: {
        type: Boolean,
        default: !isSafari
      } });
      const Button = vue.defineComponent({
        name: "Button",
        props: buttonProps,
        setup(props) {
          const selfElRef = vue.ref(null);
          const waveElRef = vue.ref(null);
          const enterPressedRef = vue.ref(false);
          const showBorderRef = useMemo(() => {
            return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
          });
          const NButtonGroup2 = vue.inject(buttonGroupInjectionKey, {});
          const { mergedSizeRef } = useFormItem({}, {
            defaultSize: "medium",
            mergedSize: (NFormItem2) => {
              const { size: size2 } = props;
              if (size2)
                return size2;
              const { size: buttonGroupSize } = NButtonGroup2;
              if (buttonGroupSize)
                return buttonGroupSize;
              const { mergedSize: formItemSize2 } = NFormItem2 || {};
              if (formItemSize2) {
                return formItemSize2.value;
              }
              return "medium";
            }
          });
          const mergedFocusableRef = vue.computed(() => {
            return props.focusable && !props.disabled;
          });
          const handleMousedown = (e) => {
            var _a;
            if (!mergedFocusableRef.value) {
              e.preventDefault();
            }
            if (props.nativeFocusBehavior) {
              return;
            }
            e.preventDefault();
            if (props.disabled) {
              return;
            }
            if (mergedFocusableRef.value) {
              (_a = selfElRef.value) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            }
          };
          const handleClick2 = (e) => {
            var _a;
            if (!props.disabled && !props.loading) {
              const { onClick } = props;
              if (onClick)
                call(onClick, e);
              if (!props.text) {
                (_a = waveElRef.value) === null || _a === void 0 ? void 0 : _a.play();
              }
            }
          };
          const handleKeyup = (e) => {
            switch (e.key) {
              case "Enter":
                if (!props.keyboard) {
                  return;
                }
                enterPressedRef.value = false;
            }
          };
          const handleKeydown = (e) => {
            switch (e.key) {
              case "Enter":
                if (!props.keyboard || props.loading) {
                  e.preventDefault();
                  return;
                }
                enterPressedRef.value = true;
            }
          };
          const handleBlur = () => {
            enterPressedRef.value = false;
          };
          const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Button", "-button", style$1a, buttonLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const theme = themeRef.value;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: self2 } = theme;
            const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self2;
            const size2 = mergedSizeRef.value;
            const { dashed, type: type2, ghost, text, color, round: round2, circle, textColor, secondary, tertiary, quaternary, strong } = props;
            const fontProps = {
              "font-weight": strong ? fontWeightStrong : fontWeight
            };
            let colorProps = {
              "--n-color": "initial",
              "--n-color-hover": "initial",
              "--n-color-pressed": "initial",
              "--n-color-focus": "initial",
              "--n-color-disabled": "initial",
              "--n-ripple-color": "initial",
              "--n-text-color": "initial",
              "--n-text-color-hover": "initial",
              "--n-text-color-pressed": "initial",
              "--n-text-color-focus": "initial",
              "--n-text-color-disabled": "initial"
            };
            const typeIsTertiary = type2 === "tertiary";
            const typeIsDefault = type2 === "default";
            const mergedType = typeIsTertiary ? "default" : type2;
            if (text) {
              const propTextColor = textColor || color;
              const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
              colorProps = {
                "--n-color": "#0000",
                "--n-color-hover": "#0000",
                "--n-color-pressed": "#0000",
                "--n-color-focus": "#0000",
                "--n-color-disabled": "#0000",
                "--n-ripple-color": "#0000",
                "--n-text-color": mergedTextColor,
                "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
                "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
                "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
                "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
              };
            } else if (ghost || dashed) {
              const mergedTextColor = textColor || color;
              colorProps = {
                "--n-color": "#0000",
                "--n-color-hover": "#0000",
                "--n-color-pressed": "#0000",
                "--n-color-focus": "#0000",
                "--n-color-disabled": "#0000",
                "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
                "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
                "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
                "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
                "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
                "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
              };
            } else if (secondary) {
              const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
              const mergedTextColor = color || typeTextColor;
              const isColoredType = type2 !== "default" && type2 !== "tertiary";
              colorProps = {
                "--n-color": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondary)
                }) : self2.colorSecondary,
                "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondaryHover)
                }) : self2.colorSecondaryHover,
                "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondaryPressed)
                }) : self2.colorSecondaryPressed,
                "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondaryHover)
                }) : self2.colorSecondaryHover,
                "--n-color-disabled": self2.colorSecondary,
                "--n-ripple-color": "#0000",
                "--n-text-color": mergedTextColor,
                "--n-text-color-hover": mergedTextColor,
                "--n-text-color-pressed": mergedTextColor,
                "--n-text-color-focus": mergedTextColor,
                "--n-text-color-disabled": mergedTextColor
              };
            } else if (tertiary || quaternary) {
              const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
              const mergedColor = color || typeColor;
              if (tertiary) {
                colorProps["--n-color"] = self2.colorTertiary;
                colorProps["--n-color-hover"] = self2.colorTertiaryHover;
                colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
                colorProps["--n-color-focus"] = self2.colorSecondaryHover;
                colorProps["--n-color-disabled"] = self2.colorTertiary;
              } else {
                colorProps["--n-color"] = self2.colorQuaternary;
                colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
                colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
                colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
                colorProps["--n-color-disabled"] = self2.colorQuaternary;
              }
              colorProps["--n-ripple-color"] = "#0000";
              colorProps["--n-text-color"] = mergedColor;
              colorProps["--n-text-color-hover"] = mergedColor;
              colorProps["--n-text-color-pressed"] = mergedColor;
              colorProps["--n-text-color-focus"] = mergedColor;
              colorProps["--n-text-color-disabled"] = mergedColor;
            } else {
              colorProps = {
                "--n-color": color || self2[createKey("color", mergedType)],
                "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
                "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
                "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
                "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
                "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
                "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
                "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
                "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
                "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
                "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
              };
            }
            let borderProps = {
              "--n-border": "initial",
              "--n-border-hover": "initial",
              "--n-border-pressed": "initial",
              "--n-border-focus": "initial",
              "--n-border-disabled": "initial"
            };
            if (text) {
              borderProps = {
                "--n-border": "none",
                "--n-border-hover": "none",
                "--n-border-pressed": "none",
                "--n-border-focus": "none",
                "--n-border-disabled": "none"
              };
            } else {
              borderProps = {
                "--n-border": self2[createKey("border", mergedType)],
                "--n-border-hover": self2[createKey("borderHover", mergedType)],
                "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
                "--n-border-focus": self2[createKey("borderFocus", mergedType)],
                "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
              };
            }
            const { [createKey("height", size2)]: height, [createKey("fontSize", size2)]: fontSize2, [createKey("padding", size2)]: padding, [createKey("paddingRound", size2)]: paddingRound, [createKey("iconSize", size2)]: iconSize, [createKey("borderRadius", size2)]: borderRadius, [createKey("iconMargin", size2)]: iconMargin, waveOpacity } = self2;
            const sizeProps = {
              "--n-width": circle && !text ? height : "initial",
              "--n-height": text ? "initial" : height,
              "--n-font-size": fontSize2,
              "--n-padding": circle ? "initial" : text ? "initial" : round2 ? paddingRound : padding,
              "--n-icon-size": iconSize,
              "--n-icon-margin": iconMargin,
              "--n-border-radius": text ? "initial" : circle || round2 ? height : borderRadius
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({ "--n-bezier": cubicBezierEaseInOut2, "--n-bezier-ease-out": cubicBezierEaseOut2, "--n-ripple-duration": rippleDuration, "--n-opacity-disabled": opacityDisabled, "--n-wave-opacity": waveOpacity }, fontProps), colorProps), borderProps), sizeProps);
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", vue.computed(() => {
            let hash = "";
            const { dashed, type: type2, ghost, text, color, round: round2, circle, textColor, secondary, tertiary, quaternary, strong } = props;
            if (dashed)
              hash += "a";
            if (ghost)
              hash += "b";
            if (text)
              hash += "c";
            if (round2)
              hash += "d";
            if (circle)
              hash += "e";
            if (secondary)
              hash += "f";
            if (tertiary)
              hash += "g";
            if (quaternary)
              hash += "h";
            if (strong)
              hash += "i";
            if (color)
              hash += "j" + color2Class(color);
            if (textColor)
              hash += "k" + color2Class(textColor);
            const { value: size2 } = mergedSizeRef;
            hash += "l" + size2[0];
            hash += "m" + type2[0];
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            selfElRef,
            waveElRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedFocusable: mergedFocusableRef,
            mergedSize: mergedSizeRef,
            showBorder: showBorderRef,
            enterPressed: enterPressedRef,
            rtlEnabled: rtlEnabledRef,
            handleMousedown,
            handleKeydown,
            handleBlur,
            handleKeyup,
            handleClick: handleClick2,
            customColorCssVars: vue.computed(() => {
              const { color } = props;
              if (!color)
                return null;
              const hoverColor = createHoverColor(color);
              return {
                "--n-border-color": color,
                "--n-border-color-hover": hoverColor,
                "--n-border-color-pressed": createPressedColor(color),
                "--n-border-color-focus": hoverColor,
                "--n-border-color-disabled": color
              };
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix, tag: Component, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && vue.h("span", { class: `${mergedClsPrefix}-button__content` }, children2));
          return vue.h(
            Component,
            { ref: "selfElRef", class: [
              this.themeClass,
              `${mergedClsPrefix}-button`,
              `${mergedClsPrefix}-button--${this.type}-type`,
              `${mergedClsPrefix}-button--${this.mergedSize}-type`,
              this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
              this.disabled && `${mergedClsPrefix}-button--disabled`,
              this.block && `${mergedClsPrefix}-button--block`,
              this.enterPressed && `${mergedClsPrefix}-button--pressed`,
              !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
              this.color && `${mergedClsPrefix}-button--color`,
              this.secondary && `${mergedClsPrefix}-button--secondary`,
              this.loading && `${mergedClsPrefix}-button--loading`,
              this.ghost && `${mergedClsPrefix}-button--ghost`
              // required for button group border collapse
            ], tabindex: this.mergedFocusable ? 0 : -1, type: this.attrType, style: this.cssVars, disabled: this.disabled, onClick: this.handleClick, onBlur: this.handleBlur, onMousedown: this.handleMousedown, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
            this.iconPlacement === "right" && children,
            vue.h(NFadeInExpandTransition, { width: true }, {
              default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && vue.h(
                "span",
                { class: `${mergedClsPrefix}-button__icon`, style: {
                  margin: isSlotEmpty(this.$slots.default) ? "0" : ""
                } },
                vue.h(NIconSwitchTransition, null, {
                  default: () => this.loading ? vue.h(NBaseLoading, { clsPrefix: mergedClsPrefix, key: "loading", class: `${mergedClsPrefix}-icon-slot`, strokeWidth: 20 }) : vue.h("div", { key: "icon", class: `${mergedClsPrefix}-icon-slot`, role: "none" }, this.renderIcon ? this.renderIcon() : children2)
                })
              ))
            }),
            this.iconPlacement === "left" && children,
            !this.text ? vue.h(NBaseWave, { ref: "waveElRef", clsPrefix: mergedClsPrefix }) : null,
            this.showBorder ? vue.h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__border`, style: this.customColorCssVars }) : null,
            this.showBorder ? vue.h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__state-border`, style: this.customColorCssVars }) : null
          );
        }
      });
      const NButton = Button;
      const XButton = Button;
      const zero = "0!important";
      const n1 = "-1px!important";
      function createLeftBorderStyle(type2) {
        return cM(type2 + "-type", [c$1("& +", [cB("button", {}, [cM(type2 + "-type", [cE("border", {
          borderLeftWidth: zero
        }), cE("state-border", {
          left: n1
        })])])])]);
      }
      function createTopBorderStyle(type2) {
        return cM(type2 + "-type", [c$1("& +", [cB("button", [cM(type2 + "-type", [cE("border", {
          borderTopWidth: zero
        }), cE("state-border", {
          top: n1
        })])])])]);
      }
      const style$19 = cB("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM("vertical", {
        flexDirection: "row"
      }, [cNotM("rtl", [cB("button", [c$1("&:first-child:not(:last-child)", `
 margin-right: ${zero};
 border-top-right-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1("&:last-child:not(:first-child)", `
 margin-left: ${zero};
 border-top-left-radius: ${zero};
 border-bottom-left-radius: ${zero};
 `), c$1("&:not(:first-child):not(:last-child)", `
 margin-left: ${zero};
 margin-right: ${zero};
 border-radius: ${zero};
 `), createLeftBorderStyle("default"), cM("ghost", [createLeftBorderStyle("primary"), createLeftBorderStyle("info"), createLeftBorderStyle("success"), createLeftBorderStyle("warning"), createLeftBorderStyle("error")])])])]), cM("vertical", {
        flexDirection: "column"
      }, [cB("button", [c$1("&:first-child:not(:last-child)", `
 margin-bottom: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-bottom-left-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1("&:last-child:not(:first-child)", `
 margin-top: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-top-left-radius: ${zero};
 border-top-right-radius: ${zero};
 `), c$1("&:not(:first-child):not(:last-child)", `
 margin: ${zero};
 border-radius: ${zero};
 `), createTopBorderStyle("default"), cM("ghost", [createTopBorderStyle("primary"), createTopBorderStyle("info"), createTopBorderStyle("success"), createTopBorderStyle("warning"), createTopBorderStyle("error")])])])]);
      const buttonGroupProps = {
        size: {
          type: String,
          default: void 0
        },
        vertical: Boolean
      };
      const NButtonGroup = vue.defineComponent({
        name: "ButtonGroup",
        props: buttonGroupProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          useStyle("-button-group", style$19, mergedClsPrefixRef);
          vue.provide(buttonGroupInjectionKey, props);
          const rtlEnabledRef = useRtl("ButtonGroup", mergedRtlRef, mergedClsPrefixRef);
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h("div", { class: [
            `${mergedClsPrefix}-button-group`,
            this.rtlEnabled && `${mergedClsPrefix}-button-group--rtl`,
            this.vertical && `${mergedClsPrefix}-button-group--vertical`
          ], role: "group" }, this.$slots);
        }
      });
      const START_YEAR = 1901;
      const MONTH_ITEM_HEIGHT = 40;
      const matcherMap = {
        date: isSameDay,
        month: isSameMonth,
        year: isSameYear,
        quarter: isSameQuarter
      };
      function matchDate(sourceTime, patternTime, type2) {
        const matcher = matcherMap[type2];
        if (Array.isArray(sourceTime)) {
          return sourceTime.some((time2) => matcher(time2, patternTime));
        } else {
          return matcher(sourceTime, patternTime);
        }
      }
      function dateItem(time2, monthTs, valueTs, currentTs) {
        let inSpan = false;
        let startOfSpan = false;
        let endOfSpan = false;
        if (Array.isArray(valueTs)) {
          if (valueTs[0] < time2 && time2 < valueTs[1]) {
            inSpan = true;
          }
          if (matchDate(valueTs[0], time2, "date"))
            startOfSpan = true;
          if (matchDate(valueTs[1], time2, "date"))
            endOfSpan = true;
        }
        const selected = valueTs !== null && (Array.isArray(valueTs) ? matchDate(valueTs[0], time2, "date") || matchDate(valueTs[1], time2, "date") : matchDate(valueTs, time2, "date"));
        return {
          type: "date",
          dateObject: {
            date: getDate(time2),
            month: getMonth(time2),
            year: getYear(time2)
          },
          inCurrentMonth: isSameMonth(time2, monthTs),
          isCurrentDate: matchDate(currentTs, time2, "date"),
          inSpan,
          startOfSpan,
          endOfSpan,
          selected,
          ts: getTime(time2)
        };
      }
      function monthItem(monthTs, valueTs, currentTs) {
        return {
          type: "month",
          dateObject: {
            month: getMonth(monthTs),
            year: getYear(monthTs)
          },
          isCurrent: isSameMonth(currentTs, monthTs),
          selected: valueTs !== null && matchDate(valueTs, monthTs, "month"),
          ts: getTime(monthTs)
        };
      }
      function yearItem(yearTs, valueTs, currentTs) {
        return {
          type: "year",
          dateObject: {
            year: getYear(yearTs)
          },
          isCurrent: isSameYear(currentTs, yearTs),
          selected: valueTs !== null && matchDate(valueTs, yearTs, "year"),
          ts: getTime(yearTs)
        };
      }
      function quarterItem(quarterTs, valueTs, currentTs) {
        return {
          type: "quarter",
          dateObject: {
            quarter: getQuarter(quarterTs),
            year: getYear(quarterTs)
          },
          isCurrent: isSameQuarter(currentTs, quarterTs),
          selected: valueTs !== null && matchDate(valueTs, quarterTs, "quarter"),
          ts: getTime(quarterTs)
        };
      }
      function dateArray(monthTs, valueTs, currentTs, startDay, strip = false) {
        const displayMonth = getMonth(monthTs);
        let displayMonthIterator = getTime(startOfMonth(monthTs));
        let lastMonthIterator = getTime(addDays(displayMonthIterator, -1));
        const calendarDays = [];
        let protectLastMonthDateIsShownFlag = !strip;
        while (getDay(lastMonthIterator) !== startDay || protectLastMonthDateIsShownFlag) {
          calendarDays.unshift(dateItem(lastMonthIterator, monthTs, valueTs, currentTs));
          lastMonthIterator = getTime(addDays(lastMonthIterator, -1));
          protectLastMonthDateIsShownFlag = false;
        }
        while (getMonth(displayMonthIterator) === displayMonth) {
          calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
          displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
        }
        const endIndex = strip ? calendarDays.length <= 28 ? 28 : calendarDays.length <= 35 ? 35 : 42 : 42;
        while (calendarDays.length < endIndex) {
          calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
          displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
        }
        return calendarDays;
      }
      function monthArray(yearAnchorTs, valueTs, currentTs) {
        const calendarMonths = [];
        const yearStart = startOfYear(yearAnchorTs);
        for (let i = 0; i < 12; i++) {
          calendarMonths.push(monthItem(getTime(addMonths(yearStart, i)), valueTs, currentTs));
        }
        return calendarMonths;
      }
      function quarterArray(yearAnchorTs, valueTs, currentTs) {
        const calendarQuarters = [];
        const yearStart = startOfYear(yearAnchorTs);
        for (let i = 0; i < 4; i++) {
          calendarQuarters.push(quarterItem(getTime(addQuarters(yearStart, i)), valueTs, currentTs));
        }
        return calendarQuarters;
      }
      function yearArray(valueTs, currentTs) {
        const calendarYears = [];
        const time1900 = new Date(START_YEAR, 0, 1);
        for (let i = 0; i < 200; i++) {
          calendarYears.push(yearItem(getTime(addYears(time1900, i)), valueTs, currentTs));
        }
        return calendarYears;
      }
      function strictParse(string2, pattern2, backup, option) {
        const result = parse$1(string2, pattern2, backup, option);
        if (!isValid$1(result))
          return result;
        else if (format$4(result, pattern2, option) === string2)
          return result;
        else
          return /* @__PURE__ */ new Date(NaN);
      }
      function getDefaultTime(timeValue) {
        if (timeValue === void 0) {
          return void 0;
        }
        if (typeof timeValue === "number") {
          return timeValue;
        }
        const [hour, minute, second] = timeValue.split(":");
        return {
          hours: Number(hour),
          minutes: Number(minute),
          seconds: Number(second)
        };
      }
      function pluckValueFromRange(value, type2) {
        return Array.isArray(value) ? value[type2 === "start" ? 0 : 1] : null;
      }
      const commonVariables$e = {
        titleFontSize: "22px"
      };
      const self$Z = (vars) => {
        const { borderRadius, fontSize: fontSize2, lineHeight: lineHeight2, textColor2, textColor1, textColorDisabled, dividerColor, fontWeightStrong, primaryColor, baseColor, hoverColor, cardColor, modalColor, popoverColor } = vars;
        return Object.assign(Object.assign({}, commonVariables$e), {
          borderRadius,
          borderColor: composite(cardColor, dividerColor),
          borderColorModal: composite(modalColor, dividerColor),
          borderColorPopover: composite(popoverColor, dividerColor),
          textColor: textColor2,
          titleFontWeight: fontWeightStrong,
          titleTextColor: textColor1,
          dayTextColor: textColorDisabled,
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          dateColorCurrent: primaryColor,
          dateTextColorCurrent: baseColor,
          cellColorHover: composite(cardColor, hoverColor),
          cellColorHoverModal: composite(modalColor, hoverColor),
          cellColorHoverPopover: composite(popoverColor, hoverColor),
          cellColor: cardColor,
          cellColorModal: modalColor,
          cellColorPopover: popoverColor,
          barColor: primaryColor
        });
      };
      const calendarLight = createTheme({
        name: "Calendar",
        common: commonLight,
        peers: {
          Button: buttonLight$1
        },
        self: self$Z
      });
      const calendarLight$1 = calendarLight;
      const calendarDark = {
        name: "Calendar",
        common: commonDark,
        peers: {
          Button: buttonDark$1
        },
        self: self$Z
      };
      const calendarDark$1 = calendarDark;
      const style$18 = c$1([cB("calendar", `
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 height: 720px;
 display: flex;
 flex-direction: column;
 `, [cB("calendar-prev-btn", `
 cursor: pointer;
 `), cB("calendar-next-btn", `
 cursor: pointer;
 `), cB("calendar-header", `
 display: flex;
 align-items: center;
 line-height: 1;
 font-size: var(--n-title-font-size);
 padding: 0 0 18px 0;
 justify-content: space-between;
 `, [cE("title", `
 color: var(--n-title-text-color);
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 `), cE("extra", `
 display: flex;
 align-items: center;
 `)]), cB("calendar-dates", `
 display: grid;
 grid-template-columns: repeat(7, minmax(0, 1fr));
 grid-auto-rows: 1fr;
 border-radius: var(--n-border-radius);
 flex: 1;
 border-top: 1px solid;
 border-left: 1px solid;
 border-color: var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 `), cB("calendar-cell", `
 box-sizing: border-box;
 padding: 10px;
 border-right: 1px solid;
 border-bottom: 1px solid;
 border-color: var(--n-border-color);
 cursor: pointer;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&:nth-child(7)", `
 border-top-right-radius: var(--n-border-radius);
 `), c$1("&:nth-last-child(7)", `
 border-bottom-left-radius: var(--n-border-radius);
 `), c$1("&:last-child", `
 border-bottom-right-radius: var(--n-border-radius);
 `), c$1("&:hover", `
 background-color: var(--n-cell-color-hover);
 `), cE("bar", `
 position: absolute;
 left: 0;
 right: 0;
 bottom: -1px;
 height: 3px;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `), cM("selected", [cE("bar", `
 background-color: var(--n-bar-color);
 `)]), cB("calendar-date", `
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 color: var(--n-text-color);
 `, [cE("date", `
 color: var(--n-text-color);
 `)]), cM("disabled, other-month", `
 color: var(--n-day-text-color);
 `, [cB("calendar-date", [cE("date", `
 color: var(--n-day-text-color);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `), cM("current", [cB("calendar-date", [cE("date", `
 color: var(--n-date-text-color-current);
 background-color: var(--n-date-color-current);
 `)])]), cB("calendar-date", `
 position: relative;
 line-height: 1;
 display: flex;
 align-items: center;
 height: 1em;
 justify-content: space-between;
 padding-bottom: .75em;
 `, [cE("date", `
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 margin-left: -0.4em;
 width: 1.8em;
 height: 1.8em;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cE("day", `
 color: var(--n-day-text-color);
 transition: color .3s var(--n-bezier);
 `)])])]), insideModal(cB("calendar", [cB("calendar-dates", `
 border-color: var(--n-border-color-modal);
 `), cB("calendar-cell", `
 border-color: var(--n-border-color-modal);
 `, [c$1("&:hover", `
 background-color: var(--n-cell-color-hover-modal);
 `)])])), insidePopover(cB("calendar", [cB("calendar-dates", `
 border-color: var(--n-border-color-popover);
 `), cB("calendar-cell", `
 border-color: var(--n-border-color-popover);
 `, [c$1("&:hover", `
 background-color: var(--n-cell-color-hover-popover);
 `)])]))]);
      const calendarProps = Object.assign(Object.assign({}, useTheme.props), { isDateDisabled: Function, value: Number, defaultValue: {
        type: Number,
        default: null
      }, onPanelChange: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
      const Calendar = vue.defineComponent({
        name: "Calendar",
        props: calendarProps,
        setup(props) {
          var _a;
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Calendar", "-calendar", style$18, calendarLight$1, props, mergedClsPrefixRef);
          const { localeRef, dateLocaleRef } = useLocale("DatePicker");
          const now2 = Date.now();
          const monthTsRef = vue.ref(startOfMonth((_a = props.defaultValue) !== null && _a !== void 0 ? _a : now2).valueOf());
          const uncontrolledValueRef = vue.ref(props.defaultValue || null);
          const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
          function doUpdateValue(value, time2) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
            if (onUpdateValue) {
              call(onUpdateValue, value, time2);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value, time2);
            }
            uncontrolledValueRef.value = value;
          }
          function handlePrevClick() {
            var _a2;
            const monthTs = addMonths(monthTsRef.value, -1).valueOf();
            monthTsRef.value = monthTs;
            (_a2 = props.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, {
              year: getYear(monthTs),
              month: getMonth(monthTs) + 1
            });
          }
          function handleNextClick() {
            var _a2;
            const monthTs = addMonths(monthTsRef.value, 1).valueOf();
            monthTsRef.value = monthTs;
            (_a2 = props.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, {
              year: getYear(monthTs),
              month: getMonth(monthTs) + 1
            });
          }
          function handleTodayClick() {
            var _a2;
            const { value: monthTs } = monthTsRef;
            const oldYear = getYear(monthTs);
            const oldMonth = getMonth(monthTs);
            const newMonthTs = startOfMonth(now2).valueOf();
            monthTsRef.value = newMonthTs;
            const newYear = getYear(newMonthTs);
            const newMonth = getMonth(newMonthTs);
            if (oldYear !== newYear || oldMonth !== newMonth) {
              (_a2 = props.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, {
                year: newYear,
                month: newMonth + 1
              });
            }
          }
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { borderColor, borderColorModal, borderColorPopover, borderRadius, titleFontSize, textColor, titleFontWeight, titleTextColor, dayTextColor, fontSize: fontSize2, lineHeight: lineHeight2, dateColorCurrent, dateTextColorCurrent, cellColorHover, cellColor, cellColorModal, barColor, cellColorPopover, cellColorHoverModal, cellColorHoverPopover } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-color": borderColor,
              "--n-border-color-modal": borderColorModal,
              "--n-border-color-popover": borderColorPopover,
              "--n-border-radius": borderRadius,
              "--n-text-color": textColor,
              "--n-title-font-weight": titleFontWeight,
              "--n-title-font-size": titleFontSize,
              "--n-title-text-color": titleTextColor,
              "--n-day-text-color": dayTextColor,
              "--n-font-size": fontSize2,
              "--n-line-height": lineHeight2,
              "--n-date-color-current": dateColorCurrent,
              "--n-date-text-color-current": dateTextColorCurrent,
              "--n-cell-color": cellColor,
              "--n-cell-color-modal": cellColorModal,
              "--n-cell-color-popover": cellColorPopover,
              "--n-cell-color-hover": cellColorHover,
              "--n-cell-color-hover-modal": cellColorHoverModal,
              "--n-cell-color-hover-popover": cellColorHoverPopover,
              "--n-bar-color": barColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("calendar", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            locale: localeRef,
            dateLocale: dateLocaleRef,
            now: now2,
            mergedValue: mergedValueRef,
            monthTs: monthTsRef,
            dateItems: vue.computed(() => {
              return dateArray(monthTsRef.value, mergedValueRef.value, now2, localeRef.value.firstDayOfWeek, true);
            }),
            doUpdateValue,
            handleTodayClick,
            handlePrevClick,
            handleNextClick,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { isDateDisabled, mergedClsPrefix, monthTs, cssVars, mergedValue, mergedTheme, $slots, locale: { monthBeforeYear, today }, dateLocale: { locale: locale2 }, handleTodayClick, handlePrevClick, handleNextClick, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const normalizedValue = mergedValue && startOfDay(mergedValue).valueOf();
          const year = getYear(monthTs);
          const calendarMonth = getMonth(monthTs) + 1;
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-calendar`, this.themeClass], style: cssVars },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-calendar-header` },
              vue.h("div", { class: `${mergedClsPrefix}-calendar-header__title` }, resolveSlotWithProps($slots.header, { year, month: calendarMonth }, () => {
                const localeMonth = format$4(monthTs, "MMMM", { locale: locale2 });
                return [
                  monthBeforeYear ? `${localeMonth} ${year}` : `${year} ${localeMonth}`
                ];
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-calendar-header__extra` },
                vue.h(NButtonGroup, null, {
                  default: () => vue.h(
                    vue.Fragment,
                    null,
                    vue.h(NButton, { size: "small", onClick: handlePrevClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, {
                      icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-calendar-prev-btn` }, { default: () => vue.h(ChevronLeftIcon, null) })
                    }),
                    vue.h(NButton, { size: "small", onClick: handleTodayClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => today }),
                    vue.h(NButton, { size: "small", onClick: handleNextClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, {
                      icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-calendar-next-btn` }, { default: () => vue.h(ChevronRightIcon, null) })
                    })
                  )
                })
              )
            ),
            vue.h("div", { class: `${mergedClsPrefix}-calendar-dates` }, this.dateItems.map(({ dateObject, ts, inCurrentMonth, isCurrentDate }, index) => {
              var _a;
              const { year: year2, month, date: date2 } = dateObject;
              const fullDate = format$4(ts, "yyyy-MM-dd");
              const notInCurrentMonth = !inCurrentMonth;
              const disabled = (isDateDisabled === null || isDateDisabled === void 0 ? void 0 : isDateDisabled(ts)) === true;
              const selected = normalizedValue === startOfDay(ts).valueOf();
              return vue.h(
                "div",
                { key: `${calendarMonth}-${index}`, class: [
                  `${mergedClsPrefix}-calendar-cell`,
                  disabled && `${mergedClsPrefix}-calendar-cell--disabled`,
                  notInCurrentMonth && `${mergedClsPrefix}-calendar-cell--other-month`,
                  disabled && `${mergedClsPrefix}-calendar-cell--not-allowed`,
                  isCurrentDate && `${mergedClsPrefix}-calendar-cell--current`,
                  selected && `${mergedClsPrefix}-calendar-cell--selected`
                ], onClick: () => {
                  var _a2;
                  if (disabled)
                    return;
                  const monthTs2 = startOfMonth(ts).valueOf();
                  this.monthTs = monthTs2;
                  if (notInCurrentMonth) {
                    (_a2 = this.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(this, {
                      year: getYear(monthTs2),
                      month: getMonth(monthTs2) + 1
                    });
                  }
                  this.doUpdateValue(ts, {
                    year: year2,
                    month: month + 1,
                    date: date2
                  });
                } },
                vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-calendar-date` },
                  vue.h("div", { class: `${mergedClsPrefix}-calendar-date__date`, title: fullDate }, date2),
                  index < 7 && vue.h("div", { class: `${mergedClsPrefix}-calendar-date__day`, title: fullDate }, format$4(ts, "EEE", {
                    locale: locale2
                  }))
                ),
                (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots, {
                  year: year2,
                  month: month + 1,
                  date: date2
                }),
                vue.h("div", { class: `${mergedClsPrefix}-calendar-cell__bar` })
              );
            }))
          );
        }
      });
      const self$Y = (vars) => {
        const { fontSize: fontSize2, boxShadow2, popoverColor, textColor2, borderRadius, borderColor, heightSmall, heightMedium, heightLarge, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor } = vars;
        return {
          panelFontSize: fontSize2,
          boxShadow: boxShadow2,
          color: popoverColor,
          textColor: textColor2,
          borderRadius,
          border: `1px solid ${borderColor}`,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          dividerColor
        };
      };
      const colorPickerLight = createTheme({
        name: "ColorPicker",
        common: commonLight,
        peers: {
          Input: inputLight$1,
          Button: buttonLight$1
        },
        self: self$Y
      });
      const colorPickerLight$1 = colorPickerLight;
      const colorPickerDark = {
        name: "ColorPicker",
        common: commonDark,
        peers: {
          Input: inputDark$1,
          Button: buttonDark$1
        },
        self: self$Y
      };
      const colorPickerDark$1 = colorPickerDark;
      function deriveDefaultValue(modes, showAlpha) {
        const mode = modes[0];
        switch (mode) {
          case "hex":
            return showAlpha ? "#000000FF" : "#000000";
          case "rgb":
            return showAlpha ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
          case "hsl":
            return showAlpha ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
          case "hsv":
            return showAlpha ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
        }
        return "#000000";
      }
      function getModeFromValue(color) {
        if (color === null)
          return null;
        if (/^ *#/.test(color))
          return "hex";
        if (color.includes("rgb"))
          return "rgb";
        if (color.includes("hsl"))
          return "hsl";
        if (color.includes("hsv"))
          return "hsv";
        return null;
      }
      function normalizeHue(hue) {
        hue = Math.round(hue);
        return hue >= 360 ? 359 : hue < 0 ? 0 : hue;
      }
      function normalizeAlpha(alpha) {
        alpha = Math.round(alpha * 100) / 100;
        return alpha > 1 ? 1 : alpha < 0 ? 0 : alpha;
      }
      const convert = {
        rgb: {
          hex(value) {
            return toHexaString(rgba(value));
          },
          hsl(value) {
            const [r, g, b, a2] = rgba(value);
            return toHslaString([...rgb2hsl(r, g, b), a2]);
          },
          hsv(value) {
            const [r, g, b, a2] = rgba(value);
            return toHsvaString([...rgb2hsv(r, g, b), a2]);
          }
        },
        hex: {
          rgb(value) {
            return toRgbaString(rgba(value));
          },
          hsl(value) {
            const [r, g, b, a2] = rgba(value);
            return toHslaString([...rgb2hsl(r, g, b), a2]);
          },
          hsv(value) {
            const [r, g, b, a2] = rgba(value);
            return toHsvaString([...rgb2hsv(r, g, b), a2]);
          }
        },
        hsl: {
          hex(value) {
            const [h2, s, l, a2] = hsla(value);
            return toHexaString([...hsl2rgb(h2, s, l), a2]);
          },
          rgb(value) {
            const [h2, s, l, a2] = hsla(value);
            return toRgbaString([...hsl2rgb(h2, s, l), a2]);
          },
          hsv(value) {
            const [h2, s, l, a2] = hsla(value);
            return toHsvaString([...hsl2hsv(h2, s, l), a2]);
          }
        },
        hsv: {
          hex(value) {
            const [h2, s, v, a2] = hsva(value);
            return toHexaString([...hsv2rgb(h2, s, v), a2]);
          },
          rgb(value) {
            const [h2, s, v, a2] = hsva(value);
            return toRgbaString([...hsv2rgb(h2, s, v), a2]);
          },
          hsl(value) {
            const [h2, s, v, a2] = hsva(value);
            return toHslaString([...hsv2hsl(h2, s, v), a2]);
          }
        }
      };
      function convertColor(value, mode, originalMode) {
        originalMode = originalMode || getModeFromValue(value);
        if (!originalMode)
          return null;
        if (originalMode === mode)
          return value;
        const conversions = convert[originalMode];
        return conversions[mode](value);
      }
      const HANDLE_SIZE$2 = "12px";
      const HANDLE_SIZE_NUM$1 = 12;
      const RADIUS$2 = "6px";
      const RADIUS_NUM = 6;
      const GRADIENT = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)";
      const HueSlider = vue.defineComponent({
        name: "HueSlider",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          hue: {
            type: Number,
            required: true
          },
          onUpdateHue: {
            type: Function,
            required: true
          },
          onComplete: Function
        },
        setup(props) {
          const railRef = vue.ref(null);
          function handleMouseDown(e) {
            if (!railRef.value)
              return;
            on("mousemove", document, handleMouseMove);
            on("mouseup", document, handleMouseUp);
            handleMouseMove(e);
          }
          function handleMouseMove(e) {
            const { value: railEl } = railRef;
            if (!railEl)
              return;
            const { width, left } = railEl.getBoundingClientRect();
            const newHue = normalizeHue((e.clientX - left - RADIUS_NUM) / (width - HANDLE_SIZE_NUM$1) * 360);
            props.onUpdateHue(newHue);
          }
          function handleMouseUp() {
            var _a;
            off("mousemove", document, handleMouseMove);
            off("mouseup", document, handleMouseUp);
            (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return {
            railRef,
            handleMouseDown
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-color-picker-slider`, style: {
              height: HANDLE_SIZE$2,
              borderRadius: RADIUS$2
            } },
            vue.h(
              "div",
              { ref: "railRef", style: {
                boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)",
                boxSizing: "border-box",
                backgroundImage: GRADIENT,
                height: HANDLE_SIZE$2,
                borderRadius: RADIUS$2,
                position: "relative"
              }, onMousedown: this.handleMouseDown },
              vue.h(
                "div",
                { style: {
                  position: "absolute",
                  left: RADIUS$2,
                  right: RADIUS$2,
                  top: 0,
                  bottom: 0
                } },
                vue.h(
                  "div",
                  { class: `${clsPrefix}-color-picker-handle`, style: {
                    left: `calc((${this.hue}%) / 359 * 100 - ${RADIUS$2})`,
                    borderRadius: RADIUS$2,
                    width: HANDLE_SIZE$2,
                    height: HANDLE_SIZE$2
                  } },
                  vue.h("div", { class: `${clsPrefix}-color-picker-handle__fill`, style: {
                    backgroundColor: `hsl(${this.hue}, 100%, 50%)`,
                    borderRadius: RADIUS$2,
                    width: HANDLE_SIZE$2,
                    height: HANDLE_SIZE$2
                  } })
                )
              )
            )
          );
        }
      });
      const HANDLE_SIZE$1 = "12px";
      const HANDLE_SIZE_NUM = 12;
      const RADIUS$1 = "6px";
      const AlphaSlider = vue.defineComponent({
        name: "AlphaSlider",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          rgba: {
            type: Array,
            default: null
          },
          alpha: {
            type: Number,
            default: 0
          },
          onUpdateAlpha: {
            type: Function,
            required: true
          },
          onComplete: Function
        },
        setup(props) {
          const railRef = vue.ref(null);
          function handleMouseDown(e) {
            if (!railRef.value || !props.rgba)
              return;
            on("mousemove", document, handleMouseMove);
            on("mouseup", document, handleMouseUp);
            handleMouseMove(e);
          }
          function handleMouseMove(e) {
            const { value: railEl } = railRef;
            if (!railEl)
              return;
            const { width, left } = railEl.getBoundingClientRect();
            const newAlpha = (e.clientX - left) / (width - HANDLE_SIZE_NUM);
            props.onUpdateAlpha(normalizeAlpha(newAlpha));
          }
          function handleMouseUp() {
            var _a;
            off("mousemove", document, handleMouseMove);
            off("mouseup", document, handleMouseUp);
            (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return {
            railRef,
            railBackgroundImage: vue.computed(() => {
              const { rgba: rgba2 } = props;
              if (!rgba2)
                return "";
              return `linear-gradient(to right, rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, 0) 0%, rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, 1) 100%)`;
            }),
            handleMouseDown
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-color-picker-slider`, ref: "railRef", style: {
              height: HANDLE_SIZE$1,
              borderRadius: RADIUS$1
            }, onMousedown: this.handleMouseDown },
            vue.h(
              "div",
              { style: {
                borderRadius: RADIUS$1,
                position: "absolute",
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                overflow: "hidden"
              } },
              vue.h("div", { class: `${clsPrefix}-color-picker-checkboard` }),
              vue.h("div", { class: `${clsPrefix}-color-picker-slider__image`, style: {
                backgroundImage: this.railBackgroundImage
              } })
            ),
            this.rgba && vue.h(
              "div",
              { style: {
                position: "absolute",
                left: RADIUS$1,
                right: RADIUS$1,
                top: 0,
                bottom: 0
              } },
              vue.h(
                "div",
                { class: `${clsPrefix}-color-picker-handle`, style: {
                  left: `calc(${this.alpha * 100}% - ${RADIUS$1})`,
                  borderRadius: RADIUS$1,
                  width: HANDLE_SIZE$1,
                  height: HANDLE_SIZE$1
                } },
                vue.h("div", { class: `${clsPrefix}-color-picker-handle__fill`, style: {
                  backgroundColor: toRgbaString(this.rgba),
                  borderRadius: RADIUS$1,
                  width: HANDLE_SIZE$1,
                  height: HANDLE_SIZE$1
                } })
              )
            )
          );
        }
      });
      const HANDLE_SIZE = "12px";
      const RADIUS = "6px";
      const Pallete = vue.defineComponent({
        name: "Pallete",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          rgba: {
            type: Array,
            default: null
          },
          // 0 - 360
          displayedHue: {
            type: Number,
            required: true
          },
          displayedSv: {
            type: Array,
            required: true
          },
          onUpdateSV: {
            type: Function,
            required: true
          },
          onComplete: Function
        },
        setup(props) {
          const palleteRef = vue.ref(null);
          function handleMouseDown(e) {
            if (!palleteRef.value)
              return;
            on("mousemove", document, handleMouseMove);
            on("mouseup", document, handleMouseUp);
            handleMouseMove(e);
          }
          function handleMouseMove(e) {
            const { value: palleteEl } = palleteRef;
            if (!palleteEl)
              return;
            const { width, height, left, bottom } = palleteEl.getBoundingClientRect();
            const newV = (bottom - e.clientY) / height;
            const newS = (e.clientX - left) / width;
            const normalizedNewS = 100 * (newS > 1 ? 1 : newS < 0 ? 0 : newS);
            const normalizedNewV = 100 * (newV > 1 ? 1 : newV < 0 ? 0 : newV);
            props.onUpdateSV(normalizedNewS, normalizedNewV);
          }
          function handleMouseUp() {
            var _a;
            off("mousemove", document, handleMouseMove);
            off("mouseup", document, handleMouseUp);
            (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return {
            palleteRef,
            handleColor: vue.computed(() => {
              const { rgba: rgba2 } = props;
              if (!rgba2)
                return "";
              return `rgb(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]})`;
            }),
            handleMouseDown
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" },
            vue.h("div", { class: `${clsPrefix}-color-picker-pallete__layer`, style: {
              backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))`
            } }),
            vue.h("div", { class: `${clsPrefix}-color-picker-pallete__layer ${clsPrefix}-color-picker-pallete__layer--shadowed`, style: {
              backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))"
            } }),
            this.rgba && vue.h(
              "div",
              { class: `${clsPrefix}-color-picker-handle`, style: {
                width: HANDLE_SIZE,
                height: HANDLE_SIZE,
                borderRadius: RADIUS,
                left: `calc(${this.displayedSv[0]}% - ${RADIUS})`,
                bottom: `calc(${this.displayedSv[1]}% - ${RADIUS})`
              } },
              vue.h("div", { class: `${clsPrefix}-color-picker-handle__fill`, style: {
                backgroundColor: this.handleColor,
                borderRadius: RADIUS,
                width: HANDLE_SIZE,
                height: HANDLE_SIZE
              } })
            )
          );
        }
      });
      const colorPickerInjectionKey = createInjectionKey("n-color-picker");
      function normalizeRgbUnit(value) {
        if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value), 255));
        }
        return false;
      }
      function normalizeHueUnit(value) {
        if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value), 360));
        }
        return false;
      }
      function normalizeSlvUnit(value) {
        if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value), 100));
        }
        return false;
      }
      function normalizeHexaUnit(value) {
        const trimmedValue = value.trim();
        if (/^#[0-9a-fA-F]+$/.test(trimmedValue)) {
          return [4, 5, 7, 9].includes(trimmedValue.length);
        }
        return false;
      }
      function normalizeAlphaUnit(value) {
        if (/^\d{1,3}\.?\d*%$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value) / 100, 100));
        }
        return false;
      }
      const inputThemeOverrides = {
        paddingSmall: "0 4px"
      };
      const ColorInputUnit = vue.defineComponent({
        name: "ColorInputUnit",
        props: {
          label: {
            type: String,
            required: true
          },
          value: {
            type: [Number, String],
            default: null
          },
          showAlpha: Boolean,
          onUpdateValue: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const inputValueRef = vue.ref("");
          const { themeRef } = vue.inject(colorPickerInjectionKey, null);
          vue.watchEffect(() => {
            inputValueRef.value = getInputString();
          });
          function getInputString() {
            const { value } = props;
            if (value === null)
              return "";
            const { label } = props;
            if (label === "HEX") {
              return value;
            }
            if (label === "A") {
              return `${Math.floor(value * 100)}%`;
            }
            return String(Math.floor(value));
          }
          function handleInputUpdateValue(value) {
            inputValueRef.value = value;
          }
          function handleInputChange(value) {
            let unit;
            let valid;
            switch (props.label) {
              case "HEX":
                valid = normalizeHexaUnit(value);
                if (valid) {
                  props.onUpdateValue(value);
                }
                inputValueRef.value = getInputString();
                break;
              case "H":
                unit = normalizeHueUnit(value);
                if (unit === false) {
                  inputValueRef.value = getInputString();
                } else {
                  props.onUpdateValue(unit);
                }
                break;
              case "S":
              case "L":
              case "V":
                unit = normalizeSlvUnit(value);
                if (unit === false) {
                  inputValueRef.value = getInputString();
                } else {
                  props.onUpdateValue(unit);
                }
                break;
              case "A":
                unit = normalizeAlphaUnit(value);
                if (unit === false) {
                  inputValueRef.value = getInputString();
                } else {
                  props.onUpdateValue(unit);
                }
                break;
              case "R":
              case "G":
              case "B":
                unit = normalizeRgbUnit(value);
                if (unit === false) {
                  inputValueRef.value = getInputString();
                } else {
                  props.onUpdateValue(unit);
                }
                break;
            }
          }
          return {
            mergedTheme: themeRef,
            inputValue: inputValueRef,
            handleInputChange,
            handleInputUpdateValue
          };
        },
        render() {
          const { mergedTheme } = this;
          return vue.h(NInput, {
            size: "small",
            placeholder: this.label,
            theme: mergedTheme.peers.Input,
            themeOverrides: mergedTheme.peerOverrides.Input,
            builtinThemeOverrides: inputThemeOverrides,
            value: this.inputValue,
            onUpdateValue: this.handleInputUpdateValue,
            onChange: this.handleInputChange,
            // add more space for xxx% input
            style: this.label === "A" ? "flex-grow: 1.25;" : ""
          });
        }
      });
      const ColorInput = vue.defineComponent({
        name: "ColorInput",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          mode: {
            type: String,
            required: true
          },
          modes: {
            type: Array,
            required: true
          },
          showAlpha: {
            type: Boolean,
            required: true
          },
          value: {
            // for hex to get percise value
            type: String,
            default: null
          },
          valueArr: {
            type: Array,
            default: null
          },
          onUpdateValue: {
            type: Function,
            required: true
          },
          onUpdateMode: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          return {
            handleUnitUpdateValue(index, value) {
              const { showAlpha } = props;
              if (props.mode === "hex") {
                props.onUpdateValue((showAlpha ? toHexaString : toHexString)(value));
                return;
              }
              let nextValueArr;
              if (props.valueArr === null) {
                nextValueArr = [0, 0, 0, 0];
              } else {
                nextValueArr = Array.from(props.valueArr);
              }
              switch (props.mode) {
                case "hsv":
                  nextValueArr[index] = value;
                  props.onUpdateValue((showAlpha ? toHsvaString : toHsvString)(nextValueArr));
                  break;
                case "rgb":
                  nextValueArr[index] = value;
                  props.onUpdateValue((showAlpha ? toRgbaString : toRgbString)(nextValueArr));
                  break;
                case "hsl":
                  nextValueArr[index] = value;
                  props.onUpdateValue((showAlpha ? toHslaString : toHslString)(nextValueArr));
                  break;
              }
            }
          };
        },
        render() {
          const { clsPrefix, modes } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-color-picker-input` },
            vue.h("div", { class: `${clsPrefix}-color-picker-input__mode`, onClick: this.onUpdateMode, style: {
              cursor: modes.length === 1 ? "" : "pointer"
            } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")),
            vue.h(NInputGroup, null, {
              default: () => {
                const { mode, valueArr, showAlpha } = this;
                if (mode === "hex") {
                  let hexValue = null;
                  try {
                    hexValue = valueArr === null ? null : (showAlpha ? toHexaString : toHexString)(valueArr);
                  } catch (_a) {
                  }
                  return vue.h(ColorInputUnit, { label: "HEX", showAlpha, value: hexValue, onUpdateValue: (unitValue) => {
                    this.handleUnitUpdateValue(0, unitValue);
                  } });
                }
                return (mode + (showAlpha ? "a" : "")).split("").map((v, i) => vue.h(ColorInputUnit, { label: v.toUpperCase(), value: valueArr === null ? null : valueArr[i], onUpdateValue: (unitValue) => {
                  this.handleUnitUpdateValue(i, unitValue);
                } }));
              }
            })
          );
        }
      });
      const ColorPickerTrigger = vue.defineComponent({
        name: "ColorPickerTrigger",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          value: {
            type: String,
            default: null
          },
          hsla: {
            type: Array,
            default: null
          },
          disabled: Boolean,
          onClick: Function
        },
        setup(props) {
          const { colorPickerSlots, renderLabelRef } = vue.inject(colorPickerInjectionKey, null);
          return () => {
            const { hsla: hsla2, value, clsPrefix, onClick, disabled } = props;
            const renderLabel = colorPickerSlots.label || renderLabelRef.value;
            return vue.h(
              "div",
              { class: [
                `${clsPrefix}-color-picker-trigger`,
                disabled && `${clsPrefix}-color-picker-trigger--disabled`
              ], onClick: disabled ? void 0 : onClick },
              vue.h(
                "div",
                { class: `${clsPrefix}-color-picker-trigger__fill` },
                vue.h("div", { class: `${clsPrefix}-color-picker-checkboard` }),
                vue.h("div", { style: {
                  position: "absolute",
                  left: 0,
                  right: 0,
                  top: 0,
                  bottom: 0,
                  backgroundColor: hsla2 ? toHslaString(hsla2) : ""
                } }),
                value && hsla2 ? vue.h("div", { class: `${clsPrefix}-color-picker-trigger__value`, style: {
                  color: hsla2[2] > 50 || hsla2[3] < 0.5 ? "black" : "white"
                } }, renderLabel ? renderLabel(value) : value) : null
              )
            );
          };
        }
      });
      function normalizeColor(color, mode) {
        if (mode === "hsv") {
          const [h2, s, v, a2] = hsva(color);
          return toRgbaString([...hsv2rgb(h2, s, v), a2]);
        }
        return color;
      }
      function getHexFromName(color) {
        const ctx2 = document.createElement("canvas").getContext("2d");
        ctx2.fillStyle = color;
        return ctx2.fillStyle;
      }
      const ColorPickerSwatches = vue.defineComponent({
        name: "ColorPickerSwatches",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          mode: {
            type: String,
            required: true
          },
          swatches: {
            type: Array,
            required: true
          },
          onUpdateColor: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const parsedSwatchesRef = vue.computed(() => props.swatches.map((value) => {
            const mode = getModeFromValue(value);
            return {
              value,
              mode,
              legalValue: normalizeColor(value, mode)
            };
          }));
          function normalizeOutput(parsed) {
            const { mode: modeProp } = props;
            let { value, mode: swatchColorMode } = parsed;
            if (!swatchColorMode) {
              swatchColorMode = "hex";
              if (/^[a-zA-Z]+$/.test(value)) {
                value = getHexFromName(value);
              } else {
                warn$2("color-picker", `color ${value} in swatches is invalid.`);
                value = "#000000";
              }
            }
            if (swatchColorMode === modeProp)
              return value;
            return convertColor(value, modeProp, swatchColorMode);
          }
          function handleSwatchSelect(parsed) {
            props.onUpdateColor(normalizeOutput(parsed));
          }
          function handleSwatchKeyDown(e, parsed) {
            if (e.key === "Enter")
              handleSwatchSelect(parsed);
          }
          return {
            parsedSwatchesRef,
            handleSwatchSelect,
            handleSwatchKeyDown
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h("div", { class: `${clsPrefix}-color-picker-swatches` }, this.parsedSwatchesRef.map((swatch) => vue.h(
            "div",
            { class: `${clsPrefix}-color-picker-swatch`, tabindex: 0, onClick: () => {
              this.handleSwatchSelect(swatch);
            }, onKeydown: (e) => {
              this.handleSwatchKeyDown(e, swatch);
            } },
            vue.h("div", { class: `${clsPrefix}-color-picker-swatch__fill`, style: { background: swatch.legalValue } })
          )));
        }
      });
      const ColorPreview = vue.defineComponent({
        name: "ColorPreview",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          mode: {
            type: String,
            required: true
          },
          color: {
            type: String,
            default: null,
            validator: (value) => {
              const mode = getModeFromValue(value);
              return Boolean(!value || mode && mode !== "hsv");
            }
          },
          onUpdateColor: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          function handleChange(e) {
            var _a;
            const value = e.target.value;
            (_a = props.onUpdateColor) === null || _a === void 0 ? void 0 : _a.call(props, convertColor(value.toUpperCase(), props.mode, "hex"));
            e.stopPropagation();
          }
          return {
            handleChange
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-color-picker-preview__preview` },
            vue.h("span", { class: `${clsPrefix}-color-picker-preview__fill`, style: {
              background: this.color || "#000000"
            } }),
            vue.h("input", { class: `${clsPrefix}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange })
          );
        }
      });
      const style$17 = c$1([cB("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), cB("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition(), cB("input", `
 text-align: center;
 `)]), cB("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [c$1("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [cE("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), c$1("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), cB("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [cE("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), cB("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [cE("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), cB("color-picker-preview", `
 display: flex;
 `, [cE("sliders", `
 flex: 1 0 auto;
 `), cE("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), cE("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), cE("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), cB("color-picker-input", `
 display: flex;
 align-items: center;
 `, [cB("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), cE("mode", `
 width: 72px;
 text-align: center;
 `)]), cB("color-picker-control", `
 padding: 12px;
 `), cB("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [cB("button", "margin-left: 8px;")]), cB("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [cE("value", `
 white-space: nowrap;
 position: relative;
 `), cE("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), cM("disabled", "cursor: not-allowed"), cB("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [c$1("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), cB("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [cB("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [cE("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), c$1("&:focus", `
 outline: none;
 `, [cE("fill", [c$1("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]);
      const colorPickerProps = Object.assign(Object.assign({}, useTheme.props), { value: String, show: {
        type: Boolean,
        default: void 0
      }, defaultShow: Boolean, defaultValue: String, modes: {
        type: Array,
        // no hsva by default since browser doesn't support it
        default: () => ["rgb", "hex", "hsl"]
      }, placement: {
        type: String,
        default: "bottom-start"
      }, to: useAdjustedTo.propTo, showAlpha: {
        type: Boolean,
        default: true
      }, showPreview: Boolean, swatches: Array, disabled: {
        type: Boolean,
        default: void 0
      }, actions: {
        type: Array,
        default: null
      }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
      const NColorPicker = vue.defineComponent({
        name: "ColorPicker",
        props: colorPickerProps,
        setup(props, { slots }) {
          const selfRef = vue.ref(null);
          let upcomingValue = null;
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const { localeRef } = useLocale("global");
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("ColorPicker", "-color-picker", style$17, colorPickerLight$1, props, mergedClsPrefixRef);
          vue.provide(colorPickerInjectionKey, {
            themeRef,
            renderLabelRef: vue.toRef(props, "renderLabel"),
            colorPickerSlots: slots
          });
          const uncontrolledShowRef = vue.ref(props.defaultShow);
          const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
          function doUpdateShow(value) {
            const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow)
              call(onUpdateShow, value);
            if (_onUpdateShow)
              call(_onUpdateShow, value);
            uncontrolledShowRef.value = value;
          }
          const { defaultValue } = props;
          const uncontrolledValueRef = vue.ref(defaultValue === void 0 ? deriveDefaultValue(props.modes, props.showAlpha) : defaultValue);
          const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
          const undoStackRef = vue.ref([mergedValueRef.value]);
          const valueIndexRef = vue.ref(0);
          const valueModeRef = vue.computed(() => getModeFromValue(mergedValueRef.value));
          const { modes } = props;
          const displayedModeRef = vue.ref(getModeFromValue(mergedValueRef.value) || modes[0] || "rgb");
          function handleUpdateDisplayedMode() {
            const { modes: modes2 } = props;
            const { value: displayedMode } = displayedModeRef;
            const currentModeIndex = modes2.findIndex((mode) => mode === displayedMode);
            if (~currentModeIndex) {
              displayedModeRef.value = modes2[(currentModeIndex + 1) % modes2.length];
            } else {
              displayedModeRef.value = "rgb";
            }
          }
          let _h, s, l, v, r, g, b, a2;
          const hsvaRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (!mergedValue)
              return null;
            switch (valueModeRef.value) {
              case "hsv":
                return hsva(mergedValue);
              case "hsl":
                [_h, s, l, a2] = hsla(mergedValue);
                return [...hsl2hsv(_h, s, l), a2];
              case "rgb":
              case "hex":
                [r, g, b, a2] = rgba(mergedValue);
                return [...rgb2hsv(r, g, b), a2];
            }
          });
          const rgbaRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (!mergedValue)
              return null;
            switch (valueModeRef.value) {
              case "rgb":
              case "hex":
                return rgba(mergedValue);
              case "hsv":
                [_h, s, v, a2] = hsva(mergedValue);
                return [...hsv2rgb(_h, s, v), a2];
              case "hsl":
                [_h, s, l, a2] = hsla(mergedValue);
                return [...hsl2rgb(_h, s, l), a2];
            }
          });
          const hslaRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (!mergedValue)
              return null;
            switch (valueModeRef.value) {
              case "hsl":
                return hsla(mergedValue);
              case "hsv":
                [_h, s, v, a2] = hsva(mergedValue);
                return [...hsv2hsl(_h, s, v), a2];
              case "rgb":
              case "hex":
                [r, g, b, a2] = rgba(mergedValue);
                return [...rgb2hsl(r, g, b), a2];
            }
          });
          const mergedValueArrRef = vue.computed(() => {
            switch (displayedModeRef.value) {
              case "rgb":
              case "hex":
                return rgbaRef.value;
              case "hsv":
                return hsvaRef.value;
              case "hsl":
                return hslaRef.value;
            }
          });
          const displayedHueRef = vue.ref(0);
          const displayedAlphaRef = vue.ref(1);
          const displayedSvRef = vue.ref([0, 0]);
          function handleUpdateSv(s2, v2) {
            const { value: hsvaArr } = hsvaRef;
            const hue = displayedHueRef.value;
            const alpha = hsvaArr ? hsvaArr[3] : 1;
            displayedSvRef.value = [s2, v2];
            const { showAlpha } = props;
            switch (displayedModeRef.value) {
              case "hsv":
                doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, alpha]), "cursor");
                break;
              case "hsl":
                doUpdateValue((showAlpha ? toHslaString : toHslString)([
                  ...hsv2hsl(hue, s2, v2),
                  alpha
                ]), "cursor");
                break;
              case "rgb":
                doUpdateValue((showAlpha ? toRgbaString : toRgbString)([
                  ...hsv2rgb(hue, s2, v2),
                  alpha
                ]), "cursor");
                break;
              case "hex":
                doUpdateValue((showAlpha ? toHexaString : toHexString)([
                  ...hsv2rgb(hue, s2, v2),
                  alpha
                ]), "cursor");
                break;
            }
          }
          function handleUpdateHue(hue) {
            displayedHueRef.value = hue;
            const { value: hsvaArr } = hsvaRef;
            if (!hsvaArr) {
              return;
            }
            const [, s2, v2, a3] = hsvaArr;
            const { showAlpha } = props;
            switch (displayedModeRef.value) {
              case "hsv":
                doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, a3]), "cursor");
                break;
              case "rgb":
                doUpdateValue((showAlpha ? toRgbaString : toRgbString)([
                  ...hsv2rgb(hue, s2, v2),
                  a3
                ]), "cursor");
                break;
              case "hex":
                doUpdateValue((showAlpha ? toHexaString : toHexString)([
                  ...hsv2rgb(hue, s2, v2),
                  a3
                ]), "cursor");
                break;
              case "hsl":
                doUpdateValue((showAlpha ? toHslaString : toHslString)([
                  ...hsv2hsl(hue, s2, v2),
                  a3
                ]), "cursor");
                break;
            }
          }
          function handleUpdateAlpha(alpha) {
            switch (displayedModeRef.value) {
              case "hsv":
                [_h, s, v] = hsvaRef.value;
                doUpdateValue(toHsvaString([_h, s, v, alpha]), "cursor");
                break;
              case "rgb":
                [r, g, b] = rgbaRef.value;
                doUpdateValue(toRgbaString([r, g, b, alpha]), "cursor");
                break;
              case "hex":
                [r, g, b] = rgbaRef.value;
                doUpdateValue(toHexaString([r, g, b, alpha]), "cursor");
                break;
              case "hsl":
                [_h, s, l] = hslaRef.value;
                doUpdateValue(toHslaString([_h, s, l, alpha]), "cursor");
                break;
            }
            displayedAlphaRef.value = alpha;
          }
          function doUpdateValue(value, updateSource) {
            if (updateSource === "cursor") {
              upcomingValue = value;
            } else {
              upcomingValue = null;
            }
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            nTriggerFormChange();
            nTriggerFormInput();
            uncontrolledValueRef.value = value;
          }
          function handleInputUpdateValue(value) {
            doUpdateValue(value, "input");
            void vue.nextTick(handleComplete);
          }
          function handleComplete(pushStack = true) {
            const { value } = mergedValueRef;
            if (value) {
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              const { onComplete } = props;
              if (onComplete) {
                onComplete(value);
              }
              const { value: undoStack } = undoStackRef;
              const { value: valueIndex } = valueIndexRef;
              if (pushStack) {
                undoStack.splice(valueIndex + 1, undoStack.length, value);
                valueIndexRef.value = valueIndex + 1;
              }
              nTriggerFormChange();
              nTriggerFormInput();
            }
          }
          function undo() {
            const { value: valueIndex } = valueIndexRef;
            if (valueIndex - 1 < 0)
              return;
            doUpdateValue(undoStackRef.value[valueIndex - 1], "input");
            handleComplete(false);
            valueIndexRef.value = valueIndex - 1;
          }
          function redo() {
            const { value: valueIndex } = valueIndexRef;
            if (valueIndex < 0 || valueIndex + 1 >= undoStackRef.value.length)
              return;
            doUpdateValue(undoStackRef.value[valueIndex + 1], "input");
            handleComplete(false);
            valueIndexRef.value = valueIndex + 1;
          }
          function handleClear() {
            doUpdateValue(null, "input");
            doUpdateShow(false);
          }
          function handleConfirm() {
            const { value } = mergedValueRef;
            const { onConfirm } = props;
            if (onConfirm) {
              onConfirm(value);
            }
            doUpdateShow(false);
          }
          const undoableRef = vue.computed(() => valueIndexRef.value >= 1);
          const redoableRef = vue.computed(() => {
            const { value: undoStack } = undoStackRef;
            return undoStack.length > 1 && valueIndexRef.value < undoStack.length - 1;
          });
          vue.watch(mergedShowRef, (value) => {
            if (!value) {
              undoStackRef.value = [mergedValueRef.value];
              valueIndexRef.value = 0;
            }
          });
          vue.watchEffect(() => {
            if (upcomingValue && upcomingValue === mergedValueRef.value)
              ;
            else {
              const { value } = hsvaRef;
              if (value) {
                displayedHueRef.value = value[0];
                displayedAlphaRef.value = value[3];
                displayedSvRef.value = [value[1], value[2]];
              }
            }
            upcomingValue = null;
          });
          const cssVarsRef = vue.computed(() => {
            const { value: mergedSize } = mergedSizeRef;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { textColor, color, panelFontSize, boxShadow, border, borderRadius, dividerColor, [createKey("height", mergedSize)]: height, [createKey("fontSize", mergedSize)]: fontSize2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-color": color,
              "--n-panel-font-size": panelFontSize,
              "--n-font-size": fontSize2,
              "--n-box-shadow": boxShadow,
              "--n-border": border,
              "--n-border-radius": borderRadius,
              "--n-height": height,
              "--n-divider-color": dividerColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("color-picker", vue.computed(() => {
            return mergedSizeRef.value[0];
          }), cssVarsRef, props) : void 0;
          function renderPanel() {
            var _a;
            const { value: rgba2 } = rgbaRef;
            const { value: displayedHue } = displayedHueRef;
            const { internalActions, modes: modes2, actions } = props;
            const { value: mergedTheme } = themeRef;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            return vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-color-picker-panel`,
                themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value
              ], onDragstart: (e) => {
                e.preventDefault();
              }, style: inlineThemeDisabled ? void 0 : cssVarsRef.value },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-color-picker-control` },
                vue.h(Pallete, { clsPrefix: mergedClsPrefix, rgba: rgba2, displayedHue, displayedSv: displayedSvRef.value, onUpdateSV: handleUpdateSv, onComplete: handleComplete }),
                vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-color-picker-preview` },
                  vue.h(
                    "div",
                    { class: `${mergedClsPrefix}-color-picker-preview__sliders` },
                    vue.h(HueSlider, { clsPrefix: mergedClsPrefix, hue: displayedHue, onUpdateHue: handleUpdateHue, onComplete: handleComplete }),
                    props.showAlpha ? vue.h(AlphaSlider, { clsPrefix: mergedClsPrefix, rgba: rgba2, alpha: displayedAlphaRef.value, onUpdateAlpha: handleUpdateAlpha, onComplete: handleComplete }) : null
                  ),
                  props.showPreview ? vue.h(ColorPreview, { clsPrefix: mergedClsPrefix, mode: displayedModeRef.value, color: rgbaRef.value && toHexString(rgbaRef.value), onUpdateColor: (color) => {
                    doUpdateValue(color, "input");
                  } }) : null
                ),
                vue.h(ColorInput, { clsPrefix: mergedClsPrefix, showAlpha: props.showAlpha, mode: displayedModeRef.value, modes: modes2, onUpdateMode: handleUpdateDisplayedMode, value: mergedValueRef.value, valueArr: mergedValueArrRef.value, onUpdateValue: handleInputUpdateValue }),
                ((_a = props.swatches) === null || _a === void 0 ? void 0 : _a.length) && vue.h(ColorPickerSwatches, { clsPrefix: mergedClsPrefix, mode: displayedModeRef.value, swatches: props.swatches, onUpdateColor: (color) => {
                  doUpdateValue(color, "input");
                } })
              ),
              (actions === null || actions === void 0 ? void 0 : actions.length) ? vue.h(
                "div",
                { class: `${mergedClsPrefix}-color-picker-action` },
                actions.includes("confirm") && vue.h(NButton, { size: "small", onClick: handleConfirm, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.confirm }),
                actions.includes("clear") && vue.h(NButton, { size: "small", onClick: handleClear, disabled: !mergedValueRef.value, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.clear })
              ) : null,
              slots.action ? vue.h("div", { class: `${mergedClsPrefix}-color-picker-action` }, { default: slots.action }) : internalActions ? vue.h(
                "div",
                { class: `${mergedClsPrefix}-color-picker-action` },
                internalActions.includes("undo") && vue.h(NButton, { size: "small", onClick: undo, disabled: !undoableRef.value, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.undo }),
                internalActions.includes("redo") && vue.h(NButton, { size: "small", onClick: redo, disabled: !redoableRef.value, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.redo })
              ) : null
            );
          }
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            selfRef,
            hsla: hslaRef,
            rgba: rgbaRef,
            mergedShow: mergedShowRef,
            mergedDisabled: mergedDisabledRef,
            isMounted: isMounted(),
            adjustedTo: useAdjustedTo(props),
            mergedValue: mergedValueRef,
            handleTriggerClick() {
              doUpdateShow(true);
            },
            handleClickOutside(e) {
              var _a;
              if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
                return;
              }
              doUpdateShow(false);
            },
            renderPanel,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [this.themeClass, `${mergedClsPrefix}-color-picker`], ref: "selfRef", style: this.cssVars },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h(ColorPickerTrigger, { clsPrefix: mergedClsPrefix, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }, {
                    label: $slots.label
                  })
                }),
                vue.h(VFollower, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, to: this.adjustedTo }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                    default: () => this.mergedShow ? vue.withDirectives(this.renderPanel(), [
                      [
                        clickoutside$1,
                        this.handleClickOutside,
                        void 0,
                        { capture: true }
                      ]
                    ]) : null
                  })
                })
              ]
            })
          );
        }
      });
      const commonVariables$d = {
        paddingSmall: "12px 16px 12px",
        paddingMedium: "19px 24px 20px",
        paddingLarge: "23px 32px 24px",
        paddingHuge: "27px 40px 28px",
        titleFontSizeSmall: "16px",
        titleFontSizeMedium: "18px",
        titleFontSizeLarge: "18px",
        titleFontSizeHuge: "18px",
        closeIconSize: "18px",
        closeSize: "22px"
      };
      const self$X = (vars) => {
        const { primaryColor, borderRadius, lineHeight: lineHeight2, fontSize: fontSize2, cardColor, textColor2, textColor1, dividerColor, fontWeightStrong, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, modalColor, boxShadow1, popoverColor, actionColor } = vars;
        return Object.assign(Object.assign({}, commonVariables$d), {
          lineHeight: lineHeight2,
          color: cardColor,
          colorModal: modalColor,
          colorPopover: popoverColor,
          colorTarget: primaryColor,
          colorEmbedded: actionColor,
          colorEmbeddedModal: actionColor,
          colorEmbeddedPopover: actionColor,
          textColor: textColor2,
          titleTextColor: textColor1,
          borderColor: dividerColor,
          actionColor,
          titleFontWeight: fontWeightStrong,
          closeColorHover,
          closeColorPressed,
          closeBorderRadius: borderRadius,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          fontSizeSmall: fontSize2,
          fontSizeMedium: fontSize2,
          fontSizeLarge: fontSize2,
          fontSizeHuge: fontSize2,
          boxShadow: boxShadow1,
          borderRadius
        });
      };
      const cardLight = {
        name: "Card",
        common: commonLight,
        self: self$X
      };
      const cardLight$1 = cardLight;
      const cardDark = {
        name: "Card",
        common: commonDark,
        self(vars) {
          const commonSelf = self$X(vars);
          const { cardColor, modalColor, popoverColor } = vars;
          commonSelf.colorEmbedded = cardColor;
          commonSelf.colorEmbeddedModal = modalColor;
          commonSelf.colorEmbeddedPopover = popoverColor;
          return commonSelf;
        }
      };
      const cardDark$1 = cardDark;
      const style$16 = c$1([cB("card", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
        background: "var(--n-color-modal)"
      }), cM("hoverable", [c$1("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c$1(">", [cE("content", {
        paddingTop: "var(--n-padding-bottom)"
      })])]), cM("content-soft-segmented", [c$1(">", [cE("content", `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM("footer-segmented", [c$1(">", [cE("footer", {
        paddingTop: "var(--n-padding-bottom)"
      })])]), cM("footer-soft-segmented", [c$1(">", [cE("footer", `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c$1(">", [cB("card-header", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE("main", `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE("extra", `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("close", `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("action", `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE("content", "flex: 1; min-width: 0;"), cE("content, footer", `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c$1("&:first-child", {
        paddingTop: "var(--n-padding-bottom)"
      })]), cE("action", `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB("card-cover", `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c$1("img", `
 display: block;
 width: 100%;
 `)]), cM("bordered", `
 border: 1px solid var(--n-border-color);
 `, [c$1("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c$1(">", [cE("action", [c$1("&:not(:first-child)", {
        borderTop: "1px solid var(--n-border-color)"
      })])])]), cM("content-segmented, content-soft-segmented", [c$1(">", [cE("content", {
        transition: "border-color 0.3s var(--n-bezier)"
      }, [c$1("&:not(:first-child)", {
        borderTop: "1px solid var(--n-border-color)"
      })])])]), cM("footer-segmented, footer-soft-segmented", [c$1(">", [cE("footer", {
        transition: "border-color 0.3s var(--n-bezier)"
      }, [c$1("&:not(:first-child)", {
        borderTop: "1px solid var(--n-border-color)"
      })])])]), cM("embedded", `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB("card", `
 background: var(--n-color-modal);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB("card", `
 background: var(--n-color-popover);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-popover);
 `)]))]);
      const cardBaseProps = {
        title: String,
        contentStyle: [Object, String],
        headerStyle: [Object, String],
        headerExtraStyle: [Object, String],
        footerStyle: [Object, String],
        embedded: Boolean,
        segmented: {
          type: [Boolean, Object],
          default: false
        },
        size: {
          type: String,
          default: "medium"
        },
        bordered: {
          type: Boolean,
          default: true
        },
        closable: Boolean,
        hoverable: Boolean,
        role: String,
        onClose: [Function, Array],
        tag: {
          type: String,
          default: "div"
        }
      };
      const cardBasePropKeys = keysOf(cardBaseProps);
      const cardProps = Object.assign(Object.assign({}, useTheme.props), cardBaseProps);
      const NCard = vue.defineComponent({
        name: "Card",
        props: cardProps,
        setup(props) {
          const handleCloseClick = () => {
            const { onClose } = props;
            if (onClose)
              call(onClose);
          };
          const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Card", "-card", style$16, cardLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { self: { color, colorModal, colorTarget, textColor, titleTextColor, titleFontWeight, borderColor, actionColor, borderRadius, lineHeight: lineHeight2, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeBorderRadius, closeIconSize, closeSize, boxShadow, colorPopover, colorEmbedded, colorEmbeddedModal, colorEmbeddedPopover, [createKey("padding", size2)]: padding, [createKey("fontSize", size2)]: fontSize2, [createKey("titleFontSize", size2)]: titleFontSize }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            const { top: paddingTop, left: paddingLeft, bottom: paddingBottom } = getMargin(padding);
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-color": color,
              "--n-color-modal": colorModal,
              "--n-color-popover": colorPopover,
              "--n-color-embedded": colorEmbedded,
              "--n-color-embedded-modal": colorEmbeddedModal,
              "--n-color-embedded-popover": colorEmbeddedPopover,
              "--n-color-target": colorTarget,
              "--n-text-color": textColor,
              "--n-line-height": lineHeight2,
              "--n-action-color": actionColor,
              "--n-title-text-color": titleTextColor,
              "--n-title-font-weight": titleFontWeight,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-border-color": borderColor,
              "--n-box-shadow": boxShadow,
              // size
              "--n-padding-top": paddingTop,
              "--n-padding-bottom": paddingBottom,
              "--n-padding-left": paddingLeft,
              "--n-font-size": fontSize2,
              "--n-title-font-size": titleFontSize,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("card", vue.computed(() => {
            return props.size[0];
          }), cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { segmented, bordered, hoverable, mergedClsPrefix, rtlEnabled, onRender, embedded, tag: Component, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            Component,
            { class: [
              `${mergedClsPrefix}-card`,
              this.themeClass,
              embedded && `${mergedClsPrefix}-card--embedded`,
              {
                [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
                [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
                [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
                [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
                [`${mergedClsPrefix}-card--bordered`]: bordered,
                [`${mergedClsPrefix}-card--hoverable`]: hoverable
              }
            ], style: this.cssVars, role: this.role },
            resolveWrappedSlot($slots.cover, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-card-cover`, role: "none" }, children)),
            resolveWrappedSlot($slots.header, (children) => {
              return children || this.title || this.closable ? vue.h(
                "div",
                { class: `${mergedClsPrefix}-card-header`, style: this.headerStyle },
                vue.h("div", { class: `${mergedClsPrefix}-card-header__main`, role: "heading" }, children || this.title),
                resolveWrappedSlot($slots["header-extra"], (children2) => children2 && vue.h("div", { class: `${mergedClsPrefix}-card-header__extra`, style: this.headerExtraStyle }, children2)),
                this.closable ? vue.h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-card-header__close`, onClick: this.handleCloseClick, absolute: true }) : null
              ) : null;
            }),
            resolveWrappedSlot($slots.default, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-card__content`, style: this.contentStyle, role: "none" }, children)),
            resolveWrappedSlot($slots.footer, (children) => children && [
              vue.h("div", { class: `${mergedClsPrefix}-card__footer`, style: this.footerStyle, role: "none" }, children)
            ]),
            resolveWrappedSlot($slots.action, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-card__action`, role: "none" }, children))
          );
        }
      });
      const self$W = (vars) => {
        return {
          dotSize: "8px",
          dotColor: "rgba(255, 255, 255, .3)",
          dotColorActive: "rgba(255, 255, 255, 1)",
          dotColorFocus: "rgba(255, 255, 255, .5)",
          dotLineWidth: "16px",
          dotLineWidthActive: "24px",
          arrowColor: "#eee"
        };
      };
      const carouselLight = {
        name: "Carousel",
        common: commonLight,
        self: self$W
      };
      const carouselLight$1 = carouselLight;
      const carouselDark = {
        name: "Carousel",
        common: commonDark,
        self: self$W
      };
      const carouselDark$1 = carouselDark;
      function addDuplicateSlides(slides) {
        const { length } = slides;
        if (length > 1) {
          slides.push(duplicateSlide(slides[0], 0, "append"));
          slides.unshift(duplicateSlide(slides[length - 1], length - 1, "prepend"));
          return slides;
        }
        return slides;
      }
      function duplicateSlide(child, index, position) {
        return vue.cloneVNode(child, {
          // for patch
          key: `carousel-item-duplicate-${index}-${position}`
        });
      }
      function getDisplayIndex(current, length, duplicatedable) {
        return !duplicatedable ? current : current === 0 ? length - 3 : current === length - 1 ? 0 : current - 1;
      }
      function getRealIndex(current, duplicatedable) {
        return !duplicatedable ? current : current + 1;
      }
      function getPrevIndex(current, length, duplicatedable) {
        if (current < 0)
          return null;
        return current === 0 ? duplicatedable ? length - 1 : null : current - 1;
      }
      function getNextIndex(current, length, duplicatedable) {
        if (current > length - 1)
          return null;
        return current === length - 1 ? duplicatedable ? 0 : null : current + 1;
      }
      function getDisplayTotalView(total, duplicatedable) {
        return duplicatedable && total > 3 ? total - 2 : total;
      }
      function isTouchEvent$1(e) {
        return window.TouchEvent && e instanceof window.TouchEvent;
      }
      function calculateSize(element, innerOnly) {
        let { offsetWidth: width, offsetHeight: height } = element;
        if (innerOnly) {
          const style2 = getComputedStyle(element);
          width = width - parseFloat(style2.getPropertyValue("padding-left")) - parseFloat(style2.getPropertyValue("padding-right"));
          height = height - parseFloat(style2.getPropertyValue("padding-top")) - parseFloat(style2.getPropertyValue("padding-bottom"));
        }
        return { width, height };
      }
      function clampValue(value, min, max) {
        return value < min ? min : value > max ? max : value;
      }
      function resolveSpeed(value) {
        if (value === void 0)
          return 0;
        if (typeof value === "number")
          return value;
        const timeRE = /^((\d+)?\.?\d+?)(ms|s)?$/;
        const match2 = value.match(timeRE);
        if (match2) {
          const [, number2, , unit = "ms"] = match2;
          return Number(number2) * (unit === "ms" ? 1 : 1e3);
        }
        return 0;
      }
      const carouselMethodsInjectionKey = createInjectionKey("n-carousel-methods");
      const provideCarouselContext = (contextValue) => {
        vue.provide(carouselMethodsInjectionKey, contextValue);
      };
      const useCarouselContext = (location = "unknown", component = "component") => {
        const CarouselContext = vue.inject(carouselMethodsInjectionKey);
        if (!CarouselContext) {
          throwError(location, `\`${component}\` must be placed inside \`n-carousel\`.`);
        }
        return CarouselContext;
      };
      const carouselDotsProps = {
        total: {
          type: Number,
          default: 0
        },
        currentIndex: {
          type: Number,
          default: 0
        },
        dotType: {
          type: String,
          default: "dot"
        },
        trigger: {
          type: String,
          default: "click"
        },
        keyboard: Boolean
      };
      const NCarouselDots = vue.defineComponent({
        name: "CarouselDots",
        props: carouselDotsProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const dotElsRef = vue.ref([]);
          const NCarousel = useCarouselContext();
          function handleKeydown(e, current) {
            switch (e.key) {
              case "Enter":
              case " ":
                e.preventDefault();
                NCarousel.to(current);
                return;
            }
            if (props.keyboard) {
              handleKeyboard(e);
            }
          }
          function handleMouseenter(current) {
            if (props.trigger === "hover") {
              NCarousel.to(current);
            }
          }
          function handleClick2(current) {
            if (props.trigger === "click") {
              NCarousel.to(current);
            }
          }
          function handleKeyboard(e) {
            var _a;
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            const nodeName = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase();
            if (nodeName === "input" || nodeName === "textarea") {
              return;
            }
            const { code: keycode } = e;
            const isVerticalNext = keycode === "PageUp" || keycode === "ArrowUp";
            const isVerticalPrev = keycode === "PageDown" || keycode === "ArrowDown";
            const isHorizontalNext = keycode === "PageUp" || keycode === "ArrowRight";
            const isHorizontalPrev = keycode === "PageDown" || keycode === "ArrowLeft";
            const vertical = NCarousel.isVertical();
            const wantToNext = vertical ? isVerticalNext : isHorizontalNext;
            const wantToPrev = vertical ? isVerticalPrev : isHorizontalPrev;
            if (!wantToNext && !wantToPrev) {
              return;
            }
            e.preventDefault();
            if (wantToNext && !NCarousel.isNextDisabled()) {
              NCarousel.next();
              focusDot(NCarousel.currentIndexRef.value);
            } else if (wantToPrev && !NCarousel.isPrevDisabled()) {
              NCarousel.prev();
              focusDot(NCarousel.currentIndexRef.value);
            }
          }
          function focusDot(index) {
            var _a;
            (_a = dotElsRef.value[index]) === null || _a === void 0 ? void 0 : _a.focus();
          }
          vue.onBeforeUpdate(() => dotElsRef.value.length = 0);
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            dotEls: dotElsRef,
            handleKeydown,
            handleMouseenter,
            handleClick: handleClick2
          };
        },
        render() {
          const { mergedClsPrefix, dotEls } = this;
          return vue.h("div", { class: [
            `${mergedClsPrefix}-carousel__dots`,
            `${mergedClsPrefix}-carousel__dots--${this.dotType}`
          ], role: "tablist" }, indexMap(this.total, (i) => {
            const selected = i === this.currentIndex;
            return vue.h("div", { "aria-selected": selected, ref: (el) => dotEls.push(el), role: "button", tabindex: "0", class: [
              `${mergedClsPrefix}-carousel__dot`,
              selected && `${mergedClsPrefix}-carousel__dot--active`
            ], key: i, onClick: () => {
              this.handleClick(i);
            }, onMouseenter: () => {
              this.handleMouseenter(i);
            }, onKeydown: (e) => {
              this.handleKeydown(e, i);
            } });
          }));
        }
      });
      const backwardIcon = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
        vue.h(
          "g",
          { fill: "none" },
          vue.h("path", { d: "M10.26 3.2a.75.75 0 0 1 .04 1.06L6.773 8l3.527 3.74a.75.75 0 1 1-1.1 1.02l-4-4.25a.75.75 0 0 1 0-1.02l4-4.25a.75.75 0 0 1 1.06-.04z", fill: "currentColor" })
        )
      );
      const forwardIcon = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
        vue.h(
          "g",
          { fill: "none" },
          vue.h("path", { d: "M5.74 3.2a.75.75 0 0 0-.04 1.06L9.227 8L5.7 11.74a.75.75 0 1 0 1.1 1.02l4-4.25a.75.75 0 0 0 0-1.02l-4-4.25a.75.75 0 0 0-1.06-.04z", fill: "currentColor" })
        )
      );
      const NCarouselArrow = vue.defineComponent({
        name: "CarouselArrow",
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const { isVertical, isPrevDisabled, isNextDisabled, prev, next } = useCarouselContext();
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            isVertical,
            isPrevDisabled,
            isNextDisabled,
            prev,
            next
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-carousel__arrow-group` },
            vue.h("div", { class: [
              `${mergedClsPrefix}-carousel__arrow`,
              this.isPrevDisabled() && `${mergedClsPrefix}-carousel__arrow--disabled`
            ], role: "button", onClick: this.prev }, backwardIcon),
            vue.h("div", { class: [
              `${mergedClsPrefix}-carousel__arrow`,
              this.isNextDisabled() && `${mergedClsPrefix}-carousel__arrow--disabled`
            ], role: "button", onClick: this.next }, forwardIcon)
          );
        }
      });
      const CarouselItemName = "CarouselItem";
      const isCarouselItem = (child) => {
        var _a;
        return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === CarouselItemName;
      };
      const NCarouselItem = vue.defineComponent({
        name: CarouselItemName,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const NCarousel = useCarouselContext(camelCase$1(CarouselItemName), `n-${camelCase$1(CarouselItemName)}`);
          const selfElRef = vue.ref();
          const indexRef = vue.computed(() => {
            const { value: selfEl } = selfElRef;
            return selfEl ? NCarousel.getSlideIndex(selfEl) : -1;
          });
          const isPrevRef = vue.computed(() => NCarousel.isPrev(indexRef.value));
          const isNextRef = vue.computed(() => NCarousel.isNext(indexRef.value));
          const isActiveRef = vue.computed(() => NCarousel.isActive(indexRef.value));
          const styleRef = vue.computed(() => NCarousel.getSlideStyle(indexRef.value));
          vue.onMounted(() => {
            NCarousel.addSlide(selfElRef.value);
          });
          vue.onBeforeUnmount(() => {
            NCarousel.removeSlide(selfElRef.value);
          });
          function handleClick2(event) {
            const { value: index } = indexRef;
            if (index !== void 0) {
              NCarousel === null || NCarousel === void 0 ? void 0 : NCarousel.onCarouselItemClick(index, event);
            }
          }
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            selfElRef,
            isPrev: isPrevRef,
            isNext: isNextRef,
            isActive: isActiveRef,
            index: indexRef,
            style: styleRef,
            handleClick: handleClick2
          };
        },
        render() {
          var _a;
          const { $slots: slots, mergedClsPrefix, isPrev, isNext, isActive, index, style: style2 } = this;
          const className = [
            `${mergedClsPrefix}-carousel__slide`,
            {
              [`${mergedClsPrefix}-carousel__slide--current`]: isActive,
              [`${mergedClsPrefix}-carousel__slide--prev`]: isPrev,
              [`${mergedClsPrefix}-carousel__slide--next`]: isNext
            }
          ];
          return vue.h("div", {
            ref: "selfElRef",
            class: className,
            role: "option",
            tabindex: "-1",
            "data-index": index,
            "aria-hidden": !isActive,
            style: style2,
            // We use ts-ignore for vue-tsc, since it seems to patch native event
            // for vue components
            // @ts-expect-error vue's tsx has type for capture events
            onClickCapture: this.handleClick
          }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
            isPrev,
            isNext,
            isActive,
            index
          }));
        }
      });
      const style$15 = cB("carousel", `
 position: relative;
 width: 100%;
 height: 100%;
 touch-action: pan-y;
 overflow: hidden;
`, [cE("slides", `
 display: flex;
 width: 100%;
 height: 100%;
 transition-timing-function: var(--n-bezier);
 transition-property: transform;
 `, [cE("slide", `
 flex-shrink: 0;
 position: relative;
 width: 100%;
 height: 100%;
 outline: none;
 overflow: hidden;
 `, [c$1("> img", `
 display: block;
 `)])]), cE("dots", `
 position: absolute;
 display: flex;
 flex-wrap: nowrap;
 `, [cM("dot", [cE("dot", `
 height: var(--n-dot-size);
 width: var(--n-dot-size);
 background-color: var(--n-dot-color);
 border-radius: 50%;
 cursor: pointer;
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [c$1("&:focus", `
 background-color: var(--n-dot-color-focus);
 `), cM("active", `
 background-color: var(--n-dot-color-active);
 `)])]), cM("line", [cE("dot", `
 border-radius: 9999px;
 width: var(--n-dot-line-width);
 height: 4px;
 background-color: var(--n-dot-color);
 cursor: pointer;
 transition:
 width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [c$1("&:focus", `
 background-color: var(--n-dot-color-focus);
 `), cM("active", `
 width: var(--n-dot-line-width-active);
 background-color: var(--n-dot-color-active);
 `)])])]), cE("arrow", `
 transition: background-color .3s var(--n-bezier);
 cursor: pointer;
 height: 28px;
 width: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 background-color: rgba(255, 255, 255, .2);
 color: var(--n-arrow-color);
 border-radius: 8px;
 user-select: none;
 -webkit-user-select: none;
 font-size: 18px;
 `, [c$1("svg", `
 height: 1em;
 width: 1em;
 `), c$1("&:hover", `
 background-color: rgba(255, 255, 255, .3);
 `)]), cM("vertical", `
 touch-action: pan-x;
 `, [cE("slides", `
 flex-direction: column;
 `), cM("fade", [cE("slide", `
 top: 50%;
 left: unset;
 transform: translateY(-50%);
 `)]), cM("card", [cE("slide", `
 top: 50%;
 left: unset;
 transform: translateY(-50%) translateZ(-400px);
 `, [cM("current", `
 transform: translateY(-50%) translateZ(0);
 `), cM("prev", `
 transform: translateY(-100%) translateZ(-200px);
 `), cM("next", `
 transform: translateY(0%) translateZ(-200px);
 `)])])]), cM("usercontrol", [cE("slides", [c$1(">", [c$1("div", `
 position: absolute;
 top: 50%;
 left: 50%;
 width: 100%;
 height: 100%;
 transform: translate(-50%, -50%);
 `)])])]), cM("left", [cE("dots", `
 transform: translateY(-50%);
 top: 50%;
 left: 12px;
 flex-direction: column;
 `, [cM("line", [cE("dot", `
 width: 4px;
 height: var(--n-dot-line-width);
 margin: 4px 0;
 transition:
 height .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [cM("active", `
 height: var(--n-dot-line-width-active);
 `)])])]), cE("dot", `
 margin: 4px 0;
 `)]), cE("arrow-group", `
 position: absolute;
 display: flex;
 flex-wrap: nowrap;
 `), cM("vertical", [cE("arrow", `
 transform: rotate(90deg);
 `)]), cM("show-arrow", [cM("bottom", [cE("dots", `
 transform: translateX(0);
 bottom: 18px;
 left: 18px;
 `)]), cM("top", [cE("dots", `
 transform: translateX(0);
 top: 18px;
 left: 18px;
 `)]), cM("left", [cE("dots", `
 transform: translateX(0);
 top: 18px;
 left: 18px;
 `)]), cM("right", [cE("dots", `
 transform: translateX(0);
 top: 18px;
 right: 18px;
 `)])]), cM("left", [cE("arrow-group", `
 bottom: 12px;
 left: 12px;
 flex-direction: column;
 `, [c$1("> *:first-child", `
 margin-bottom: 12px;
 `)])]), cM("right", [cE("dots", `
 transform: translateY(-50%);
 top: 50%;
 right: 12px;
 flex-direction: column;
 `, [cM("line", [cE("dot", `
 width: 4px;
 height: var(--n-dot-line-width);
 margin: 4px 0;
 transition:
 height .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [cM("active", `
 height: var(--n-dot-line-width-active);
 `)])])]), cE("dot", `
 margin: 4px 0;
 `), cE("arrow-group", `
 bottom: 12px;
 right: 12px;
 flex-direction: column;
 `, [c$1("> *:first-child", `
 margin-bottom: 12px;
 `)])]), cM("top", [cE("dots", `
 transform: translateX(-50%);
 top: 12px;
 left: 50%;
 `, [cM("line", [cE("dot", `
 margin: 0 4px;
 `)])]), cE("dot", `
 margin: 0 4px;
 `), cE("arrow-group", `
 top: 12px;
 right: 12px;
 `, [c$1("> *:first-child", `
 margin-right: 12px;
 `)])]), cM("bottom", [cE("dots", `
 transform: translateX(-50%);
 bottom: 12px;
 left: 50%;
 `, [cM("line", [cE("dot", `
 margin: 0 4px;
 `)])]), cE("dot", `
 margin: 0 4px;
 `), cE("arrow-group", `
 bottom: 12px;
 right: 12px;
 `, [c$1("> *:first-child", `
 margin-right: 12px;
 `)])]), cM("fade", [cE("slide", `
 position: absolute;
 opacity: 0;
 transition-property: opacity;
 pointer-events: none;
 `, [cM("current", `
 opacity: 1;
 pointer-events: auto;
 `)])]), cM("card", [cE("slides", `
 perspective: 1000px;
 `), cE("slide", `
 position: absolute;
 left: 50%;
 opacity: 0;
 transform: translateX(-50%) translateZ(-400px);
 transition-property: opacity, transform;
 `, [cM("current", `
 opacity: 1;
 transform: translateX(-50%) translateZ(0);
 z-index: 1;
 `), cM("prev", `
 opacity: 0.4;
 transform: translateX(-100%) translateZ(-200px);
 `), cM("next", `
 opacity: 0.4;
 transform: translateX(0%) translateZ(-200px);
 `)])])]);
      const transitionProperties = [
        "transitionDuration",
        "transitionTimingFunction"
      ];
      const carouselProps = Object.assign(Object.assign({}, useTheme.props), { defaultIndex: {
        type: Number,
        default: 0
      }, currentIndex: Number, showArrow: Boolean, dotType: {
        type: String,
        default: "dot"
      }, dotPlacement: {
        type: String,
        default: "bottom"
      }, slidesPerView: {
        type: [Number, String],
        default: 1
      }, spaceBetween: {
        type: Number,
        default: 0
      }, centeredSlides: Boolean, direction: {
        type: String,
        default: "horizontal"
      }, autoplay: Boolean, interval: {
        type: Number,
        default: 5e3
      }, loop: {
        type: Boolean,
        default: true
      }, effect: {
        type: String,
        default: "slide"
      }, showDots: {
        type: Boolean,
        default: true
      }, trigger: {
        type: String,
        default: "click"
      }, transitionStyle: {
        type: Object,
        default: () => ({
          transitionDuration: "300ms"
        })
      }, transitionProps: Object, draggable: Boolean, prevSlideStyle: [Object, String], nextSlideStyle: [Object, String], touchable: {
        type: Boolean,
        default: true
      }, mousewheel: Boolean, keyboard: Boolean, "onUpdate:currentIndex": Function, onUpdateCurrentIndex: Function });
      let globalDragging = false;
      const Carousel = vue.defineComponent({
        name: "Carousel",
        props: carouselProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const selfElRef = vue.ref(null);
          const slidesElRef = vue.ref(null);
          const slideElsRef = vue.ref([]);
          const slideVNodesRef = { value: [] };
          const verticalRef = vue.computed(() => props.direction === "vertical");
          const sizeAxisRef = vue.computed(() => verticalRef.value ? "height" : "width");
          const spaceAxisRef = vue.computed(() => verticalRef.value ? "bottom" : "right");
          const sequenceLayoutRef = vue.computed(() => props.effect === "slide");
          const duplicatedableRef = vue.computed(
            // duplicate the copy operation in `slide` mode,
            // because only its DOM is sequence layout
            () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value
          );
          const userWantsControlRef = vue.computed(() => props.effect === "custom");
          const displaySlidesPerViewRef = vue.computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);
          const realSlidesPerViewRef = vue.computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);
          const autoSlideSizeRef = vue.computed(() => displaySlidesPerViewRef.value === "auto" || props.slidesPerView === "auto" && props.centeredSlides);
          const perViewSizeRef = vue.ref({ width: 0, height: 0 });
          const slideSizesRef = vue.computed(() => {
            const { value: slidesEls } = slideElsRef;
            if (!slidesEls.length)
              return [];
            const { value: autoSlideSize } = autoSlideSizeRef;
            if (autoSlideSize) {
              return slidesEls.map((slide) => calculateSize(slide));
            }
            const { value: slidesPerView } = realSlidesPerViewRef;
            const { value: perViewSize } = perViewSizeRef;
            const { value: axis } = sizeAxisRef;
            let axisSize = perViewSize[axis];
            if (slidesPerView !== "auto") {
              const { spaceBetween } = props;
              const remaining = axisSize - (slidesPerView - 1) * spaceBetween;
              const percentage = 1 / Math.max(1, slidesPerView);
              axisSize = remaining * percentage;
            }
            const slideSize = Object.assign(Object.assign({}, perViewSize), { [axis]: axisSize });
            return slidesEls.map(() => slideSize);
          });
          const slideTranlatesRef = vue.computed(() => {
            const { value: slideSizes } = slideSizesRef;
            if (!slideSizes.length)
              return [];
            const { centeredSlides, spaceBetween } = props;
            const { value: axis } = sizeAxisRef;
            const { [axis]: perViewSize } = perViewSizeRef.value;
            let previousTranslate2 = 0;
            return slideSizes.map(({ [axis]: slideSize }) => {
              let translate = previousTranslate2;
              if (centeredSlides) {
                translate += (slideSize - perViewSize) / 2;
              }
              previousTranslate2 += slideSize + spaceBetween;
              return translate;
            });
          });
          const isMountedRef = vue.ref(false);
          const transitionStyleRef = vue.computed(() => {
            const { transitionStyle } = props;
            return transitionStyle ? keep(transitionStyle, transitionProperties) : {};
          });
          const speedRef = vue.computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));
          const slideStylesRef = vue.computed(() => {
            const { value: slidesEls } = slideElsRef;
            if (!slidesEls.length)
              return [];
            const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);
            const getSlideSize = (index) => {
              if (useComputedSize) {
                const { value: axis } = sizeAxisRef;
                return {
                  [axis]: `${slideSizesRef.value[index][axis]}px`
                };
              }
            };
            if (userWantsControlRef.value) {
              return slidesEls.map((_, i) => getSlideSize(i));
            }
            const { effect, spaceBetween } = props;
            const { value: spaceAxis } = spaceAxisRef;
            return slidesEls.reduce((styles2, _, i) => {
              const style2 = Object.assign(Object.assign({}, getSlideSize(i)), { [`margin-${spaceAxis}`]: `${spaceBetween}px` });
              styles2.push(style2);
              if (isMountedRef.value && (effect === "fade" || effect === "card")) {
                Object.assign(style2, transitionStyleRef.value);
              }
              return styles2;
            }, []);
          });
          const totalViewRef = vue.computed(() => {
            const { value: slidesPerView } = displaySlidesPerViewRef;
            const { length: totalSlides } = slideElsRef.value;
            if (slidesPerView !== "auto") {
              return Math.max(totalSlides - slidesPerView, 0) + 1;
            } else {
              const { value: slideSizes } = slideSizesRef;
              const { length } = slideSizes;
              if (!length)
                return totalSlides;
              const { value: translates } = slideTranlatesRef;
              const { value: axis } = sizeAxisRef;
              const perViewSize = perViewSizeRef.value[axis];
              let lastViewSize = slideSizes[slideSizes.length - 1][axis];
              let i = length;
              while (i > 1 && lastViewSize < perViewSize) {
                i--;
                lastViewSize += translates[i] - translates[i - 1];
              }
              return clampValue(i + 1, 1, length);
            }
          });
          const displayTotalViewRef = vue.computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));
          const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);
          const uncontrolledDisplayIndexRef = vue.ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));
          const mergedDisplayIndexRef = useMergedState(vue.toRef(props, "currentIndex"), uncontrolledDisplayIndexRef);
          const realIndexRef = vue.computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));
          function toRealIndex(index) {
            var _a, _b;
            index = clampValue(index, 0, totalViewRef.value - 1);
            const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);
            const { value: lastDisplayIndex } = mergedDisplayIndexRef;
            if (displayIndex !== mergedDisplayIndexRef.value) {
              uncontrolledDisplayIndexRef.value = displayIndex;
              (_a = props["onUpdate:currentIndex"]) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);
              (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);
            }
          }
          function getRealPrevIndex(index = realIndexRef.value) {
            return getPrevIndex(index, totalViewRef.value, props.loop);
          }
          function getRealNextIndex(index = realIndexRef.value) {
            return getNextIndex(index, totalViewRef.value, props.loop);
          }
          function isRealPrev(slideOrIndex) {
            const index = getSlideIndex(slideOrIndex);
            return index !== null && getRealPrevIndex() === index;
          }
          function isRealNext(slideOrIndex) {
            const index = getSlideIndex(slideOrIndex);
            return index !== null && getRealNextIndex() === index;
          }
          function isRealActive(slideOrIndex) {
            return realIndexRef.value === getSlideIndex(slideOrIndex);
          }
          function isDisplayActive(index) {
            return mergedDisplayIndexRef.value === index;
          }
          function isPrevDisabled() {
            return getRealPrevIndex() === null;
          }
          function isNextDisabled() {
            return getRealNextIndex() === null;
          }
          function to(index) {
            const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);
            if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {
              toRealIndex(realIndex);
            }
          }
          function prev() {
            const prevIndex = getRealPrevIndex();
            if (prevIndex !== null)
              toRealIndex(prevIndex);
          }
          function next() {
            const nextIndex = getRealNextIndex();
            if (nextIndex !== null)
              toRealIndex(nextIndex);
          }
          function prevIfSlideTransitionEnd() {
            if (!inTransition || !duplicatedableRef.value)
              prev();
          }
          function nextIfSlideTransitionEnd() {
            if (!inTransition || !duplicatedableRef.value)
              next();
          }
          let inTransition = false;
          let previousTranslate = 0;
          const translateStyleRef = vue.ref({});
          function updateTranslate(translate, speed = 0) {
            translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {
              transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,
              transitionDuration: `${speed}ms`
            });
          }
          function fixTranslate(speed = 0) {
            if (sequenceLayoutRef.value) {
              translateTo(realIndexRef.value, speed);
            } else if (previousTranslate !== 0) {
              if (!inTransition && speed > 0) {
                inTransition = true;
              }
              updateTranslate(previousTranslate = 0, speed);
            }
          }
          function translateTo(index, speed) {
            const translate = getTranslate(index);
            if (translate !== previousTranslate && speed > 0) {
              inTransition = true;
            }
            previousTranslate = getTranslate(realIndexRef.value);
            updateTranslate(translate, speed);
          }
          function getTranslate(index) {
            let translate;
            if (index >= totalViewRef.value - 1) {
              translate = getLastViewTranslate();
            } else {
              translate = slideTranlatesRef.value[index] || 0;
            }
            return translate;
          }
          function getLastViewTranslate() {
            if (displaySlidesPerViewRef.value === "auto") {
              const { value: axis } = sizeAxisRef;
              const { [axis]: perViewSize } = perViewSizeRef.value;
              const { value: translates } = slideTranlatesRef;
              const lastTranslate = translates[translates.length - 1];
              let overallSize;
              if (lastTranslate === void 0) {
                overallSize = perViewSize;
              } else {
                const { value: slideSizes } = slideSizesRef;
                overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];
              }
              return overallSize - perViewSize;
            } else {
              const { value: translates } = slideTranlatesRef;
              return translates[totalViewRef.value - 1] || 0;
            }
          }
          const carouselContext = {
            currentIndexRef: mergedDisplayIndexRef,
            to,
            prev: prevIfSlideTransitionEnd,
            next: nextIfSlideTransitionEnd,
            isVertical: () => verticalRef.value,
            isHorizontal: () => !verticalRef.value,
            isPrev: isRealPrev,
            isNext: isRealNext,
            isActive: isRealActive,
            isPrevDisabled,
            isNextDisabled,
            getSlideIndex,
            getSlideStyle,
            addSlide,
            removeSlide,
            onCarouselItemClick
          };
          provideCarouselContext(carouselContext);
          function addSlide(slide) {
            if (!slide)
              return;
            slideElsRef.value.push(slide);
          }
          function removeSlide(slide) {
            if (!slide)
              return;
            const index = getSlideIndex(slide);
            if (index !== -1) {
              slideElsRef.value.splice(index, 1);
            }
          }
          function getSlideIndex(slideOrIndex) {
            return typeof slideOrIndex === "number" ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;
          }
          function getSlideStyle(slide) {
            const index = getSlideIndex(slide);
            if (index !== -1) {
              const styles2 = [slideStylesRef.value[index]];
              const isPrev = carouselContext.isPrev(index);
              const isNext = carouselContext.isNext(index);
              if (isPrev) {
                styles2.push(props.prevSlideStyle || "");
              }
              if (isNext) {
                styles2.push(props.nextSlideStyle || "");
              }
              return vue.normalizeStyle(styles2);
            }
          }
          function onCarouselItemClick(index, event) {
            let allowClick = !inTransition && !dragging && !isEffectiveDrag;
            if (props.effect === "card" && allowClick && !isRealActive(index)) {
              to(index);
              allowClick = false;
            }
            if (!allowClick) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
          let autoplayTimer = null;
          function stopAutoplay() {
            if (autoplayTimer) {
              clearInterval(autoplayTimer);
              autoplayTimer = null;
            }
          }
          function resetAutoplay() {
            stopAutoplay();
            const disabled = !props.autoplay || displayTotalViewRef.value < 2;
            if (!disabled) {
              autoplayTimer = window.setInterval(next, props.interval);
            }
          }
          let dragStartX = 0;
          let dragStartY = 0;
          let dragOffset = 0;
          let dragStartTime = 0;
          let dragging = false;
          let isEffectiveDrag = false;
          function handleTouchstart(event) {
            var _a;
            if (globalDragging)
              return;
            if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {
              return;
            }
            globalDragging = true;
            dragging = true;
            isEffectiveDrag = false;
            dragStartTime = Date.now();
            stopAutoplay();
            if (event.type !== "touchstart" && !event.target.isContentEditable) {
              event.preventDefault();
            }
            const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
            if (verticalRef.value) {
              dragStartY = touchEvent.clientY;
            } else {
              dragStartX = touchEvent.clientX;
            }
            if (props.touchable) {
              on("touchmove", document, handleTouchmove, { passive: true });
              on("touchend", document, handleTouchend);
              on("touchcancel", document, handleTouchend);
            }
            if (props.draggable) {
              on("mousemove", document, handleTouchmove);
              on("mouseup", document, handleTouchend);
            }
          }
          function handleTouchmove(event) {
            const { value: vertical } = verticalRef;
            const { value: axis } = sizeAxisRef;
            const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
            const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;
            const perViewSize = perViewSizeRef.value[axis];
            dragOffset = clampValue(offset, -perViewSize, perViewSize);
            if (event.cancelable) {
              event.preventDefault();
            }
            if (sequenceLayoutRef.value) {
              updateTranslate(previousTranslate - dragOffset, 0);
            }
          }
          function handleTouchend() {
            const { value: realIndex } = realIndexRef;
            let currentIndex = realIndex;
            if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {
              const currentTranslate = previousTranslate - dragOffset;
              const translates = [
                ...slideTranlatesRef.value.slice(0, totalViewRef.value - 1),
                getLastViewTranslate()
              ];
              let prevOffset = null;
              for (let i = 0; i < translates.length; i++) {
                const offset = Math.abs(translates[i] - currentTranslate);
                if (prevOffset !== null && prevOffset < offset) {
                  break;
                }
                prevOffset = offset;
                currentIndex = i;
              }
            }
            if (currentIndex === realIndex) {
              const timeElapsed = Date.now() - dragStartTime;
              const { value: axis } = sizeAxisRef;
              const perViewSize = perViewSizeRef.value[axis];
              if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {
                currentIndex = getRealPrevIndex(realIndex);
              } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {
                currentIndex = getRealNextIndex(realIndex);
              }
            }
            if (currentIndex !== null && currentIndex !== realIndex) {
              isEffectiveDrag = true;
              toRealIndex(currentIndex);
              void vue.nextTick(() => {
                if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {
                  fixTranslate(speedRef.value);
                }
              });
            } else {
              fixTranslate(speedRef.value);
            }
            resetDragStatus();
            resetAutoplay();
          }
          function resetDragStatus() {
            if (dragging) {
              globalDragging = false;
            }
            dragging = false;
            dragStartX = 0;
            dragStartY = 0;
            dragOffset = 0;
            dragStartTime = 0;
            off("touchmove", document, handleTouchmove);
            off("touchend", document, handleTouchend);
            off("touchcancel", document, handleTouchend);
            off("mousemove", document, handleTouchmove);
            off("mouseup", document, handleTouchend);
          }
          function handleTransitionEnd() {
            if (sequenceLayoutRef.value && inTransition) {
              const { value: realIndex } = realIndexRef;
              translateTo(realIndex, 0);
            } else {
              resetAutoplay();
            }
            if (sequenceLayoutRef.value) {
              translateStyleRef.value.transitionDuration = "0ms";
            }
            inTransition = false;
          }
          function handleMousewheel(event) {
            event.preventDefault();
            if (inTransition)
              return;
            let { deltaX, deltaY } = event;
            if (event.shiftKey && !deltaX) {
              deltaX = deltaY;
            }
            const prevMultiplier = -1;
            const nextMultiplier = 1;
            const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;
            let rx = 0;
            let ry = 0;
            if (verticalRef.value) {
              ry = m;
            } else {
              rx = m;
            }
            const responseStep = 10;
            if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {
              if (m === nextMultiplier && !isNextDisabled()) {
                next();
              } else if (m === prevMultiplier && !isPrevDisabled()) {
                prev();
              }
            }
          }
          function handleResize() {
            perViewSizeRef.value = calculateSize(selfElRef.value, true);
            resetAutoplay();
          }
          function handleSlideResize() {
            var _a, _b;
            if (autoSlideSizeRef.value) {
              (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);
              slideSizesRef.effect.run();
            }
          }
          function handleMouseenter() {
            if (props.autoplay) {
              stopAutoplay();
            }
          }
          function handleMouseleave() {
            if (props.autoplay) {
              resetAutoplay();
            }
          }
          vue.onMounted(() => {
            vue.watchEffect(resetAutoplay);
            requestAnimationFrame(() => isMountedRef.value = true);
          });
          vue.onBeforeUnmount(() => {
            resetDragStatus();
            stopAutoplay();
          });
          vue.onUpdated(() => {
            const { value: slidesEls } = slideElsRef;
            const { value: slideVNodes } = slideVNodesRef;
            const indexMap2 = /* @__PURE__ */ new Map();
            const getDisplayIndex2 = (el) => (
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              indexMap2.has(el) ? indexMap2.get(el) : -1
            );
            let isChanged = false;
            for (let i = 0; i < slidesEls.length; i++) {
              const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);
              if (index !== i) {
                isChanged = true;
              }
              indexMap2.set(slidesEls[i], index);
            }
            if (isChanged) {
              slidesEls.sort((a2, b) => getDisplayIndex2(a2) - getDisplayIndex2(b));
            }
          });
          vue.watch(realIndexRef, (realIndex, lastRealIndex) => {
            if (realIndex === lastRealIndex)
              return;
            resetAutoplay();
            if (sequenceLayoutRef.value) {
              if (duplicatedableRef.value && displayTotalViewRef.value > 2) {
                const { value: length } = totalViewRef;
                if (realIndex === length - 2 && lastRealIndex === 1) {
                  realIndex = 0;
                } else if (realIndex === 1 && lastRealIndex === length - 2) {
                  realIndex = length - 1;
                }
              }
              translateTo(realIndex, speedRef.value);
            } else {
              fixTranslate();
            }
          }, { immediate: true });
          vue.watch([duplicatedableRef, displaySlidesPerViewRef], () => void vue.nextTick(() => {
            toRealIndex(realIndexRef.value);
          }));
          vue.watch(slideTranlatesRef, () => {
            sequenceLayoutRef.value && fixTranslate();
          }, {
            deep: true
          });
          vue.watch(sequenceLayoutRef, (value) => {
            if (!value) {
              inTransition = false;
              updateTranslate(previousTranslate = 0);
            } else {
              fixTranslate();
            }
          });
          const slidesControlListenersRef = vue.computed(() => {
            return {
              onTouchstartPassive: props.touchable ? handleTouchstart : void 0,
              onMousedown: props.draggable ? handleTouchstart : void 0,
              onWheel: props.mousewheel ? handleMousewheel : void 0
            };
          });
          const arrowSlotPropsRef = vue.computed(() => Object.assign(Object.assign({}, keep(carouselContext, [
            "to",
            "prev",
            "next",
            "isPrevDisabled",
            "isNextDisabled"
          ])), { total: displayTotalViewRef.value, currentIndex: mergedDisplayIndexRef.value }));
          const dotSlotPropsRef = vue.computed(() => ({
            total: displayTotalViewRef.value,
            currentIndex: mergedDisplayIndexRef.value,
            to: carouselContext.to
          }));
          const caroulseExposedMethod = {
            getCurrentIndex: () => mergedDisplayIndexRef.value,
            to,
            prev,
            next
          };
          const themeRef = useTheme("Carousel", "-carousel", style$15, carouselLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { dotSize, dotColor, dotColorActive, dotColorFocus, dotLineWidth, dotLineWidthActive, arrowColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-dot-color": dotColor,
              "--n-dot-color-focus": dotColorFocus,
              "--n-dot-color-active": dotColorActive,
              "--n-dot-size": dotSize,
              "--n-dot-line-width": dotLineWidth,
              "--n-dot-line-width-active": dotLineWidthActive,
              "--n-arrow-color": arrowColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("carousel", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            selfElRef,
            slidesElRef,
            slideVNodes: slideVNodesRef,
            duplicatedable: duplicatedableRef,
            userWantsControl: userWantsControlRef,
            autoSlideSize: autoSlideSizeRef,
            displayIndex: mergedDisplayIndexRef,
            realIndex: realIndexRef,
            slideStyles: slideStylesRef,
            translateStyle: translateStyleRef,
            slidesControlListeners: slidesControlListenersRef,
            handleTransitionEnd,
            handleResize,
            handleSlideResize,
            handleMouseenter,
            handleMouseleave,
            isActive: isDisplayActive,
            arrowSlotProps: arrowSlotPropsRef,
            dotSlotProps: dotSlotPropsRef
          }, caroulseExposedMethod), { cssVars: inlineThemeDisabled ? void 0 : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
        },
        render() {
          var _a;
          const { mergedClsPrefix, showArrow, userWantsControl, slideStyles, dotType, dotPlacement, slidesControlListeners, transitionProps = {}, arrowSlotProps, dotSlotProps, $slots: { default: defaultSlot, dots: dotsSlot, arrow: arrowSlot } } = this;
          const children = defaultSlot && flatten$3(defaultSlot()) || [];
          let slides = filterCarouselItem(children);
          if (!slides.length) {
            slides = children.map((ch) => vue.h(NCarouselItem, null, {
              default: () => vue.cloneVNode(ch)
            }));
          }
          if (this.duplicatedable) {
            slides = addDuplicateSlides(slides);
          }
          this.slideVNodes.value = slides;
          if (this.autoSlideSize) {
            slides = slides.map((slide) => vue.h(VResizeObserver, { onResize: this.handleSlideResize }, {
              default: () => slide
            }));
          }
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            Object.assign({ ref: "selfElRef", class: [
              this.themeClass,
              `${mergedClsPrefix}-carousel`,
              this.direction === "vertical" && `${mergedClsPrefix}-carousel--vertical`,
              this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`,
              `${mergedClsPrefix}-carousel--${dotPlacement}`,
              `${mergedClsPrefix}-carousel--${this.direction}`,
              `${mergedClsPrefix}-carousel--${this.effect}`,
              userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`
            ], style: this.cssVars }, slidesControlListeners, { onMouseenter: this.handleMouseenter, onMouseleave: this.handleMouseleave }),
            vue.h(VResizeObserver, { onResize: this.handleResize }, {
              default: () => vue.h("div", { ref: "slidesElRef", class: `${mergedClsPrefix}-carousel__slides`, role: "listbox", style: this.translateStyle, onTransitionend: this.handleTransitionEnd }, userWantsControl ? slides.map((slide, i) => vue.h("div", { style: slideStyles[i], key: i }, vue.withDirectives(vue.h(vue.Transition, Object.assign({}, transitionProps), {
                default: () => slide
              }), [[vue.vShow, this.isActive(i)]]))) : slides)
            }),
            this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [
              vue.h(NCarouselDots, { key: dotType + dotPlacement, total: dotSlotProps.total, currentIndex: dotSlotProps.currentIndex, dotType, trigger: this.trigger, keyboard: this.keyboard })
            ]),
            showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [
              vue.h(NCarouselArrow, null)
            ])
          );
        }
      });
      function filterCarouselItem(vnodes) {
        return vnodes.reduce((carouselItems, vnode) => {
          if (isCarouselItem(vnode)) {
            carouselItems.push(vnode);
          }
          return carouselItems;
        }, []);
      }
      const commonVariables$c = {
        sizeSmall: "14px",
        sizeMedium: "16px",
        sizeLarge: "18px",
        labelPadding: "0 8px",
        labelFontWeight: "400"
      };
      const self$V = (vars) => {
        const { baseColor, inputColorDisabled, cardColor, modalColor, popoverColor, textColorDisabled, borderColor, primaryColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, borderRadiusSmall, lineHeight: lineHeight2 } = vars;
        return Object.assign(Object.assign({}, commonVariables$c), {
          labelLineHeight: lineHeight2,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius: borderRadiusSmall,
          color: baseColor,
          colorChecked: primaryColor,
          colorDisabled: inputColorDisabled,
          colorDisabledChecked: inputColorDisabled,
          colorTableHeader: cardColor,
          colorTableHeaderModal: modalColor,
          colorTableHeaderPopover: popoverColor,
          checkMarkColor: baseColor,
          checkMarkColorDisabled: textColorDisabled,
          checkMarkColorDisabledChecked: textColorDisabled,
          border: `1px solid ${borderColor}`,
          borderDisabled: `1px solid ${borderColor}`,
          borderDisabledChecked: `1px solid ${borderColor}`,
          borderChecked: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColor}`,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
          textColor: textColor2,
          textColorDisabled
        });
      };
      const checkboxLight = {
        name: "Checkbox",
        common: commonLight,
        self: self$V
      };
      const checkboxLight$1 = checkboxLight;
      const checkboxDark = {
        name: "Checkbox",
        common: commonDark,
        self(vars) {
          const { cardColor } = vars;
          const commonSelf = self$V(vars);
          commonSelf.color = "#0000";
          commonSelf.checkMarkColor = cardColor;
          return commonSelf;
        }
      };
      const checkboxDark$1 = checkboxDark;
      const self$U = (vars) => {
        const { borderRadius, boxShadow2, popoverColor, textColor2, textColor3, primaryColor, textColorDisabled, dividerColor, hoverColor, fontSizeMedium, heightMedium } = vars;
        return {
          menuBorderRadius: borderRadius,
          menuColor: popoverColor,
          menuBoxShadow: boxShadow2,
          menuDividerColor: dividerColor,
          menuHeight: "calc(var(--n-option-height) * 6.6)",
          optionArrowColor: textColor3,
          optionHeight: heightMedium,
          optionFontSize: fontSizeMedium,
          optionColorHover: hoverColor,
          optionTextColor: textColor2,
          optionTextColorActive: primaryColor,
          optionTextColorDisabled: textColorDisabled,
          optionCheckMarkColor: primaryColor,
          loadingColor: primaryColor,
          columnWidth: "180px"
        };
      };
      const cascaderLight = createTheme({
        name: "Cascader",
        common: commonLight,
        peers: {
          InternalSelectMenu: internalSelectMenuLight$1,
          InternalSelection: internalSelectionLight$1,
          Scrollbar: scrollbarLight$1,
          Checkbox: checkboxLight$1,
          Empty: emptyLight$1
        },
        self: self$U
      });
      const cascaderLight$1 = cascaderLight;
      const cascaderDark = {
        name: "Cascader",
        common: commonDark,
        peers: {
          InternalSelectMenu: internalSelectMenuDark$1,
          InternalSelection: internalSelectionDark$1,
          Scrollbar: scrollbarDark$1,
          Checkbox: checkboxDark$1,
          Empty: emptyLight$1
        },
        self: self$U
      };
      const cascaderDark$1 = cascaderDark;
      function getRawNodePath(tmNodes) {
        if (!tmNodes)
          return null;
        return tmNodes.map((tmNode) => tmNode.rawNode);
      }
      function createSelectOptions(tmNodes, checkStrategyIsChild, labelField, separator) {
        const selectOptions = [];
        const path = [];
        function traverse2(_tmNodes) {
          for (const tmNode of _tmNodes) {
            if (tmNode.disabled)
              continue;
            const { rawNode } = tmNode;
            path.push(rawNode);
            if (tmNode.isLeaf || !checkStrategyIsChild) {
              selectOptions.push({
                label: getPathLabel(tmNode, separator, labelField),
                value: tmNode.key,
                rawNode: tmNode.rawNode,
                path: Array.from(path)
              });
            }
            if (!tmNode.isLeaf && tmNode.children) {
              traverse2(tmNode.children);
            }
            path.pop();
          }
        }
        traverse2(tmNodes);
        return selectOptions;
      }
      function getPathLabel(node, separator, labelField) {
        const path = [];
        while (node) {
          path.push(node.rawNode[labelField]);
          node = node.parent;
        }
        return path.reverse().join(separator);
      }
      const CheckMark = vue.h(
        "svg",
        { viewBox: "0 0 64 64", class: "check-icon" },
        vue.h("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })
      );
      const LineMark = vue.h(
        "svg",
        { viewBox: "0 0 100 100", class: "line-icon" },
        vue.h("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })
      );
      const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
      const checkboxGroupProps = {
        min: Number,
        max: Number,
        size: String,
        value: Array,
        defaultValue: {
          type: Array,
          default: null
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        // deprecated
        onChange: [Function, Array]
      };
      const NCheckboxGroup = vue.defineComponent({
        name: "CheckboxGroup",
        props: checkboxGroupProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.computed(() => props.value);
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const checkedCount = vue.computed(() => {
            var _a;
            return ((_a = mergedValueRef.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
          });
          const valueSetRef = vue.computed(() => {
            if (Array.isArray(mergedValueRef.value)) {
              return new Set(mergedValueRef.value);
            }
            return /* @__PURE__ */ new Set();
          });
          function toggleCheckbox(checked, checkboxValue) {
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            const { onChange, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
            if (Array.isArray(mergedValueRef.value)) {
              const groupValue = Array.from(mergedValueRef.value);
              const index = groupValue.findIndex((value) => value === checkboxValue);
              if (checked) {
                if (!~index) {
                  groupValue.push(checkboxValue);
                  if (onUpdateValue) {
                    call(onUpdateValue, groupValue, {
                      actionType: "check",
                      value: checkboxValue
                    });
                  }
                  if (_onUpdateValue) {
                    call(_onUpdateValue, groupValue, {
                      actionType: "check",
                      value: checkboxValue
                    });
                  }
                  nTriggerFormInput();
                  nTriggerFormChange();
                  uncontrolledValueRef.value = groupValue;
                  if (onChange)
                    call(onChange, groupValue);
                }
              } else {
                if (~index) {
                  groupValue.splice(index, 1);
                  if (onUpdateValue) {
                    call(onUpdateValue, groupValue, {
                      actionType: "uncheck",
                      value: checkboxValue
                    });
                  }
                  if (_onUpdateValue) {
                    call(_onUpdateValue, groupValue, {
                      actionType: "uncheck",
                      value: checkboxValue
                    });
                  }
                  if (onChange)
                    call(onChange, groupValue);
                  uncontrolledValueRef.value = groupValue;
                  nTriggerFormInput();
                  nTriggerFormChange();
                }
              }
            } else {
              if (checked) {
                if (onUpdateValue) {
                  call(onUpdateValue, [checkboxValue], {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, [checkboxValue], {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                if (onChange)
                  call(onChange, [checkboxValue]);
                uncontrolledValueRef.value = [checkboxValue];
                nTriggerFormInput();
                nTriggerFormChange();
              } else {
                if (onUpdateValue) {
                  call(onUpdateValue, [], {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, [], {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (onChange)
                  call(onChange, []);
                uncontrolledValueRef.value = [];
                nTriggerFormInput();
                nTriggerFormChange();
              }
            }
          }
          vue.provide(checkboxGroupInjectionKey, {
            checkedCountRef: checkedCount,
            maxRef: vue.toRef(props, "max"),
            minRef: vue.toRef(props, "min"),
            valueSetRef,
            disabledRef: mergedDisabledRef,
            mergedSizeRef,
            toggleCheckbox
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef
          };
        },
        render() {
          return vue.h("div", { class: `${this.mergedClsPrefix}-checkbox-group`, role: "group" }, this.$slots);
        }
      });
      const style$14 = c$1([
        cB("checkbox", `
 line-height: var(--n-label-line-height);
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 --n-merged-color-table: var(--n-color-table);
 `, [c$1("&:hover", [cB("checkbox-box", [cE("border", {
          border: "var(--n-border-checked)"
        })])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM("inside-table", [cB("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [cB("checkbox-icon", [
          // if not set width to 100%, safari & old chrome won't display the icon
          c$1(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)
        ])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), c$1(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE("border", {
          border: "var(--n-border-checked)"
        })])]), cM("disabled", {
          cursor: "not-allowed"
        }, [cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [cE("border", {
          border: "var(--n-border-disabled-checked)"
        }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
          fill: "var(--n-check-mark-color-disabled-checked)"
        })])])]), cB("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [cE("border", {
          border: "var(--n-border-disabled)"
        }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
          fill: "var(--n-check-mark-color-disabled)"
        })])]), cE("label", {
          color: "var(--n-text-color-disabled)"
        })]), cB("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
          left: "1px",
          top: "1px"
        })])]), cE("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1("&:empty", {
          display: "none"
        })])]),
        // modal table header checkbox
        insideModal(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
        // popover table header checkbox
        insidePopover(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))
      ]);
      const checkboxProps = Object.assign(Object.assign({}, useTheme.props), {
        size: String,
        checked: {
          type: [Boolean, String, Number],
          default: void 0
        },
        defaultChecked: {
          type: [Boolean, String, Number],
          default: false
        },
        value: [String, Number],
        disabled: {
          type: Boolean,
          default: void 0
        },
        indeterminate: Boolean,
        label: String,
        focusable: {
          type: Boolean,
          default: true
        },
        checkedValue: {
          type: [Boolean, String, Number],
          default: true
        },
        uncheckedValue: {
          type: [Boolean, String, Number],
          default: false
        },
        "onUpdate:checked": [Function, Array],
        onUpdateChecked: [Function, Array],
        // private
        privateInsideTable: Boolean,
        // deprecated
        onChange: [Function, Array]
      });
      const NCheckbox = vue.defineComponent({
        name: "Checkbox",
        props: checkboxProps,
        setup(props) {
          const selfRef = vue.ref(null);
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const formItem = useFormItem(props, {
            mergedSize(NFormItem2) {
              const { size: size2 } = props;
              if (size2 !== void 0)
                return size2;
              if (NCheckboxGroup2) {
                const { value: mergedSize } = NCheckboxGroup2.mergedSizeRef;
                if (mergedSize !== void 0) {
                  return mergedSize;
                }
              }
              if (NFormItem2) {
                const { mergedSize } = NFormItem2;
                if (mergedSize !== void 0)
                  return mergedSize.value;
              }
              return "medium";
            },
            mergedDisabled(NFormItem2) {
              const { disabled } = props;
              if (disabled !== void 0)
                return disabled;
              if (NCheckboxGroup2) {
                if (NCheckboxGroup2.disabledRef.value)
                  return true;
                const { maxRef: { value: max }, checkedCountRef } = NCheckboxGroup2;
                if (max !== void 0 && checkedCountRef.value >= max && !renderedCheckedRef.value) {
                  return true;
                }
                const { minRef: { value: min } } = NCheckboxGroup2;
                if (min !== void 0 && checkedCountRef.value <= min && renderedCheckedRef.value) {
                  return true;
                }
              }
              if (NFormItem2) {
                return NFormItem2.disabled.value;
              }
              return false;
            }
          });
          const { mergedDisabledRef, mergedSizeRef } = formItem;
          const NCheckboxGroup2 = vue.inject(checkboxGroupInjectionKey, null);
          const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
          const controlledCheckedRef = vue.toRef(props, "checked");
          const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
          const renderedCheckedRef = useMemo(() => {
            if (NCheckboxGroup2) {
              const groupValueSet = NCheckboxGroup2.valueSetRef.value;
              if (groupValueSet && props.value !== void 0) {
                return groupValueSet.has(props.value);
              }
              return false;
            } else {
              return mergedCheckedRef.value === props.checkedValue;
            }
          });
          const themeRef = useTheme("Checkbox", "-checkbox", style$14, checkboxLight$1, props, mergedClsPrefixRef);
          function toggle(e) {
            if (NCheckboxGroup2 && props.value !== void 0) {
              NCheckboxGroup2.toggleCheckbox(!renderedCheckedRef.value, props.value);
            } else {
              const { onChange, "onUpdate:checked": _onUpdateCheck, onUpdateChecked } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
              if (_onUpdateCheck) {
                call(_onUpdateCheck, nextChecked, e);
              }
              if (onUpdateChecked) {
                call(onUpdateChecked, nextChecked, e);
              }
              if (onChange)
                call(onChange, nextChecked, e);
              nTriggerFormInput();
              nTriggerFormChange();
              uncontrolledCheckedRef.value = nextChecked;
            }
          }
          function handleClick2(e) {
            if (!mergedDisabledRef.value) {
              toggle(e);
            }
          }
          function handleKeyUp(e) {
            if (mergedDisabledRef.value)
              return;
            switch (e.key) {
              case " ":
              case "Enter":
                toggle(e);
            }
          }
          function handleKeyDown(e) {
            switch (e.key) {
              case " ":
                e.preventDefault();
            }
          }
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { value: mergedSize } = mergedSizeRef;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { borderRadius, color, colorChecked, colorDisabled, colorTableHeader, colorTableHeaderModal, colorTableHeaderPopover, checkMarkColor, checkMarkColorDisabled, border, borderFocus, borderDisabled, borderChecked, boxShadowFocus, textColor, textColorDisabled, checkMarkColorDisabledChecked, colorDisabledChecked, borderDisabledChecked, labelPadding, labelLineHeight, labelFontWeight, [createKey("fontSize", mergedSize)]: fontSize2, [createKey("size", mergedSize)]: size2 } } = themeRef.value;
            return {
              "--n-label-line-height": labelLineHeight,
              "--n-label-font-weight": labelFontWeight,
              "--n-size": size2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-border": border,
              "--n-border-checked": borderChecked,
              "--n-border-focus": borderFocus,
              "--n-border-disabled": borderDisabled,
              "--n-border-disabled-checked": borderDisabledChecked,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-color": color,
              "--n-color-checked": colorChecked,
              "--n-color-table": colorTableHeader,
              "--n-color-table-modal": colorTableHeaderModal,
              "--n-color-table-popover": colorTableHeaderPopover,
              "--n-color-disabled": colorDisabled,
              "--n-color-disabled-checked": colorDisabledChecked,
              "--n-text-color": textColor,
              "--n-text-color-disabled": textColorDisabled,
              "--n-check-mark-color": checkMarkColor,
              "--n-check-mark-color-disabled": checkMarkColorDisabled,
              "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
              "--n-font-size": fontSize2,
              "--n-label-padding": labelPadding
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("checkbox", vue.computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
          return Object.assign(formItem, exposedMethods, {
            rtlEnabled: rtlEnabledRef,
            selfRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedDisabled: mergedDisabledRef,
            renderedChecked: renderedCheckedRef,
            mergedTheme: themeRef,
            labelId: createId(),
            handleClick: handleClick2,
            handleKeyUp,
            handleKeyDown,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const { $slots, renderedChecked, mergedDisabled, indeterminate, privateInsideTable, cssVars, labelId, label, mergedClsPrefix, focusable, handleKeyUp, handleKeyDown, handleClick: handleClick2 } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { ref: "selfRef", class: [
              `${mergedClsPrefix}-checkbox`,
              this.themeClass,
              this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`,
              renderedChecked && `${mergedClsPrefix}-checkbox--checked`,
              mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`,
              indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`,
              privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`
            ], tabindex: mergedDisabled || !focusable ? void 0 : 0, role: "checkbox", "aria-checked": indeterminate ? "mixed" : renderedChecked, "aria-labelledby": labelId, style: cssVars, onKeyup: handleKeyUp, onKeydown: handleKeyDown, onClick: handleClick2, onMousedown: () => {
              on("selectstart", window, (e) => {
                e.preventDefault();
              }, {
                once: true
              });
            } },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-checkbox-box-wrapper` },
              "",
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-checkbox-box` },
                vue.h(NIconSwitchTransition, null, {
                  default: () => this.indeterminate ? vue.h("div", { key: "indeterminate", class: `${mergedClsPrefix}-checkbox-icon` }, LineMark) : vue.h("div", { key: "check", class: `${mergedClsPrefix}-checkbox-icon` }, CheckMark)
                }),
                vue.h("div", { class: `${mergedClsPrefix}-checkbox-box__border` })
              )
            ),
            label !== null || $slots.default ? vue.h("span", { class: `${mergedClsPrefix}-checkbox__label`, id: labelId }, $slots.default ? $slots.default() : label) : null
          );
        }
      });
      const cascaderInjectionKey = createInjectionKey("n-cascader");
      const NCascaderOption = vue.defineComponent({
        name: "NCascaderOption",
        props: {
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const {
            expandTriggerRef,
            remoteRef,
            multipleRef,
            mergedValueRef,
            checkedKeysRef,
            indeterminateKeysRef,
            hoverKeyPathRef,
            keyboardKeyRef,
            loadingKeySetRef,
            cascadeRef,
            mergedCheckStrategyRef,
            onLoadRef,
            mergedClsPrefixRef,
            mergedThemeRef,
            labelFieldRef,
            showCheckboxRef,
            updateHoverKey,
            updateKeyboardKey,
            addLoadingKey,
            deleteLoadingKey,
            closeMenu,
            doCheck,
            doUncheck,
            renderLabelRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(cascaderInjectionKey);
          const valueRef = vue.computed(() => props.tmNode.key);
          const useHoverTriggerRef = vue.computed(() => {
            const { value: expandTrigger } = expandTriggerRef;
            const { value: remote } = remoteRef;
            return !remote && expandTrigger === "hover";
          });
          const mergedHandleMouseEnterRef = vue.computed(() => {
            if (useHoverTriggerRef.value) {
              return handleMouseEnter;
            }
            return void 0;
          });
          const mergedHandleMouseMoveRef = vue.computed(() => {
            if (useHoverTriggerRef.value) {
              return handleMouseMove;
            }
            return void 0;
          });
          const checkedRef = useMemo(() => {
            const { value: multiple } = multipleRef;
            if (!multiple)
              return mergedValueRef.value === valueRef.value;
            return checkedKeysRef.value.includes(valueRef.value);
          });
          const indeterminateRef = useMemo(() => {
            if (!multipleRef.value)
              return false;
            return indeterminateKeysRef.value.includes(valueRef.value);
          });
          const hoverPendingRef = useMemo(() => {
            return hoverKeyPathRef.value.includes(valueRef.value);
          });
          const keyboardPendingRef = useMemo(() => {
            const { value: keyboardKey } = keyboardKeyRef;
            if (keyboardKey === null)
              return false;
            return keyboardKey === valueRef.value;
          });
          const isLoadingRef = useMemo(() => {
            if (remoteRef.value) {
              return loadingKeySetRef.value.has(valueRef.value);
            }
            return false;
          });
          const isLeafRef = vue.computed(() => props.tmNode.isLeaf);
          const disabledRef = vue.computed(() => props.tmNode.disabled);
          const labelRef = vue.computed(() => props.tmNode.rawNode[labelFieldRef.value]);
          const isShallowLoadedRef = vue.computed(() => {
            return props.tmNode.shallowLoaded;
          });
          function handleClick2(e) {
            if (disabledRef.value)
              return;
            const { value: remote } = remoteRef;
            const { value: loadingKeySet } = loadingKeySetRef;
            const { value: onLoad } = onLoadRef;
            const { value } = valueRef;
            const { value: isLeaf2 } = isLeafRef;
            const { value: isShallowLoaded2 } = isShallowLoadedRef;
            if (!happensIn(e, "checkbox")) {
              if (remote && !isShallowLoaded2 && !loadingKeySet.has(value) && onLoad) {
                addLoadingKey(value);
                onLoad(props.tmNode.rawNode).then(() => {
                  deleteLoadingKey(value);
                }).catch(() => {
                  deleteLoadingKey(value);
                });
              }
              updateHoverKey(value);
              updateKeyboardKey(value);
            }
            if (isLeaf2) {
              toggleCheckbox();
            }
          }
          function handleMouseEnter() {
            if (!useHoverTriggerRef.value || disabledRef.value)
              return;
            const { value } = valueRef;
            updateHoverKey(value);
            updateKeyboardKey(value);
          }
          function handleMouseMove() {
            if (!useHoverTriggerRef.value)
              return;
            handleMouseEnter();
          }
          function handleCheckboxUpdateValue() {
            const { value: isLeaf2 } = isLeafRef;
            if (!isLeaf2)
              toggleCheckbox();
          }
          function toggleCheckbox() {
            const { value: multiple } = multipleRef;
            const { value } = valueRef;
            if (multiple) {
              if (indeterminateRef.value || checkedRef.value) {
                doUncheck(value);
              } else {
                doCheck(value);
              }
            } else {
              doCheck(value);
              closeMenu(true);
            }
          }
          return {
            checkStrategy: mergedCheckStrategyRef,
            multiple: multipleRef,
            cascade: cascadeRef,
            checked: checkedRef,
            indeterminate: indeterminateRef,
            hoverPending: hoverPendingRef,
            keyboardPending: keyboardPendingRef,
            isLoading: isLoadingRef,
            showCheckbox: showCheckboxRef,
            isLeaf: isLeafRef,
            disabled: disabledRef,
            label: labelRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            handleClick: handleClick2,
            handleCheckboxUpdateValue,
            mergedHandleMouseEnter: mergedHandleMouseEnterRef,
            mergedHandleMouseMove: mergedHandleMouseMoveRef,
            renderLabel: renderLabelRef
          };
        },
        render() {
          const { mergedClsPrefix, renderLabel } = this;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-cascader-option`,
              {
                [`${mergedClsPrefix}-cascader-option--pending`]: this.keyboardPending || this.hoverPending,
                [`${mergedClsPrefix}-cascader-option--disabled`]: this.disabled,
                [`${mergedClsPrefix}-cascader-option--show-prefix`]: this.showCheckbox
              }
            ], onMouseenter: this.mergedHandleMouseEnter, onMousemove: this.mergedHandleMouseMove, onClick: this.handleClick },
            this.showCheckbox ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-cascader-option__prefix` },
              vue.h(NCheckbox, { focusable: false, "data-checkbox": true, disabled: this.disabled, checked: this.checked, indeterminate: this.indeterminate, theme: this.mergedTheme.peers.Checkbox, themeOverrides: this.mergedTheme.peerOverrides.Checkbox, onUpdateChecked: this.handleCheckboxUpdateValue })
            ) : null,
            vue.h("span", { class: `${mergedClsPrefix}-cascader-option__label` }, renderLabel ? renderLabel(this.tmNode.rawNode, this.checked) : this.label),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-cascader-option__suffix` },
              vue.h("div", { class: `${mergedClsPrefix}-cascader-option-icon-placeholder` }, !this.isLeaf ? vue.h(NBaseLoading, { clsPrefix: mergedClsPrefix, scale: 0.85, strokeWidth: 24, show: this.isLoading, class: `${mergedClsPrefix}-cascader-option-icon` }, {
                default: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, key: "arrow", class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--arrow` }, {
                  default: () => vue.h(ChevronRightIcon, null)
                })
              }) : this.checkStrategy === "child" && !(this.multiple && this.cascade) ? vue.h(vue.Transition, { name: "fade-in-scale-up-transition" }, {
                default: () => this.checked ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--checkmark` }, { default: () => vue.h(FinishedIcon, null) }) : null
              }) : null)
            )
          );
        }
      });
      const NCascaderSubmenu = vue.defineComponent({
        name: "CascaderSubmenu",
        props: {
          depth: {
            type: Number,
            required: true
          },
          tmNodes: {
            type: Array,
            required: true
          }
        },
        setup() {
          const {
            virtualScrollRef,
            mergedClsPrefixRef,
            mergedThemeRef,
            optionHeightRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(cascaderInjectionKey);
          const scrollbarInstRef = vue.ref(null);
          const vlInstRef = vue.ref(null);
          const inst = {
            scroll(index, elSize) {
              var _a, _b;
              if (virtualScrollRef.value) {
                (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
                  index
                });
              } else {
                (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
                  index,
                  elSize
                });
              }
            }
          };
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            scrollbarInstRef,
            vlInstRef,
            virtualScroll: virtualScrollRef,
            itemSize: vue.computed(() => depx(optionHeightRef.value)),
            handleVlScroll: () => {
              var _a;
              (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
            },
            getVlContainer: () => {
              var _a;
              return (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
            },
            getVlContent: () => {
              var _a;
              return (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
            }
          }, inst);
        },
        render() {
          const { mergedClsPrefix, mergedTheme, virtualScroll } = this;
          return vue.h(
            "div",
            { class: [
              virtualScroll && `${mergedClsPrefix}-cascader-submenu--virtual`,
              `${mergedClsPrefix}-cascader-submenu`
            ] },
            vue.h(NScrollbar, { ref: "scrollbarInstRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: virtualScroll ? this.getVlContainer : void 0, content: virtualScroll ? this.getVlContent : void 0 }, {
              default: () => virtualScroll ? vue.h(VVirtualList, { items: this.tmNodes, itemSize: this.itemSize, onScroll: this.handleVlScroll, showScrollbar: false, ref: "vlInstRef" }, {
                default: ({ item: tmNode }) => vue.h(NCascaderOption, { key: tmNode.key, tmNode })
              }) : this.tmNodes.map((tmNode) => vue.h(NCascaderOption, { key: tmNode.key, tmNode }))
            })
          );
        }
      });
      const CascaderMenu = vue.defineComponent({
        name: "NCascaderMenu",
        props: {
          value: [String, Number, Array],
          placement: {
            type: String,
            default: "bottom-start"
          },
          show: Boolean,
          menuModel: {
            type: Array,
            required: true
          },
          loading: Boolean,
          onFocus: {
            type: Function,
            required: true
          },
          onBlur: {
            type: Function,
            required: true
          },
          onKeydown: {
            type: Function,
            required: true
          },
          onMousedown: {
            type: Function,
            required: true
          },
          onTabout: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            localeRef,
            isMountedRef,
            mergedClsPrefixRef,
            syncCascaderMenuPosition,
            handleCascaderMenuClickOutside,
            mergedThemeRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(cascaderInjectionKey);
          const submenuInstRefs = [];
          const maskInstRef = vue.ref(null);
          const selfElRef = vue.ref(null);
          function handleResize() {
            syncCascaderMenuPosition();
          }
          useOnResize(selfElRef, handleResize);
          function showErrorMessage(label) {
            var _a;
            const { value: { loadingRequiredMessage } } = localeRef;
            (_a = maskInstRef.value) === null || _a === void 0 ? void 0 : _a.showOnce(loadingRequiredMessage(label));
          }
          function handleClickOutside(e) {
            handleCascaderMenuClickOutside(e);
          }
          function handleFocusin(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
              return;
            if (!selfEl.contains(e.relatedTarget)) {
              props.onFocus(e);
            }
          }
          function handleFocusout(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
              return;
            if (!selfEl.contains(e.relatedTarget)) {
              props.onBlur(e);
            }
          }
          const exposedRef = {
            scroll(depth, index, elSize) {
              const submenuInst = submenuInstRefs[depth];
              if (submenuInst) {
                submenuInst.scroll(index, elSize);
              }
            },
            showErrorMessage
          };
          return Object.assign({
            isMounted: isMountedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            selfElRef,
            submenuInstRefs,
            maskInstRef,
            mergedTheme: mergedThemeRef,
            handleFocusin,
            handleFocusout,
            handleClickOutside
          }, exposedRef);
        },
        render() {
          const { submenuInstRefs, mergedClsPrefix, mergedTheme } = this;
          return vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
            default: () => {
              if (!this.show)
                return null;
              return vue.withDirectives(vue.h(
                "div",
                { tabindex: "0", ref: "selfElRef", class: `${mergedClsPrefix}-cascader-menu`, onMousedown: this.onMousedown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeydown: this.onKeydown },
                this.menuModel[0].length ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-cascader-submenu-wrapper` },
                  this.menuModel.map((submenuOptions, index) => vue.h(NCascaderSubmenu, { ref: (instance) => {
                    if (instance) {
                      submenuInstRefs[index] = instance;
                    }
                  }, key: index, tmNodes: submenuOptions, depth: index + 1 })),
                  vue.h(NBaseMenuMask, { clsPrefix: mergedClsPrefix, ref: "maskInstRef" })
                ) : vue.h("div", { class: `${mergedClsPrefix}-cascader-menu__empty` }, resolveSlot(this.$slots.empty, () => [
                  vue.h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
                ])),
                resolveWrappedSlot(this.$slots.action, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-cascader-menu-action`, "data-action": true }, children)),
                vue.h(FocusDetector, { onFocus: this.onTabout })
              ), [
                [
                  clickoutside$1,
                  this.handleClickOutside,
                  void 0,
                  { capture: true }
                ]
              ]);
            }
          });
        }
      });
      const CascaderSelectMenu = vue.defineComponent({
        name: "NCascaderSelectMenu",
        props: {
          value: {
            type: [String, Number, Array],
            default: null
          },
          show: Boolean,
          pattern: {
            type: String,
            default: ""
          },
          multiple: Boolean,
          tmNodes: {
            type: Array,
            default: () => []
          },
          filter: Function,
          labelField: {
            type: String,
            required: true
          },
          separator: {
            type: String,
            required: true
          }
        },
        setup(props) {
          const {
            isMountedRef,
            mergedValueRef,
            mergedClsPrefixRef,
            mergedThemeRef,
            mergedCheckStrategyRef,
            slots: cascaderSlots,
            syncSelectMenuPosition,
            closeMenu,
            handleSelectMenuClickOutside,
            doUncheck: cascaderDoUncheck,
            doCheck: cascaderDoCheck,
            clearPattern
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(cascaderInjectionKey);
          const menuInstRef = vue.ref(null);
          const selectOptionsRef = vue.computed(() => {
            return createSelectOptions(props.tmNodes, mergedCheckStrategyRef.value === "child", props.labelField, props.separator);
          });
          const mergedFilterRef = vue.computed(() => {
            const { filter } = props;
            if (filter)
              return filter;
            const { labelField } = props;
            return (pattern2, _, path) => path.some((option) => option[labelField] && ~option[labelField].indexOf(pattern2));
          });
          const filteredSelectOptionsRef = vue.computed(() => {
            const { pattern: pattern2 } = props;
            const { value: mergedFilter } = mergedFilterRef;
            return (pattern2 ? selectOptionsRef.value.filter((option) => {
              return mergedFilter(pattern2, option.rawNode, option.path);
            }) : selectOptionsRef.value).map((option) => ({
              value: option.value,
              label: option.label
            }));
          });
          const selectTreeMateRef = vue.computed(() => {
            return createTreeMate(filteredSelectOptionsRef.value, createTmOptions("value", "children"));
          });
          function handleResize() {
            syncSelectMenuPosition();
          }
          function handleToggle(tmNode) {
            doCheck(tmNode);
          }
          function doCheck(tmNode) {
            if (props.multiple) {
              const { value: mergedValue } = mergedValueRef;
              if (Array.isArray(mergedValue)) {
                if (!mergedValue.includes(tmNode.key)) {
                  cascaderDoCheck(tmNode.key);
                } else {
                  cascaderDoUncheck(tmNode.key);
                }
              } else if (mergedValue === null) {
                cascaderDoCheck(tmNode.key);
              }
              clearPattern();
            } else {
              cascaderDoCheck(tmNode.key);
              closeMenu(true);
            }
          }
          function prev() {
            var _a;
            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
          }
          function next() {
            var _a;
            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();
          }
          function enter() {
            var _a;
            if (menuInstRef) {
              const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();
              if (pendingOptionTmNode) {
                doCheck(pendingOptionTmNode);
              }
              return true;
            }
            return false;
          }
          function handleClickOutside(e) {
            handleSelectMenuClickOutside(e);
          }
          const exposedRef = {
            prev,
            next,
            enter
          };
          return Object.assign({
            isMounted: isMountedRef,
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            menuInstRef,
            selectTreeMate: selectTreeMateRef,
            handleResize,
            handleToggle,
            handleClickOutside,
            cascaderSlots
          }, exposedRef);
        },
        render() {
          const { mergedClsPrefix, isMounted: isMounted2, mergedTheme, cascaderSlots } = this;
          return vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: isMounted2 }, {
            default: () => this.show ? vue.withDirectives(vue.h(NInternalSelectMenu, { ref: "menuInstRef", onResize: this.handleResize, clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-menu`, autoPending: true, themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu, theme: mergedTheme.peers.InternalSelectMenu, treeMate: this.selectTreeMate, multiple: this.multiple, value: this.value, onToggle: this.handleToggle }, {
              empty: () => resolveSlot(cascaderSlots["not-found"], () => [])
            }), [
              [
                clickoutside$1,
                this.handleClickOutside,
                void 0,
                { capture: true }
              ]
            ]) : null
          });
        }
      });
      const style$13 = c$1([cB("cascader-menu", `
 outline: none;
 position: relative;
 margin: 4px 0;
 display: flex;
 flex-flow: column nowrap;
 border-radius: var(--n-menu-border-radius);
 overflow: hidden;
 box-shadow: var(--n-menu-box-shadow);
 color: var(--n-option-text-color);
 background-color: var(--n-menu-color);
 `, [fadeInScaleUpTransition({
        transformOrigin: "inherit",
        duration: "0.2s"
      }), cE("empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cB("scrollbar", {
        // if width not set, cascader select menu's inner scroll area's width is
        // not correct, which won't change after select menu width is set
        width: "100%"
      }), cB("base-menu-mask", {
        backgroundColor: "var(--n-menu-mask-color)"
      }), cB("base-loading", {
        color: "var(--n-loading-color)"
      }), cB("cascader-submenu-wrapper", `
 position: relative;
 display: flex;
 flex-wrap: nowrap;
 `), cB("cascader-submenu", `
 height: var(--n-menu-height);
 min-width: var(--n-column-width);
 position: relative;
 `, [cM("virtual", `
 width: var(--n-column-width);
 `), cB("scrollbar-content", {
        position: "relative"
      }), c$1("&:first-child", `
 border-top-left-radius: var(--n-menu-border-radius);
 border-bottom-left-radius: var(--n-menu-border-radius);
 `), c$1("&:last-child", `
 border-top-right-radius: var(--n-menu-border-radius);
 border-bottom-right-radius: var(--n-menu-border-radius);
 `), c$1("&:not(:first-child)", `
 border-left: 1px solid var(--n-menu-divider-color);
 `)]), cB("cascader-menu-action", `
 box-sizing: border-box;
 padding: 8px;
 border-top: 1px solid var(--n-menu-divider-color);
 `), cB("cascader-option", `
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 padding: 0 0 0 18px;
 box-sizing: border-box;
 min-width: 182px;
 background-color: #0000;
 display: flex;
 align-items: center;
 white-space: nowrap;
 position: relative;
 cursor: pointer;
 transition:
 background-color .2s var(--n-bezier),
 color 0.2s var(--n-bezier);
 `, [cM("show-prefix", {
        paddingLeft: 0
      }), cE("label", `
 flex: 1 0 0;
 overflow: hidden;
 text-overflow: ellipsis;
 `), cE("prefix", {
        width: "32px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }), cE("suffix", {
        width: "32px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }), cB("cascader-option-icon-placeholder", {
        lineHeight: 0,
        position: "relative",
        width: "16px",
        height: "16px",
        fontSize: "16px"
      }, [cB("cascader-option-icon", [cM("checkmark", {
        color: "var(--n-option-check-mark-color)"
      }, [fadeInScaleUpTransition({
        originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
      })]), cM("arrow", {
        color: "var(--n-option-arrow-color)"
      })])]), cM("selected", {
        color: "var(--n-option-text-color-active)"
      }), cM("active", {
        color: "var(--n-option-text-color-active)",
        backgroundColor: "var(--n-option-color-hover)"
      }), cM("pending", {
        backgroundColor: "var(--n-option-color-hover)"
      }), c$1("&:hover", {
        backgroundColor: "var(--n-option-color-hover)"
      }), cM("disabled", `
 color: var(--n-option-text-color-disabled);
 background-color: #0000;
 cursor: not-allowed;
 `, [cB("cascader-option-icon", [cM("arrow", {
        color: "var(--n-option-text-color-disabled)"
      })])])])]), cB("cascader", `
 z-index: auto;
 position: relative;
 width: 100%;
 `)]);
      const cascaderProps = Object.assign(Object.assign({}, useTheme.props), {
        allowCheckingNotLoaded: Boolean,
        to: useAdjustedTo.propTo,
        bordered: {
          type: Boolean,
          default: void 0
        },
        options: {
          type: Array,
          default: () => []
        },
        value: [String, Number, Array],
        defaultValue: {
          type: [String, Number, Array],
          default: null
        },
        placeholder: String,
        multiple: Boolean,
        size: String,
        filterable: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        },
        disabledField: {
          type: String,
          default: "disabled"
        },
        expandTrigger: {
          type: String,
          default: "click"
        },
        clearable: Boolean,
        clearFilterAfterSelect: {
          type: Boolean,
          default: true
        },
        remote: Boolean,
        onLoad: Function,
        separator: {
          type: String,
          default: " / "
        },
        filter: Function,
        placement: {
          type: String,
          default: "bottom-start"
        },
        cascade: {
          type: Boolean,
          default: true
        },
        leafOnly: Boolean,
        showPath: {
          type: Boolean,
          default: true
        },
        show: {
          type: Boolean,
          default: void 0
        },
        maxTagCount: [String, Number],
        menuProps: Object,
        filterMenuProps: Object,
        virtualScroll: {
          type: Boolean,
          default: true
        },
        checkStrategy: {
          type: String,
          default: "all"
        },
        valueField: {
          type: String,
          default: "value"
        },
        labelField: {
          type: String,
          default: "label"
        },
        childrenField: {
          type: String,
          default: "children"
        },
        renderLabel: Function,
        status: String,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        onBlur: Function,
        onFocus: Function,
        // deprecated
        onChange: [Function, Array]
      });
      const Cascader = vue.defineComponent({
        name: "Cascader",
        props: cascaderProps,
        setup(props, { slots }) {
          const { mergedBorderedRef, mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Cascader", "-cascader", style$13, cascaderLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale("Cascader");
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.computed(() => props.value);
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const mergedCheckStrategyRef = vue.computed(() => {
            return props.leafOnly ? "child" : props.checkStrategy;
          });
          const patternRef = vue.ref("");
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const cascaderMenuInstRef = vue.ref(null);
          const selectMenuInstRef = vue.ref(null);
          const triggerInstRef = vue.ref(null);
          const keyboardKeyRef = vue.ref(null);
          const hoverKeyRef = vue.ref(null);
          const loadingKeySetRef = vue.ref(/* @__PURE__ */ new Set());
          const selectMenuFollowerRef = vue.ref(null);
          const cascaderMenuFollowerRef = vue.ref(null);
          const adjustedToRef = useAdjustedTo(props);
          const focusedRef = vue.ref(false);
          const addLoadingKey = (key) => {
            loadingKeySetRef.value.add(key);
          };
          const deleteLoadingKey = (key) => {
            loadingKeySetRef.value.delete(key);
          };
          const treeMateRef = vue.computed(() => {
            const { valueField, childrenField, disabledField } = props;
            return createTreeMate(props.options, {
              getDisabled(node) {
                return node[disabledField];
              },
              getKey(node) {
                return node[valueField];
              },
              getChildren(node) {
                return node[childrenField];
              }
            });
          });
          const mergedKeysRef = vue.computed(() => {
            const { cascade, multiple } = props;
            if (multiple && Array.isArray(mergedValueRef.value)) {
              return treeMateRef.value.getCheckedKeys(mergedValueRef.value, {
                cascade,
                allowNotLoaded: props.allowCheckingNotLoaded
              });
            } else {
              return {
                checkedKeys: [],
                indeterminateKeys: []
              };
            }
          });
          const checkedKeysRef = vue.computed(() => mergedKeysRef.value.checkedKeys);
          const indeterminateKeysRef = vue.computed(() => mergedKeysRef.value.indeterminateKeys);
          const menuModelRef = vue.computed(() => {
            const { treeNodePath, treeNode } = treeMateRef.value.getPath(hoverKeyRef.value);
            let ret;
            if (treeNode === null) {
              ret = [treeMateRef.value.treeNodes];
            } else {
              ret = treeNodePath.map((treeNode2) => treeNode2.siblings);
              if (!treeNode.isLeaf && !loadingKeySetRef.value.has(treeNode.key) && treeNode.children) {
                ret.push(treeNode.children);
              }
            }
            return ret;
          });
          const hoverKeyPathRef = vue.computed(() => {
            const { keyPath } = treeMateRef.value.getPath(hoverKeyRef.value);
            return keyPath;
          });
          const optionHeightRef = vue.computed(() => {
            return themeRef.value.self.optionHeight;
          });
          if (vue.isReactive(props.options)) {
            vue.watch(props.options, (value, oldValue) => {
              if (!(value === oldValue)) {
                hoverKeyRef.value = null;
                keyboardKeyRef.value = null;
              }
            });
          }
          function doUpdateShow(value) {
            const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow) {
              call(onUpdateShow, value);
            }
            if (_onUpdateShow) {
              call(_onUpdateShow, value);
            }
            uncontrolledShowRef.value = value;
          }
          function doUpdateValue(value, option, optionPath) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue, onChange } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateValue) {
              call(onUpdateValue, value, option, optionPath);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value, option, optionPath);
            }
            if (onChange) {
              call(onChange, value, option, optionPath);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function updateKeyboardKey(key) {
            keyboardKeyRef.value = key;
          }
          function updateHoverKey(key) {
            hoverKeyRef.value = key;
          }
          function getOptionsByKeys(keys2) {
            const { value: { getNode } } = treeMateRef;
            return keys2.map((keys3) => {
              var _a;
              return ((_a = getNode(keys3)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
            });
          }
          function doCheck(key) {
            var _a;
            const { cascade, multiple, filterable } = props;
            const { value: { check, getNode, getPath: getPath2 } } = treeMateRef;
            if (multiple) {
              try {
                const { checkedKeys } = check(key, mergedKeysRef.value.checkedKeys, {
                  cascade,
                  checkStrategy: mergedCheckStrategyRef.value,
                  allowNotLoaded: props.allowCheckingNotLoaded
                });
                doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys), checkedKeys.map((checkedKey) => {
                  var _a2;
                  return getRawNodePath((_a2 = getPath2(checkedKey)) === null || _a2 === void 0 ? void 0 : _a2.treeNodePath);
                }));
                if (filterable)
                  focusSelectionInput();
                keyboardKeyRef.value = key;
                hoverKeyRef.value = key;
              } catch (err) {
                if (err instanceof SubtreeNotLoadedError) {
                  if (cascaderMenuInstRef.value) {
                    const tmNode = getNode(key);
                    if (tmNode !== null) {
                      cascaderMenuInstRef.value.showErrorMessage(tmNode.rawNode[props.labelField]);
                    }
                  }
                } else {
                  throw err;
                }
              }
            } else {
              if (mergedCheckStrategyRef.value === "child") {
                const tmNode = getNode(key);
                if (tmNode === null || tmNode === void 0 ? void 0 : tmNode.isLeaf) {
                  doUpdateValue(key, tmNode.rawNode, getRawNodePath(getPath2(key).treeNodePath));
                } else {
                  return false;
                }
              } else {
                const tmNode = getNode(key);
                doUpdateValue(key, (tmNode === null || tmNode === void 0 ? void 0 : tmNode.rawNode) || null, getRawNodePath((_a = getPath2(key)) === null || _a === void 0 ? void 0 : _a.treeNodePath));
              }
            }
            return true;
          }
          function doUncheck(key) {
            const { cascade, multiple } = props;
            if (multiple) {
              const { value: { uncheck, getNode, getPath: getPath2 } } = treeMateRef;
              const { checkedKeys } = uncheck(key, mergedKeysRef.value.checkedKeys, {
                cascade,
                checkStrategy: mergedCheckStrategyRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              });
              doUpdateValue(checkedKeys, checkedKeys.map((checkedKey) => {
                var _a;
                return ((_a = getNode(checkedKey)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
              }), checkedKeys.map((checkedKey) => {
                var _a;
                return getRawNodePath((_a = getPath2(checkedKey)) === null || _a === void 0 ? void 0 : _a.treeNodePath);
              }));
              keyboardKeyRef.value = key;
              hoverKeyRef.value = key;
            }
          }
          const selectedOptionsRef = vue.computed(() => {
            if (props.multiple) {
              const { showPath, separator, labelField, cascade } = props;
              const { getCheckedKeys: getCheckedKeys2, getNode } = treeMateRef.value;
              const value = getCheckedKeys2(checkedKeysRef.value, {
                cascade,
                checkStrategy: mergedCheckStrategyRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              }).checkedKeys;
              return value.map((key) => {
                const node = getNode(key);
                if (node === null) {
                  return {
                    label: String(key),
                    value: key
                  };
                } else {
                  return {
                    label: showPath ? getPathLabel(node, separator, labelField) : node.rawNode[labelField],
                    value: node.key
                  };
                }
              });
            } else
              return [];
          });
          const selectedOptionRef = vue.computed(() => {
            const { multiple, showPath, separator, labelField } = props;
            const { value } = mergedValueRef;
            if (!multiple && !Array.isArray(value)) {
              const { getNode } = treeMateRef.value;
              if (value === null) {
                return null;
              }
              const node = getNode(value);
              if (node === null) {
                return {
                  label: String(value),
                  value
                };
              } else {
                return {
                  label: showPath ? getPathLabel(node, separator, labelField) : node.rawNode[labelField],
                  value: node.key
                };
              }
            } else
              return null;
          });
          const uncontrolledShowRef = vue.ref(false);
          const controlledShowRef = vue.toRef(props, "show");
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const localizedPlaceholderRef = vue.computed(() => {
            const { placeholder } = props;
            if (placeholder !== void 0)
              return placeholder;
            return localeRef.value.placeholder;
          });
          const showSelectMenuRef = vue.computed(() => {
            return !!(props.filterable && patternRef.value);
          });
          vue.watch(mergedShowRef, (show) => {
            if (!show)
              return;
            if (props.multiple)
              return;
            const { value } = mergedValueRef;
            if (!Array.isArray(value) && value !== null) {
              keyboardKeyRef.value = value;
              hoverKeyRef.value = value;
              void vue.nextTick(() => {
                var _a;
                if (!mergedShowRef.value)
                  return;
                const { value: hoverKey } = hoverKeyRef;
                if (mergedValueRef.value !== null) {
                  const node = treeMateRef.value.getNode(hoverKey);
                  if (node) {
                    (_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.scroll(node.level, node.index, depx(optionHeightRef.value));
                  }
                }
              });
            } else {
              keyboardKeyRef.value = null;
              hoverKeyRef.value = null;
            }
          }, {
            immediate: true
          });
          function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
          }
          function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
          }
          function focusSelectionInput() {
            var _a;
            (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function focusSelection() {
            var _a;
            (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function openMenu() {
            if (!mergedDisabledRef.value) {
              patternRef.value = "";
              doUpdateShow(true);
              if (props.filterable) {
                focusSelectionInput();
              }
            }
          }
          function closeMenu(returnFocus = false) {
            if (returnFocus) {
              focusSelection();
            }
            doUpdateShow(false);
            patternRef.value = "";
          }
          function handleCascaderMenuClickOutside(e) {
            var _a;
            if (showSelectMenuRef.value)
              return;
            if (mergedShowRef.value) {
              if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                closeMenu();
              }
            }
          }
          function handleSelectMenuClickOutside(e) {
            if (!showSelectMenuRef.value)
              return;
            handleCascaderMenuClickOutside(e);
          }
          function clearPattern() {
            if (props.clearFilterAfterSelect)
              patternRef.value = "";
          }
          function move2(direction) {
            var _a, _b, _c;
            const { value: keyboardKey } = keyboardKeyRef;
            const { value: treeMate } = treeMateRef;
            switch (direction) {
              case "prev":
                if (keyboardKey !== null) {
                  const node = treeMate.getPrev(keyboardKey, { loop: true });
                  if (node !== null) {
                    updateKeyboardKey(node.key);
                    (_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.scroll(node.level, node.index, depx(optionHeightRef.value));
                  }
                }
                break;
              case "next":
                if (keyboardKey === null) {
                  const node = treeMate.getFirstAvailableNode();
                  if (node !== null) {
                    updateKeyboardKey(node.key);
                    (_b = cascaderMenuInstRef.value) === null || _b === void 0 ? void 0 : _b.scroll(node.level, node.index, depx(optionHeightRef.value));
                  }
                } else {
                  const node = treeMate.getNext(keyboardKey, { loop: true });
                  if (node !== null) {
                    updateKeyboardKey(node.key);
                    (_c = cascaderMenuInstRef.value) === null || _c === void 0 ? void 0 : _c.scroll(node.level, node.index, depx(optionHeightRef.value));
                  }
                }
                break;
              case "child":
                if (keyboardKey !== null) {
                  const currentNode = treeMate.getNode(keyboardKey);
                  if (currentNode !== null) {
                    if (currentNode.shallowLoaded) {
                      const node = treeMate.getChild(keyboardKey);
                      if (node !== null) {
                        updateHoverKey(keyboardKey);
                        updateKeyboardKey(node.key);
                      }
                    } else {
                      const { value: loadingKeySet } = loadingKeySetRef;
                      if (!loadingKeySet.has(keyboardKey)) {
                        addLoadingKey(keyboardKey);
                        updateHoverKey(keyboardKey);
                        const { onLoad } = props;
                        if (onLoad) {
                          onLoad(currentNode.rawNode).then(() => {
                            deleteLoadingKey(keyboardKey);
                          }).catch(() => {
                            deleteLoadingKey(keyboardKey);
                          });
                        }
                      }
                    }
                  }
                }
                break;
              case "parent":
                if (keyboardKey !== null) {
                  const node = treeMate.getParent(keyboardKey);
                  if (node !== null) {
                    updateKeyboardKey(node.key);
                    const parentNode = node.getParent();
                    if (parentNode === null) {
                      updateHoverKey(null);
                    } else {
                      updateHoverKey(parentNode.key);
                    }
                  }
                }
                break;
            }
          }
          function handleKeydown(e) {
            var _a, _b;
            switch (e.key) {
              case " ":
              case "ArrowDown":
              case "ArrowUp":
                if (props.filterable && mergedShowRef.value) {
                  break;
                }
                e.preventDefault();
                break;
            }
            if (happensIn(e, "action"))
              return;
            switch (e.key) {
              case " ":
                if (props.filterable)
                  return;
              case "Enter":
                if (!mergedShowRef.value) {
                  openMenu();
                } else {
                  const { value: showSelectMenu } = showSelectMenuRef;
                  const { value: keyboardKey } = keyboardKeyRef;
                  if (!showSelectMenu) {
                    if (keyboardKey !== null) {
                      if (checkedKeysRef.value.includes(keyboardKey) || indeterminateKeysRef.value.includes(keyboardKey)) {
                        doUncheck(keyboardKey);
                      } else {
                        const checkIsValid = doCheck(keyboardKey);
                        if (!props.multiple && checkIsValid) {
                          closeMenu(true);
                        }
                      }
                    }
                  } else {
                    if (selectMenuInstRef.value) {
                      const hasCorrespondingOption = selectMenuInstRef.value.enter();
                      if (hasCorrespondingOption)
                        clearPattern();
                    }
                  }
                }
                break;
              case "ArrowUp":
                e.preventDefault();
                if (mergedShowRef.value) {
                  if (showSelectMenuRef.value) {
                    (_a = selectMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
                  } else {
                    move2("prev");
                  }
                }
                break;
              case "ArrowDown":
                e.preventDefault();
                if (mergedShowRef.value) {
                  if (showSelectMenuRef.value) {
                    (_b = selectMenuInstRef.value) === null || _b === void 0 ? void 0 : _b.next();
                  } else {
                    move2("next");
                  }
                } else {
                  openMenu();
                }
                break;
              case "ArrowLeft":
                e.preventDefault();
                if (mergedShowRef.value && !showSelectMenuRef.value) {
                  move2("parent");
                }
                break;
              case "ArrowRight":
                e.preventDefault();
                if (mergedShowRef.value && !showSelectMenuRef.value) {
                  move2("child");
                }
                break;
              case "Escape":
                if (mergedShowRef.value) {
                  markEventEffectPerformed(e);
                  closeMenu(true);
                }
            }
          }
          function handleMenuKeydown(e) {
            handleKeydown(e);
          }
          function handleClear(e) {
            e.stopPropagation();
            if (props.multiple) {
              doUpdateValue([], [], []);
            } else {
              doUpdateValue(null, null, null);
            }
          }
          function handleTriggerFocus(e) {
            var _a;
            if (!((_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
              focusedRef.value = true;
              doFocus(e);
            }
          }
          function handleTriggerBlur(e) {
            var _a;
            if (!((_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
              focusedRef.value = false;
              doBlur(e);
              closeMenu();
            }
          }
          function handleMenuFocus(e) {
            var _a;
            if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
              focusedRef.value = true;
              doFocus(e);
            }
          }
          function handleMenuBlur(e) {
            var _a;
            if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
              focusedRef.value = false;
              doBlur(e);
            }
          }
          function handleMenuMousedown(e) {
            if (!happensIn(e, "action")) {
              if (props.multiple && props.filter) {
                e.preventDefault();
                focusSelectionInput();
              }
            }
          }
          function handleMenuTabout() {
            closeMenu(true);
          }
          function handleTriggerClick() {
            if (props.filterable) {
              openMenu();
            } else {
              if (mergedShowRef.value) {
                closeMenu(true);
              } else {
                openMenu();
              }
            }
          }
          function handlePatternInput(e) {
            patternRef.value = e.target.value;
          }
          function handleDeleteOption(option) {
            const { multiple } = props;
            const { value: mergedValue } = mergedValueRef;
            if (multiple && Array.isArray(mergedValue) && option.value !== void 0) {
              doUncheck(option.value);
            } else {
              doUpdateValue(null, null, null);
            }
          }
          function syncSelectMenuPosition() {
            var _a;
            (_a = selectMenuFollowerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function syncCascaderMenuPosition() {
            var _a;
            (_a = cascaderMenuFollowerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleTriggerResize() {
            if (mergedShowRef.value) {
              if (showSelectMenuRef.value) {
                syncSelectMenuPosition();
              } else {
                syncCascaderMenuPosition();
              }
            }
          }
          const showCheckboxRef = vue.computed(() => {
            if (props.multiple && props.cascade)
              return true;
            if (mergedCheckStrategyRef.value !== "child")
              return true;
            return false;
          });
          vue.provide(cascaderInjectionKey, {
            slots,
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            mergedValueRef,
            checkedKeysRef,
            indeterminateKeysRef,
            hoverKeyPathRef,
            mergedCheckStrategyRef,
            showCheckboxRef,
            cascadeRef: vue.toRef(props, "cascade"),
            multipleRef: vue.toRef(props, "multiple"),
            keyboardKeyRef,
            hoverKeyRef,
            remoteRef: vue.toRef(props, "remote"),
            loadingKeySetRef,
            expandTriggerRef: vue.toRef(props, "expandTrigger"),
            isMountedRef: isMounted(),
            onLoadRef: vue.toRef(props, "onLoad"),
            virtualScrollRef: vue.toRef(props, "virtualScroll"),
            optionHeightRef,
            localeRef,
            labelFieldRef: vue.toRef(props, "labelField"),
            renderLabelRef: vue.toRef(props, "renderLabel"),
            syncCascaderMenuPosition,
            syncSelectMenuPosition,
            updateKeyboardKey,
            updateHoverKey,
            addLoadingKey,
            deleteLoadingKey,
            doCheck,
            doUncheck,
            closeMenu,
            handleSelectMenuClickOutside,
            handleCascaderMenuClickOutside,
            clearPattern
          });
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            },
            getCheckedData: () => {
              if (showCheckboxRef.value) {
                const checkedKeys = checkedKeysRef.value;
                return {
                  keys: checkedKeys,
                  options: getOptionsByKeys(checkedKeys)
                };
              }
              return {
                keys: [],
                options: []
              };
            },
            getIndeterminateData: () => {
              if (showCheckboxRef.value) {
                const indeterminateKeys = indeterminateKeysRef.value;
                return {
                  keys: indeterminateKeys,
                  options: getOptionsByKeys(indeterminateKeys)
                };
              }
              return {
                keys: [],
                options: []
              };
            }
          };
          const cssVarsRef = vue.computed(() => {
            const { self: { optionArrowColor, optionTextColor, optionTextColorActive, optionTextColorDisabled, optionCheckMarkColor, menuColor, menuBoxShadow, menuDividerColor, menuBorderRadius, menuHeight, optionColorHover, optionHeight, optionFontSize, loadingColor, columnWidth }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-menu-border-radius": menuBorderRadius,
              "--n-menu-box-shadow": menuBoxShadow,
              "--n-menu-height": menuHeight,
              "--n-column-width": columnWidth,
              "--n-menu-color": menuColor,
              "--n-menu-divider-color": menuDividerColor,
              "--n-option-height": optionHeight,
              "--n-option-font-size": optionFontSize,
              "--n-option-text-color": optionTextColor,
              "--n-option-text-color-disabled": optionTextColorDisabled,
              "--n-option-text-color-active": optionTextColorActive,
              "--n-option-color-hover": optionColorHover,
              "--n-option-check-mark-color": optionCheckMarkColor,
              "--n-option-arrow-color": optionArrowColor,
              "--n-menu-mask-color": changeColor(menuColor, { alpha: 0.75 }),
              "--n-loading-color": loadingColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("cascader", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedMethods), {
            handleTriggerResize,
            mergedStatus: mergedStatusRef,
            selectMenuFollowerRef,
            cascaderMenuFollowerRef,
            triggerInstRef,
            selectMenuInstRef,
            cascaderMenuInstRef,
            mergedBordered: mergedBorderedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            mergedValue: mergedValueRef,
            mergedShow: mergedShowRef,
            showSelectMenu: showSelectMenuRef,
            pattern: patternRef,
            treeMate: treeMateRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            localizedPlaceholder: localizedPlaceholderRef,
            selectedOption: selectedOptionRef,
            selectedOptions: selectedOptionsRef,
            adjustedTo: adjustedToRef,
            menuModel: menuModelRef,
            handleMenuTabout,
            handleMenuFocus,
            handleMenuBlur,
            handleMenuKeydown,
            handleMenuMousedown,
            handleTriggerFocus,
            handleTriggerBlur,
            handleTriggerClick,
            handleClear,
            handleDeleteOption,
            handlePatternInput,
            handleKeydown,
            focused: focusedRef,
            optionHeight: optionHeightRef,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-cascader` },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h(NInternalSelection, { onResize: this.handleTriggerResize, ref: "triggerInstRef", status: this.mergedStatus, clsPrefix: mergedClsPrefix, maxTagCount: this.maxTagCount, bordered: this.mergedBordered, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, active: this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, focused: this.focused, onFocus: this.handleTriggerFocus, onBlur: this.handleTriggerBlur, onClick: this.handleTriggerClick, onClear: this.handleClear, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onKeydown: this.handleKeydown }, {
                    arrow: () => {
                      var _a, _b;
                      return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a);
                    }
                  })
                }),
                vue.h(VFollower, { key: "cascaderMenu", ref: "cascaderMenuFollowerRef", show: this.mergedShow && !this.showSelectMenu, containerClass: this.namespace, placement: this.placement, width: !this.options.length ? "target" : void 0, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, to: this.adjustedTo }, {
                  default: () => {
                    var _a;
                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                    const { menuProps: menuProps2 } = this;
                    return vue.h(CascaderMenu, Object.assign({}, menuProps2, { ref: "cascaderMenuInstRef", class: [this.themeClass, menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.class], value: this.mergedValue, show: this.mergedShow && !this.showSelectMenu, menuModel: this.menuModel, style: [
                      this.cssVars,
                      menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.style
                    ], onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onMousedown: this.handleMenuMousedown, onTabout: this.handleMenuTabout }), {
                      action: () => {
                        var _a2, _b;
                        return (_b = (_a2 = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a2);
                      },
                      empty: () => {
                        var _a2, _b;
                        return (_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2);
                      }
                    });
                  }
                }),
                vue.h(VFollower, { key: "selectMenu", ref: "selectMenuFollowerRef", show: this.mergedShow && this.showSelectMenu, containerClass: this.namespace, width: "target", placement: this.placement, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
                  default: () => {
                    var _a;
                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                    const { filterMenuProps } = this;
                    return vue.h(CascaderSelectMenu, Object.assign({}, filterMenuProps, { ref: "selectMenuInstRef", class: [this.themeClass, filterMenuProps === null || filterMenuProps === void 0 ? void 0 : filterMenuProps.class], value: this.mergedValue, show: this.mergedShow && this.showSelectMenu, pattern: this.pattern, multiple: this.multiple, tmNodes: this.treeMate.treeNodes, filter: this.filter, labelField: this.labelField, separator: this.separator, style: [
                      this.cssVars,
                      filterMenuProps === null || filterMenuProps === void 0 ? void 0 : filterMenuProps.style
                    ] }));
                  }
                })
              ]
            })
          );
        }
      });
      const codeDark = {
        name: "Code",
        common: commonDark,
        self(vars) {
          const { textColor2, fontSize: fontSize2, fontWeightStrong, textColor3 } = vars;
          return {
            textColor: textColor2,
            fontSize: fontSize2,
            fontWeightStrong,
            // extracted from hljs atom-one-dark.scss
            "mono-3": "#5c6370",
            "hue-1": "#56b6c2",
            "hue-2": "#61aeee",
            "hue-3": "#c678dd",
            "hue-4": "#98c379",
            "hue-5": "#e06c75",
            "hue-5-2": "#be5046",
            "hue-6": "#d19a66",
            "hue-6-2": "#e6c07b",
            // line-number styles
            lineNumberTextColor: textColor3
          };
        }
      };
      const codeDark$1 = codeDark;
      const self$T = (vars) => {
        const { textColor2, fontSize: fontSize2, fontWeightStrong, textColor3 } = vars;
        return {
          textColor: textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          // extracted from hljs atom-one-light.scss
          "mono-3": "#a0a1a7",
          "hue-1": "#0184bb",
          "hue-2": "#4078f2",
          "hue-3": "#a626a4",
          "hue-4": "#50a14f",
          "hue-5": "#e45649",
          "hue-5-2": "#c91243",
          "hue-6": "#986801",
          "hue-6-2": "#c18401",
          // line-number styles
          lineNumberTextColor: textColor3
        };
      };
      const codeLight = {
        name: "Code",
        common: commonLight,
        self: self$T
      };
      const codeLight$1 = codeLight;
      const style$12 = c$1([cB("code", `
 font-size: var(--n-font-size);
 font-family: var(--n-font-family);
 `, [cM("show-line-numbers", `
 display: flex;
 `), cE("line-numbers", `
 user-select: none;
 padding-right: 12px;
 text-align: right;
 transition: color .3s var(--n-bezier);
 color: var(--n-line-number-text-color);
 `), cM("word-wrap", [c$1("pre", `
 white-space: pre-wrap;
 word-break: break-all;
 `)]), c$1("pre", `
 margin: 0;
 line-height: inherit;
 font-size: inherit;
 font-family: inherit;
 `), c$1("[class^=hljs]", `
 color: var(--n-text-color);
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ({
        props
      }) => {
        const codeClass = `${props.bPrefix}code`;
        return [`${codeClass} .hljs-comment,
 ${codeClass} .hljs-quote {
 color: var(--n-mono-3);
 font-style: italic;
 }`, `${codeClass} .hljs-doctag,
 ${codeClass} .hljs-keyword,
 ${codeClass} .hljs-formula {
 color: var(--n-hue-3);
 }`, `${codeClass} .hljs-section,
 ${codeClass} .hljs-name,
 ${codeClass} .hljs-selector-tag,
 ${codeClass} .hljs-deletion,
 ${codeClass} .hljs-subst {
 color: var(--n-hue-5);
 }`, `${codeClass} .hljs-literal {
 color: var(--n-hue-1);
 }`, `${codeClass} .hljs-string,
 ${codeClass} .hljs-regexp,
 ${codeClass} .hljs-addition,
 ${codeClass} .hljs-attribute,
 ${codeClass} .hljs-meta-string {
 color: var(--n-hue-4);
 }`, `${codeClass} .hljs-built_in,
 ${codeClass} .hljs-class .hljs-title {
 color: var(--n-hue-6-2);
 }`, `${codeClass} .hljs-attr,
 ${codeClass} .hljs-variable,
 ${codeClass} .hljs-template-variable,
 ${codeClass} .hljs-type,
 ${codeClass} .hljs-selector-class,
 ${codeClass} .hljs-selector-attr,
 ${codeClass} .hljs-selector-pseudo,
 ${codeClass} .hljs-number {
 color: var(--n-hue-6);
 }`, `${codeClass} .hljs-symbol,
 ${codeClass} .hljs-bullet,
 ${codeClass} .hljs-link,
 ${codeClass} .hljs-meta,
 ${codeClass} .hljs-selector-id,
 ${codeClass} .hljs-title {
 color: var(--n-hue-2);
 }`, `${codeClass} .hljs-emphasis {
 font-style: italic;
 }`, `${codeClass} .hljs-strong {
 font-weight: var(--n-font-weight-strong);
 }`, `${codeClass} .hljs-link {
 text-decoration: underline;
 }`];
      }]);
      const codeProps = Object.assign(Object.assign({}, useTheme.props), {
        language: String,
        code: {
          type: String,
          default: ""
        },
        trim: {
          type: Boolean,
          default: true
        },
        hljs: Object,
        uri: Boolean,
        inline: Boolean,
        wordWrap: Boolean,
        showLineNumbers: Boolean,
        // In n-log, we only need to mount code's style for highlight
        internalFontSize: Number,
        internalNoHighlight: Boolean
      });
      const NCode = vue.defineComponent({
        name: "Code",
        props: codeProps,
        setup(props, { slots }) {
          const { internalNoHighlight } = props;
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig();
          const codeRef = vue.ref(null);
          const hljsRef = internalNoHighlight ? { value: void 0 } : useHljs(props);
          const createCodeHtml = (language, code, trim2) => {
            const { value: hljs } = hljsRef;
            if (!hljs) {
              return null;
            }
            if (!(language && hljs.getLanguage(language))) {
              return null;
            }
            return hljs.highlight(trim2 ? code.trim() : code, {
              language
            }).value;
          };
          const mergedShowLineNumbersRef = vue.computed(() => {
            if (props.inline || props.wordWrap)
              return false;
            return props.showLineNumbers;
          });
          const setCode = () => {
            if (slots.default)
              return;
            const { value: codeEl } = codeRef;
            if (!codeEl)
              return;
            const { language } = props;
            const code = props.uri ? window.decodeURIComponent(props.code) : props.code;
            if (language) {
              const html = createCodeHtml(language, code, props.trim);
              if (html !== null) {
                if (props.inline) {
                  codeEl.innerHTML = html;
                } else {
                  const prevPreEl = codeEl.querySelector(".__code__");
                  if (prevPreEl)
                    codeEl.removeChild(prevPreEl);
                  const preEl = document.createElement("pre");
                  preEl.className = "__code__";
                  preEl.innerHTML = html;
                  codeEl.appendChild(preEl);
                }
                return;
              }
            }
            if (props.inline) {
              codeEl.textContent = code;
              return;
            }
            const maybePreEl = codeEl.querySelector(".__code__");
            if (maybePreEl) {
              maybePreEl.textContent = code;
            } else {
              const wrap = document.createElement("pre");
              wrap.className = "__code__";
              wrap.textContent = code;
              codeEl.innerHTML = "";
              codeEl.appendChild(wrap);
            }
          };
          vue.onMounted(setCode);
          vue.watch(vue.toRef(props, "language"), setCode);
          vue.watch(vue.toRef(props, "code"), setCode);
          if (!internalNoHighlight)
            vue.watch(hljsRef, setCode);
          const themeRef = useTheme("Code", "-code", style$12, codeLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, fontFamilyMono }, self: {
              textColor,
              fontSize: fontSize2,
              fontWeightStrong,
              lineNumberTextColor,
              // extracted from hljs atom-one-light.scss
              "mono-3": $1,
              "hue-1": $2,
              "hue-2": $3,
              "hue-3": $4,
              "hue-4": $5,
              "hue-5": $6,
              "hue-5-2": $7,
              "hue-6": $8,
              "hue-6-2": $9
            } } = themeRef.value;
            const { internalFontSize } = props;
            return {
              "--n-font-size": internalFontSize ? `${internalFontSize}px` : fontSize2,
              "--n-font-family": fontFamilyMono,
              "--n-font-weight-strong": fontWeightStrong,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-mono-3": $1,
              "--n-hue-1": $2,
              "--n-hue-2": $3,
              "--n-hue-3": $4,
              "--n-hue-4": $5,
              "--n-hue-5": $6,
              "--n-hue-5-2": $7,
              "--n-hue-6": $8,
              "--n-hue-6-2": $9,
              "--n-line-number-text-color": lineNumberTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("code", vue.computed(() => {
            return `${props.internalFontSize || "a"}`;
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            codeRef,
            mergedShowLineNumbers: mergedShowLineNumbersRef,
            lineNumbers: vue.computed(() => {
              let number2 = 1;
              const numbers = [];
              let lastIsLineWrap = false;
              for (const char of props.code) {
                if (char === "\n") {
                  lastIsLineWrap = true;
                  numbers.push(number2++);
                } else {
                  lastIsLineWrap = false;
                }
              }
              if (!lastIsLineWrap) {
                numbers.push(number2++);
              }
              return numbers.join("\n");
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a, _b;
          const { mergedClsPrefix, wordWrap, mergedShowLineNumbers, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "code",
            { class: [
              `${mergedClsPrefix}-code`,
              this.themeClass,
              wordWrap && `${mergedClsPrefix}-code--word-wrap`,
              mergedShowLineNumbers && `${mergedClsPrefix}-code--show-line-numbers`
            ], style: this.cssVars, ref: "codeRef" },
            mergedShowLineNumbers ? vue.h("pre", { class: `${mergedClsPrefix}-code__line-numbers` }, this.lineNumbers) : null,
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)
          );
        }
      });
      const self$S = (vars) => {
        const { fontWeight, textColor1, textColor2, textColorDisabled, dividerColor, fontSize: fontSize2 } = vars;
        return {
          titleFontSize: fontSize2,
          titleFontWeight: fontWeight,
          dividerColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          fontSize: fontSize2,
          textColor: textColor2,
          arrowColor: textColor2,
          arrowColorDisabled: textColorDisabled,
          itemMargin: "16px 0 0 0",
          titlePadding: "16px 0 0 0"
        };
      };
      const collapseLight = {
        name: "Collapse",
        common: commonLight,
        self: self$S
      };
      const collapseLight$1 = collapseLight;
      const collapseDark = {
        name: "Collapse",
        common: commonDark,
        self: self$S
      };
      const collapseDark$1 = collapseDark;
      const style$11 = cB("collapse", "width: 100%;", [cB("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [cM("disabled", [cE("header", "cursor: not-allowed;", [cE("header-main", `
 color: var(--n-title-text-color-disabled);
 `), cB("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), cB("collapse-item", "margin-left: 32px;"), c$1("&:first-child", "margin-top: 0;"), c$1("&:first-child >", [cE("header", "padding-top: 0;")]), cM("left-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-right: 4px;")])]), cM("right-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-left: 4px;")])]), cE("content-wrapper", [cE("content-inner", "padding-top: 16px;"), fadeInHeightExpandTransition({
        duration: "0.15s"
      })]), cM("active", [cE("header", [cM("active", [cB("collapse-item-arrow", "transform: rotate(90deg);")])])]), c$1("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), cE("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 cursor: pointer;
 `, [cE("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), cE("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cB("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]);
      const collapseProps = Object.assign(Object.assign({}, useTheme.props), {
        defaultExpandedNames: {
          type: [Array, String],
          default: null
        },
        expandedNames: [Array, String],
        arrowPlacement: {
          type: String,
          default: "left"
        },
        accordion: {
          type: Boolean,
          default: false
        },
        displayDirective: {
          type: String,
          default: "if"
        },
        onItemHeaderClick: [Function, Array],
        "onUpdate:expandedNames": [Function, Array],
        onUpdateExpandedNames: [Function, Array],
        // deprecated
        onExpandedNamesChange: {
          type: [Function, Array],
          validator: () => {
            return true;
          },
          default: void 0
        }
      });
      const collapseInjectionKey = createInjectionKey("n-collapse");
      const NCollapse = vue.defineComponent({
        name: "Collapse",
        props: collapseProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const uncontrolledExpandedNamesRef = vue.ref(props.defaultExpandedNames);
          const controlledExpandedNamesRef = vue.computed(() => props.expandedNames);
          const mergedExpandedNamesRef = useMergedState(controlledExpandedNamesRef, uncontrolledExpandedNamesRef);
          const themeRef = useTheme("Collapse", "-collapse", style$11, collapseLight$1, props, mergedClsPrefixRef);
          function doUpdateExpandedNames(names) {
            const { "onUpdate:expandedNames": _onUpdateExpandedNames, onUpdateExpandedNames, onExpandedNamesChange } = props;
            if (onUpdateExpandedNames) {
              call(onUpdateExpandedNames, names);
            }
            if (_onUpdateExpandedNames) {
              call(_onUpdateExpandedNames, names);
            }
            if (onExpandedNamesChange) {
              call(onExpandedNamesChange, names);
            }
            uncontrolledExpandedNamesRef.value = names;
          }
          function doItemHeaderClick(info) {
            const { onItemHeaderClick } = props;
            if (onItemHeaderClick) {
              call(onItemHeaderClick, info);
            }
          }
          function toggleItem(collapse, name, event) {
            const { accordion } = props;
            const { value: expandedNames } = mergedExpandedNamesRef;
            if (accordion) {
              if (collapse) {
                doUpdateExpandedNames([name]);
                doItemHeaderClick({ name, expanded: true, event });
              } else {
                doUpdateExpandedNames([]);
                doItemHeaderClick({ name, expanded: false, event });
              }
            } else {
              if (!Array.isArray(expandedNames)) {
                doUpdateExpandedNames([name]);
                doItemHeaderClick({ name, expanded: true, event });
              } else {
                const activeNames = expandedNames.slice();
                const index = activeNames.findIndex((activeName) => name === activeName);
                if (~index) {
                  activeNames.splice(index, 1);
                  doUpdateExpandedNames(activeNames);
                  doItemHeaderClick({ name, expanded: false, event });
                } else {
                  activeNames.push(name);
                  doUpdateExpandedNames(activeNames);
                  doItemHeaderClick({ name, expanded: true, event });
                }
              }
            }
          }
          vue.provide(collapseInjectionKey, {
            props,
            mergedClsPrefixRef,
            expandedNamesRef: mergedExpandedNamesRef,
            slots,
            toggleItem
          });
          const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { titleFontWeight, dividerColor, titlePadding, titleTextColor, titleTextColorDisabled, textColor, arrowColor, fontSize: fontSize2, titleFontSize, arrowColorDisabled, itemMargin } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-divider-color": dividerColor,
              "--n-title-padding": titlePadding,
              "--n-title-font-size": titleFontSize,
              "--n-title-text-color": titleTextColor,
              "--n-title-text-color-disabled": titleTextColorDisabled,
              "--n-title-font-weight": titleFontWeight,
              "--n-arrow-color": arrowColor,
              "--n-arrow-color-disabled": arrowColorDisabled,
              "--n-item-margin": itemMargin
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse", void 0, cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedTheme: themeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", { class: [
            `${this.mergedClsPrefix}-collapse`,
            this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`,
            this.themeClass
          ], style: this.cssVars }, this.$slots);
        }
      });
      const NCollapseItemContent = vue.defineComponent({
        name: "CollapseItemContent",
        props: {
          displayDirective: {
            type: String,
            required: true
          },
          show: Boolean,
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup(props) {
          const onceTrueRef = useFalseUntilTruthy(vue.toRef(props, "show"));
          return {
            onceTrue: onceTrueRef
          };
        },
        render() {
          return vue.h(NFadeInExpandTransition, null, {
            default: () => {
              const { show, displayDirective, onceTrue, clsPrefix } = this;
              const useVShow = displayDirective === "show" && onceTrue;
              const contentNode = vue.h(
                "div",
                { class: `${clsPrefix}-collapse-item__content-wrapper` },
                vue.h("div", { class: `${clsPrefix}-collapse-item__content-inner` }, this.$slots)
              );
              return useVShow ? vue.withDirectives(contentNode, [[vue.vShow, show]]) : show ? contentNode : null;
            }
          });
        }
      });
      const collapseItemProps = {
        title: String,
        name: [String, Number],
        disabled: Boolean,
        displayDirective: String
      };
      const NCollapseItem = vue.defineComponent({
        name: "CollapseItem",
        props: collapseItemProps,
        setup(props) {
          const { mergedRtlRef } = useConfig(props);
          const randomName = createId();
          const mergedNameRef = useMemo(() => {
            var _a;
            return (_a = props.name) !== null && _a !== void 0 ? _a : randomName;
          });
          const NCollapse2 = vue.inject(collapseInjectionKey);
          if (!NCollapse2) {
            throwError("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
          }
          const { expandedNamesRef, props: collapseProps2, mergedClsPrefixRef, slots: collapseSlots } = NCollapse2;
          const collapsedRef = vue.computed(() => {
            const { value: expandedNames } = expandedNamesRef;
            if (Array.isArray(expandedNames)) {
              const { value: name } = mergedNameRef;
              return !~expandedNames.findIndex((expandedName) => expandedName === name);
            } else if (expandedNames) {
              const { value: name } = mergedNameRef;
              return name !== expandedNames;
            }
            return true;
          });
          const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
          return {
            rtlEnabled: rtlEnabledRef,
            collapseSlots,
            randomName,
            mergedClsPrefix: mergedClsPrefixRef,
            collapsed: collapsedRef,
            mergedDisplayDirective: vue.computed(() => {
              const { displayDirective } = props;
              if (displayDirective) {
                return displayDirective;
              } else {
                return collapseProps2.displayDirective;
              }
            }),
            arrowPlacement: vue.computed(() => {
              return collapseProps2.arrowPlacement;
            }),
            handleClick(e) {
              if (NCollapse2 && !props.disabled) {
                NCollapse2.toggleItem(collapsedRef.value, mergedNameRef.value, e);
              }
            }
          };
        },
        render() {
          const { collapseSlots, $slots, arrowPlacement, collapsed, mergedDisplayDirective, mergedClsPrefix, disabled } = this;
          const headerNode = resolveSlotWithProps($slots.header, { collapsed }, () => [this.title]);
          const headerExtraSlot = $slots["header-extra"] || collapseSlots["header-extra"];
          const arrowSlot = $slots.arrow || collapseSlots.arrow;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-collapse-item`,
              `${mergedClsPrefix}-collapse-item--${arrowPlacement}-arrow-placement`,
              disabled && `${mergedClsPrefix}-collapse-item--disabled`,
              !collapsed && `${mergedClsPrefix}-collapse-item--active`
            ] },
            vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-collapse-item__header`,
                !collapsed && `${mergedClsPrefix}-collapse-item__header--active`
              ] },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-collapse-item__header-main`, onClick: this.handleClick },
                arrowPlacement === "right" && headerNode,
                vue.h("div", { class: `${mergedClsPrefix}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1 }, resolveSlotWithProps(arrowSlot, { collapsed }, () => {
                  var _a;
                  return [
                    vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                      default: (_a = collapseSlots.expandIcon) !== null && _a !== void 0 ? _a : () => this.rtlEnabled ? vue.h(ChevronLeftIcon, null) : vue.h(ChevronRightIcon, null)
                    })
                  ];
                })),
                arrowPlacement === "left" && headerNode
              ),
              resolveWrappedSlotWithProps(headerExtraSlot, { collapsed }, (children) => vue.h("div", { class: `${mergedClsPrefix}-collapse-item__header-extra`, onClick: this.handleClick }, children))
            ),
            vue.h(NCollapseItemContent, { clsPrefix: mergedClsPrefix, displayDirective: mergedDisplayDirective, show: !collapsed }, $slots)
          );
        }
      });
      const style$10 = cB("collapse-transition", {
        width: "100%"
      }, [fadeInHeightExpandTransition()]);
      const self$R = (vars) => {
        const { cubicBezierEaseInOut: cubicBezierEaseInOut2 } = vars;
        return {
          bezier: cubicBezierEaseInOut2
        };
      };
      const collapseTransitionLight = {
        name: "CollapseTransition",
        common: commonLight,
        self: self$R
      };
      const collapseTransitionLight$1 = collapseTransitionLight;
      const collapseTransitionDark = {
        name: "CollapseTransition",
        common: commonDark,
        self: self$R
      };
      const collapseTransitionDark$1 = collapseTransitionDark;
      const collapseTransitionProps = Object.assign(Object.assign({}, useTheme.props), {
        show: {
          type: Boolean,
          default: true
        },
        appear: Boolean,
        // The collapsed is implemented with mistake, collapsed=true would make it show
        // However there's no possibility to change so I just let it deprecated and use
        // `show` prop instead.
        /** @deprecated */
        collapsed: {
          type: Boolean,
          default: void 0
        }
      });
      const CollapseTransition = vue.defineComponent({
        name: "CollapseTransition",
        props: collapseTransitionProps,
        inheritAttrs: false,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const mergedThemeRef = useTheme("CollapseTransition", "-collapse-transition", style$10, collapseTransitionLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("CollapseTransition", mergedRtlRef, mergedClsPrefixRef);
          const mergedShowRef = vue.computed(() => {
            if (props.collapsed !== void 0) {
              return props.collapsed;
            }
            return props.show;
          });
          const cssVarsRef = vue.computed(() => {
            const { self: { bezier } } = mergedThemeRef.value;
            return {
              "--n-bezier": bezier
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse-transition", void 0, cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedShow: mergedShowRef,
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          return vue.h(NFadeInExpandTransition, { appear: this.appear }, {
            default: () => {
              var _a;
              if (!this.mergedShow)
                return;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return vue.h(
                "div",
                // Don't use jsx since it would cause useless spread in each rendering
                vue.mergeProps({
                  class: [
                    `${this.mergedClsPrefix}-collapse-transition`,
                    this.rtlEnabled && `${this.mergedClsPrefix}-collapse-transition--rtl`,
                    this.themeClass
                  ],
                  style: this.cssVars
                }, this.$attrs),
                this.$slots
              );
            }
          });
        }
      });
      const configProviderProps = {
        abstract: Boolean,
        bordered: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: String,
        locale: Object,
        dateLocale: Object,
        namespace: String,
        rtl: Array,
        tag: {
          type: String,
          default: "div"
        },
        hljs: Object,
        katex: Object,
        theme: Object,
        themeOverrides: Object,
        componentOptions: Object,
        icons: Object,
        breakpoints: Object,
        preflightStyleDisabled: Boolean,
        inlineThemeDisabled: {
          type: Boolean,
          default: void 0
        },
        // deprecated
        as: {
          type: String,
          validator: () => {
            warn$2("config-provider", "`as` is deprecated, please use `tag` instead.");
            return true;
          },
          default: void 0
        }
      };
      const NConfigProvider = vue.defineComponent({
        name: "ConfigProvider",
        alias: ["App"],
        props: configProviderProps,
        setup(props) {
          const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
          const mergedThemeRef = vue.computed(() => {
            const { theme } = props;
            if (theme === null)
              return void 0;
            const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
            return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
          });
          const mergedThemeOverridesRef = vue.computed(() => {
            const { themeOverrides } = props;
            if (themeOverrides === null)
              return void 0;
            if (themeOverrides === void 0) {
              return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
            } else {
              const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
              if (inheritedThemeOverrides === void 0) {
                return themeOverrides;
              } else {
                return merge$3({}, inheritedThemeOverrides, themeOverrides);
              }
            }
          });
          const mergedNamespaceRef = useMemo(() => {
            const { namespace: namespace2 } = props;
            return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
          });
          const mergedBorderedRef = useMemo(() => {
            const { bordered } = props;
            return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
          });
          const mergedIconsRef = vue.computed(() => {
            const { icons } = props;
            return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
          });
          const mergedComponentPropsRef = vue.computed(() => {
            const { componentOptions } = props;
            if (componentOptions !== void 0)
              return componentOptions;
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
          });
          const mergedClsPrefixRef = vue.computed(() => {
            const { clsPrefix } = props;
            if (clsPrefix !== void 0)
              return clsPrefix;
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedClsPrefixRef.value;
          });
          const mergedRtlRef = vue.computed(() => {
            var _a;
            const { rtl } = props;
            if (rtl === void 0) {
              return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
            }
            const rtlEnabledState = {};
            for (const rtlInfo of rtl) {
              rtlEnabledState[rtlInfo.name] = vue.markRaw(rtlInfo);
              (_a = rtlInfo.peers) === null || _a === void 0 ? void 0 : _a.forEach((peerRtlInfo) => {
                if (!(peerRtlInfo.name in rtlEnabledState)) {
                  rtlEnabledState[peerRtlInfo.name] = vue.markRaw(peerRtlInfo);
                }
              });
            }
            return rtlEnabledState;
          });
          const mergedBreakpointsRef = vue.computed(() => {
            return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
          });
          const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
          const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
          const mergedThemeHashRef = vue.computed(() => {
            const { value: theme } = mergedThemeRef;
            const { value: mergedThemeOverrides } = mergedThemeOverridesRef;
            const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
            const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
            if (themeName) {
              if (hasThemeOverrides) {
                return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
              }
              return themeName;
            } else {
              if (hasThemeOverrides) {
                return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
              }
              return "";
            }
          });
          vue.provide(configProviderInjectionKey, {
            mergedThemeHashRef,
            mergedBreakpointsRef,
            mergedRtlRef,
            mergedIconsRef,
            mergedComponentPropsRef,
            mergedBorderedRef,
            mergedNamespaceRef,
            mergedClsPrefixRef,
            mergedLocaleRef: vue.computed(() => {
              const { locale: locale2 } = props;
              if (locale2 === null)
                return void 0;
              return locale2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale2;
            }),
            mergedDateLocaleRef: vue.computed(() => {
              const { dateLocale } = props;
              if (dateLocale === null)
                return void 0;
              return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
            }),
            mergedHljsRef: vue.computed(() => {
              const { hljs } = props;
              return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
            }),
            mergedKatexRef: vue.computed(() => {
              const { katex } = props;
              return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
            }),
            mergedThemeRef,
            mergedThemeOverridesRef,
            inlineThemeDisabled: inlineThemeDisabled || false,
            preflightStyleDisabled: preflightStyleDisabled || false
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            mergedNamespace: mergedNamespaceRef,
            mergedTheme: mergedThemeRef,
            mergedThemeOverrides: mergedThemeOverridesRef
          };
        },
        render() {
          var _a, _b, _c, _d;
          return !this.abstract ? vue.h(this.as || this.tag, {
            class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
          }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)) : (_d = (_c = this.$slots).default) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      });
      const countdownProps = {
        duration: {
          type: Number,
          default: 0
        },
        active: {
          type: Boolean,
          default: true
        },
        precision: {
          type: Number,
          default: 0
        },
        render: Function,
        onFinish: Function
      };
      const Countdown = vue.defineComponent({
        name: "Countdown",
        props: countdownProps,
        setup(props) {
          let timerId = null;
          let elapsed = 0;
          let finished = false;
          const distanceRef = vue.ref(0);
          vue.watchEffect(() => {
            distanceRef.value = props.duration;
          });
          let pnow = -1;
          function getDistance(time2) {
            return props.duration - elapsed + pnow - time2;
          }
          function getTimeInfo(distance) {
            const hours = Math.floor(distance / 36e5);
            const minutes = Math.floor(distance % 36e5 / 6e4);
            const seconds = Math.floor(distance % 6e4 / 1e3);
            const milliseconds = Math.floor(distance % 1e3);
            return {
              hours,
              minutes,
              seconds,
              milliseconds
            };
          }
          function getDisplayValue(info) {
            const { hours, minutes, seconds, milliseconds } = info;
            const { precision } = props;
            switch (precision) {
              case 0:
                return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
              default:
                return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(Math.floor(milliseconds / (precision === 1 ? 100 : precision === 2 ? 10 : 1))).padStart(precision, "0")}`;
            }
          }
          const frame = () => {
            var _a;
            const { precision } = props;
            const distance = getDistance(performance.now());
            if (distance <= 0) {
              distanceRef.value = 0;
              stopTimer();
              if (!finished) {
                finished = true;
                (_a = props.onFinish) === null || _a === void 0 ? void 0 : _a.call(props);
              }
              return;
            }
            let leftTime;
            switch (precision) {
              case 3:
              case 2:
                leftTime = distance % 34;
                break;
              case 1:
                leftTime = distance % 100;
                break;
              default:
                leftTime = distance % 1e3;
            }
            distanceRef.value = distance;
            timerId = window.setTimeout(() => {
              frame();
            }, leftTime);
          };
          const stopTimer = () => {
            if (timerId !== null) {
              window.clearTimeout(timerId);
              timerId = null;
            }
          };
          vue.onMounted(() => {
            vue.watchEffect(() => {
              if (props.active) {
                pnow = performance.now();
                frame();
              } else {
                const now2 = performance.now();
                if (pnow !== -1) {
                  elapsed += now2 - pnow;
                }
                stopTimer();
              }
            });
          });
          vue.onBeforeUnmount(() => {
            stopTimer();
          });
          function reset() {
            distanceRef.value = props.duration;
            elapsed = 0;
            pnow = performance.now();
            if (props.active && finished) {
              frame();
            }
            finished = false;
          }
          const countdownExposedMethod = {
            reset
          };
          return Object.assign(countdownExposedMethod, {
            distance: distanceRef,
            getTimeInfo,
            getDisplayValue
          });
        },
        render() {
          const { render: render2, precision, distance, getTimeInfo, getDisplayValue } = this;
          let timeInfo;
          switch (precision) {
            case 0:
              timeInfo = getTimeInfo(distance + 999);
              timeInfo.milliseconds = 0;
              break;
            case 1:
              timeInfo = getTimeInfo(distance + 99);
              timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 100) * 100;
              break;
            case 2:
              timeInfo = getTimeInfo(distance + 9);
              timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 10) * 10;
              break;
            case 3:
              timeInfo = getTimeInfo(distance);
          }
          if (render2) {
            return render2(timeInfo);
          } else {
            return getDisplayValue(timeInfo);
          }
        }
      });
      const easeOut = (t) => 1 - Math.pow(1 - t, 5);
      function tween(props) {
        const { from, to, duration, onUpdate, onFinish } = props;
        const tick = () => {
          const current = performance.now();
          const elapsedTime = Math.min(current - startTime, duration);
          const currentValue = from + (to - from) * easeOut(elapsedTime / duration);
          if (elapsedTime === duration) {
            onFinish();
            return;
          }
          onUpdate(currentValue);
          requestAnimationFrame(tick);
        };
        const startTime = performance.now();
        tick();
      }
      const numberAnimationProps = {
        to: {
          type: Number,
          default: 0
        },
        precision: {
          type: Number,
          default: 0
        },
        showSeparator: Boolean,
        locale: String,
        from: { type: Number, default: 0 },
        active: {
          type: Boolean,
          default: true
        },
        duration: {
          type: Number,
          default: 2e3
        },
        onFinish: Function
      };
      const NumberAnimation = vue.defineComponent({
        name: "NumberAnimation",
        props: numberAnimationProps,
        setup(props) {
          const { localeRef } = useLocale("name");
          const { duration } = props;
          const displayedValueRef = vue.ref(props.from);
          const mergedLocaleRef = vue.computed(() => {
            const { locale: locale2 } = props;
            if (locale2 !== void 0)
              return locale2;
            return localeRef.value;
          });
          let animating = false;
          const onUpdate = (currentValue) => {
            displayedValueRef.value = currentValue;
          };
          const onFinish = () => {
            var _a;
            displayedValueRef.value = props.to;
            animating = false;
            (_a = props.onFinish) === null || _a === void 0 ? void 0 : _a.call(props);
          };
          const animate = (from = props.from, to = props.to) => {
            animating = true;
            displayedValueRef.value = props.from;
            if (from !== to) {
              tween({
                from,
                to,
                duration,
                onUpdate,
                onFinish
              });
            }
          };
          const formattedValueRef = vue.computed(() => {
            var _a;
            const formatted = round$1(displayedValueRef.value, props.precision).toFixed(props.precision);
            const splitValue = formatted.split(".");
            const numberFormatter = new Intl.NumberFormat(mergedLocaleRef.value);
            const decimalSeparator = (_a = numberFormatter.formatToParts(0.5).find((part) => part.type === "decimal")) === null || _a === void 0 ? void 0 : _a.value;
            const integer2 = props.showSeparator ? numberFormatter.format(Number(splitValue[0])) : splitValue[0];
            const decimal = splitValue[1];
            return {
              integer: integer2,
              decimal,
              decimalSeparator
            };
          });
          function play() {
            if (animating)
              return;
            animate();
          }
          vue.onMounted(() => {
            vue.watchEffect(() => {
              if (props.active)
                animate();
            });
          });
          const exposedMethods = { play };
          return Object.assign({ formattedValue: formattedValueRef }, exposedMethods);
        },
        render() {
          const { formattedValue: { integer: integer2, decimal, decimalSeparator } } = this;
          return [integer2, decimal ? decimalSeparator : null, decimal];
        }
      });
      const popselect = {
        name: "Popselect",
        common: commonDark,
        peers: {
          Popover: popoverDark$1,
          InternalSelectMenu: internalSelectMenuDark$1
        }
      };
      const popselectDark = popselect;
      function self$Q(vars) {
        const { boxShadow2 } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
      const popselectLight = createTheme({
        name: "Popselect",
        common: commonLight,
        peers: {
          Popover: popoverLight$1,
          InternalSelectMenu: internalSelectMenuLight$1
        },
        self: self$Q
      });
      const popselectLight$1 = popselectLight;
      const popselectInjectionKey = createInjectionKey("n-popselect");
      const style$$ = cB("popselect-menu", `
 box-shadow: var(--n-menu-box-shadow);
`);
      const panelProps$1 = {
        multiple: Boolean,
        value: {
          type: [String, Number, Array],
          default: null
        },
        cancelable: Boolean,
        options: {
          type: Array,
          default: () => []
        },
        size: {
          type: String,
          default: "medium"
        },
        scrollable: Boolean,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onMouseenter: Function,
        onMouseleave: Function,
        renderLabel: Function,
        showCheckmark: {
          type: Boolean,
          default: void 0
        },
        nodeProps: Function,
        virtualScroll: Boolean,
        // deprecated
        onChange: [Function, Array]
      };
      const panelPropKeys$1 = keysOf(panelProps$1);
      const NPopselectPanel = vue.defineComponent({
        name: "PopselectPanel",
        props: panelProps$1,
        setup(props) {
          const NPopselect2 = vue.inject(popselectInjectionKey);
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Popselect", "-pop-select", style$$, popselectLight$1, NPopselect2.props, mergedClsPrefixRef);
          const treeMateRef = vue.computed(() => {
            return createTreeMate(props.options, createTmOptions("value", "children"));
          });
          function doUpdateValue(value, option) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue, onChange } = props;
            if (onUpdateValue)
              call(onUpdateValue, value, option);
            if (_onUpdateValue) {
              call(_onUpdateValue, value, option);
            }
            if (onChange)
              call(onChange, value, option);
          }
          function handleToggle(tmNode) {
            toggle(tmNode.key);
          }
          function handleMenuMousedown(e) {
            if (!happensIn(e, "action"))
              e.preventDefault();
          }
          function toggle(value) {
            const { value: { getNode } } = treeMateRef;
            if (props.multiple) {
              if (Array.isArray(props.value)) {
                const newValue = [];
                const newOptions = [];
                let shouldAddValue = true;
                props.value.forEach((v) => {
                  if (v === value) {
                    shouldAddValue = false;
                    return;
                  }
                  const tmNode = getNode(v);
                  if (tmNode) {
                    newValue.push(tmNode.key);
                    newOptions.push(tmNode.rawNode);
                  }
                });
                if (shouldAddValue) {
                  newValue.push(value);
                  newOptions.push(getNode(value).rawNode);
                }
                doUpdateValue(newValue, newOptions);
              } else {
                const tmNode = getNode(value);
                if (tmNode) {
                  doUpdateValue([value], [tmNode.rawNode]);
                }
              }
            } else {
              if (props.value === value && props.cancelable) {
                doUpdateValue(null, null);
              } else {
                const tmNode = getNode(value);
                if (tmNode) {
                  doUpdateValue(value, tmNode.rawNode);
                }
                const { "onUpdate:show": _onUpdateShow, onUpdateShow } = NPopselect2.props;
                if (_onUpdateShow)
                  call(_onUpdateShow, false);
                if (onUpdateShow)
                  call(onUpdateShow, false);
                NPopselect2.setShow(false);
              }
            }
            void vue.nextTick(() => {
              NPopselect2.syncPosition();
            });
          }
          vue.watch(vue.toRef(props, "options"), () => {
            void vue.nextTick(() => {
              NPopselect2.syncPosition();
            });
          });
          const cssVarsRef = vue.computed(() => {
            const { self: { menuBoxShadow } } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, NPopselect2.props) : void 0;
          return {
            mergedTheme: NPopselect2.mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            treeMate: treeMateRef,
            handleToggle,
            handleMenuMousedown,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(NInternalSelectMenu, { clsPrefix: this.mergedClsPrefix, focusable: true, nodeProps: this.nodeProps, class: [`${this.mergedClsPrefix}-popselect-menu`, this.themeClass], style: this.cssVars, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, multiple: this.multiple, treeMate: this.treeMate, size: this.size, value: this.value, virtualScroll: this.virtualScroll, scrollable: this.scrollable, renderLabel: this.renderLabel, onToggle: this.handleToggle, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseenter, onMousedown: this.handleMenuMousedown, showCheckmark: this.showCheckmark }, {
            action: () => {
              var _a2, _b;
              return ((_b = (_a2 = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
            },
            empty: () => {
              var _a2, _b;
              return ((_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
            }
          });
        }
      });
      const popselectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), omit(popoverBaseProps, ["showArrow", "arrow"])), { placement: Object.assign(Object.assign({}, popoverBaseProps.placement), { default: "bottom" }), trigger: {
        type: String,
        default: "hover"
      } }), panelProps$1);
      const NPopselect = vue.defineComponent({
        name: "Popselect",
        props: popselectProps,
        inheritAttrs: false,
        __popover__: true,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("Popselect", "-popselect", void 0, popselectLight$1, props, mergedClsPrefixRef);
          const popoverInstRef = vue.ref(null);
          function syncPosition() {
            var _a;
            (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function setShow(value) {
            var _a;
            (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
          }
          vue.provide(popselectInjectionKey, {
            props,
            mergedThemeRef: themeRef,
            syncPosition,
            setShow
          });
          const exposedMethods = {
            syncPosition,
            setShow
          };
          return Object.assign(Object.assign({}, exposedMethods), { popoverInstRef, mergedTheme: themeRef });
        },
        render() {
          const { mergedTheme } = this;
          const popoverProps2 = {
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            builtinThemeOverrides: {
              padding: "0"
            },
            ref: "popoverInstRef",
            internalRenderBody: (className, ref2, style2, onMouseenter, onMouseleave) => {
              const { $attrs } = this;
              return vue.h(NPopselectPanel, Object.assign({}, $attrs, { class: [$attrs.class, className], style: [$attrs.style, style2] }, keep(this.$props, panelPropKeys$1), { ref: createRefSetter(ref2), onMouseenter: mergeEventHandlers([
                onMouseenter,
                $attrs.onMouseenter
              ]), onMouseleave: mergeEventHandlers([
                onMouseleave,
                $attrs.onMouseleave
              ]) }), {
                action: () => {
                  var _a, _b;
                  return (_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a);
                },
                empty: () => {
                  var _a, _b;
                  return (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a);
                }
              });
            }
          };
          return vue.h(NPopover, Object.assign({}, omit(this.$props, panelPropKeys$1), popoverProps2, { internalDeactivateImmediately: true }), {
            trigger: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          });
        }
      });
      function self$P(vars) {
        const { boxShadow2 } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
      const selectLight = createTheme({
        name: "Select",
        common: commonLight,
        peers: {
          InternalSelection: internalSelectionLight$1,
          InternalSelectMenu: internalSelectMenuLight$1
        },
        self: self$P
      });
      const selectLight$1 = selectLight;
      const selectDark = {
        name: "Select",
        common: commonDark,
        peers: {
          InternalSelection: internalSelectionDark$1,
          InternalSelectMenu: internalSelectMenuDark$1
        },
        self: self$P
      };
      const selectDark$1 = selectDark;
      const style$_ = c$1([cB("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
        originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
      })])]);
      const selectProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        bordered: {
          type: Boolean,
          default: void 0
        },
        clearable: Boolean,
        clearFilterAfterSelect: {
          type: Boolean,
          default: true
        },
        options: {
          type: Array,
          default: () => []
        },
        defaultValue: {
          type: [String, Number, Array],
          default: null
        },
        keyboard: {
          type: Boolean,
          default: true
        },
        value: [String, Number, Array],
        placeholder: String,
        menuProps: Object,
        multiple: Boolean,
        size: String,
        filterable: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        },
        remote: Boolean,
        loading: Boolean,
        filter: Function,
        placement: {
          type: String,
          default: "bottom-start"
        },
        widthMode: {
          type: String,
          default: "trigger"
        },
        tag: Boolean,
        onCreate: Function,
        fallbackOption: {
          type: [Function, Boolean],
          default: void 0
        },
        show: {
          type: Boolean,
          default: void 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        maxTagCount: [Number, String],
        consistentMenuWidth: {
          type: Boolean,
          default: true
        },
        virtualScroll: {
          type: Boolean,
          default: true
        },
        labelField: {
          type: String,
          default: "label"
        },
        valueField: {
          type: String,
          default: "value"
        },
        childrenField: {
          type: String,
          default: "children"
        },
        renderLabel: Function,
        renderOption: Function,
        renderTag: Function,
        "onUpdate:value": [Function, Array],
        inputProps: Object,
        nodeProps: Function,
        ignoreComposition: { type: Boolean, default: true },
        showOnFocus: Boolean,
        // for jsx
        onUpdateValue: [Function, Array],
        onBlur: [Function, Array],
        onClear: [Function, Array],
        onFocus: [Function, Array],
        onScroll: [Function, Array],
        onSearch: [Function, Array],
        onUpdateShow: [Function, Array],
        "onUpdate:show": [Function, Array],
        displayDirective: {
          type: String,
          default: "show"
        },
        resetMenuOnOptionsChange: {
          type: Boolean,
          default: true
        },
        status: String,
        showCheckmark: {
          type: Boolean,
          default: true
        },
        /** deprecated */
        onChange: [Function, Array],
        items: Array
      });
      const NSelect = vue.defineComponent({
        name: "Select",
        props: selectProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedBorderedRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Select", "-select", style$_, selectLight$1, props, mergedClsPrefixRef);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const focusedRef = vue.ref(false);
          const patternRef = vue.ref("");
          const treeMateRef = vue.computed(() => {
            const { valueField, childrenField } = props;
            const options = createTmOptions(valueField, childrenField);
            return createTreeMate(filteredOptionsRef.value, options);
          });
          const valOptMapRef = vue.computed(() => createValOptMap(localOptionsRef.value, props.valueField, props.childrenField));
          const uncontrolledShowRef = vue.ref(false);
          const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
          const triggerRef = vue.ref(null);
          const followerRef = vue.ref(null);
          const menuRef = vue.ref(null);
          const { localeRef } = useLocale("Select");
          const localizedPlaceholderRef = vue.computed(() => {
            var _a;
            return (_a = props.placeholder) !== null && _a !== void 0 ? _a : localeRef.value.placeholder;
          });
          const compitableOptionsRef = useCompitable(props, ["items", "options"]);
          const emptyArray = [];
          const createdOptionsRef = vue.ref([]);
          const beingCreatedOptionsRef = vue.ref([]);
          const memoValOptMapRef = vue.ref(/* @__PURE__ */ new Map());
          const wrappedFallbackOptionRef = vue.computed(() => {
            const { fallbackOption } = props;
            if (fallbackOption === void 0) {
              const { labelField, valueField } = props;
              return (value) => ({
                [labelField]: String(value),
                [valueField]: value
              });
            }
            if (fallbackOption === false)
              return false;
            return (value) => {
              return Object.assign(fallbackOption(value), {
                value
              });
            };
          });
          const localOptionsRef = vue.computed(() => {
            return beingCreatedOptionsRef.value.concat(createdOptionsRef.value).concat(compitableOptionsRef.value);
          });
          const resolvedFilterRef = vue.computed(() => {
            const { filter } = props;
            if (filter)
              return filter;
            const { labelField, valueField } = props;
            return (pattern2, option) => {
              if (!option)
                return false;
              const label = option[labelField];
              if (typeof label === "string") {
                return patternMatched(pattern2, label);
              }
              const value = option[valueField];
              if (typeof value === "string") {
                return patternMatched(pattern2, value);
              }
              if (typeof value === "number") {
                return patternMatched(pattern2, String(value));
              }
              return false;
            };
          });
          const filteredOptionsRef = vue.computed(() => {
            if (props.remote) {
              return compitableOptionsRef.value;
            } else {
              const { value: localOptions } = localOptionsRef;
              const { value: pattern2 } = patternRef;
              if (!pattern2.length || !props.filterable) {
                return localOptions;
              } else {
                return filterOptions(localOptions, resolvedFilterRef.value, pattern2, props.childrenField);
              }
            }
          });
          function getMergedOptions(values) {
            const remote = props.remote;
            const { value: memoValOptMap } = memoValOptMapRef;
            const { value: valOptMap } = valOptMapRef;
            const { value: wrappedFallbackOption } = wrappedFallbackOptionRef;
            const options = [];
            values.forEach((value) => {
              if (valOptMap.has(value)) {
                options.push(valOptMap.get(value));
              } else if (remote && memoValOptMap.has(value)) {
                options.push(memoValOptMap.get(value));
              } else if (wrappedFallbackOption) {
                const option = wrappedFallbackOption(value);
                if (option) {
                  options.push(option);
                }
              }
            });
            return options;
          }
          const selectedOptionsRef = vue.computed(() => {
            if (props.multiple) {
              const { value: values } = mergedValueRef;
              if (!Array.isArray(values))
                return [];
              return getMergedOptions(values);
            }
            return null;
          });
          const selectedOptionRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (!props.multiple && !Array.isArray(mergedValue)) {
              if (mergedValue === null)
                return null;
              return getMergedOptions([mergedValue])[0] || null;
            }
            return null;
          });
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          function doUpdateValue(value, option) {
            const { onChange, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            if (onChange)
              call(onChange, value, option);
            if (onUpdateValue)
              call(onUpdateValue, value, option);
            if (_onUpdateValue) {
              call(_onUpdateValue, value, option);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
          }
          function doClear() {
            const { onClear } = props;
            if (onClear)
              call(onClear);
          }
          function doFocus(e) {
            const { onFocus, showOnFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
            if (showOnFocus) {
              openMenu();
            }
          }
          function doSearch(value) {
            const { onSearch } = props;
            if (onSearch)
              call(onSearch, value);
          }
          function doScroll(e) {
            const { onScroll } = props;
            if (onScroll)
              call(onScroll, e);
          }
          function updateMemorizedOptions() {
            var _a;
            const { remote, multiple } = props;
            if (remote) {
              const { value: memoValOptMap } = memoValOptMapRef;
              if (multiple) {
                const { valueField } = props;
                (_a = selectedOptionsRef.value) === null || _a === void 0 ? void 0 : _a.forEach((option) => {
                  memoValOptMap.set(option[valueField], option);
                });
              } else {
                const option = selectedOptionRef.value;
                if (option) {
                  memoValOptMap.set(option[props.valueField], option);
                }
              }
            }
          }
          function doUpdateShow(value) {
            const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow)
              call(onUpdateShow, value);
            if (_onUpdateShow)
              call(_onUpdateShow, value);
            uncontrolledShowRef.value = value;
          }
          function openMenu() {
            if (!mergedDisabledRef.value) {
              doUpdateShow(true);
              uncontrolledShowRef.value = true;
              if (props.filterable) {
                focusSelectionInput();
              }
            }
          }
          function closeMenu() {
            doUpdateShow(false);
          }
          function handleMenuAfterLeave() {
            patternRef.value = "";
            beingCreatedOptionsRef.value = emptyArray;
          }
          const activeWithoutMenuOpenRef = vue.ref(false);
          function onTriggerInputFocus() {
            if (props.filterable) {
              activeWithoutMenuOpenRef.value = true;
            }
          }
          function onTriggerInputBlur() {
            if (props.filterable) {
              activeWithoutMenuOpenRef.value = false;
              if (!mergedShowRef.value) {
                handleMenuAfterLeave();
              }
            }
          }
          function handleTriggerClick() {
            if (mergedDisabledRef.value)
              return;
            if (!mergedShowRef.value) {
              openMenu();
            } else {
              if (!props.filterable) {
                closeMenu();
              } else {
                focusSelectionInput();
              }
            }
          }
          function handleTriggerBlur(e) {
            var _a, _b;
            if ((_b = (_a = menuRef.value) === null || _a === void 0 ? void 0 : _a.selfRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) {
              return;
            }
            focusedRef.value = false;
            doBlur(e);
            closeMenu();
          }
          function handleTriggerFocus(e) {
            doFocus(e);
            focusedRef.value = true;
          }
          function handleMenuFocus(e) {
            focusedRef.value = true;
          }
          function handleMenuBlur(e) {
            var _a;
            if ((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))
              return;
            focusedRef.value = false;
            doBlur(e);
            closeMenu();
          }
          function handleMenuTabOut() {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            closeMenu();
          }
          function handleMenuClickOutside(e) {
            var _a;
            if (mergedShowRef.value) {
              if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                closeMenu();
              }
            }
          }
          function createClearedMultipleSelectValue(value) {
            if (!Array.isArray(value))
              return [];
            if (wrappedFallbackOptionRef.value) {
              return Array.from(value);
            } else {
              const { remote } = props;
              const { value: valOptMap } = valOptMapRef;
              if (remote) {
                const { value: memoValOptMap } = memoValOptMapRef;
                return value.filter((v) => valOptMap.has(v) || memoValOptMap.has(v));
              } else {
                return value.filter((v) => valOptMap.has(v));
              }
            }
          }
          function handleToggleByTmNode(tmNode) {
            handleToggleByOption(tmNode.rawNode);
          }
          function handleToggleByOption(option) {
            if (mergedDisabledRef.value)
              return;
            const { tag, remote, clearFilterAfterSelect, valueField } = props;
            if (tag && !remote) {
              const { value: beingCreatedOptions } = beingCreatedOptionsRef;
              const beingCreatedOption = beingCreatedOptions[0] || null;
              if (beingCreatedOption) {
                const createdOptions = createdOptionsRef.value;
                if (!createdOptions.length) {
                  createdOptionsRef.value = [beingCreatedOption];
                } else {
                  createdOptions.push(beingCreatedOption);
                }
                beingCreatedOptionsRef.value = emptyArray;
              }
            }
            if (remote) {
              memoValOptMapRef.value.set(option[valueField], option);
            }
            if (props.multiple) {
              const changedValue = createClearedMultipleSelectValue(mergedValueRef.value);
              const index = changedValue.findIndex((value) => value === option[valueField]);
              if (~index) {
                changedValue.splice(index, 1);
                if (tag && !remote) {
                  const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                  if (~createdOptionIndex) {
                    createdOptionsRef.value.splice(createdOptionIndex, 1);
                    if (clearFilterAfterSelect)
                      patternRef.value = "";
                  }
                }
              } else {
                changedValue.push(option[valueField]);
                if (clearFilterAfterSelect)
                  patternRef.value = "";
              }
              doUpdateValue(changedValue, getMergedOptions(changedValue));
            } else {
              if (tag && !remote) {
                const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                if (~createdOptionIndex) {
                  createdOptionsRef.value = [
                    createdOptionsRef.value[createdOptionIndex]
                  ];
                } else {
                  createdOptionsRef.value = emptyArray;
                }
              }
              focusSelection();
              closeMenu();
              doUpdateValue(option[valueField], option);
            }
          }
          function getCreatedOptionIndex(optionValue) {
            const createdOptions = createdOptionsRef.value;
            return createdOptions.findIndex((createdOption) => createdOption[props.valueField] === optionValue);
          }
          function handlePatternInput(e) {
            if (!mergedShowRef.value) {
              openMenu();
            }
            const { value } = e.target;
            patternRef.value = value;
            const { tag, remote } = props;
            doSearch(value);
            if (tag && !remote) {
              if (!value) {
                beingCreatedOptionsRef.value = emptyArray;
                return;
              }
              const { onCreate } = props;
              const optionBeingCreated = onCreate ? onCreate(value) : { [props.labelField]: value, [props.valueField]: value };
              const { valueField } = props;
              if (compitableOptionsRef.value.some((option) => option[valueField] === optionBeingCreated[valueField]) || createdOptionsRef.value.some((option) => option[valueField] === optionBeingCreated[valueField])) {
                beingCreatedOptionsRef.value = emptyArray;
              } else {
                beingCreatedOptionsRef.value = [optionBeingCreated];
              }
            }
          }
          function handleClear(e) {
            e.stopPropagation();
            const { multiple } = props;
            if (!multiple && props.filterable) {
              closeMenu();
            }
            doClear();
            if (multiple) {
              doUpdateValue([], []);
            } else {
              doUpdateValue(null, null);
            }
          }
          function handleMenuMousedown(e) {
            if (!happensIn(e, "action") && !happensIn(e, "empty"))
              e.preventDefault();
          }
          function handleMenuScroll(e) {
            doScroll(e);
          }
          function handleKeydown(e) {
            var _a, _b, _c, _d, _e;
            if (!props.keyboard) {
              e.preventDefault();
              return;
            }
            switch (e.key) {
              case " ":
                if (props.filterable)
                  break;
                else {
                  e.preventDefault();
                }
              case "Enter":
                if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.isComposing)) {
                  if (mergedShowRef.value) {
                    const pendingTmNode = (_b = menuRef.value) === null || _b === void 0 ? void 0 : _b.getPendingTmNode();
                    if (pendingTmNode) {
                      handleToggleByTmNode(pendingTmNode);
                    } else if (!props.filterable) {
                      closeMenu();
                      focusSelection();
                    }
                  } else {
                    openMenu();
                    if (props.tag && activeWithoutMenuOpenRef.value) {
                      const beingCreatedOption = beingCreatedOptionsRef.value[0];
                      if (beingCreatedOption) {
                        const optionValue = beingCreatedOption[props.valueField];
                        const { value: mergedValue } = mergedValueRef;
                        if (props.multiple) {
                          if (Array.isArray(mergedValue) && mergedValue.some((value) => value === optionValue))
                            ;
                          else {
                            handleToggleByOption(beingCreatedOption);
                          }
                        } else {
                          handleToggleByOption(beingCreatedOption);
                        }
                      }
                    }
                  }
                }
                e.preventDefault();
                break;
              case "ArrowUp":
                e.preventDefault();
                if (props.loading)
                  return;
                if (mergedShowRef.value) {
                  (_c = menuRef.value) === null || _c === void 0 ? void 0 : _c.prev();
                }
                break;
              case "ArrowDown":
                e.preventDefault();
                if (props.loading)
                  return;
                if (mergedShowRef.value) {
                  (_d = menuRef.value) === null || _d === void 0 ? void 0 : _d.next();
                } else {
                  openMenu();
                }
                break;
              case "Escape":
                if (mergedShowRef.value) {
                  markEventEffectPerformed(e);
                  closeMenu();
                }
                (_e = triggerRef.value) === null || _e === void 0 ? void 0 : _e.focus();
                break;
            }
          }
          function focusSelection() {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function focusSelectionInput() {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function handleTriggerOrMenuResize() {
            var _a;
            if (!mergedShowRef.value)
              return;
            (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          updateMemorizedOptions();
          vue.watch(vue.toRef(props, "options"), updateMemorizedOptions);
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          const cssVarsRef = vue.computed(() => {
            const { self: { menuBoxShadow } } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedStatus: mergedStatusRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            namespace: namespaceRef,
            treeMate: treeMateRef,
            isMounted: isMounted(),
            triggerRef,
            menuRef,
            pattern: patternRef,
            uncontrolledShow: uncontrolledShowRef,
            mergedShow: mergedShowRef,
            adjustedTo: useAdjustedTo(props),
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            followerRef,
            localizedPlaceholder: localizedPlaceholderRef,
            selectedOption: selectedOptionRef,
            selectedOptions: selectedOptionsRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            focused: focusedRef,
            activeWithoutMenuOpen: activeWithoutMenuOpenRef,
            inlineThemeDisabled,
            onTriggerInputFocus,
            onTriggerInputBlur,
            handleTriggerOrMenuResize,
            handleMenuFocus,
            handleMenuBlur,
            handleMenuTabOut,
            handleTriggerClick,
            handleToggle: handleToggleByTmNode,
            handleDeleteOption: handleToggleByOption,
            handlePatternInput,
            handleClear,
            handleTriggerBlur,
            handleTriggerFocus,
            handleKeydown,
            handleMenuAfterLeave,
            handleMenuClickOutside,
            handleMenuScroll,
            handleMenuKeydown: handleKeydown,
            handleMenuMousedown,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          return vue.h(
            "div",
            { class: `${this.mergedClsPrefix}-select` },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h(NInternalSelection, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, {
                    arrow: () => {
                      var _a, _b;
                      return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)];
                    }
                  })
                }),
                vue.h(VFollower, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, {
                    default: () => {
                      var _a, _b, _c;
                      if (!(this.mergedShow || this.displayDirective === "show")) {
                        return null;
                      }
                      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                      return vue.withDirectives(vue.h(NInternalSelectMenu, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [
                        `${this.mergedClsPrefix}-select-menu`,
                        this.themeClass,
                        (_b = this.menuProps) === null || _b === void 0 ? void 0 : _b.class
                      ], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: "medium", renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(_c = this.menuProps) === null || _c === void 0 ? void 0 : _c.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), {
                        empty: () => {
                          var _a2, _b2;
                          return [(_b2 = (_a2 = this.$slots).empty) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                        },
                        action: () => {
                          var _a2, _b2;
                          return [(_b2 = (_a2 = this.$slots).action) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                        }
                      }), this.displayDirective === "show" ? [
                        [vue.vShow, this.mergedShow],
                        [
                          clickoutside$1,
                          this.handleMenuClickOutside,
                          void 0,
                          { capture: true }
                        ]
                      ] : [
                        [
                          clickoutside$1,
                          this.handleMenuClickOutside,
                          void 0,
                          { capture: true }
                        ]
                      ]);
                    }
                  })
                })
              ]
            })
          );
        }
      });
      const commonVariables$b = {
        itemPaddingSmall: "0 4px",
        itemMarginSmall: "0 0 0 8px",
        itemMarginSmallRtl: "0 8px 0 0",
        itemPaddingMedium: "0 4px",
        itemMarginMedium: "0 0 0 8px",
        itemMarginMediumRtl: "0 8px 0 0",
        itemPaddingLarge: "0 4px",
        itemMarginLarge: "0 0 0 8px",
        itemMarginLargeRtl: "0 8px 0 0",
        buttonIconSizeSmall: "14px",
        buttonIconSizeMedium: "16px",
        buttonIconSizeLarge: "18px",
        inputWidthSmall: "60px",
        selectWidthSmall: "unset",
        inputMarginSmall: "0 0 0 8px",
        inputMarginSmallRtl: "0 8px 0 0",
        selectMarginSmall: "0 0 0 8px",
        prefixMarginSmall: "0 8px 0 0",
        suffixMarginSmall: "0 0 0 8px",
        inputWidthMedium: "60px",
        selectWidthMedium: "unset",
        inputMarginMedium: "0 0 0 8px",
        inputMarginMediumRtl: "0 8px 0 0",
        selectMarginMedium: "0 0 0 8px",
        prefixMarginMedium: "0 8px 0 0",
        suffixMarginMedium: "0 0 0 8px",
        inputWidthLarge: "60px",
        selectWidthLarge: "unset",
        inputMarginLarge: "0 0 0 8px",
        inputMarginLargeRtl: "0 8px 0 0",
        selectMarginLarge: "0 0 0 8px",
        prefixMarginLarge: "0 8px 0 0",
        suffixMarginLarge: "0 0 0 8px"
      };
      const self$O = (vars) => {
        const {
          textColor2,
          primaryColor,
          primaryColorHover,
          primaryColorPressed,
          inputColorDisabled,
          textColorDisabled,
          borderColor,
          borderRadius,
          // item font size
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          // item size
          heightTiny,
          heightSmall,
          heightMedium
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$b), { buttonColor: "#0000", buttonColorHover: "#0000", buttonColorPressed: "#0000", buttonBorder: `1px solid ${borderColor}`, buttonBorderHover: `1px solid ${borderColor}`, buttonBorderPressed: `1px solid ${borderColor}`, buttonIconColor: textColor2, buttonIconColorHover: textColor2, buttonIconColorPressed: textColor2, itemTextColor: textColor2, itemTextColorHover: primaryColorHover, itemTextColorPressed: primaryColorPressed, itemTextColorActive: primaryColor, itemTextColorDisabled: textColorDisabled, itemColor: "#0000", itemColorHover: "#0000", itemColorPressed: "#0000", itemColorActive: "#0000", itemColorActiveHover: "#0000", itemColorDisabled: inputColorDisabled, itemBorder: "1px solid #0000", itemBorderHover: "1px solid #0000", itemBorderPressed: "1px solid #0000", itemBorderActive: `1px solid ${primaryColor}`, itemBorderDisabled: `1px solid ${borderColor}`, itemBorderRadius: borderRadius, itemSizeSmall: heightTiny, itemSizeMedium: heightSmall, itemSizeLarge: heightMedium, itemFontSizeSmall: fontSizeTiny, itemFontSizeMedium: fontSizeSmall, itemFontSizeLarge: fontSizeMedium, jumperFontSizeSmall: fontSizeTiny, jumperFontSizeMedium: fontSizeSmall, jumperFontSizeLarge: fontSizeMedium, jumperTextColor: textColor2, jumperTextColorDisabled: textColorDisabled });
      };
      const paginationLight = createTheme({
        name: "Pagination",
        common: commonLight,
        peers: {
          Select: selectLight$1,
          Input: inputLight$1,
          Popselect: popselectLight$1
        },
        self: self$O
      });
      const paginationLight$1 = paginationLight;
      const paginationDark = {
        name: "Pagination",
        common: commonDark,
        peers: {
          Select: selectDark$1,
          Input: inputDark$1,
          Popselect: popselectDark
        },
        self(vars) {
          const { primaryColor, opacity3 } = vars;
          const borderColorActive = changeColor(primaryColor, {
            alpha: Number(opacity3)
          });
          const commonSelf = self$O(vars);
          commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
          commonSelf.itemBorderDisabled = "1px solid #0000";
          return commonSelf;
        }
      };
      const paginationDark$1 = paginationDark;
      function createPageItemsInfo(currentPage, pageCount, pageSlot) {
        let hasFastBackward = false;
        let hasFastForward = false;
        let fastBackwardTo = 1;
        let fastForwardTo = pageCount;
        if (pageCount === 1) {
          return {
            hasFastBackward: false,
            hasFastForward: false,
            fastForwardTo,
            fastBackwardTo,
            items: [
              {
                type: "page",
                label: 1,
                active: currentPage === 1,
                mayBeFastBackward: false,
                mayBeFastForward: false
              }
            ]
          };
        }
        if (pageCount === 2) {
          return {
            hasFastBackward: false,
            hasFastForward: false,
            fastForwardTo,
            fastBackwardTo,
            items: [
              {
                type: "page",
                label: 1,
                active: currentPage === 1,
                mayBeFastBackward: false,
                mayBeFastForward: false
              },
              {
                type: "page",
                label: 2,
                active: currentPage === 2,
                mayBeFastBackward: true,
                mayBeFastForward: false
              }
            ]
          };
        }
        const firstPage = 1;
        const lastPage = pageCount;
        let middleStart = currentPage;
        let middleEnd = currentPage;
        const middleDelta = (pageSlot - 5) / 2;
        middleEnd += Math.ceil(middleDelta);
        middleEnd = Math.min(Math.max(middleEnd, firstPage + pageSlot - 3), lastPage - 2);
        middleStart -= Math.floor(middleDelta);
        middleStart = Math.max(Math.min(middleStart, lastPage - pageSlot + 3), firstPage + 2);
        let leftSplit = false;
        let rightSplit = false;
        if (middleStart > firstPage + 2)
          leftSplit = true;
        if (middleEnd < lastPage - 2)
          rightSplit = true;
        const items = [];
        items.push({
          type: "page",
          label: 1,
          active: currentPage === 1,
          mayBeFastBackward: false,
          mayBeFastForward: false
        });
        if (leftSplit) {
          hasFastBackward = true;
          fastBackwardTo = middleStart - 1;
          items.push({
            type: "fast-backward",
            active: false,
            label: void 0,
            options: createRange(firstPage + 1, middleStart - 1)
          });
        } else if (lastPage >= firstPage + 1) {
          items.push({
            type: "page",
            label: firstPage + 1,
            mayBeFastBackward: true,
            mayBeFastForward: false,
            active: currentPage === firstPage + 1
          });
        }
        for (let i = middleStart; i <= middleEnd; ++i) {
          items.push({
            type: "page",
            label: i,
            mayBeFastBackward: false,
            mayBeFastForward: false,
            active: currentPage === i
          });
        }
        if (rightSplit) {
          hasFastForward = true;
          fastForwardTo = middleEnd + 1;
          items.push({
            type: "fast-forward",
            active: false,
            label: void 0,
            options: createRange(middleEnd + 1, lastPage - 1)
          });
        } else if (middleEnd === lastPage - 2 && items[items.length - 1].label !== lastPage - 1) {
          items.push({
            type: "page",
            mayBeFastForward: true,
            mayBeFastBackward: false,
            label: lastPage - 1,
            active: currentPage === lastPage - 1
          });
        }
        if (items[items.length - 1].label !== lastPage) {
          items.push({
            type: "page",
            mayBeFastForward: false,
            mayBeFastBackward: false,
            label: lastPage,
            active: currentPage === lastPage
          });
        }
        return {
          hasFastBackward,
          hasFastForward,
          fastBackwardTo,
          fastForwardTo,
          items
        };
      }
      function createRange(from, to) {
        const range2 = [];
        for (let i = from; i <= to; ++i) {
          range2.push({
            label: `${i}`,
            value: i
          });
        }
        return range2;
      }
      const hoverStyleProps = `
 background: var(--n-item-color-hover);
 color: var(--n-item-text-color-hover);
 border: var(--n-item-border-hover);
`;
      const hoverStyleChildren$1 = [cM("button", `
 background: var(--n-button-color-hover);
 border: var(--n-button-border-hover);
 color: var(--n-button-icon-color-hover);
 `)];
      const style$Z = cB("pagination", `
 display: flex;
 vertical-align: middle;
 font-size: var(--n-item-font-size);
 flex-wrap: nowrap;
`, [cB("pagination-prefix", `
 display: flex;
 align-items: center;
 margin: var(--n-prefix-margin);
 `), cB("pagination-suffix", `
 display: flex;
 align-items: center;
 margin: var(--n-suffix-margin);
 `), c$1("> *:not(:first-child)", `
 margin: var(--n-item-margin);
 `), cB("select", `
 width: var(--n-select-width);
 `), c$1("&.transition-disabled", [cB("pagination-item", "transition: none!important;")]), cB("pagination-quick-jumper", `
 white-space: nowrap;
 display: flex;
 color: var(--n-jumper-text-color);
 transition: color .3s var(--n-bezier);
 align-items: center;
 font-size: var(--n-jumper-font-size);
 `, [cB("input", `
 margin: var(--n-input-margin);
 width: var(--n-input-width);
 `)]), cB("pagination-item", `
 position: relative;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 display: flex;
 align-items: center;
 justify-content: center;
 box-sizing: border-box;
 min-width: var(--n-item-size);
 height: var(--n-item-size);
 padding: var(--n-item-padding);
 background-color: var(--n-item-color);
 color: var(--n-item-text-color);
 border-radius: var(--n-item-border-radius);
 border: var(--n-item-border);
 fill: var(--n-button-icon-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 fill .3s var(--n-bezier);
 `, [cM("button", `
 background: var(--n-button-color);
 color: var(--n-button-icon-color);
 border: var(--n-button-border);
 padding: 0;
 `, [cB("base-icon", `
 font-size: var(--n-button-icon-size);
 `)]), cNotM("disabled", [cM("hover", hoverStyleProps, hoverStyleChildren$1), c$1("&:hover", hoverStyleProps, hoverStyleChildren$1), c$1("&:active", `
 background: var(--n-item-color-pressed);
 color: var(--n-item-text-color-pressed);
 border: var(--n-item-border-pressed);
 `, [cM("button", `
 background: var(--n-button-color-pressed);
 border: var(--n-button-border-pressed);
 color: var(--n-button-icon-color-pressed);
 `)]), cM("active", `
 background: var(--n-item-color-active);
 color: var(--n-item-text-color-active);
 border: var(--n-item-border-active);
 `, [c$1("&:hover", `
 background: var(--n-item-color-active-hover);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `, [cM("active, button", `
 background-color: var(--n-item-color-disabled);
 border: var(--n-item-border-disabled);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cB("pagination-quick-jumper", `
 color: var(--n-jumper-text-color-disabled);
 `)]), cM("simple", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 `, [cB("pagination-quick-jumper", [cB("input", `
 margin: 0;
 `)])])]);
      const paginationProps = Object.assign(Object.assign({}, useTheme.props), {
        simple: Boolean,
        page: Number,
        defaultPage: {
          type: Number,
          default: 1
        },
        itemCount: Number,
        pageCount: Number,
        defaultPageCount: {
          type: Number,
          default: 1
        },
        showSizePicker: Boolean,
        pageSize: Number,
        defaultPageSize: Number,
        pageSizes: {
          type: Array,
          default() {
            return [10];
          }
        },
        showQuickJumper: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        disabled: Boolean,
        pageSlot: {
          type: Number,
          default: 9
        },
        selectProps: Object,
        prev: Function,
        next: Function,
        goto: Function,
        prefix: Function,
        suffix: Function,
        label: Function,
        displayOrder: {
          type: Array,
          default: ["pages", "size-picker", "quick-jumper"]
        },
        to: useAdjustedTo.propTo,
        "onUpdate:page": [Function, Array],
        onUpdatePage: [Function, Array],
        "onUpdate:pageSize": [Function, Array],
        onUpdatePageSize: [Function, Array],
        /** @deprecated */
        onPageSizeChange: [Function, Array],
        /** @deprecated */
        onChange: [Function, Array]
      });
      const NPagination = vue.defineComponent({
        name: "Pagination",
        props: paginationProps,
        setup(props) {
          const { mergedComponentPropsRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Pagination", "-pagination", style$Z, paginationLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale("Pagination");
          const selfRef = vue.ref(null);
          const uncontrolledPageRef = vue.ref(props.defaultPage);
          const getDefaultPageSize = () => {
            const { defaultPageSize } = props;
            if (defaultPageSize !== void 0)
              return defaultPageSize;
            const pageSizeOption = props.pageSizes[0];
            if (typeof pageSizeOption === "number")
              return pageSizeOption;
            return pageSizeOption.value || 10;
          };
          const uncontrolledPageSizeRef = vue.ref(getDefaultPageSize());
          const mergedPageRef = useMergedState(vue.toRef(props, "page"), uncontrolledPageRef);
          const mergedPageSizeRef = useMergedState(vue.toRef(props, "pageSize"), uncontrolledPageSizeRef);
          const mergedPageCountRef = vue.computed(() => {
            const { itemCount } = props;
            if (itemCount !== void 0) {
              return Math.max(1, Math.ceil(itemCount / mergedPageSizeRef.value));
            }
            const { pageCount } = props;
            if (pageCount !== void 0)
              return Math.max(pageCount, 1);
            return 1;
          });
          const jumperValueRef = vue.ref("");
          vue.watchEffect(() => {
            void props.simple;
            jumperValueRef.value = String(mergedPageRef.value);
          });
          const fastForwardActiveRef = vue.ref(false);
          const fastBackwardActiveRef = vue.ref(false);
          const showFastForwardMenuRef = vue.ref(false);
          const showFastBackwardMenuRef = vue.ref(false);
          const handleFastForwardMouseenter = () => {
            if (props.disabled)
              return;
            fastForwardActiveRef.value = true;
            disableTransitionOneTick();
          };
          const handleFastForwardMouseleave = () => {
            if (props.disabled)
              return;
            fastForwardActiveRef.value = false;
            disableTransitionOneTick();
          };
          const handleFastBackwardMouseenter = () => {
            fastBackwardActiveRef.value = true;
            disableTransitionOneTick();
          };
          const handleFastBackwardMouseleave = () => {
            fastBackwardActiveRef.value = false;
            disableTransitionOneTick();
          };
          const handleMenuSelect = (value) => {
            doUpdatePage(value);
          };
          const pageItemsInfo = vue.computed(() => createPageItemsInfo(mergedPageRef.value, mergedPageCountRef.value, props.pageSlot));
          vue.watchEffect(() => {
            if (!pageItemsInfo.value.hasFastBackward) {
              fastBackwardActiveRef.value = false;
              showFastBackwardMenuRef.value = false;
            } else if (!pageItemsInfo.value.hasFastForward) {
              fastForwardActiveRef.value = false;
              showFastForwardMenuRef.value = false;
            }
          });
          const pageSizeOptionsRef = vue.computed(() => {
            const suffix2 = localeRef.value.selectionSuffix;
            return props.pageSizes.map((size2) => {
              if (typeof size2 === "number") {
                return {
                  label: `${size2} / ${suffix2}`,
                  value: size2
                };
              } else {
                return size2;
              }
            });
          });
          const inputSizeRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.inputSize) || smallerSize(props.size);
          });
          const selectSizeRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.selectSize) || smallerSize(props.size);
          });
          const startIndexRef = vue.computed(() => {
            return (mergedPageRef.value - 1) * mergedPageSizeRef.value;
          });
          const endIndexRef = vue.computed(() => {
            const endIndex = mergedPageRef.value * mergedPageSizeRef.value - 1;
            const { itemCount } = props;
            if (itemCount !== void 0) {
              return endIndex > itemCount - 1 ? itemCount - 1 : endIndex;
            }
            return endIndex;
          });
          const mergedItemCountRef = vue.computed(() => {
            const { itemCount } = props;
            if (itemCount !== void 0)
              return itemCount;
            return (props.pageCount || 1) * mergedPageSizeRef.value;
          });
          const rtlEnabledRef = useRtl("Pagination", mergedRtlRef, mergedClsPrefixRef);
          const disableTransitionOneTick = () => {
            void vue.nextTick(() => {
              var _a;
              const { value: selfEl } = selfRef;
              if (!selfEl)
                return;
              selfEl.classList.add("transition-disabled");
              void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
              selfEl.classList.remove("transition-disabled");
            });
          };
          function doUpdatePage(page) {
            if (page === mergedPageRef.value)
              return;
            const { "onUpdate:page": _onUpdatePage, onUpdatePage, onChange, simple } = props;
            if (_onUpdatePage)
              call(_onUpdatePage, page);
            if (onUpdatePage)
              call(onUpdatePage, page);
            if (onChange)
              call(onChange, page);
            uncontrolledPageRef.value = page;
            if (simple) {
              jumperValueRef.value = String(page);
            }
          }
          function doUpdatePageSize(pageSize) {
            if (pageSize === mergedPageSizeRef.value)
              return;
            const { "onUpdate:pageSize": _onUpdatePageSize, onUpdatePageSize, onPageSizeChange } = props;
            if (_onUpdatePageSize)
              call(_onUpdatePageSize, pageSize);
            if (onUpdatePageSize)
              call(onUpdatePageSize, pageSize);
            if (onPageSizeChange)
              call(onPageSizeChange, pageSize);
            uncontrolledPageSizeRef.value = pageSize;
            if (mergedPageCountRef.value < mergedPageRef.value) {
              doUpdatePage(mergedPageCountRef.value);
            }
          }
          function forward() {
            if (props.disabled)
              return;
            const page = Math.min(mergedPageRef.value + 1, mergedPageCountRef.value);
            doUpdatePage(page);
          }
          function backward() {
            if (props.disabled)
              return;
            const page = Math.max(mergedPageRef.value - 1, 1);
            doUpdatePage(page);
          }
          function fastForward() {
            if (props.disabled)
              return;
            const page = Math.min(pageItemsInfo.value.fastForwardTo, mergedPageCountRef.value);
            doUpdatePage(page);
          }
          function fastBackward() {
            if (props.disabled)
              return;
            const page = Math.max(pageItemsInfo.value.fastBackwardTo, 1);
            doUpdatePage(page);
          }
          function handleSizePickerChange(value) {
            doUpdatePageSize(value);
          }
          function doQuickJump() {
            const page = parseInt(jumperValueRef.value);
            if (Number.isNaN(page))
              return;
            doUpdatePage(Math.max(1, Math.min(page, mergedPageCountRef.value)));
            if (!props.simple) {
              jumperValueRef.value = "";
            }
          }
          function handleQuickJumperChange() {
            doQuickJump();
          }
          function handlePageItemClick(pageItem) {
            if (props.disabled)
              return;
            switch (pageItem.type) {
              case "page":
                doUpdatePage(pageItem.label);
                break;
              case "fast-backward":
                fastBackward();
                break;
              case "fast-forward":
                fastForward();
                break;
            }
          }
          function handleJumperInput(value) {
            jumperValueRef.value = value.replace(/\D+/g, "");
          }
          vue.watchEffect(() => {
            void mergedPageRef.value;
            void mergedPageSizeRef.value;
            disableTransitionOneTick();
          });
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { self: { buttonBorder, buttonBorderHover, buttonBorderPressed, buttonIconColor, buttonIconColorHover, buttonIconColorPressed, itemTextColor, itemTextColorHover, itemTextColorPressed, itemTextColorActive, itemTextColorDisabled, itemColor, itemColorHover, itemColorPressed, itemColorActive, itemColorActiveHover, itemColorDisabled, itemBorder, itemBorderHover, itemBorderPressed, itemBorderActive, itemBorderDisabled, itemBorderRadius, jumperTextColor, jumperTextColorDisabled, buttonColor, buttonColorHover, buttonColorPressed, [createKey("itemPadding", size2)]: itemPadding, [createKey("itemMargin", size2)]: itemMargin, [createKey("inputWidth", size2)]: inputWidth, [createKey("selectWidth", size2)]: selectWidth, [createKey("inputMargin", size2)]: inputMargin, [createKey("selectMargin", size2)]: selectMargin, [createKey("jumperFontSize", size2)]: jumperFontSize, [createKey("prefixMargin", size2)]: prefixMargin, [createKey("suffixMargin", size2)]: suffixMargin, [createKey("itemSize", size2)]: itemSize, [createKey("buttonIconSize", size2)]: buttonIconSize, [createKey("itemFontSize", size2)]: itemFontSize, [`${createKey("itemMargin", size2)}Rtl`]: itemMarginRtl, [`${createKey("inputMargin", size2)}Rtl`]: inputMarginRtl }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-prefix-margin": prefixMargin,
              "--n-suffix-margin": suffixMargin,
              "--n-item-font-size": itemFontSize,
              "--n-select-width": selectWidth,
              "--n-select-margin": selectMargin,
              "--n-input-width": inputWidth,
              "--n-input-margin": inputMargin,
              "--n-input-margin-rtl": inputMarginRtl,
              "--n-item-size": itemSize,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-disabled": itemTextColorDisabled,
              "--n-item-text-color-hover": itemTextColorHover,
              "--n-item-text-color-active": itemTextColorActive,
              "--n-item-text-color-pressed": itemTextColorPressed,
              "--n-item-color": itemColor,
              "--n-item-color-hover": itemColorHover,
              "--n-item-color-disabled": itemColorDisabled,
              "--n-item-color-active": itemColorActive,
              "--n-item-color-active-hover": itemColorActiveHover,
              "--n-item-color-pressed": itemColorPressed,
              "--n-item-border": itemBorder,
              "--n-item-border-hover": itemBorderHover,
              "--n-item-border-disabled": itemBorderDisabled,
              "--n-item-border-active": itemBorderActive,
              "--n-item-border-pressed": itemBorderPressed,
              "--n-item-padding": itemPadding,
              "--n-item-border-radius": itemBorderRadius,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-jumper-font-size": jumperFontSize,
              "--n-jumper-text-color": jumperTextColor,
              "--n-jumper-text-color-disabled": jumperTextColorDisabled,
              "--n-item-margin": itemMargin,
              "--n-item-margin-rtl": itemMarginRtl,
              "--n-button-icon-size": buttonIconSize,
              "--n-button-icon-color": buttonIconColor,
              "--n-button-icon-color-hover": buttonIconColorHover,
              "--n-button-icon-color-pressed": buttonIconColorPressed,
              "--n-button-color-hover": buttonColorHover,
              "--n-button-color": buttonColor,
              "--n-button-color-pressed": buttonColorPressed,
              "--n-button-border": buttonBorder,
              "--n-button-border-hover": buttonBorderHover,
              "--n-button-border-pressed": buttonBorderPressed
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("pagination", vue.computed(() => {
            let hash = "";
            const { size: size2 } = props;
            hash += size2[0];
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            locale: localeRef,
            selfRef,
            mergedPage: mergedPageRef,
            pageItems: vue.computed(() => {
              return pageItemsInfo.value.items;
            }),
            mergedItemCount: mergedItemCountRef,
            jumperValue: jumperValueRef,
            pageSizeOptions: pageSizeOptionsRef,
            mergedPageSize: mergedPageSizeRef,
            inputSize: inputSizeRef,
            selectSize: selectSizeRef,
            mergedTheme: themeRef,
            mergedPageCount: mergedPageCountRef,
            startIndex: startIndexRef,
            endIndex: endIndexRef,
            showFastForwardMenu: showFastForwardMenuRef,
            showFastBackwardMenu: showFastBackwardMenuRef,
            fastForwardActive: fastForwardActiveRef,
            fastBackwardActive: fastBackwardActiveRef,
            handleMenuSelect,
            handleFastForwardMouseenter,
            handleFastForwardMouseleave,
            handleFastBackwardMouseenter,
            handleFastBackwardMouseleave,
            handleJumperInput,
            handleBackwardClick: backward,
            handleForwardClick: forward,
            handlePageItemClick,
            handleSizePickerChange,
            handleQuickJumperChange,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { $slots, mergedClsPrefix, disabled, cssVars, mergedPage, mergedPageCount, pageItems, showSizePicker, showQuickJumper, mergedTheme, locale: locale2, inputSize, selectSize, mergedPageSize, pageSizeOptions, jumperValue, simple, prev, next, prefix: prefix2, suffix: suffix2, label, goto, handleJumperInput, handleSizePickerChange, handleBackwardClick, handlePageItemClick, handleForwardClick, handleQuickJumperChange, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderPrefix = $slots.prefix || prefix2;
          const renderSuffix = $slots.suffix || suffix2;
          const renderPrev = prev || $slots.prev;
          const renderNext = next || $slots.next;
          const renderLabel = label || $slots.label;
          return vue.h(
            "div",
            { ref: "selfRef", class: [
              `${mergedClsPrefix}-pagination`,
              this.themeClass,
              this.rtlEnabled && `${mergedClsPrefix}-pagination--rtl`,
              disabled && `${mergedClsPrefix}-pagination--disabled`,
              simple && `${mergedClsPrefix}-pagination--simple`
            ], style: cssVars },
            renderPrefix ? vue.h("div", { class: `${mergedClsPrefix}-pagination-prefix` }, renderPrefix({
              page: mergedPage,
              pageSize: mergedPageSize,
              pageCount: mergedPageCount,
              startIndex: this.startIndex,
              endIndex: this.endIndex,
              itemCount: this.mergedItemCount
            })) : null,
            this.displayOrder.map((part) => {
              switch (part) {
                case "pages":
                  return vue.h(
                    vue.Fragment,
                    null,
                    vue.h("div", { class: [
                      `${mergedClsPrefix}-pagination-item`,
                      !renderPrev && `${mergedClsPrefix}-pagination-item--button`,
                      (mergedPage <= 1 || mergedPage > mergedPageCount || disabled) && `${mergedClsPrefix}-pagination-item--disabled`
                    ], onClick: handleBackwardClick }, renderPrev ? renderPrev({
                      page: mergedPage,
                      pageSize: mergedPageSize,
                      pageCount: mergedPageCount,
                      startIndex: this.startIndex,
                      endIndex: this.endIndex,
                      itemCount: this.mergedItemCount
                    }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                      default: () => this.rtlEnabled ? vue.h(ForwardIcon, null) : vue.h(BackwardIcon, null)
                    })),
                    simple ? vue.h(
                      vue.Fragment,
                      null,
                      vue.h(
                        "div",
                        { class: `${mergedClsPrefix}-pagination-quick-jumper` },
                        vue.h(NInput, { value: jumperValue, onUpdateValue: handleJumperInput, size: inputSize, placeholder: "", disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onChange: handleQuickJumperChange })
                      ),
                      "/ ",
                      mergedPageCount
                    ) : pageItems.map((pageItem, index) => {
                      let contentNode;
                      let onMouseenter;
                      let onMouseleave;
                      const { type: type2 } = pageItem;
                      switch (type2) {
                        case "page":
                          const pageNode = pageItem.label;
                          if (renderLabel) {
                            contentNode = renderLabel({
                              type: "page",
                              node: pageNode,
                              active: pageItem.active
                            });
                          } else {
                            contentNode = pageNode;
                          }
                          break;
                        case "fast-forward":
                          const fastForwardNode = this.fastForwardActive ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                            default: () => this.rtlEnabled ? vue.h(FastBackwardIcon, null) : vue.h(FastForwardIcon, null)
                          }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(MoreIcon, null) });
                          if (renderLabel) {
                            contentNode = renderLabel({
                              type: "fast-forward",
                              node: fastForwardNode,
                              active: this.fastForwardActive || this.showFastForwardMenu
                            });
                          } else {
                            contentNode = fastForwardNode;
                          }
                          onMouseenter = this.handleFastForwardMouseenter;
                          onMouseleave = this.handleFastForwardMouseleave;
                          break;
                        case "fast-backward":
                          const fastBackwardNode = this.fastBackwardActive ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                            default: () => this.rtlEnabled ? vue.h(FastForwardIcon, null) : vue.h(FastBackwardIcon, null)
                          }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(MoreIcon, null) });
                          if (renderLabel) {
                            contentNode = renderLabel({
                              type: "fast-backward",
                              node: fastBackwardNode,
                              active: this.fastBackwardActive || this.showFastBackwardMenu
                            });
                          } else {
                            contentNode = fastBackwardNode;
                          }
                          onMouseenter = this.handleFastBackwardMouseenter;
                          onMouseleave = this.handleFastBackwardMouseleave;
                          break;
                      }
                      const itemNode = vue.h("div", { key: index, class: [
                        `${mergedClsPrefix}-pagination-item`,
                        pageItem.active && `${mergedClsPrefix}-pagination-item--active`,
                        type2 !== "page" && (type2 === "fast-backward" && this.showFastBackwardMenu || type2 === "fast-forward" && this.showFastForwardMenu) && `${mergedClsPrefix}-pagination-item--hover`,
                        disabled && `${mergedClsPrefix}-pagination-item--disabled`,
                        type2 === "page" && `${mergedClsPrefix}-pagination-item--clickable`
                      ], onClick: () => {
                        handlePageItemClick(pageItem);
                      }, onMouseenter, onMouseleave }, contentNode);
                      if (type2 === "page" && !pageItem.mayBeFastBackward && !pageItem.mayBeFastForward) {
                        return itemNode;
                      } else {
                        const key = pageItem.type === "page" ? pageItem.mayBeFastBackward ? "fast-backward" : "fast-forward" : pageItem.type;
                        return vue.h(NPopselect, { to: this.to, key, disabled, trigger: "hover", virtualScroll: true, style: { width: "60px" }, theme: mergedTheme.peers.Popselect, themeOverrides: mergedTheme.peerOverrides.Popselect, builtinThemeOverrides: {
                          peers: {
                            InternalSelectMenu: {
                              height: "calc(var(--n-option-height) * 4.6)"
                            }
                          }
                        }, nodeProps: () => ({
                          style: {
                            justifyContent: "center"
                          }
                        }), show: type2 === "page" ? false : type2 === "fast-backward" ? this.showFastBackwardMenu : this.showFastForwardMenu, onUpdateShow: (value) => {
                          if (type2 === "page")
                            return;
                          if (value) {
                            if (type2 === "fast-backward") {
                              this.showFastBackwardMenu = value;
                            } else {
                              this.showFastForwardMenu = value;
                            }
                          } else {
                            this.showFastBackwardMenu = false;
                            this.showFastForwardMenu = false;
                          }
                        }, options: pageItem.type !== "page" ? pageItem.options : [], onUpdateValue: this.handleMenuSelect, scrollable: true, showCheckmark: false }, { default: () => itemNode });
                      }
                    }),
                    vue.h("div", { class: [
                      `${mergedClsPrefix}-pagination-item`,
                      !renderNext && `${mergedClsPrefix}-pagination-item--button`,
                      {
                        [`${mergedClsPrefix}-pagination-item--disabled`]: mergedPage < 1 || mergedPage >= mergedPageCount || disabled
                      }
                    ], onClick: handleForwardClick }, renderNext ? renderNext({
                      page: mergedPage,
                      pageSize: mergedPageSize,
                      pageCount: mergedPageCount,
                      itemCount: this.mergedItemCount,
                      startIndex: this.startIndex,
                      endIndex: this.endIndex
                    }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                      default: () => this.rtlEnabled ? vue.h(BackwardIcon, null) : vue.h(ForwardIcon, null)
                    }))
                  );
                case "size-picker": {
                  return !simple && showSizePicker ? vue.h(NSelect, Object.assign({ consistentMenuWidth: false, placeholder: "", showCheckmark: false, to: this.to }, this.selectProps, { size: selectSize, options: pageSizeOptions, value: mergedPageSize, disabled, theme: mergedTheme.peers.Select, themeOverrides: mergedTheme.peerOverrides.Select, onUpdateValue: handleSizePickerChange })) : null;
                }
                case "quick-jumper":
                  return !simple && showQuickJumper ? vue.h(
                    "div",
                    { class: `${mergedClsPrefix}-pagination-quick-jumper` },
                    goto ? goto() : resolveSlot(this.$slots.goto, () => [locale2.goto]),
                    vue.h(NInput, { value: jumperValue, onUpdateValue: handleJumperInput, size: inputSize, placeholder: "", disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onChange: handleQuickJumperChange })
                  ) : null;
                default:
                  return null;
              }
            }),
            renderSuffix ? vue.h("div", { class: `${mergedClsPrefix}-pagination-suffix` }, renderSuffix({
              page: mergedPage,
              pageSize: mergedPageSize,
              pageCount: mergedPageCount,
              startIndex: this.startIndex,
              endIndex: this.endIndex,
              itemCount: this.mergedItemCount
            })) : null
          );
        }
      });
      const commonVars$8 = {
        padding: "8px 14px"
      };
      const tooltipDark = {
        name: "Tooltip",
        common: commonDark,
        peers: {
          Popover: popoverDark$1
        },
        self(vars) {
          const { borderRadius, boxShadow2, popoverColor, textColor2 } = vars;
          return Object.assign(Object.assign({}, commonVars$8), { borderRadius, boxShadow: boxShadow2, color: popoverColor, textColor: textColor2 });
        }
      };
      const tooltipDark$1 = tooltipDark;
      const self$N = (vars) => {
        const { borderRadius, boxShadow2, baseColor } = vars;
        return Object.assign(Object.assign({}, commonVars$8), { borderRadius, boxShadow: boxShadow2, color: composite(baseColor, "rgba(0, 0, 0, .85)"), textColor: baseColor });
      };
      const tooltipLight = createTheme({
        name: "Tooltip",
        common: commonLight,
        peers: {
          Popover: popoverLight$1
        },
        self: self$N
      });
      const tooltipLight$1 = tooltipLight;
      const ellipsisDark = {
        name: "Ellipsis",
        common: commonDark,
        peers: {
          Tooltip: tooltipDark$1
        }
      };
      const ellipsisDark$1 = ellipsisDark;
      const ellipsisLight = createTheme({
        name: "Ellipsis",
        common: commonLight,
        peers: {
          Tooltip: tooltipLight$1
        }
      });
      const ellipsisLight$1 = ellipsisLight;
      const commonVariables$a = {
        radioSizeSmall: "14px",
        radioSizeMedium: "16px",
        radioSizeLarge: "18px",
        labelPadding: "0 8px",
        labelFontWeight: "400"
      };
      const radioDark = {
        name: "Radio",
        common: commonDark,
        self(vars) {
          const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight2 } = vars;
          return Object.assign(Object.assign({}, commonVariables$a), {
            labelLineHeight: lineHeight2,
            buttonHeightSmall: heightSmall,
            buttonHeightMedium: heightMedium,
            buttonHeightLarge: heightLarge,
            fontSizeSmall,
            fontSizeMedium,
            fontSizeLarge,
            boxShadow: `inset 0 0 0 1px ${borderColor}`,
            boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
            boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
            boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
            boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
            color: "#0000",
            colorDisabled: inputColorDisabled,
            colorActive: "#0000",
            textColor: textColor2,
            textColorDisabled,
            dotColorActive: primaryColor,
            dotColorDisabled: borderColor,
            buttonBorderColor: borderColor,
            buttonBorderColorActive: primaryColor,
            buttonBorderColorHover: primaryColor,
            buttonColor: "#0000",
            buttonColorActive: primaryColor,
            buttonTextColor: textColor2,
            buttonTextColorActive: baseColor,
            buttonTextColorHover: primaryColor,
            opacityDisabled,
            buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
            buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
            buttonBoxShadow: "inset 0 0 0 1px #0000",
            buttonBorderRadius: borderRadius
          });
        }
      };
      const radioDark$1 = radioDark;
      const self$M = (vars) => {
        const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight2 } = vars;
        return Object.assign(Object.assign({}, commonVariables$a), {
          labelLineHeight: lineHeight2,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: baseColor,
          colorDisabled: inputColorDisabled,
          colorActive: "#0000",
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: borderColor,
          buttonColor: baseColor,
          buttonColorActive: baseColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: primaryColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
          buttonBoxShadowHover: "inset 0 0 0 1px #0000",
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        });
      };
      const radioLight = {
        name: "Radio",
        common: commonLight,
        self: self$M
      };
      const radioLight$1 = radioLight;
      const commonVariables$9 = {
        padding: "4px 0",
        optionIconSizeSmall: "14px",
        optionIconSizeMedium: "16px",
        optionIconSizeLarge: "16px",
        optionIconSizeHuge: "18px",
        optionSuffixWidthSmall: "14px",
        optionSuffixWidthMedium: "14px",
        optionSuffixWidthLarge: "16px",
        optionSuffixWidthHuge: "16px",
        optionIconSuffixWidthSmall: "32px",
        optionIconSuffixWidthMedium: "32px",
        optionIconSuffixWidthLarge: "36px",
        optionIconSuffixWidthHuge: "36px",
        optionPrefixWidthSmall: "14px",
        optionPrefixWidthMedium: "14px",
        optionPrefixWidthLarge: "16px",
        optionPrefixWidthHuge: "16px",
        optionIconPrefixWidthSmall: "36px",
        optionIconPrefixWidthMedium: "36px",
        optionIconPrefixWidthLarge: "40px",
        optionIconPrefixWidthHuge: "40px"
      };
      const self$L = (vars) => {
        const { primaryColor, textColor2, dividerColor, hoverColor, popoverColor, invertedColor, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge, textColor3, opacityDisabled } = vars;
        return Object.assign(Object.assign({}, commonVariables$9), {
          optionHeightSmall: heightSmall,
          optionHeightMedium: heightMedium,
          optionHeightLarge: heightLarge,
          optionHeightHuge: heightHuge,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge,
          // non-inverted
          optionTextColor: textColor2,
          optionTextColorHover: textColor2,
          optionTextColorActive: primaryColor,
          optionTextColorChildActive: primaryColor,
          color: popoverColor,
          dividerColor,
          suffixColor: textColor2,
          prefixColor: textColor2,
          optionColorHover: hoverColor,
          optionColorActive: changeColor(primaryColor, { alpha: 0.1 }),
          groupHeaderTextColor: textColor3,
          // inverted
          optionTextColorInverted: "#BBB",
          optionTextColorHoverInverted: "#FFF",
          optionTextColorActiveInverted: "#FFF",
          optionTextColorChildActiveInverted: "#FFF",
          colorInverted: invertedColor,
          dividerColorInverted: "#BBB",
          suffixColorInverted: "#BBB",
          prefixColorInverted: "#BBB",
          optionColorHoverInverted: primaryColor,
          optionColorActiveInverted: primaryColor,
          groupHeaderTextColorInverted: "#AAA",
          optionOpacityDisabled: opacityDisabled
        });
      };
      const dropdownLight = createTheme({
        name: "Dropdown",
        common: commonLight,
        peers: {
          Popover: popoverLight$1
        },
        self: self$L
      });
      const dropdownLight$1 = dropdownLight;
      const dropdownDark = {
        name: "Dropdown",
        common: commonDark,
        peers: {
          Popover: popoverDark$1
        },
        self(vars) {
          const { primaryColorSuppl, primaryColor, popoverColor } = vars;
          const commonSelf = self$L(vars);
          commonSelf.colorInverted = popoverColor;
          commonSelf.optionColorActive = changeColor(primaryColor, { alpha: 0.15 });
          commonSelf.optionColorActiveInverted = primaryColorSuppl;
          commonSelf.optionColorHoverInverted = primaryColorSuppl;
          return commonSelf;
        }
      };
      const dropdownDark$1 = dropdownDark;
      const commonVariables$8 = {
        thPaddingSmall: "8px",
        thPaddingMedium: "12px",
        thPaddingLarge: "12px",
        tdPaddingSmall: "8px",
        tdPaddingMedium: "12px",
        tdPaddingLarge: "12px",
        sorterSize: "15px",
        resizableContainerSize: "8px",
        resizableSize: "2px",
        filterSize: "15px",
        paginationMargin: "12px 0 0 0",
        emptyPadding: "48px 0",
        actionPadding: "8px 12px",
        actionButtonMargin: "0 8px 0 0"
      };
      const self$K = (vars) => {
        const { cardColor, modalColor, popoverColor, textColor2, textColor1, tableHeaderColor, tableColorHover, iconColor, primaryColor, fontWeightStrong, borderRadius, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor, heightSmall, opacityDisabled, tableColorStriped } = vars;
        return Object.assign(Object.assign({}, commonVariables$8), {
          actionDividerColor: dividerColor,
          lineHeight: lineHeight2,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderColor: composite(cardColor, dividerColor),
          tdColorHover: composite(cardColor, tableColorHover),
          tdColorStriped: composite(cardColor, tableColorStriped),
          thColor: composite(cardColor, tableHeaderColor),
          thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
          tdColor: cardColor,
          tdTextColor: textColor2,
          thTextColor: textColor1,
          thFontWeight: fontWeightStrong,
          thButtonColorHover: tableColorHover,
          thIconColor: iconColor,
          thIconColorActive: primaryColor,
          // modal
          borderColorModal: composite(modalColor, dividerColor),
          tdColorHoverModal: composite(modalColor, tableColorHover),
          tdColorStripedModal: composite(modalColor, tableColorStriped),
          thColorModal: composite(modalColor, tableHeaderColor),
          thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
          tdColorModal: modalColor,
          // popover
          borderColorPopover: composite(popoverColor, dividerColor),
          tdColorHoverPopover: composite(popoverColor, tableColorHover),
          tdColorStripedPopover: composite(popoverColor, tableColorStriped),
          thColorPopover: composite(popoverColor, tableHeaderColor),
          thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
          tdColorPopover: popoverColor,
          boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
          boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
          // loading
          loadingColor: primaryColor,
          loadingSize: heightSmall,
          opacityLoading: opacityDisabled
        });
      };
      const dataTableLight = createTheme({
        name: "DataTable",
        common: commonLight,
        peers: {
          Button: buttonLight$1,
          Checkbox: checkboxLight$1,
          Radio: radioLight$1,
          Pagination: paginationLight$1,
          Scrollbar: scrollbarLight$1,
          Empty: emptyLight$1,
          Popover: popoverLight$1,
          Ellipsis: ellipsisLight$1,
          Dropdown: dropdownLight$1
        },
        self: self$K
      });
      const dataTableLight$1 = dataTableLight;
      const dataTableDark = {
        name: "DataTable",
        common: commonDark,
        peers: {
          Button: buttonDark$1,
          Checkbox: checkboxDark$1,
          Radio: radioDark$1,
          Pagination: paginationDark$1,
          Scrollbar: scrollbarDark$1,
          Empty: emptyDark$1,
          Popover: popoverDark$1,
          Ellipsis: ellipsisDark$1,
          Dropdown: dropdownDark$1
        },
        self(vars) {
          const commonSelf = self$K(vars);
          commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
          commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
          return commonSelf;
        }
      };
      const dataTableDark$1 = dataTableDark;
      const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
      const NTooltip = vue.defineComponent({
        name: "Tooltip",
        props: tooltipProps,
        __popover__: true,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight$1, props, mergedClsPrefixRef);
          const popoverRef = vue.ref(null);
          const tooltipExposedMethod = {
            syncPosition() {
              popoverRef.value.syncPosition();
            },
            setShow(show) {
              popoverRef.value.setShow(show);
            }
          };
          return Object.assign(Object.assign({}, tooltipExposedMethod), { popoverRef, mergedTheme: themeRef, popoverThemeOverrides: vue.computed(() => {
            return themeRef.value.self;
          }) });
        },
        render() {
          const { mergedTheme, internalExtraClass } = this;
          return vue.h(NPopover, Object.assign(Object.assign({}, this.$props), { theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, builtinThemeOverrides: this.popoverThemeOverrides, internalExtraClass: internalExtraClass.concat("tooltip"), ref: "popoverRef" }), this.$slots);
        }
      });
      const style$Y = cB("ellipsis", {
        overflow: "hidden"
      }, [cNotM("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), cM("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), cM("cursor-pointer", `
 cursor: pointer;
 `)]);
      function createLineClampClass(clsPrefix) {
        return `${clsPrefix}-ellipsis--line-clamp`;
      }
      function createCursorClass(clsPrefix, cursor) {
        return `${clsPrefix}-ellipsis--cursor-${cursor}`;
      }
      const ellipsisProps = Object.assign(Object.assign({}, useTheme.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: {
        type: [Boolean, Object],
        default: true
      } });
      const NEllipsis = vue.defineComponent({
        name: "Ellipsis",
        inheritAttrs: false,
        props: ellipsisProps,
        setup(props, { slots, attrs }) {
          const { mergedClsPrefixRef } = useConfig(props);
          const mergedTheme = useTheme("Ellipsis", "-ellipsis", style$Y, ellipsisLight$1, props, mergedClsPrefixRef);
          const triggerRef = vue.ref(null);
          const triggerInnerRef = vue.ref(null);
          const tooltipRef = vue.ref(null);
          const expandedRef = vue.ref(false);
          const ellipsisStyleRef = vue.computed(() => {
            const { lineClamp } = props;
            const { value: expanded } = expandedRef;
            if (lineClamp !== void 0) {
              return {
                textOverflow: "",
                "-webkit-line-clamp": expanded ? "" : lineClamp
              };
            } else {
              return {
                textOverflow: expanded ? "" : "ellipsis",
                "-webkit-line-clamp": ""
              };
            }
          });
          function getTooltipDisabled() {
            let tooltipDisabled = false;
            const { value: expanded } = expandedRef;
            if (expanded)
              return true;
            const { value: trigger2 } = triggerRef;
            if (trigger2) {
              const { lineClamp } = props;
              syncEllipsisStyle(trigger2);
              if (lineClamp !== void 0) {
                tooltipDisabled = trigger2.scrollHeight <= trigger2.offsetHeight;
              } else {
                const { value: triggerInner } = triggerInnerRef;
                if (triggerInner) {
                  tooltipDisabled = triggerInner.getBoundingClientRect().width <= trigger2.getBoundingClientRect().width;
                }
              }
              syncCursorStyle(trigger2, tooltipDisabled);
            }
            return tooltipDisabled;
          }
          const handleClickRef = vue.computed(() => {
            return props.expandTrigger === "click" ? () => {
              var _a;
              const { value: expanded } = expandedRef;
              if (expanded) {
                (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
              }
              expandedRef.value = !expanded;
            } : void 0;
          });
          vue.onDeactivated(() => {
            var _a;
            if (props.tooltip) {
              (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
            }
          });
          const renderTrigger = () => vue.h("span", Object.assign({}, vue.mergeProps(attrs, {
            class: [
              `${mergedClsPrefixRef.value}-ellipsis`,
              props.lineClamp !== void 0 ? createLineClampClass(mergedClsPrefixRef.value) : void 0,
              props.expandTrigger === "click" ? createCursorClass(mergedClsPrefixRef.value, "pointer") : void 0
            ],
            style: ellipsisStyleRef.value
          }), { ref: "triggerRef", onClick: handleClickRef.value, onMouseenter: (
            // get tooltip disabled will derive cursor style
            props.expandTrigger === "click" ? getTooltipDisabled : void 0
          ) }), props.lineClamp ? slots : vue.h("span", { ref: "triggerInnerRef" }, slots));
          function syncEllipsisStyle(trigger2) {
            if (!trigger2)
              return;
            const latestStyle = ellipsisStyleRef.value;
            const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
            if (props.lineClamp !== void 0) {
              syncTriggerClass(trigger2, lineClampClass, "add");
            } else {
              syncTriggerClass(trigger2, lineClampClass, "remove");
            }
            for (const key in latestStyle) {
              if (trigger2.style[key] !== latestStyle[key]) {
                trigger2.style[key] = latestStyle[key];
              }
            }
          }
          function syncCursorStyle(trigger2, tooltipDisabled) {
            const cursorClass = createCursorClass(mergedClsPrefixRef.value, "pointer");
            if (props.expandTrigger === "click" && !tooltipDisabled) {
              syncTriggerClass(trigger2, cursorClass, "add");
            } else {
              syncTriggerClass(trigger2, cursorClass, "remove");
            }
          }
          function syncTriggerClass(trigger2, styleClass, action) {
            if (action === "add") {
              if (!trigger2.classList.contains(styleClass)) {
                trigger2.classList.add(styleClass);
              }
            } else {
              if (trigger2.classList.contains(styleClass)) {
                trigger2.classList.remove(styleClass);
              }
            }
          }
          return {
            mergedTheme,
            triggerRef,
            triggerInnerRef,
            tooltipRef,
            handleClick: handleClickRef,
            renderTrigger,
            getTooltipDisabled
          };
        },
        render() {
          var _a;
          const { tooltip, renderTrigger, $slots } = this;
          if (tooltip) {
            const { mergedTheme } = this;
            return vue.h(NTooltip, Object.assign({ ref: "tooltipRef", placement: "top" }, tooltip, { getDisabled: this.getTooltipDisabled, theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip }), {
              trigger: renderTrigger,
              default: (_a = $slots.tooltip) !== null && _a !== void 0 ? _a : $slots.default
            });
          } else
            return renderTrigger();
        }
      });
      const RenderSorter = vue.defineComponent({
        name: "DataTableRenderSorter",
        props: {
          render: {
            type: Function,
            required: true
          },
          order: {
            // asc, desc
            type: [String, Boolean],
            default: false
          }
        },
        render() {
          const { render: render2, order } = this;
          return render2({
            order
          });
        }
      });
      const dataTableProps = Object.assign(Object.assign({}, useTheme.props), {
        onUnstableColumnResize: Function,
        pagination: {
          type: [Object, Boolean],
          default: false
        },
        paginateSinglePage: {
          type: Boolean,
          default: true
        },
        minHeight: [Number, String],
        maxHeight: [Number, String],
        // Use any type as row data to make prop data acceptable
        columns: {
          type: Array,
          default: () => []
        },
        rowClassName: [String, Function],
        rowProps: Function,
        rowKey: Function,
        summary: [Function],
        data: {
          type: Array,
          default: () => []
        },
        loading: Boolean,
        bordered: {
          type: Boolean,
          default: void 0
        },
        bottomBordered: {
          type: Boolean,
          default: void 0
        },
        striped: Boolean,
        scrollX: [Number, String],
        defaultCheckedRowKeys: {
          type: Array,
          default: () => []
        },
        checkedRowKeys: Array,
        singleLine: {
          type: Boolean,
          default: true
        },
        singleColumn: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        remote: Boolean,
        defaultExpandedRowKeys: {
          type: Array,
          default: []
        },
        defaultExpandAll: Boolean,
        expandedRowKeys: Array,
        stickyExpandedRows: Boolean,
        virtualScroll: Boolean,
        tableLayout: {
          type: String,
          default: "auto"
        },
        allowCheckingNotLoaded: Boolean,
        cascade: {
          type: Boolean,
          default: true
        },
        childrenKey: {
          type: String,
          default: "children"
        },
        indent: {
          type: Number,
          default: 16
        },
        flexHeight: Boolean,
        summaryPlacement: {
          type: String,
          default: "bottom"
        },
        paginationBehaviorOnFilter: {
          type: String,
          default: "current"
        },
        scrollbarProps: Object,
        renderCell: Function,
        renderExpandIcon: Function,
        spinProps: { type: Object, default: {} },
        onLoad: Function,
        "onUpdate:page": [Function, Array],
        onUpdatePage: [Function, Array],
        "onUpdate:pageSize": [Function, Array],
        onUpdatePageSize: [Function, Array],
        "onUpdate:sorter": [Function, Array],
        onUpdateSorter: [Function, Array],
        "onUpdate:filters": [Function, Array],
        onUpdateFilters: [Function, Array],
        "onUpdate:checkedRowKeys": [Function, Array],
        onUpdateCheckedRowKeys: [Function, Array],
        "onUpdate:expandedRowKeys": [Function, Array],
        onUpdateExpandedRowKeys: [Function, Array],
        onScroll: Function,
        // deprecated
        onPageChange: [Function, Array],
        onPageSizeChange: [Function, Array],
        onSorterChange: [Function, Array],
        onFiltersChange: [Function, Array],
        onCheckedRowKeysChange: [Function, Array]
      });
      const dataTableInjectionKey = createInjectionKey("n-data-table");
      const SortButton = vue.defineComponent({
        name: "SortIcon",
        props: {
          column: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const { mergedComponentPropsRef } = useConfig();
          const { mergedSortStateRef, mergedClsPrefixRef } = vue.inject(dataTableInjectionKey);
          const sortStateRef = vue.computed(() => mergedSortStateRef.value.find((state) => state.columnKey === props.column.key));
          const activeRef = vue.computed(() => {
            return sortStateRef.value !== void 0;
          });
          const mergedSortOrderRef = vue.computed(() => {
            const { value: sortState } = sortStateRef;
            if (sortState && activeRef.value) {
              return sortState.order;
            }
            return false;
          });
          const mergedRenderSorterRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderSorter) || props.column.renderSorter;
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            active: activeRef,
            mergedSortOrder: mergedSortOrderRef,
            mergedRenderSorter: mergedRenderSorterRef
          };
        },
        render() {
          const { mergedRenderSorter, mergedSortOrder, mergedClsPrefix } = this;
          const { renderSorterIcon } = this.column;
          return mergedRenderSorter ? vue.h(RenderSorter, { render: mergedRenderSorter, order: mergedSortOrder }) : vue.h("span", { class: [
            `${mergedClsPrefix}-data-table-sorter`,
            mergedSortOrder === "ascend" && `${mergedClsPrefix}-data-table-sorter--asc`,
            mergedSortOrder === "descend" && `${mergedClsPrefix}-data-table-sorter--desc`
          ] }, renderSorterIcon ? renderSorterIcon({ order: mergedSortOrder }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(ArrowDownIcon, null) }));
        }
      });
      const RenderFilter = vue.defineComponent({
        name: "DataTableRenderFilter",
        props: {
          render: {
            type: Function,
            required: true
          },
          active: {
            type: Boolean,
            default: false
          },
          show: {
            type: Boolean,
            default: false
          }
        },
        render() {
          const { render: render2, active, show } = this;
          return render2({
            active,
            show
          });
        }
      });
      const radioProps = {
        name: String,
        value: {
          type: [String, Number, Boolean],
          default: "on"
        },
        checked: {
          type: Boolean,
          default: void 0
        },
        defaultChecked: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        },
        label: String,
        size: String,
        onUpdateChecked: [Function, Array],
        "onUpdate:checked": [Function, Array],
        // deprecated
        checkedValue: {
          type: Boolean,
          default: void 0
        }
      };
      const radioGroupInjectionKey = createInjectionKey("n-radio-group");
      function setup(props) {
        const formItem = useFormItem(props, {
          mergedSize(NFormItem2) {
            const { size: size2 } = props;
            if (size2 !== void 0)
              return size2;
            if (NRadioGroup2) {
              const { mergedSizeRef: { value: mergedSize } } = NRadioGroup2;
              if (mergedSize !== void 0) {
                return mergedSize;
              }
            }
            if (NFormItem2) {
              return NFormItem2.mergedSize.value;
            }
            return "medium";
          },
          mergedDisabled(NFormItem2) {
            if (props.disabled)
              return true;
            if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value)
              return true;
            if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value)
              return true;
            return false;
          }
        });
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const inputRef = vue.ref(null);
        const labelRef = vue.ref(null);
        const NRadioGroup2 = vue.inject(radioGroupInjectionKey, null);
        const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
        const controlledCheckedRef = vue.toRef(props, "checked");
        const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
        const renderSafeCheckedRef = useMemo(() => {
          if (NRadioGroup2)
            return NRadioGroup2.valueRef.value === props.value;
          return mergedCheckedRef.value;
        });
        const mergedNameRef = useMemo(() => {
          const { name } = props;
          if (name !== void 0)
            return name;
          if (NRadioGroup2)
            return NRadioGroup2.nameRef.value;
        });
        const focusRef = vue.ref(false);
        function doUpdateChecked() {
          if (NRadioGroup2) {
            const { doUpdateValue } = NRadioGroup2;
            const { value } = props;
            call(doUpdateValue, value);
          } else {
            const { onUpdateChecked, "onUpdate:checked": _onUpdateChecked } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateChecked)
              call(onUpdateChecked, true);
            if (_onUpdateChecked)
              call(_onUpdateChecked, true);
            nTriggerFormInput();
            nTriggerFormChange();
            uncontrolledCheckedRef.value = true;
          }
        }
        function toggle() {
          if (mergedDisabledRef.value)
            return;
          if (!renderSafeCheckedRef.value) {
            doUpdateChecked();
          }
        }
        function handleRadioInputChange() {
          toggle();
        }
        function handleRadioInputBlur() {
          focusRef.value = false;
        }
        function handleRadioInputFocus() {
          focusRef.value = true;
        }
        return {
          mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
          inputRef,
          labelRef,
          mergedName: mergedNameRef,
          mergedDisabled: mergedDisabledRef,
          uncontrolledChecked: uncontrolledCheckedRef,
          renderSafeChecked: renderSafeCheckedRef,
          focus: focusRef,
          mergedSize: mergedSizeRef,
          handleRadioInputChange,
          handleRadioInputBlur,
          handleRadioInputFocus
        };
      }
      const style$X = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM("checked", [cE("dot", `
 background-color: var(--n-color-active);
 `)]), cE("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM("checked", {
        boxShadow: "var(--n-box-shadow-active)"
      }, [c$1("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("dot", {
        boxShadow: "var(--n-box-shadow-hover)"
      })]), cM("focus", [c$1("&:not(:active)", [cE("dot", {
        boxShadow: "var(--n-box-shadow-focus)"
      })])])]), cM("disabled", `
 cursor: not-allowed;
 `, [cE("dot", {
        boxShadow: "var(--n-box-shadow-disabled)",
        backgroundColor: "var(--n-color-disabled)"
      }, [c$1("&::before", {
        backgroundColor: "var(--n-dot-color-disabled)"
      }), cM("checked", `
 opacity: 1;
 `)]), cE("label", {
        color: "var(--n-text-color-disabled)"
      }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
      const NRadio = vue.defineComponent({
        name: "Radio",
        props: Object.assign(Object.assign({}, useTheme.props), radioProps),
        setup(props) {
          const radio = setup(props);
          const themeRef = useTheme("Radio", "-radio", style$X, radioLight$1, props, radio.mergedClsPrefix);
          const cssVarsRef = vue.computed(() => {
            const { mergedSize: { value: size2 } } = radio;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { boxShadow, boxShadowActive, boxShadowDisabled, boxShadowFocus, boxShadowHover, color, colorDisabled, colorActive, textColor, textColorDisabled, dotColorActive, dotColorDisabled, labelPadding, labelLineHeight, labelFontWeight, [createKey("fontSize", size2)]: fontSize2, [createKey("radioSize", size2)]: radioSize } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-label-line-height": labelLineHeight,
              "--n-label-font-weight": labelFontWeight,
              "--n-box-shadow": boxShadow,
              "--n-box-shadow-active": boxShadowActive,
              "--n-box-shadow-disabled": boxShadowDisabled,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-box-shadow-hover": boxShadowHover,
              "--n-color": color,
              "--n-color-active": colorActive,
              "--n-color-disabled": colorDisabled,
              "--n-dot-color-active": dotColorActive,
              "--n-dot-color-disabled": dotColorDisabled,
              "--n-font-size": fontSize2,
              "--n-radio-size": radioSize,
              "--n-text-color": textColor,
              "--n-text-color-disabled": textColorDisabled,
              "--n-label-padding": labelPadding
            };
          });
          const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", vue.computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
          return Object.assign(radio, {
            rtlEnabled: rtlEnabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const { $slots, mergedClsPrefix, onRender, label } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "label",
            { class: [
              `${mergedClsPrefix}-radio`,
              this.themeClass,
              {
                [`${mergedClsPrefix}-radio--rtl`]: this.rtlEnabled,
                [`${mergedClsPrefix}-radio--disabled`]: this.mergedDisabled,
                [`${mergedClsPrefix}-radio--checked`]: this.renderSafeChecked,
                [`${mergedClsPrefix}-radio--focus`]: this.focus
              }
            ], style: this.cssVars },
            vue.h("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-radio__dot-wrapper` },
              "",
              vue.h("div", { class: [
                `${mergedClsPrefix}-radio__dot`,
                this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`
              ] })
            ),
            resolveWrappedSlot($slots.default, (children) => {
              if (!children && !label)
                return null;
              return vue.h("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, children || label);
            })
          );
        }
      });
      const style$W = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM("checked", {
        backgroundColor: "var(--n-button-border-color-active)"
      }), cM("disabled", {
        opacity: "var(--n-opacity-disabled)"
      })]), cM("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
        height: "var(--n-height)",
        lineHeight: "var(--n-height)"
      }), cE("splitor", {
        height: "var(--n-height)"
      })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c$1("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c$1("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
        color: "var(--n-button-text-color-hover)"
      })]), cM("focus", [c$1("&:not(:active)", [cE("state-border", {
        boxShadow: "var(--n-button-box-shadow-focus)"
      })])])]), cM("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
      function mapSlot(defaultSlot, value, clsPrefix) {
        var _a;
        const children = [];
        let isButtonGroup = false;
        for (let i = 0; i < defaultSlot.length; ++i) {
          const wrappedInstance = defaultSlot[i];
          const name = (_a = wrappedInstance.type) === null || _a === void 0 ? void 0 : _a.name;
          if (name === "RadioButton") {
            isButtonGroup = true;
          }
          const instanceProps = wrappedInstance.props;
          if (name !== "RadioButton") {
            children.push(wrappedInstance);
            continue;
          }
          if (i === 0) {
            children.push(wrappedInstance);
          } else {
            const lastInstanceProps = children[children.length - 1].props;
            const lastInstanceChecked = value === lastInstanceProps.value;
            const lastInstanceDisabled = lastInstanceProps.disabled;
            const currentInstanceChecked = value === instanceProps.value;
            const currentInstanceDisabled = instanceProps.disabled;
            const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
            const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
            const lastInstanceClass = {
              [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
              [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
            };
            const currentInstanceClass = {
              [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
              [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
            };
            const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
            children.push(vue.h("div", { class: [`${clsPrefix}-radio-group__splitor`, splitorClass] }), wrappedInstance);
          }
        }
        return {
          children,
          isButtonGroup
        };
      }
      const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), { name: String, value: [String, Number, Boolean], defaultValue: {
        type: [String, Number, Boolean],
        default: null
      }, size: String, disabled: {
        type: Boolean,
        default: void 0
      }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
      const NRadioGroup = vue.defineComponent({
        name: "RadioGroup",
        props: radioGroupProps,
        setup(props) {
          const selfElRef = vue.ref(null);
          const { mergedSizeRef, mergedDisabledRef, nTriggerFormChange, nTriggerFormInput, nTriggerFormBlur, nTriggerFormFocus } = useFormItem(props);
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Radio", "-radio-group", style$W, radioLight$1, props, mergedClsPrefixRef);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          function doUpdateValue(value) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
            if (onUpdateValue) {
              call(onUpdateValue, value);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function handleFocusin(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
              return;
            if (selfEl.contains(e.relatedTarget))
              return;
            nTriggerFormFocus();
          }
          function handleFocusout(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
              return;
            if (selfEl.contains(e.relatedTarget))
              return;
            nTriggerFormBlur();
          }
          vue.provide(radioGroupInjectionKey, {
            mergedClsPrefixRef,
            nameRef: vue.toRef(props, "name"),
            valueRef: mergedValueRef,
            disabledRef: mergedDisabledRef,
            mergedSizeRef,
            doUpdateValue
          });
          const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { value: size2 } = mergedSizeRef;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { buttonBorderColor, buttonBorderColorActive, buttonBorderRadius, buttonBoxShadow, buttonBoxShadowFocus, buttonBoxShadowHover, buttonColorActive, buttonTextColor, buttonTextColorActive, buttonTextColorHover, opacityDisabled, [createKey("buttonHeight", size2)]: height, [createKey("fontSize", size2)]: fontSize2 } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-button-border-color": buttonBorderColor,
              "--n-button-border-color-active": buttonBorderColorActive,
              "--n-button-border-radius": buttonBorderRadius,
              "--n-button-box-shadow": buttonBoxShadow,
              "--n-button-box-shadow-focus": buttonBoxShadowFocus,
              "--n-button-box-shadow-hover": buttonBoxShadowHover,
              "--n-button-color-active": buttonColorActive,
              "--n-button-text-color": buttonTextColor,
              "--n-button-text-color-hover": buttonTextColorHover,
              "--n-button-text-color-active": buttonTextColorActive,
              "--n-height": height,
              "--n-opacity-disabled": opacityDisabled
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", vue.computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
          return {
            selfElRef,
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            handleFocusout,
            handleFocusin,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedValue, mergedClsPrefix, handleFocusin, handleFocusout } = this;
          const { children, isButtonGroup } = mapSlot(flatten$3(getSlot$1(this)), mergedValue, mergedClsPrefix);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", { onFocusin: handleFocusin, onFocusout: handleFocusout, ref: "selfElRef", class: [
            `${mergedClsPrefix}-radio-group`,
            this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`,
            this.themeClass,
            isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`
          ], style: this.cssVars }, children);
        }
      });
      const radioButtonProps = radioProps;
      const RadioButton = vue.defineComponent({
        name: "RadioButton",
        props: radioProps,
        setup,
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(
            "label",
            { class: [
              `${mergedClsPrefix}-radio-button`,
              this.mergedDisabled && `${mergedClsPrefix}-radio-button--disabled`,
              this.renderSafeChecked && `${mergedClsPrefix}-radio-button--checked`,
              this.focus && [`${mergedClsPrefix}-radio-button--focus`]
            ] },
            vue.h("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
            vue.h("div", { class: `${mergedClsPrefix}-radio-button__state-border` }),
            resolveWrappedSlot(this.$slots.default, (children) => {
              if (!children && !this.label)
                return null;
              return vue.h("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, children || this.label);
            })
          );
        }
      });
      const SELECTION_COL_WIDTH = 40;
      const EXPAND_COL_WIDTH = 40;
      function getNumberColWidth(col) {
        if (col.type === "selection") {
          return col.width === void 0 ? SELECTION_COL_WIDTH : depx(col.width);
        }
        if (col.type === "expand") {
          return col.width === void 0 ? EXPAND_COL_WIDTH : depx(col.width);
        }
        if ("children" in col)
          return void 0;
        if (typeof col.width === "string") {
          return depx(col.width);
        }
        return col.width;
      }
      function getStringColWidth(col) {
        var _a, _b;
        if (col.type === "selection") {
          return formatLength((_a = col.width) !== null && _a !== void 0 ? _a : SELECTION_COL_WIDTH);
        }
        if (col.type === "expand") {
          return formatLength((_b = col.width) !== null && _b !== void 0 ? _b : EXPAND_COL_WIDTH);
        }
        if ("children" in col) {
          return void 0;
        }
        return formatLength(col.width);
      }
      function getColKey(col) {
        if (col.type === "selection")
          return "__n_selection__";
        if (col.type === "expand")
          return "__n_expand__";
        return col.key;
      }
      function createShallowClonedObject(object2) {
        if (!object2)
          return object2;
        if (typeof object2 === "object") {
          return Object.assign({}, object2);
        }
        return object2;
      }
      function getFlagOfOrder(order) {
        if (order === "ascend")
          return 1;
        else if (order === "descend")
          return -1;
        return 0;
      }
      function clampValueFollowCSSRules(value, min, max) {
        if (max !== void 0) {
          value = Math.min(value, typeof max === "number" ? max : parseFloat(max));
        }
        if (min !== void 0) {
          value = Math.max(value, typeof min === "number" ? min : parseFloat(min));
        }
        return value;
      }
      function createCustomWidthStyle(column, resizedWidth) {
        if (resizedWidth !== void 0) {
          return {
            width: resizedWidth,
            minWidth: resizedWidth,
            maxWidth: resizedWidth
          };
        }
        const width = getStringColWidth(column);
        const { minWidth, maxWidth } = column;
        return {
          width,
          minWidth: formatLength(minWidth) || width,
          maxWidth: formatLength(maxWidth)
        };
      }
      function createRowClassName(row, index, rowClassName) {
        if (typeof rowClassName === "function")
          return rowClassName(row, index);
        return rowClassName || "";
      }
      function shouldUseArrayInSingleMode(column) {
        return column.filterOptionValues !== void 0 || column.filterOptionValue === void 0 && column.defaultFilterOptionValues !== void 0;
      }
      function isColumnSortable(column) {
        if ("children" in column)
          return false;
        return !!column.sorter;
      }
      function isColumnResizable(column) {
        if ("children" in column && !!column.children.length)
          return false;
        return !!column.resizable;
      }
      function isColumnFilterable(column) {
        if ("children" in column)
          return false;
        return !!column.filter && (!!column.filterOptions || !!column.renderFilterMenu);
      }
      function getNextOrderOf(order) {
        if (!order)
          return "descend";
        else if (order === "descend")
          return "ascend";
        return false;
      }
      function createNextSorter(column, currentSortState) {
        if (column.sorter === void 0)
          return null;
        if (currentSortState === null || currentSortState.columnKey !== column.key) {
          return {
            columnKey: column.key,
            sorter: column.sorter,
            order: getNextOrderOf(false)
          };
        } else {
          return Object.assign(Object.assign({}, currentSortState), { order: getNextOrderOf(currentSortState.order) });
        }
      }
      function isColumnSorting(column, mergedSortState) {
        return mergedSortState.find((state) => state.columnKey === column.key && state.order) !== void 0;
      }
      const NDataTableFilterMenu = vue.defineComponent({
        name: "DataTableFilterMenu",
        props: {
          column: {
            type: Object,
            required: true
          },
          radioGroupName: {
            type: String,
            required: true
          },
          multiple: {
            type: Boolean,
            required: true
          },
          value: {
            type: [Array, String, Number],
            default: null
          },
          options: {
            type: Array,
            required: true
          },
          onConfirm: {
            type: Function,
            required: true
          },
          onClear: {
            type: Function,
            required: true
          },
          onChange: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            localeRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          const temporalValueRef = vue.ref(props.value);
          const checkboxGroupValueRef = vue.computed(() => {
            const { value: temporalValue } = temporalValueRef;
            if (!Array.isArray(temporalValue))
              return null;
            return temporalValue;
          });
          const radioGroupValueRef = vue.computed(() => {
            const { value: temporalValue } = temporalValueRef;
            if (shouldUseArrayInSingleMode(props.column)) {
              return Array.isArray(temporalValue) && temporalValue.length && temporalValue[0] || null;
            }
            if (!Array.isArray(temporalValue))
              return temporalValue;
            return null;
          });
          function doChange(value) {
            props.onChange(value);
          }
          function handleChange(value) {
            if (props.multiple && Array.isArray(value)) {
              temporalValueRef.value = value;
            } else if (shouldUseArrayInSingleMode(props.column) && !Array.isArray(value)) {
              temporalValueRef.value = [value];
            } else {
              temporalValueRef.value = value;
            }
          }
          function handleConfirmClick() {
            doChange(temporalValueRef.value);
            props.onConfirm();
          }
          function handleClearClick() {
            if (props.multiple || shouldUseArrayInSingleMode(props.column)) {
              doChange([]);
            } else {
              doChange(null);
            }
            props.onClear();
          }
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            locale: localeRef,
            checkboxGroupValue: checkboxGroupValueRef,
            radioGroupValue: radioGroupValueRef,
            handleChange,
            handleConfirmClick,
            handleClearClick
          };
        },
        render() {
          const { mergedTheme, locale: locale2, mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-data-table-filter-menu` },
            vue.h(NScrollbar, null, {
              default: () => {
                const { checkboxGroupValue, handleChange } = this;
                return this.multiple ? vue.h(NCheckboxGroup, { value: checkboxGroupValue, class: `${mergedClsPrefix}-data-table-filter-menu__group`, onUpdateValue: handleChange }, {
                  default: () => this.options.map((option) => {
                    return vue.h(NCheckbox, { key: option.value, theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, value: option.value }, { default: () => option.label });
                  })
                }) : vue.h(NRadioGroup, { name: this.radioGroupName, class: `${mergedClsPrefix}-data-table-filter-menu__group`, value: this.radioGroupValue, onUpdateValue: this.handleChange }, {
                  default: () => this.options.map((option) => vue.h(NRadio, { key: option.value, value: option.value, theme: mergedTheme.peers.Radio, themeOverrides: mergedTheme.peerOverrides.Radio }, { default: () => option.label }))
                });
              }
            }),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-data-table-filter-menu__action` },
              vue.h(NButton, { size: "tiny", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleClearClick }, { default: () => locale2.clear }),
              vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, type: "primary", size: "tiny", onClick: this.handleConfirmClick }, { default: () => locale2.confirm })
            )
          );
        }
      });
      function createFilterState(currentFilterState, columnKey, mergedFilterValue) {
        const nextFilterState = Object.assign({}, currentFilterState);
        nextFilterState[columnKey] = mergedFilterValue;
        return nextFilterState;
      }
      const FilterButton = vue.defineComponent({
        name: "DataTableFilterButton",
        props: {
          column: {
            type: Object,
            required: true
          },
          options: {
            type: Array,
            default: () => []
          }
        },
        setup(props) {
          const { mergedComponentPropsRef } = useConfig();
          const {
            mergedThemeRef,
            mergedClsPrefixRef,
            mergedFilterStateRef,
            filterMenuCssVarsRef,
            paginationBehaviorOnFilterRef,
            doUpdatePage,
            doUpdateFilters
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          const showPopoverRef = vue.ref(false);
          const filterStateRef = mergedFilterStateRef;
          const filterMultipleRef = vue.computed(() => {
            return props.column.filterMultiple !== false;
          });
          const mergedFilterValueRef = vue.computed(() => {
            const filterValue = filterStateRef.value[props.column.key];
            if (filterValue === void 0) {
              const { value: multiple } = filterMultipleRef;
              if (multiple)
                return [];
              else
                return null;
            }
            return filterValue;
          });
          const activeRef = vue.computed(() => {
            const { value: filterValue } = mergedFilterValueRef;
            if (Array.isArray(filterValue)) {
              return filterValue.length > 0;
            }
            return filterValue !== null;
          });
          const mergedRenderFilterRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderFilter) || props.column.renderFilter;
          });
          function handleFilterChange(mergedFilterValue) {
            const nextFilterState = createFilterState(filterStateRef.value, props.column.key, mergedFilterValue);
            doUpdateFilters(nextFilterState, props.column);
            if (paginationBehaviorOnFilterRef.value === "first") {
              doUpdatePage(1);
            }
          }
          function handleFilterMenuCancel() {
            showPopoverRef.value = false;
          }
          function handleFilterMenuConfirm() {
            showPopoverRef.value = false;
          }
          return {
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            active: activeRef,
            showPopover: showPopoverRef,
            mergedRenderFilter: mergedRenderFilterRef,
            filterMultiple: filterMultipleRef,
            mergedFilterValue: mergedFilterValueRef,
            filterMenuCssVars: filterMenuCssVarsRef,
            handleFilterChange,
            handleFilterMenuConfirm,
            handleFilterMenuCancel
          };
        },
        render() {
          const { mergedTheme, mergedClsPrefix, handleFilterMenuCancel } = this;
          return vue.h(NPopover, { show: this.showPopover, onUpdateShow: (v) => this.showPopover = v, trigger: "click", theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, placement: "bottom", style: { padding: 0 } }, {
            trigger: () => {
              const { mergedRenderFilter } = this;
              if (mergedRenderFilter) {
                return vue.h(RenderFilter, { "data-data-table-filter": true, render: mergedRenderFilter, active: this.active, show: this.showPopover });
              }
              const { renderFilterIcon } = this.column;
              return vue.h("div", { "data-data-table-filter": true, class: [
                `${mergedClsPrefix}-data-table-filter`,
                {
                  [`${mergedClsPrefix}-data-table-filter--active`]: this.active,
                  [`${mergedClsPrefix}-data-table-filter--show`]: this.showPopover
                }
              ] }, renderFilterIcon ? renderFilterIcon({
                active: this.active,
                show: this.showPopover
              }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(FilterIcon, null) }));
            },
            default: () => {
              const { renderFilterMenu } = this.column;
              return renderFilterMenu ? renderFilterMenu({ hide: handleFilterMenuCancel }) : vue.h(NDataTableFilterMenu, { style: this.filterMenuCssVars, radioGroupName: String(this.column.key), multiple: this.filterMultiple, value: this.mergedFilterValue, options: this.options, column: this.column, onChange: this.handleFilterChange, onClear: this.handleFilterMenuCancel, onConfirm: this.handleFilterMenuConfirm });
            }
          });
        }
      });
      const ResizeButton = vue.defineComponent({
        name: "ColumnResizeButton",
        props: {
          onResizeStart: Function,
          onResize: Function,
          onResizeEnd: Function
        },
        setup(props) {
          const { mergedClsPrefixRef } = vue.inject(dataTableInjectionKey);
          const activeRef = vue.ref(false);
          let startX = 0;
          function getMouseX(e) {
            return e.clientX;
          }
          function handleMousedown(e) {
            var _a;
            const alreadyStarted = activeRef.value;
            startX = getMouseX(e);
            activeRef.value = true;
            if (!alreadyStarted) {
              on("mousemove", window, handleMousemove);
              on("mouseup", window, handleMouseup);
              (_a = props.onResizeStart) === null || _a === void 0 ? void 0 : _a.call(props);
            }
          }
          function handleMousemove(e) {
            var _a;
            (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, getMouseX(e) - startX);
          }
          function handleMouseup() {
            var _a;
            activeRef.value = false;
            (_a = props.onResizeEnd) === null || _a === void 0 ? void 0 : _a.call(props);
            off("mousemove", window, handleMousemove);
            off("mouseup", window, handleMouseup);
          }
          vue.onBeforeUnmount(() => {
            off("mousemove", window, handleMousemove);
            off("mouseup", window, handleMouseup);
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            active: activeRef,
            handleMousedown
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h("span", { "data-data-table-resizable": true, class: [
            `${mergedClsPrefix}-data-table-resize-button`,
            this.active && `${mergedClsPrefix}-data-table-resize-button--active`
          ], onMousedown: this.handleMousedown });
        }
      });
      const NDropdownDivider = vue.defineComponent({
        name: "DropdownDivider",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        render() {
          return vue.h("div", { class: `${this.clsPrefix}-dropdown-divider` });
        }
      });
      const self$J = (vars) => {
        const { textColorBase, opacity1, opacity2, opacity3, opacity4, opacity5 } = vars;
        return {
          color: textColorBase,
          opacity1Depth: opacity1,
          opacity2Depth: opacity2,
          opacity3Depth: opacity3,
          opacity4Depth: opacity4,
          opacity5Depth: opacity5
        };
      };
      const iconLight = {
        name: "Icon",
        common: commonLight,
        self: self$J
      };
      const iconLight$1 = iconLight;
      const iconDark$1 = {
        name: "Icon",
        common: commonDark,
        self: self$J
      };
      const iconDark$2 = iconDark$1;
      const style$V = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM("color-transition", {
        transition: "color .3s var(--n-bezier)"
      }), cM("depth", {
        color: "var(--n-color)"
      }, [c$1("svg", {
        opacity: "var(--n-opacity)",
        transition: "opacity .3s var(--n-bezier)"
      })]), c$1("svg", {
        height: "1em",
        width: "1em"
      })]);
      const iconProps = Object.assign(Object.assign({}, useTheme.props), { depth: [String, Number], size: [Number, String], color: String, component: Object });
      const NIcon = vue.defineComponent({
        _n_icon__: true,
        name: "Icon",
        inheritAttrs: false,
        props: iconProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Icon", "-icon", style$V, iconLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { depth } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            if (depth !== void 0) {
              const { color, [`opacity${depth}Depth`]: opacity } = self2;
              return {
                "--n-bezier": cubicBezierEaseInOut2,
                "--n-color": color,
                "--n-opacity": opacity
              };
            }
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": "",
              "--n-opacity": ""
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", vue.computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedStyle: vue.computed(() => {
              const { size: size2, color } = props;
              return {
                fontSize: formatLength(size2),
                color
              };
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { $parent, depth, mergedClsPrefix, component, onRender, themeClass } = this;
          if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
            warn$2("icon", "don't wrap `n-icon` inside `n-icon`");
          }
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("i", vue.mergeProps(this.$attrs, {
            role: "img",
            class: [
              `${mergedClsPrefix}-icon`,
              themeClass,
              {
                [`${mergedClsPrefix}-icon--depth`]: depth,
                [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
              }
            ],
            style: [this.cssVars, this.mergedStyle]
          }), component ? vue.h(component) : this.$slots);
        }
      });
      const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
      const dropdownInjectionKey = createInjectionKey("n-dropdown");
      const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
      function isSubmenuNode(rawNode, childrenField) {
        return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
      }
      function isGroupNode(rawNode) {
        return rawNode.type === "group";
      }
      function isDividerNode$1(rawNode) {
        return rawNode.type === "divider";
      }
      function isRenderNode(rawNode) {
        return rawNode.type === "render";
      }
      const NDropdownOption = vue.defineComponent({
        name: "DropdownOption",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          },
          parentKey: {
            type: [String, Number],
            default: null
          },
          placement: {
            type: String,
            default: "right-start"
          },
          props: Object,
          scrollable: Boolean
        },
        setup(props) {
          const NDropdown2 = vue.inject(dropdownInjectionKey);
          const { hoverKeyRef, keyboardKeyRef, lastToggledSubmenuKeyRef, pendingKeyPathRef, activeKeyPathRef, animatedRef, mergedShowRef, renderLabelRef, renderIconRef, labelFieldRef, childrenFieldRef, renderOptionRef, nodePropsRef, menuPropsRef } = NDropdown2;
          const NDropdownOption2 = vue.inject(dropdownOptionInjectionKey, null);
          const NDropdownMenu2 = vue.inject(dropdownMenuInjectionKey);
          const NPopoverBody2 = vue.inject(popoverBodyInjectionKey);
          const rawNodeRef = vue.computed(() => props.tmNode.rawNode);
          const hasSubmenuRef = vue.computed(() => {
            const { value: childrenField } = childrenFieldRef;
            return isSubmenuNode(props.tmNode.rawNode, childrenField);
          });
          const mergedDisabledRef = vue.computed(() => {
            const { disabled } = props.tmNode;
            return disabled;
          });
          const showSubmenuRef = vue.computed(() => {
            if (!hasSubmenuRef.value)
              return false;
            const { key, disabled } = props.tmNode;
            if (disabled)
              return false;
            const { value: hoverKey } = hoverKeyRef;
            const { value: keyboardKey } = keyboardKeyRef;
            const { value: lastToggledSubmenuKey } = lastToggledSubmenuKeyRef;
            const { value: pendingKeyPath } = pendingKeyPathRef;
            if (hoverKey !== null)
              return pendingKeyPath.includes(key);
            if (keyboardKey !== null) {
              return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
            }
            if (lastToggledSubmenuKey !== null)
              return pendingKeyPath.includes(key);
            return false;
          });
          const shouldDelayRef = vue.computed(() => {
            return keyboardKeyRef.value === null && !animatedRef.value;
          });
          const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
          const parentEnteringSubmenuRef = vue.computed(() => {
            return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
          });
          const enteringSubmenuRef = vue.ref(false);
          vue.provide(dropdownOptionInjectionKey, {
            enteringSubmenuRef
          });
          function handleSubmenuBeforeEnter() {
            enteringSubmenuRef.value = true;
          }
          function handleSubmenuAfterEnter() {
            enteringSubmenuRef.value = false;
          }
          function handleMouseEnter() {
            const { parentKey, tmNode } = props;
            if (tmNode.disabled)
              return;
            if (!mergedShowRef.value)
              return;
            lastToggledSubmenuKeyRef.value = parentKey;
            keyboardKeyRef.value = null;
            hoverKeyRef.value = tmNode.key;
          }
          function handleMouseMove() {
            const { tmNode } = props;
            if (tmNode.disabled)
              return;
            if (!mergedShowRef.value)
              return;
            if (hoverKeyRef.value === tmNode.key)
              return;
            handleMouseEnter();
          }
          function handleMouseLeave(e) {
            if (props.tmNode.disabled)
              return;
            if (!mergedShowRef.value)
              return;
            const { relatedTarget } = e;
            if (relatedTarget && !happensIn({ target: relatedTarget }, "dropdownOption") && !happensIn({ target: relatedTarget }, "scrollbarRail")) {
              hoverKeyRef.value = null;
            }
          }
          function handleClick2() {
            const { value: hasSubmenu } = hasSubmenuRef;
            const { tmNode } = props;
            if (!mergedShowRef.value)
              return;
            if (!hasSubmenu && !tmNode.disabled) {
              NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
              NDropdown2.doUpdateShow(false);
            }
          }
          return {
            labelField: labelFieldRef,
            renderLabel: renderLabelRef,
            renderIcon: renderIconRef,
            siblingHasIcon: NDropdownMenu2.showIconRef,
            siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
            menuProps: menuPropsRef,
            popoverBody: NPopoverBody2,
            animated: animatedRef,
            mergedShowSubmenu: vue.computed(() => {
              return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
            }),
            rawNode: rawNodeRef,
            hasSubmenu: hasSubmenuRef,
            pending: useMemo(() => {
              const { value: pendingKeyPath } = pendingKeyPathRef;
              const { key } = props.tmNode;
              return pendingKeyPath.includes(key);
            }),
            childActive: useMemo(() => {
              const { value: activeKeyPath } = activeKeyPathRef;
              const { key } = props.tmNode;
              const index = activeKeyPath.findIndex((k) => key === k);
              if (index === -1)
                return false;
              return index < activeKeyPath.length - 1;
            }),
            active: useMemo(() => {
              const { value: activeKeyPath } = activeKeyPathRef;
              const { key } = props.tmNode;
              const index = activeKeyPath.findIndex((k) => key === k);
              if (index === -1)
                return false;
              return index === activeKeyPath.length - 1;
            }),
            mergedDisabled: mergedDisabledRef,
            renderOption: renderOptionRef,
            nodeProps: nodePropsRef,
            handleClick: handleClick2,
            handleMouseMove,
            handleMouseEnter,
            handleMouseLeave,
            handleSubmenuBeforeEnter,
            handleSubmenuAfterEnter
          };
        },
        render() {
          var _a, _b;
          const { animated, rawNode, mergedShowSubmenu, clsPrefix, siblingHasIcon, siblingHasSubmenu, renderLabel, renderIcon, renderOption, nodeProps, props, scrollable } = this;
          let submenuVNode = null;
          if (mergedShowSubmenu) {
            const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(
              this,
              rawNode,
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              rawNode.children
            );
            submenuVNode = vue.h(NDropdownMenu, Object.assign({}, submenuNodeProps, { clsPrefix, scrollable: this.scrollable, tmNodes: this.tmNode.children, parentKey: this.tmNode.key }));
          }
          const builtinProps = {
            class: [
              `${clsPrefix}-dropdown-option-body`,
              this.pending && `${clsPrefix}-dropdown-option-body--pending`,
              this.active && `${clsPrefix}-dropdown-option-body--active`,
              this.childActive && `${clsPrefix}-dropdown-option-body--child-active`,
              this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`
            ],
            onMousemove: this.handleMouseMove,
            onMouseenter: this.handleMouseEnter,
            onMouseleave: this.handleMouseLeave,
            onClick: this.handleClick
          };
          const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const node = vue.h(
            "div",
            Object.assign({ class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class], "data-dropdown-option": true }, optionNodeProps),
            vue.h("div", vue.mergeProps(builtinProps, props), [
              vue.h("div", { class: [
                `${clsPrefix}-dropdown-option-body__prefix`,
                siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
              ] }, [renderIcon ? renderIcon(rawNode) : render$1(rawNode.icon)]),
              vue.h("div", { "data-dropdown-option": true, class: `${clsPrefix}-dropdown-option-body__label` }, renderLabel ? renderLabel(rawNode) : render$1((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)),
              vue.h("div", { "data-dropdown-option": true, class: [
                `${clsPrefix}-dropdown-option-body__suffix`,
                siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
              ] }, this.hasSubmenu ? vue.h(NIcon, null, {
                default: () => vue.h(ChevronRightIcon, null)
              }) : null)
            ]),
            this.hasSubmenu ? vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h(
                    "div",
                    { class: `${clsPrefix}-dropdown-offset-container` },
                    vue.h(VFollower, { show: this.mergedShowSubmenu, placement: this.placement, to: scrollable ? this.popoverBody || void 0 : void 0, teleportDisabled: !scrollable }, {
                      default: () => {
                        return vue.h("div", { class: `${clsPrefix}-dropdown-menu-wrapper` }, animated ? vue.h(vue.Transition, { onBeforeEnter: this.handleSubmenuBeforeEnter, onAfterEnter: this.handleSubmenuAfterEnter, name: "fade-in-scale-up-transition", appear: true }, {
                          default: () => submenuVNode
                        }) : submenuVNode);
                      }
                    })
                  )
                })
              ]
            }) : null
          );
          if (renderOption) {
            return renderOption({ node, option: rawNode });
          }
          return node;
        }
      });
      const NDropdownGroupHeader = vue.defineComponent({
        name: "DropdownGroupHeader",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup() {
          const {
            showIconRef,
            hasSubmenuRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dropdownMenuInjectionKey);
          const { renderLabelRef, labelFieldRef, nodePropsRef, renderOptionRef } = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            vue.inject(dropdownInjectionKey)
          );
          return {
            labelField: labelFieldRef,
            showIcon: showIconRef,
            hasSubmenu: hasSubmenuRef,
            renderLabel: renderLabelRef,
            nodeProps: nodePropsRef,
            renderOption: renderOptionRef
          };
        },
        render() {
          var _a;
          const { clsPrefix, hasSubmenu, showIcon, nodeProps, renderLabel, renderOption } = this;
          const { rawNode } = this.tmNode;
          const node = vue.h(
            "div",
            Object.assign({ class: `${clsPrefix}-dropdown-option` }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)),
            vue.h(
              "div",
              { class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group` },
              vue.h("div", { "data-dropdown-option": true, class: [
                `${clsPrefix}-dropdown-option-body__prefix`,
                showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
              ] }, render$1(rawNode.icon)),
              vue.h("div", { class: `${clsPrefix}-dropdown-option-body__label`, "data-dropdown-option": true }, renderLabel ? renderLabel(rawNode) : render$1((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])),
              vue.h("div", { class: [
                `${clsPrefix}-dropdown-option-body__suffix`,
                hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
              ], "data-dropdown-option": true })
            )
          );
          if (renderOption) {
            return renderOption({ node, option: rawNode });
          }
          return node;
        }
      });
      const NDropdownGroup = vue.defineComponent({
        name: "NDropdownGroup",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          },
          parentKey: {
            type: [String, Number],
            default: null
          }
        },
        render() {
          const { tmNode, parentKey, clsPrefix } = this;
          const { children } = tmNode;
          return vue.h(
            vue.Fragment,
            null,
            vue.h(NDropdownGroupHeader, { clsPrefix, tmNode, key: tmNode.key }),
            children === null || children === void 0 ? void 0 : children.map((child) => {
              const { rawNode } = child;
              if (rawNode.show === false)
                return null;
              if (isDividerNode$1(rawNode)) {
                return vue.h(NDropdownDivider, {
                  clsPrefix,
                  key: child.key
                });
              }
              if (child.isGroup) {
                warn$2("dropdown", "`group` node is not allowed to be put in `group` node.");
                return null;
              }
              return vue.h(NDropdownOption, { clsPrefix, tmNode: child, parentKey, key: child.key });
            })
          );
        }
      });
      const NDropdownRenderOption = vue.defineComponent({
        name: "DropdownRenderOption",
        props: {
          tmNode: {
            type: Object,
            required: true
          }
        },
        render() {
          const { rawNode: { render: render2, props } } = this.tmNode;
          return vue.h("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
        }
      });
      const NDropdownMenu = vue.defineComponent({
        name: "DropdownMenu",
        props: {
          scrollable: Boolean,
          showArrow: Boolean,
          arrowStyle: [String, Object],
          clsPrefix: {
            type: String,
            required: true
          },
          tmNodes: {
            type: Array,
            default: () => []
          },
          parentKey: {
            type: [String, Number],
            default: null
          }
        },
        setup(props) {
          const { renderIconRef, childrenFieldRef } = vue.inject(dropdownInjectionKey);
          vue.provide(dropdownMenuInjectionKey, {
            showIconRef: vue.computed(() => {
              const renderIcon = renderIconRef.value;
              return props.tmNodes.some((tmNode) => {
                var _a;
                if (tmNode.isGroup) {
                  return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({ rawNode: rawChild }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
                }
                const { rawNode } = tmNode;
                return renderIcon ? renderIcon(rawNode) : rawNode.icon;
              });
            }),
            hasSubmenuRef: vue.computed(() => {
              const { value: childrenField } = childrenFieldRef;
              return props.tmNodes.some((tmNode) => {
                var _a;
                if (tmNode.isGroup) {
                  return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({ rawNode: rawChild }) => isSubmenuNode(rawChild, childrenField));
                }
                const { rawNode } = tmNode;
                return isSubmenuNode(rawNode, childrenField);
              });
            })
          });
          const bodyRef = vue.ref(null);
          vue.provide(modalBodyInjectionKey, null);
          vue.provide(drawerBodyInjectionKey, null);
          vue.provide(popoverBodyInjectionKey, bodyRef);
          return {
            bodyRef
          };
        },
        render() {
          const { parentKey, clsPrefix, scrollable } = this;
          const menuOptionsNode = this.tmNodes.map((tmNode) => {
            const { rawNode } = tmNode;
            if (rawNode.show === false)
              return null;
            if (isRenderNode(rawNode)) {
              return vue.h(NDropdownRenderOption, { tmNode, key: tmNode.key });
            }
            if (isDividerNode$1(rawNode)) {
              return vue.h(NDropdownDivider, { clsPrefix, key: tmNode.key });
            }
            if (isGroupNode(rawNode)) {
              return vue.h(NDropdownGroup, { clsPrefix, tmNode, parentKey, key: tmNode.key });
            }
            return vue.h(NDropdownOption, { clsPrefix, tmNode, parentKey, key: tmNode.key, props: rawNode.props, scrollable });
          });
          return vue.h(
            "div",
            { class: [
              `${clsPrefix}-dropdown-menu`,
              scrollable && `${clsPrefix}-dropdown-menu--scrollable`
            ], ref: "bodyRef" },
            scrollable ? vue.h(XScrollbar, { contentClass: `${clsPrefix}-dropdown-menu__content` }, {
              default: () => menuOptionsNode
            }) : menuOptionsNode,
            this.showArrow ? renderArrow({
              clsPrefix,
              arrowStyle: this.arrowStyle
            }) : null
          );
        }
      });
      const style$U = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
      const dropdownBaseProps = {
        animated: {
          type: Boolean,
          default: true
        },
        keyboard: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          default: "medium"
        },
        inverted: Boolean,
        placement: {
          type: String,
          default: "bottom"
        },
        onSelect: [Function, Array],
        options: {
          type: Array,
          default: () => []
        },
        menuProps: Function,
        showArrow: Boolean,
        renderLabel: Function,
        renderIcon: Function,
        renderOption: Function,
        nodeProps: Function,
        labelField: {
          type: String,
          default: "label"
        },
        keyField: {
          type: String,
          default: "key"
        },
        childrenField: {
          type: String,
          default: "children"
        },
        // for menu, not documented
        value: [String, Number]
      };
      const popoverPropKeys = Object.keys(popoverBaseProps);
      const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
      const NDropdown = vue.defineComponent({
        name: "Dropdown",
        inheritAttrs: false,
        props: dropdownProps,
        setup(props) {
          const uncontrolledShowRef = vue.ref(false);
          const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
          const treemateRef = vue.computed(() => {
            const { keyField, childrenField } = props;
            return createTreeMate(props.options, {
              getKey(node) {
                return node[keyField];
              },
              getDisabled(node) {
                return node.disabled === true;
              },
              getIgnored(node) {
                return node.type === "divider" || node.type === "render";
              },
              getChildren(node) {
                return node[childrenField];
              }
            });
          });
          const tmNodesRef = vue.computed(() => {
            return treemateRef.value.treeNodes;
          });
          const hoverKeyRef = vue.ref(null);
          const keyboardKeyRef = vue.ref(null);
          const lastToggledSubmenuKeyRef = vue.ref(null);
          const pendingKeyRef = vue.computed(() => {
            var _a, _b, _c;
            return (_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
          });
          const pendingKeyPathRef = vue.computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
          const activeKeyPathRef = vue.computed(() => treemateRef.value.getPath(props.value).keyPath);
          const keyboardEnabledRef = useMemo(() => {
            return props.keyboard && mergedShowRef.value;
          });
          useKeyboard$1({
            keydown: {
              ArrowUp: {
                prevent: true,
                handler: handleKeydownUp
              },
              ArrowRight: {
                prevent: true,
                handler: handleKeydownRight
              },
              ArrowDown: {
                prevent: true,
                handler: handleKeydownDown
              },
              ArrowLeft: {
                prevent: true,
                handler: handleKeydownLeft
              },
              Enter: {
                prevent: true,
                handler: handleKeydownEnter
              },
              Escape: handleKeydownEsc
            }
          }, keyboardEnabledRef);
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Dropdown", "-dropdown", style$U, dropdownLight$1, props, mergedClsPrefixRef);
          vue.provide(dropdownInjectionKey, {
            labelFieldRef: vue.toRef(props, "labelField"),
            childrenFieldRef: vue.toRef(props, "childrenField"),
            renderLabelRef: vue.toRef(props, "renderLabel"),
            renderIconRef: vue.toRef(props, "renderIcon"),
            hoverKeyRef,
            keyboardKeyRef,
            lastToggledSubmenuKeyRef,
            pendingKeyPathRef,
            activeKeyPathRef,
            animatedRef: vue.toRef(props, "animated"),
            mergedShowRef,
            nodePropsRef: vue.toRef(props, "nodeProps"),
            renderOptionRef: vue.toRef(props, "renderOption"),
            menuPropsRef: vue.toRef(props, "menuProps"),
            doSelect,
            doUpdateShow
          });
          vue.watch(mergedShowRef, (value) => {
            if (!props.animated && !value) {
              clearPendingState();
            }
          });
          function doSelect(key, node) {
            const { onSelect } = props;
            if (onSelect)
              call(onSelect, key, node);
          }
          function doUpdateShow(value) {
            const { "onUpdate:show": _onUpdateShow, onUpdateShow } = props;
            if (_onUpdateShow)
              call(_onUpdateShow, value);
            if (onUpdateShow)
              call(onUpdateShow, value);
            uncontrolledShowRef.value = value;
          }
          function clearPendingState() {
            hoverKeyRef.value = null;
            keyboardKeyRef.value = null;
            lastToggledSubmenuKeyRef.value = null;
          }
          function handleKeydownEsc() {
            doUpdateShow(false);
          }
          function handleKeydownLeft() {
            handleKeydown("left");
          }
          function handleKeydownRight() {
            handleKeydown("right");
          }
          function handleKeydownUp() {
            handleKeydown("up");
          }
          function handleKeydownDown() {
            handleKeydown("down");
          }
          function handleKeydownEnter() {
            const pendingNode = getPendingNode();
            if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
              doSelect(pendingNode.key, pendingNode.rawNode);
              doUpdateShow(false);
            }
          }
          function getPendingNode() {
            var _a;
            const { value: treeMate } = treemateRef;
            const { value: pendingKey } = pendingKeyRef;
            if (!treeMate || pendingKey === null)
              return null;
            return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
          }
          function handleKeydown(direction) {
            const { value: pendingKey } = pendingKeyRef;
            const { value: { getFirstAvailableNode: getFirstAvailableNode2 } } = treemateRef;
            let nextKeyboardKey = null;
            if (pendingKey === null) {
              const firstNode = getFirstAvailableNode2();
              if (firstNode !== null) {
                nextKeyboardKey = firstNode.key;
              }
            } else {
              const currentNode = getPendingNode();
              if (currentNode) {
                let nextNode;
                switch (direction) {
                  case "down":
                    nextNode = currentNode.getNext();
                    break;
                  case "up":
                    nextNode = currentNode.getPrev();
                    break;
                  case "right":
                    nextNode = currentNode.getChild();
                    break;
                  case "left":
                    nextNode = currentNode.getParent();
                    break;
                }
                if (nextNode)
                  nextKeyboardKey = nextNode.key;
              }
            }
            if (nextKeyboardKey !== null) {
              hoverKeyRef.value = null;
              keyboardKeyRef.value = nextKeyboardKey;
            }
          }
          const cssVarsRef = vue.computed(() => {
            const { size: size2, inverted } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const { padding, dividerColor, borderRadius, optionOpacityDisabled, [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth, [createKey("optionSuffixWidth", size2)]: optionSuffixWidth, [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth, [createKey("optionPrefixWidth", size2)]: optionPrefixWidth, [createKey("fontSize", size2)]: fontSize2, [createKey("optionHeight", size2)]: optionHeight, [createKey("optionIconSize", size2)]: optionIconSize } = self2;
            const vars = {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-padding": padding,
              "--n-border-radius": borderRadius,
              "--n-option-height": optionHeight,
              "--n-option-prefix-width": optionPrefixWidth,
              "--n-option-icon-prefix-width": optionIconPrefixWidth,
              "--n-option-suffix-width": optionSuffixWidth,
              "--n-option-icon-suffix-width": optionIconSuffixWidth,
              "--n-option-icon-size": optionIconSize,
              "--n-divider-color": dividerColor,
              "--n-option-opacity-disabled": optionOpacityDisabled
            };
            if (inverted) {
              vars["--n-color"] = self2.colorInverted;
              vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
              vars["--n-option-color-active"] = self2.optionColorActiveInverted;
              vars["--n-option-text-color"] = self2.optionTextColorInverted;
              vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
              vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
              vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
              vars["--n-prefix-color"] = self2.prefixColorInverted;
              vars["--n-suffix-color"] = self2.suffixColorInverted;
              vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
            } else {
              vars["--n-color"] = self2.color;
              vars["--n-option-color-hover"] = self2.optionColorHover;
              vars["--n-option-color-active"] = self2.optionColorActive;
              vars["--n-option-text-color"] = self2.optionTextColor;
              vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
              vars["--n-option-text-color-active"] = self2.optionTextColorActive;
              vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
              vars["--n-prefix-color"] = self2.prefixColor;
              vars["--n-suffix-color"] = self2.suffixColor;
              vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
            }
            return vars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", vue.computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
            // data
            tmNodes: tmNodesRef,
            // show
            mergedShow: mergedShowRef,
            // methods
            handleAfterLeave: () => {
              if (!props.animated)
                return;
              clearPendingState();
            },
            doUpdateShow,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
            var _a;
            const { mergedClsPrefix, menuProps: menuProps2 } = this;
            (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
            const menuNodeProps = (menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
            const dropdownProps2 = {
              ref: createRefSetter(ref2),
              class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
              clsPrefix: mergedClsPrefix,
              tmNodes: this.tmNodes,
              style: [style2, this.cssVars],
              showArrow: this.showArrow,
              arrowStyle: this.arrowStyle,
              scrollable: this.scrollable,
              onMouseenter,
              onMouseleave
            };
            return vue.h(NDropdownMenu, vue.mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
          };
          const { mergedTheme } = this;
          const popoverProps2 = {
            show: this.mergedShow,
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            internalOnAfterLeave: this.handleAfterLeave,
            internalRenderBody: renderPopoverBody,
            onUpdateShow: this.doUpdateShow,
            "onUpdate:show": void 0
          };
          return vue.h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
            trigger: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          });
        }
      });
      const allKey = "_n_all__";
      const noneKey = "_n_none__";
      function createSelectHandler(options, rawPaginatedDataRef, doCheckAll, doUncheckAll) {
        if (!options)
          return () => {
          };
        return (key) => {
          for (const option of options) {
            switch (key) {
              case allKey:
                doCheckAll(true);
                return;
              case noneKey:
                doUncheckAll(true);
                return;
              default:
                if (typeof option === "object" && option.key === key) {
                  option.onSelect(rawPaginatedDataRef.value);
                  return;
                }
            }
          }
        };
      }
      function createDropdownOptions(options, localeRef) {
        if (!options)
          return [];
        return options.map((option) => {
          switch (option) {
            case "all":
              return {
                label: localeRef.checkTableAll,
                key: allKey
              };
            case "none":
              return {
                label: localeRef.uncheckTableAll,
                key: noneKey
              };
            default:
              return option;
          }
        });
      }
      const SelectionMenu = vue.defineComponent({
        name: "DataTableSelectionMenu",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup(props) {
          const {
            props: dataTableProps2,
            localeRef,
            checkOptionsRef,
            rawPaginatedDataRef,
            doCheckAll,
            doUncheckAll
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          const handleSelectRef = vue.computed(() => createSelectHandler(checkOptionsRef.value, rawPaginatedDataRef, doCheckAll, doUncheckAll));
          const optionsRef = vue.computed(() => createDropdownOptions(checkOptionsRef.value, localeRef.value));
          return () => {
            var _a, _b, _c, _d;
            const { clsPrefix } = props;
            return vue.h(NDropdown, { theme: (_b = (_a = dataTableProps2.theme) === null || _a === void 0 ? void 0 : _a.peers) === null || _b === void 0 ? void 0 : _b.Dropdown, themeOverrides: (_d = (_c = dataTableProps2.themeOverrides) === null || _c === void 0 ? void 0 : _c.peers) === null || _d === void 0 ? void 0 : _d.Dropdown, options: optionsRef.value, onSelect: handleSelectRef.value }, {
              default: () => vue.h(NBaseIcon, { clsPrefix, class: `${clsPrefix}-data-table-check-extra` }, {
                default: () => vue.h(ChevronDownIcon, null)
              })
            });
          };
        }
      });
      function renderTitle(column) {
        return typeof column.title === "function" ? column.title(column) : column.title;
      }
      const TableHeader = vue.defineComponent({
        name: "DataTableHeader",
        props: {
          discrete: {
            type: Boolean,
            default: true
          }
        },
        setup() {
          const {
            mergedClsPrefixRef,
            scrollXRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef,
            mergedCurrentPageRef,
            allRowsCheckedRef,
            someRowsCheckedRef,
            rowsRef,
            colsRef,
            mergedThemeRef,
            checkOptionsRef,
            mergedSortStateRef,
            componentId,
            scrollPartRef,
            mergedTableLayoutRef,
            headerCheckboxDisabledRef,
            onUnstableColumnResize,
            doUpdateResizableWidth,
            handleTableHeaderScroll,
            deriveNextSorter,
            doUncheckAll,
            doCheckAll
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          const cellElsRef = vue.ref({});
          function getCellActualWidth(key) {
            const element = cellElsRef.value[key];
            return element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width;
          }
          function handleCheckboxUpdateChecked() {
            if (allRowsCheckedRef.value) {
              doUncheckAll();
            } else {
              doCheckAll();
            }
          }
          function handleColHeaderClick(e, column) {
            if (happensIn(e, "dataTableFilter") || happensIn(e, "dataTableResizable")) {
              return;
            }
            if (!isColumnSortable(column))
              return;
            const activeSorter = mergedSortStateRef.value.find((state) => state.columnKey === column.key) || null;
            const nextSorter = createNextSorter(column, activeSorter);
            deriveNextSorter(nextSorter);
          }
          function handleMouseenter() {
            scrollPartRef.value = "head";
          }
          function handleMouseleave() {
            scrollPartRef.value = "body";
          }
          const resizeStartWidthMap = /* @__PURE__ */ new Map();
          function handleColumnResizeStart(column) {
            resizeStartWidthMap.set(column.key, getCellActualWidth(column.key));
          }
          function handleColumnResize(column, displacementX) {
            const startWidth = resizeStartWidthMap.get(column.key);
            if (startWidth === void 0) {
              return;
            }
            const widthAfterResize = startWidth + displacementX;
            const limitWidth = clampValueFollowCSSRules(widthAfterResize, column.minWidth, column.maxWidth);
            onUnstableColumnResize(widthAfterResize, limitWidth, column, getCellActualWidth);
            doUpdateResizableWidth(column, limitWidth);
          }
          return {
            cellElsRef,
            componentId,
            mergedSortState: mergedSortStateRef,
            mergedClsPrefix: mergedClsPrefixRef,
            scrollX: scrollXRef,
            fixedColumnLeftMap: fixedColumnLeftMapRef,
            fixedColumnRightMap: fixedColumnRightMapRef,
            currentPage: mergedCurrentPageRef,
            allRowsChecked: allRowsCheckedRef,
            someRowsChecked: someRowsCheckedRef,
            rows: rowsRef,
            cols: colsRef,
            mergedTheme: mergedThemeRef,
            checkOptions: checkOptionsRef,
            mergedTableLayout: mergedTableLayoutRef,
            headerCheckboxDisabled: headerCheckboxDisabledRef,
            handleMouseenter,
            handleMouseleave,
            handleCheckboxUpdateChecked,
            handleColHeaderClick,
            handleTableHeaderScroll,
            handleColumnResizeStart,
            handleColumnResize
          };
        },
        render() {
          const { cellElsRef, mergedClsPrefix, fixedColumnLeftMap, fixedColumnRightMap, currentPage, allRowsChecked, someRowsChecked, rows, cols, mergedTheme, checkOptions, componentId, discrete, mergedTableLayout, headerCheckboxDisabled, mergedSortState, handleColHeaderClick, handleCheckboxUpdateChecked, handleColumnResizeStart, handleColumnResize } = this;
          const theadVNode = vue.h("thead", { class: `${mergedClsPrefix}-data-table-thead`, "data-n-id": componentId }, rows.map((row) => {
            return vue.h("tr", { class: `${mergedClsPrefix}-data-table-tr` }, row.map(({ column, colSpan, rowSpan, isLast }) => {
              var _a, _b;
              const key = getColKey(column);
              const { ellipsis } = column;
              const createColumnVNode = () => {
                if (column.type === "selection") {
                  return column.multiple !== false ? vue.h(
                    vue.Fragment,
                    null,
                    vue.h(NCheckbox, { key: currentPage, privateInsideTable: true, checked: allRowsChecked, indeterminate: someRowsChecked, disabled: headerCheckboxDisabled, onUpdateChecked: handleCheckboxUpdateChecked }),
                    checkOptions ? vue.h(SelectionMenu, { clsPrefix: mergedClsPrefix }) : null
                  ) : null;
                }
                return vue.h(
                  vue.Fragment,
                  null,
                  vue.h(
                    "div",
                    { class: `${mergedClsPrefix}-data-table-th__title-wrapper` },
                    vue.h("div", { class: `${mergedClsPrefix}-data-table-th__title` }, ellipsis === true || ellipsis && !ellipsis.tooltip ? vue.h("div", { class: `${mergedClsPrefix}-data-table-th__ellipsis` }, renderTitle(column)) : ellipsis && typeof ellipsis === "object" ? vue.h(NEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), {
                      default: () => renderTitle(column)
                    }) : renderTitle(column)),
                    isColumnSortable(column) ? vue.h(SortButton, { column }) : null
                  ),
                  isColumnFilterable(column) ? vue.h(FilterButton, { column, options: column.filterOptions }) : null,
                  isColumnResizable(column) ? vue.h(ResizeButton, { onResizeStart: () => {
                    handleColumnResizeStart(column);
                  }, onResize: (displacementX) => {
                    handleColumnResize(column, displacementX);
                  } }) : null
                );
              };
              const leftFixed = key in fixedColumnLeftMap;
              const rightFixed = key in fixedColumnRightMap;
              return vue.h("th", { ref: (el) => cellElsRef[key] = el, key, style: {
                textAlign: column.titleAlign || column.align,
                left: pxfy((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start),
                right: pxfy((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.start)
              }, colspan: colSpan, rowspan: rowSpan, "data-col-key": key, class: [
                `${mergedClsPrefix}-data-table-th`,
                (leftFixed || rightFixed) && `${mergedClsPrefix}-data-table-th--fixed-${leftFixed ? "left" : "right"}`,
                {
                  [`${mergedClsPrefix}-data-table-th--hover`]: isColumnSorting(column, mergedSortState),
                  [`${mergedClsPrefix}-data-table-th--filterable`]: isColumnFilterable(column),
                  [`${mergedClsPrefix}-data-table-th--sortable`]: isColumnSortable(column),
                  [`${mergedClsPrefix}-data-table-th--selection`]: column.type === "selection",
                  [`${mergedClsPrefix}-data-table-th--last`]: isLast
                },
                column.className
              ], onClick: column.type !== "selection" && column.type !== "expand" && !("children" in column) ? (e) => {
                handleColHeaderClick(e, column);
              } : void 0 }, createColumnVNode());
            }));
          }));
          if (!discrete) {
            return theadVNode;
          }
          const { handleTableHeaderScroll, handleMouseenter, handleMouseleave, scrollX } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-data-table-base-table-header`, onScroll: handleTableHeaderScroll, onMouseenter: handleMouseenter, onMouseleave: handleMouseleave },
            vue.h(
              "table",
              { ref: "body", class: `${mergedClsPrefix}-data-table-table`, style: {
                minWidth: formatLength(scrollX),
                tableLayout: mergedTableLayout
              } },
              vue.h("colgroup", null, cols.map((col) => vue.h("col", { key: col.key, style: col.style }))),
              theadVNode
            )
          );
        }
      });
      const Cell = vue.defineComponent({
        name: "DataTableCell",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          row: {
            type: Object,
            required: true
          },
          index: {
            type: Number,
            required: true
          },
          column: {
            type: Object,
            required: true
          },
          isSummary: Boolean,
          mergedTheme: {
            type: Object,
            required: true
          },
          renderCell: Function
        },
        render() {
          const { isSummary, column, row, renderCell } = this;
          let cell;
          const { render: render2, key, ellipsis } = column;
          if (render2 && !isSummary) {
            cell = render2(row, this.index);
          } else {
            if (isSummary) {
              cell = row[key].value;
            } else {
              cell = renderCell ? renderCell(get(row, key), row, column) : get(row, key);
            }
          }
          if (ellipsis) {
            if (typeof ellipsis === "object") {
              const { mergedTheme } = this;
              return vue.h(NEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), { default: () => cell });
            } else {
              return vue.h("span", { class: `${this.clsPrefix}-data-table-td__ellipsis` }, cell);
            }
          }
          return cell;
        }
      });
      const ExpandTrigger = vue.defineComponent({
        name: "DataTableExpandTrigger",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          expanded: Boolean,
          loading: Boolean,
          onClick: {
            type: Function,
            required: true
          },
          renderExpandIcon: {
            type: Function
          }
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: [
              `${clsPrefix}-data-table-expand-trigger`,
              this.expanded && `${clsPrefix}-data-table-expand-trigger--expanded`
            ], onClick: this.onClick },
            vue.h(NIconSwitchTransition, null, {
              default: () => {
                return this.loading ? vue.h(NBaseLoading, { key: "loading", clsPrefix: this.clsPrefix, radius: 85, strokeWidth: 15, scale: 0.88 }) : this.renderExpandIcon ? this.renderExpandIcon({
                  expanded: this.expanded
                }) : vue.h(NBaseIcon, { clsPrefix, key: "base-icon" }, {
                  default: () => vue.h(ChevronRightIcon, null)
                });
              }
            })
          );
        }
      });
      const RenderSafeCheckbox = vue.defineComponent({
        name: "DataTableBodyCheckbox",
        props: {
          rowKey: {
            type: [String, Number],
            required: true
          },
          disabled: {
            type: Boolean,
            required: true
          },
          onUpdateChecked: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            mergedCheckedRowKeySetRef,
            mergedInderminateRowKeySetRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          return () => {
            const { rowKey } = props;
            return vue.h(NCheckbox, { privateInsideTable: true, disabled: props.disabled, indeterminate: mergedInderminateRowKeySetRef.value.has(rowKey), checked: mergedCheckedRowKeySetRef.value.has(rowKey), onUpdateChecked: props.onUpdateChecked });
          };
        }
      });
      const RenderSafeRadio = vue.defineComponent({
        name: "DataTableBodyRadio",
        props: {
          rowKey: {
            type: [String, Number],
            required: true
          },
          disabled: {
            type: Boolean,
            required: true
          },
          onUpdateChecked: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            mergedCheckedRowKeySetRef,
            componentId
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          return () => {
            const { rowKey } = props;
            return vue.h(NRadio, { name: componentId, disabled: props.disabled, checked: mergedCheckedRowKeySetRef.value.has(rowKey), onUpdateChecked: props.onUpdateChecked });
          };
        }
      });
      function flatten(rowInfos, expandedRowKeys) {
        const fRows = [];
        function traverse2(rs, rootIndex) {
          rs.forEach((r) => {
            if (r.children && expandedRowKeys.has(r.key)) {
              fRows.push({
                tmNode: r,
                striped: false,
                key: r.key,
                index: rootIndex
              });
              traverse2(r.children, rootIndex);
            } else {
              fRows.push({
                key: r.key,
                tmNode: r,
                striped: false,
                index: rootIndex
              });
            }
          });
        }
        rowInfos.forEach((rowInfo) => {
          fRows.push(rowInfo);
          const { children } = rowInfo.tmNode;
          if (children && expandedRowKeys.has(rowInfo.key)) {
            traverse2(children, rowInfo.index);
          }
        });
        return fRows;
      }
      const VirtualListItemWrapper = vue.defineComponent({
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          id: {
            type: String,
            required: true
          },
          cols: {
            type: Array,
            required: true
          },
          onMouseenter: Function,
          onMouseleave: Function
        },
        render() {
          const { clsPrefix, id, cols, onMouseenter, onMouseleave } = this;
          return vue.h(
            "table",
            { style: { tableLayout: "fixed" }, class: `${clsPrefix}-data-table-table`, onMouseenter, onMouseleave },
            vue.h("colgroup", null, cols.map((col) => vue.h("col", { key: col.key, style: col.style }))),
            vue.h("tbody", { "data-n-id": id, class: `${clsPrefix}-data-table-tbody` }, this.$slots)
          );
        }
      });
      const TableBody = vue.defineComponent({
        name: "DataTableBody",
        props: {
          onResize: Function,
          showHeader: Boolean,
          flexHeight: Boolean,
          bodyStyle: Object
        },
        setup(props) {
          const {
            slots: dataTableSlots,
            bodyWidthRef,
            mergedExpandedRowKeysRef,
            mergedClsPrefixRef,
            mergedThemeRef,
            scrollXRef,
            colsRef,
            paginatedDataRef,
            rawPaginatedDataRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef,
            mergedCurrentPageRef,
            rowClassNameRef,
            leftActiveFixedColKeyRef,
            leftActiveFixedChildrenColKeysRef,
            rightActiveFixedColKeyRef,
            rightActiveFixedChildrenColKeysRef,
            renderExpandRef,
            hoverKeyRef,
            summaryRef,
            mergedSortStateRef,
            virtualScrollRef,
            componentId,
            scrollPartRef,
            mergedTableLayoutRef,
            childTriggerColIndexRef,
            indentRef,
            rowPropsRef,
            maxHeightRef,
            stripedRef,
            loadingRef,
            onLoadRef,
            loadingKeySetRef,
            expandableRef,
            stickyExpandedRowsRef,
            renderExpandIconRef,
            summaryPlacementRef,
            treeMateRef,
            scrollbarPropsRef,
            setHeaderScrollLeft,
            doUpdateExpandedRowKeys,
            handleTableBodyScroll,
            doCheck,
            doUncheck,
            renderCell
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          const scrollbarInstRef = vue.ref(null);
          const virtualListRef = vue.ref(null);
          const emptyElRef = vue.ref(null);
          const emptyRef = useMemo(() => paginatedDataRef.value.length === 0);
          const shouldDisplaySomeTablePartRef = useMemo(() => props.showHeader || !emptyRef.value);
          const bodyShowHeaderOnlyRef = useMemo(() => {
            return props.showHeader || emptyRef.value;
          });
          let lastSelectedKey = "";
          const mergedExpandedRowKeySetRef = vue.computed(() => {
            return new Set(mergedExpandedRowKeysRef.value);
          });
          function getRowInfo(key) {
            var _a;
            return (_a = treeMateRef.value.getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
          }
          function handleCheckboxUpdateChecked(tmNode, checked, shiftKey) {
            const rowInfo = getRowInfo(tmNode.key);
            if (!rowInfo) {
              warn$2("data-table", `fail to get row data with key ${tmNode.key}`);
              return;
            }
            if (shiftKey) {
              const lastIndex = paginatedDataRef.value.findIndex((item) => item.key === lastSelectedKey);
              if (lastIndex !== -1) {
                const currentIndex = paginatedDataRef.value.findIndex((item) => item.key === tmNode.key);
                const start = Math.min(lastIndex, currentIndex);
                const end = Math.max(lastIndex, currentIndex);
                const rowKeysToCheck = [];
                paginatedDataRef.value.slice(start, end + 1).forEach((r) => {
                  if (!r.disabled) {
                    rowKeysToCheck.push(r.key);
                  }
                });
                if (checked) {
                  doCheck(rowKeysToCheck, false, rowInfo);
                } else {
                  doUncheck(rowKeysToCheck, rowInfo);
                }
                lastSelectedKey = tmNode.key;
                return;
              }
            }
            if (checked) {
              doCheck(tmNode.key, false, rowInfo);
            } else {
              doUncheck(tmNode.key, rowInfo);
            }
            lastSelectedKey = tmNode.key;
          }
          function handleRadioUpdateChecked(tmNode) {
            const rowInfo = getRowInfo(tmNode.key);
            if (!rowInfo) {
              warn$2("data-table", `fail to get row data with key ${tmNode.key}`);
              return;
            }
            doCheck(tmNode.key, true, rowInfo);
          }
          function getScrollContainer() {
            if (!shouldDisplaySomeTablePartRef.value) {
              const { value: emptyEl } = emptyElRef;
              if (emptyEl) {
                return emptyEl;
              } else {
                return null;
              }
            }
            if (virtualScrollRef.value) {
              return virtualListContainer();
            }
            const { value } = scrollbarInstRef;
            if (value)
              return value.containerRef;
            return null;
          }
          function handleUpdateExpanded(key, tmNode) {
            var _a;
            if (loadingKeySetRef.value.has(key))
              return;
            const { value: mergedExpandedRowKeys } = mergedExpandedRowKeysRef;
            const index = mergedExpandedRowKeys.indexOf(key);
            const nextExpandedKeys = Array.from(mergedExpandedRowKeys);
            if (~index) {
              nextExpandedKeys.splice(index, 1);
              doUpdateExpandedRowKeys(nextExpandedKeys);
            } else {
              if (tmNode && !tmNode.isLeaf && !tmNode.shallowLoaded) {
                loadingKeySetRef.value.add(key);
                void ((_a = onLoadRef.value) === null || _a === void 0 ? void 0 : _a.call(onLoadRef, tmNode.rawNode).then(() => {
                  const { value: futureMergedExpandedRowKeys } = mergedExpandedRowKeysRef;
                  const futureNextExpandedKeys = Array.from(futureMergedExpandedRowKeys);
                  const index2 = futureNextExpandedKeys.indexOf(key);
                  if (!~index2) {
                    futureNextExpandedKeys.push(key);
                  }
                  doUpdateExpandedRowKeys(futureNextExpandedKeys);
                }).finally(() => {
                  loadingKeySetRef.value.delete(key);
                }));
              } else {
                nextExpandedKeys.push(key);
                doUpdateExpandedRowKeys(nextExpandedKeys);
              }
            }
          }
          function handleMouseleaveTable() {
            hoverKeyRef.value = null;
          }
          function handleMouseenterTable() {
            scrollPartRef.value = "body";
          }
          function virtualListContainer() {
            const { value } = virtualListRef;
            return value === null || value === void 0 ? void 0 : value.listElRef;
          }
          function virtualListContent() {
            const { value } = virtualListRef;
            return value === null || value === void 0 ? void 0 : value.itemsElRef;
          }
          function handleVirtualListScroll(e) {
            var _a;
            handleTableBodyScroll(e);
            (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function handleVirtualListResize(e) {
            var _a;
            const { onResize } = props;
            if (onResize)
              onResize(e);
            (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          const exposedMethods = {
            getScrollContainer,
            scrollTo(arg0, arg1) {
              var _a, _b;
              if (virtualScrollRef.value) {
                (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
              } else {
                (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(arg0, arg1);
              }
            }
          };
          const style2 = c$1([
            ({ props: cProps }) => {
              const createActiveLeftFixedStyle = (leftActiveFixedColKey) => {
                if (leftActiveFixedColKey === null)
                  return null;
                return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${leftActiveFixedColKey}"]::after`, { boxShadow: "var(--n-box-shadow-after)" });
              };
              const createActiveRightFixedStyle = (rightActiveFixedColKey) => {
                if (rightActiveFixedColKey === null)
                  return null;
                return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${rightActiveFixedColKey}"]::before`, { boxShadow: "var(--n-box-shadow-before)" });
              };
              return c$1([
                createActiveLeftFixedStyle(cProps.leftActiveFixedColKey),
                createActiveRightFixedStyle(cProps.rightActiveFixedColKey),
                cProps.leftActiveFixedChildrenColKeys.map((leftActiveFixedColKey) => createActiveLeftFixedStyle(leftActiveFixedColKey)),
                cProps.rightActiveFixedChildrenColKeys.map((rightActiveFixedColKey) => createActiveRightFixedStyle(rightActiveFixedColKey))
              ]);
            }
          ]);
          let fixedStyleMounted = false;
          vue.watchEffect(() => {
            const { value: leftActiveFixedColKey } = leftActiveFixedColKeyRef;
            const { value: leftActiveFixedChildrenColKeys } = leftActiveFixedChildrenColKeysRef;
            const { value: rightActiveFixedColKey } = rightActiveFixedColKeyRef;
            const { value: rightActiveFixedChildrenColKeys } = rightActiveFixedChildrenColKeysRef;
            if (!fixedStyleMounted && leftActiveFixedColKey === null && rightActiveFixedColKey === null) {
              return;
            }
            const cProps = {
              leftActiveFixedColKey,
              leftActiveFixedChildrenColKeys,
              rightActiveFixedColKey,
              rightActiveFixedChildrenColKeys,
              componentId
            };
            style2.mount({
              id: `n-${componentId}`,
              force: true,
              props: cProps,
              anchorMetaName: cssrAnchorMetaName
            });
            fixedStyleMounted = true;
          });
          vue.onUnmounted(() => {
            style2.unmount({
              id: `n-${componentId}`
            });
          });
          return Object.assign({
            bodyWidth: bodyWidthRef,
            summaryPlacement: summaryPlacementRef,
            dataTableSlots,
            componentId,
            scrollbarInstRef,
            virtualListRef,
            emptyElRef,
            summary: summaryRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            scrollX: scrollXRef,
            cols: colsRef,
            loading: loadingRef,
            bodyShowHeaderOnly: bodyShowHeaderOnlyRef,
            shouldDisplaySomeTablePart: shouldDisplaySomeTablePartRef,
            empty: emptyRef,
            paginatedDataAndInfo: vue.computed(() => {
              const { value: striped } = stripedRef;
              let hasChildren = false;
              const data = paginatedDataRef.value.map(striped ? (tmNode, index) => {
                if (!tmNode.isLeaf)
                  hasChildren = true;
                return {
                  tmNode,
                  key: tmNode.key,
                  striped: index % 2 === 1,
                  index
                };
              } : (tmNode, index) => {
                if (!tmNode.isLeaf)
                  hasChildren = true;
                return {
                  tmNode,
                  key: tmNode.key,
                  striped: false,
                  index
                };
              });
              return {
                data,
                hasChildren
              };
            }),
            rawPaginatedData: rawPaginatedDataRef,
            fixedColumnLeftMap: fixedColumnLeftMapRef,
            fixedColumnRightMap: fixedColumnRightMapRef,
            currentPage: mergedCurrentPageRef,
            rowClassName: rowClassNameRef,
            renderExpand: renderExpandRef,
            mergedExpandedRowKeySet: mergedExpandedRowKeySetRef,
            hoverKey: hoverKeyRef,
            mergedSortState: mergedSortStateRef,
            virtualScroll: virtualScrollRef,
            mergedTableLayout: mergedTableLayoutRef,
            childTriggerColIndex: childTriggerColIndexRef,
            indent: indentRef,
            rowProps: rowPropsRef,
            maxHeight: maxHeightRef,
            loadingKeySet: loadingKeySetRef,
            expandable: expandableRef,
            stickyExpandedRows: stickyExpandedRowsRef,
            renderExpandIcon: renderExpandIconRef,
            scrollbarProps: scrollbarPropsRef,
            setHeaderScrollLeft,
            handleMouseenterTable,
            handleVirtualListScroll,
            handleVirtualListResize,
            handleMouseleaveTable,
            virtualListContainer,
            virtualListContent,
            handleTableBodyScroll,
            handleCheckboxUpdateChecked,
            handleRadioUpdateChecked,
            handleUpdateExpanded,
            renderCell
          }, exposedMethods);
        },
        render() {
          const { mergedTheme, scrollX, mergedClsPrefix, virtualScroll, maxHeight, mergedTableLayout, flexHeight, loadingKeySet, onResize, setHeaderScrollLeft } = this;
          const scrollable = scrollX !== void 0 || maxHeight !== void 0 || flexHeight;
          const isBasicAutoLayout = !scrollable && mergedTableLayout === "auto";
          const xScrollable = scrollX !== void 0 || isBasicAutoLayout;
          const contentStyle = {
            minWidth: formatLength(scrollX) || "100%"
          };
          if (scrollX)
            contentStyle.width = "100%";
          const tableNode = vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, { ref: "scrollbarInstRef", scrollable: scrollable || isBasicAutoLayout, class: `${mergedClsPrefix}-data-table-base-table-body`, style: this.bodyStyle, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, contentStyle, container: virtualScroll ? this.virtualListContainer : void 0, content: virtualScroll ? this.virtualListContent : void 0, horizontalRailStyle: { zIndex: 3 }, verticalRailStyle: { zIndex: 3 }, xScrollable, onScroll: virtualScroll ? void 0 : this.handleTableBodyScroll, internalOnUpdateScrollLeft: setHeaderScrollLeft, onResize }), {
            default: () => {
              const cordToPass = {};
              const cordKey = {};
              const { cols, paginatedDataAndInfo, mergedTheme: mergedTheme2, fixedColumnLeftMap, fixedColumnRightMap, currentPage, rowClassName, mergedSortState, mergedExpandedRowKeySet, stickyExpandedRows, componentId, childTriggerColIndex, expandable, rowProps: rowProps2, handleMouseenterTable, handleMouseleaveTable, renderExpand, summary, handleCheckboxUpdateChecked, handleRadioUpdateChecked, handleUpdateExpanded } = this;
              const { length: colCount } = cols;
              let mergedData;
              const { data: paginatedData, hasChildren } = paginatedDataAndInfo;
              const mergedPaginationData = hasChildren ? flatten(paginatedData, mergedExpandedRowKeySet) : paginatedData;
              if (summary) {
                const summaryRows = summary(this.rawPaginatedData);
                if (Array.isArray(summaryRows)) {
                  const summaryRowData = summaryRows.map((row, i) => ({
                    isSummaryRow: true,
                    key: `__n_summary__${i}`,
                    tmNode: {
                      rawNode: row,
                      disabled: true
                    },
                    index: -1
                  }));
                  mergedData = this.summaryPlacement === "top" ? [...summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, ...summaryRowData];
                } else {
                  const summaryRowData = {
                    isSummaryRow: true,
                    key: "__n_summary__",
                    tmNode: {
                      rawNode: summaryRows,
                      disabled: true
                    },
                    index: -1
                  };
                  mergedData = this.summaryPlacement === "top" ? [summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, summaryRowData];
                }
              } else {
                mergedData = mergedPaginationData;
              }
              const indentStyle = hasChildren ? { width: pxfy(this.indent) } : void 0;
              const displayedData = [];
              mergedData.forEach((rowInfo) => {
                if (renderExpand && mergedExpandedRowKeySet.has(rowInfo.key) && (!expandable || expandable(rowInfo.tmNode.rawNode))) {
                  displayedData.push(rowInfo, {
                    isExpandedRow: true,
                    key: `${rowInfo.key}-expand`,
                    tmNode: rowInfo.tmNode,
                    index: rowInfo.index
                  });
                } else {
                  displayedData.push(rowInfo);
                }
              });
              const { length: rowCount } = displayedData;
              const rowIndexToKey = {};
              paginatedData.forEach(({ tmNode }, rowIndex) => {
                rowIndexToKey[rowIndex] = tmNode.key;
              });
              const bodyWidth = stickyExpandedRows ? this.bodyWidth : null;
              const bodyWidthPx = bodyWidth === null ? void 0 : `${bodyWidth}px`;
              const renderRow = (rowInfo, displayedRowIndex, isVirtual) => {
                const { index: actualRowIndex } = rowInfo;
                if ("isExpandedRow" in rowInfo) {
                  const { tmNode: { key, rawNode } } = rowInfo;
                  return vue.h(
                    "tr",
                    { class: `${mergedClsPrefix}-data-table-tr`, key: `${key}__expand` },
                    vue.h("td", { class: [
                      `${mergedClsPrefix}-data-table-td`,
                      `${mergedClsPrefix}-data-table-td--last-col`,
                      displayedRowIndex + 1 === rowCount && `${mergedClsPrefix}-data-table-td--last-row`
                    ], colspan: colCount }, stickyExpandedRows ? vue.h("div", { class: `${mergedClsPrefix}-data-table-expand`, style: {
                      width: bodyWidthPx
                    } }, renderExpand(rawNode, actualRowIndex)) : renderExpand(rawNode, actualRowIndex))
                  );
                }
                const isSummary = "isSummaryRow" in rowInfo;
                const striped = !isSummary && rowInfo.striped;
                const { tmNode, key: rowKey } = rowInfo;
                const { rawNode: rowData } = tmNode;
                const expanded = mergedExpandedRowKeySet.has(rowKey);
                const props = rowProps2 ? rowProps2(rowData, actualRowIndex) : void 0;
                const mergedRowClassName = typeof rowClassName === "string" ? rowClassName : createRowClassName(rowData, actualRowIndex, rowClassName);
                const row = vue.h("tr", Object.assign({ onMouseenter: () => {
                  this.hoverKey = rowKey;
                }, key: rowKey, class: [
                  `${mergedClsPrefix}-data-table-tr`,
                  isSummary && `${mergedClsPrefix}-data-table-tr--summary`,
                  striped && `${mergedClsPrefix}-data-table-tr--striped`,
                  mergedRowClassName
                ] }, props), cols.map((col, colIndex) => {
                  var _a, _b, _c, _d, _e;
                  if (displayedRowIndex in cordToPass) {
                    const cordOfRowToPass = cordToPass[displayedRowIndex];
                    const indexInCordOfRowToPass = cordOfRowToPass.indexOf(colIndex);
                    if (~indexInCordOfRowToPass) {
                      cordOfRowToPass.splice(indexInCordOfRowToPass, 1);
                      return null;
                    }
                  }
                  const { column } = col;
                  const colKey = getColKey(col);
                  const { rowSpan, colSpan } = column;
                  const mergedColSpan = isSummary ? ((_a = rowInfo.tmNode.rawNode[colKey]) === null || _a === void 0 ? void 0 : _a.colSpan) || 1 : colSpan ? colSpan(rowData, actualRowIndex) : 1;
                  const mergedRowSpan = isSummary ? ((_b = rowInfo.tmNode.rawNode[colKey]) === null || _b === void 0 ? void 0 : _b.rowSpan) || 1 : rowSpan ? rowSpan(rowData, actualRowIndex) : 1;
                  const isLastCol = colIndex + mergedColSpan === colCount;
                  const isLastRow = displayedRowIndex + mergedRowSpan === rowCount;
                  const isCrossRowTd = mergedRowSpan > 1;
                  if (isCrossRowTd) {
                    cordKey[displayedRowIndex] = {
                      [colIndex]: []
                    };
                  }
                  if (mergedColSpan > 1 || isCrossRowTd) {
                    for (let i = displayedRowIndex; i < displayedRowIndex + mergedRowSpan; ++i) {
                      if (isCrossRowTd) {
                        cordKey[displayedRowIndex][colIndex].push(rowIndexToKey[i]);
                      }
                      for (let j = colIndex; j < colIndex + mergedColSpan; ++j) {
                        if (i === displayedRowIndex && j === colIndex) {
                          continue;
                        }
                        if (!(i in cordToPass)) {
                          cordToPass[i] = [j];
                        } else {
                          cordToPass[i].push(j);
                        }
                      }
                    }
                  }
                  const hoverKey = isCrossRowTd ? this.hoverKey : null;
                  const { cellProps } = column;
                  const resolvedCellProps = cellProps === null || cellProps === void 0 ? void 0 : cellProps(rowData, actualRowIndex);
                  return vue.h(
                    "td",
                    Object.assign({}, resolvedCellProps, { key: colKey, style: [
                      {
                        textAlign: column.align || void 0,
                        left: pxfy((_c = fixedColumnLeftMap[colKey]) === null || _c === void 0 ? void 0 : _c.start),
                        right: pxfy((_d = fixedColumnRightMap[colKey]) === null || _d === void 0 ? void 0 : _d.start)
                      },
                      (resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.style) || ""
                    ], colspan: mergedColSpan, rowspan: isVirtual ? void 0 : mergedRowSpan, "data-col-key": colKey, class: [
                      `${mergedClsPrefix}-data-table-td`,
                      column.className,
                      resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.class,
                      isSummary && `${mergedClsPrefix}-data-table-td--summary`,
                      (hoverKey !== null && cordKey[displayedRowIndex][colIndex].includes(hoverKey) || isColumnSorting(column, mergedSortState)) && `${mergedClsPrefix}-data-table-td--hover`,
                      column.fixed && `${mergedClsPrefix}-data-table-td--fixed-${column.fixed}`,
                      column.align && `${mergedClsPrefix}-data-table-td--${column.align}-align`,
                      column.type === "selection" && `${mergedClsPrefix}-data-table-td--selection`,
                      column.type === "expand" && `${mergedClsPrefix}-data-table-td--expand`,
                      isLastCol && `${mergedClsPrefix}-data-table-td--last-col`,
                      isLastRow && `${mergedClsPrefix}-data-table-td--last-row`
                    ] }),
                    hasChildren && colIndex === childTriggerColIndex ? [
                      repeat(isSummary ? 0 : rowInfo.tmNode.level, vue.h("div", { class: `${mergedClsPrefix}-data-table-indent`, style: indentStyle })),
                      isSummary || rowInfo.tmNode.isLeaf ? vue.h("div", { class: `${mergedClsPrefix}-data-table-expand-placeholder` }) : vue.h(ExpandTrigger, { class: `${mergedClsPrefix}-data-table-expand-trigger`, clsPrefix: mergedClsPrefix, expanded, renderExpandIcon: this.renderExpandIcon, loading: loadingKeySet.has(rowInfo.key), onClick: () => {
                        handleUpdateExpanded(rowKey, rowInfo.tmNode);
                      } })
                    ] : null,
                    column.type === "selection" ? !isSummary ? column.multiple === false ? vue.h(RenderSafeRadio, { key: currentPage, rowKey, disabled: rowInfo.tmNode.disabled, onUpdateChecked: () => {
                      handleRadioUpdateChecked(rowInfo.tmNode);
                    } }) : vue.h(RenderSafeCheckbox, { key: currentPage, rowKey, disabled: rowInfo.tmNode.disabled, onUpdateChecked: (checked, e) => {
                      handleCheckboxUpdateChecked(rowInfo.tmNode, checked, e.shiftKey);
                    } }) : null : column.type === "expand" ? !isSummary ? !column.expandable || ((_e = column.expandable) === null || _e === void 0 ? void 0 : _e.call(column, rowData)) ? vue.h(ExpandTrigger, { clsPrefix: mergedClsPrefix, expanded, renderExpandIcon: this.renderExpandIcon, onClick: () => {
                      handleUpdateExpanded(rowKey, null);
                    } }) : null : null : vue.h(Cell, { clsPrefix: mergedClsPrefix, index: actualRowIndex, row: rowData, column, isSummary, mergedTheme: mergedTheme2, renderCell: this.renderCell })
                  );
                }));
                return row;
              };
              if (!virtualScroll) {
                return vue.h(
                  "table",
                  { class: `${mergedClsPrefix}-data-table-table`, onMouseleave: handleMouseleaveTable, onMouseenter: handleMouseenterTable, style: {
                    tableLayout: this.mergedTableLayout
                  } },
                  vue.h("colgroup", null, cols.map((col) => vue.h("col", { key: col.key, style: col.style }))),
                  this.showHeader ? vue.h(TableHeader, { discrete: false }) : null,
                  !this.empty ? vue.h("tbody", { "data-n-id": componentId, class: `${mergedClsPrefix}-data-table-tbody` }, displayedData.map((rowInfo, displayedRowIndex) => {
                    return renderRow(rowInfo, displayedRowIndex, false);
                  })) : null
                );
              } else {
                return vue.h(VVirtualList, { ref: "virtualListRef", items: displayedData, itemSize: 28, visibleItemsTag: VirtualListItemWrapper, visibleItemsProps: {
                  clsPrefix: mergedClsPrefix,
                  id: componentId,
                  cols,
                  onMouseenter: handleMouseenterTable,
                  onMouseleave: handleMouseleaveTable
                }, showScrollbar: false, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemsStyle: contentStyle, itemResizable: true }, {
                  default: ({ item, index }) => renderRow(item, index, true)
                });
              }
            }
          });
          if (this.empty) {
            const createEmptyNode = () => vue.h("div", { class: [
              `${mergedClsPrefix}-data-table-empty`,
              this.loading && `${mergedClsPrefix}-data-table-empty--hide`
            ], style: this.bodyStyle, ref: "emptyElRef" }, resolveSlot(this.dataTableSlots.empty, () => [
              vue.h(NEmpty, { theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })
            ]));
            if (this.shouldDisplaySomeTablePart) {
              return vue.h(
                vue.Fragment,
                null,
                tableNode,
                createEmptyNode()
              );
            } else {
              return vue.h(VResizeObserver, { onResize: this.onResize }, { default: createEmptyNode });
            }
          }
          return tableNode;
        }
      });
      const MainTable = vue.defineComponent({
        setup() {
          const {
            mergedClsPrefixRef,
            rightFixedColumnsRef,
            leftFixedColumnsRef,
            bodyWidthRef,
            maxHeightRef,
            minHeightRef,
            flexHeightRef,
            syncScrollState
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dataTableInjectionKey);
          const headerInstRef = vue.ref(null);
          const bodyInstRef = vue.ref(null);
          const selfElRef = vue.ref(null);
          const fixedStateInitializedRef = vue.ref(!(leftFixedColumnsRef.value.length || rightFixedColumnsRef.value.length));
          const bodyStyleRef = vue.computed(() => {
            return {
              maxHeight: formatLength(maxHeightRef.value),
              minHeight: formatLength(minHeightRef.value)
            };
          });
          function handleBodyResize(entry) {
            bodyWidthRef.value = entry.contentRect.width;
            syncScrollState();
            if (!fixedStateInitializedRef.value) {
              fixedStateInitializedRef.value = true;
            }
          }
          function getHeaderElement() {
            const { value } = headerInstRef;
            if (value) {
              return value.$el;
            }
            return null;
          }
          function getBodyElement() {
            const { value } = bodyInstRef;
            if (value) {
              return value.getScrollContainer();
            }
            return null;
          }
          const exposedMethods = {
            getBodyElement,
            getHeaderElement,
            scrollTo(arg0, arg1) {
              var _a;
              (_a = bodyInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
            }
          };
          vue.watchEffect(() => {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
              return;
            const transitionDisabledClass = `${mergedClsPrefixRef.value}-data-table-base-table--transition-disabled`;
            if (fixedStateInitializedRef.value) {
              setTimeout(() => {
                selfEl.classList.remove(transitionDisabledClass);
              }, 0);
            } else {
              selfEl.classList.add(transitionDisabledClass);
            }
          });
          return Object.assign({
            maxHeight: maxHeightRef,
            mergedClsPrefix: mergedClsPrefixRef,
            selfElRef,
            headerInstRef,
            bodyInstRef,
            bodyStyle: bodyStyleRef,
            flexHeight: flexHeightRef,
            handleBodyResize
          }, exposedMethods);
        },
        render() {
          const { mergedClsPrefix, maxHeight, flexHeight } = this;
          const headerInBody = maxHeight === void 0 && !flexHeight;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-data-table-base-table`, ref: "selfElRef" },
            headerInBody ? null : vue.h(TableHeader, { ref: "headerInstRef" }),
            vue.h(TableBody, { ref: "bodyInstRef", bodyStyle: this.bodyStyle, showHeader: headerInBody, flexHeight, onResize: this.handleBodyResize })
          );
        }
      });
      function useCheck(props, data) {
        const { paginatedDataRef, treeMateRef, selectionColumnRef } = data;
        const uncontrolledCheckedRowKeysRef = vue.ref(props.defaultCheckedRowKeys);
        const mergedCheckState = vue.computed(() => {
          var _a;
          const { checkedRowKeys } = props;
          const sourceKeys = checkedRowKeys === void 0 ? uncontrolledCheckedRowKeysRef.value : checkedRowKeys;
          if (((_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.multiple) === false) {
            return {
              checkedKeys: sourceKeys.slice(0, 1),
              indeterminateKeys: []
            };
          }
          return treeMateRef.value.getCheckedKeys(sourceKeys, {
            cascade: props.cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
        });
        const mergedCheckedRowKeysRef = vue.computed(() => mergedCheckState.value.checkedKeys);
        const mergedInderminateRowKeysRef = vue.computed(() => mergedCheckState.value.indeterminateKeys);
        const mergedCheckedRowKeySetRef = vue.computed(() => {
          return new Set(mergedCheckedRowKeysRef.value);
        });
        const mergedInderminateRowKeySetRef = vue.computed(() => {
          return new Set(mergedInderminateRowKeysRef.value);
        });
        const countOfCurrentPageCheckedRowsRef = vue.computed(() => {
          const { value: mergedCheckedRowKeySet } = mergedCheckedRowKeySetRef;
          return paginatedDataRef.value.reduce((total, tmNode) => {
            const { key, disabled } = tmNode;
            return total + (!disabled && mergedCheckedRowKeySet.has(key) ? 1 : 0);
          }, 0);
        });
        const countOfCurrentPageDisabledRowsRef = vue.computed(() => {
          return paginatedDataRef.value.filter((item) => item.disabled).length;
        });
        const someRowsCheckedRef = vue.computed(() => {
          const { length } = paginatedDataRef.value;
          const { value: mergedInderminateRowKeySet } = mergedInderminateRowKeySetRef;
          return countOfCurrentPageCheckedRowsRef.value > 0 && countOfCurrentPageCheckedRowsRef.value < length - countOfCurrentPageDisabledRowsRef.value || paginatedDataRef.value.some((rowData) => mergedInderminateRowKeySet.has(rowData.key));
        });
        const allRowsCheckedRef = vue.computed(() => {
          const { length } = paginatedDataRef.value;
          return countOfCurrentPageCheckedRowsRef.value !== 0 && countOfCurrentPageCheckedRowsRef.value === length - countOfCurrentPageDisabledRowsRef.value;
        });
        const headerCheckboxDisabledRef = vue.computed(() => {
          return paginatedDataRef.value.length === 0;
        });
        function doUpdateCheckedRowKeys(keys2, row, action) {
          const { "onUpdate:checkedRowKeys": _onUpdateCheckedRowKeys, onUpdateCheckedRowKeys, onCheckedRowKeysChange } = props;
          const rows = [];
          const { value: { getNode } } = treeMateRef;
          keys2.forEach((key) => {
            var _a;
            const row2 = (_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
            rows.push(row2);
          });
          if (_onUpdateCheckedRowKeys) {
            call(_onUpdateCheckedRowKeys, keys2, rows, { row, action });
          }
          if (onUpdateCheckedRowKeys) {
            call(onUpdateCheckedRowKeys, keys2, rows, { row, action });
          }
          if (onCheckedRowKeysChange) {
            call(onCheckedRowKeysChange, keys2, rows, { row, action });
          }
          uncontrolledCheckedRowKeysRef.value = keys2;
        }
        function doCheck(rowKey, single = false, rowInfo) {
          if (props.loading)
            return;
          if (single) {
            doUpdateCheckedRowKeys(Array.isArray(rowKey) ? rowKey.slice(0, 1) : [rowKey], rowInfo, "check");
            return;
          }
          doUpdateCheckedRowKeys(treeMateRef.value.check(rowKey, mergedCheckedRowKeysRef.value, {
            cascade: props.cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, rowInfo, "check");
        }
        function doUncheck(rowKey, rowInfo) {
          if (props.loading)
            return;
          doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKey, mergedCheckedRowKeysRef.value, {
            cascade: props.cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, rowInfo, "uncheck");
        }
        function doCheckAll(checkWholeTable = false) {
          const { value: column } = selectionColumnRef;
          if (!column || props.loading)
            return;
          const rowKeysToCheck = [];
          (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
            if (!tmNode.disabled) {
              rowKeysToCheck.push(tmNode.key);
            }
          });
          doUpdateCheckedRowKeys(treeMateRef.value.check(rowKeysToCheck, mergedCheckedRowKeysRef.value, {
            cascade: true,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, void 0, "checkAll");
        }
        function doUncheckAll(checkWholeTable = false) {
          const { value: column } = selectionColumnRef;
          if (!column || props.loading)
            return;
          const rowKeysToUncheck = [];
          (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
            if (!tmNode.disabled) {
              rowKeysToUncheck.push(tmNode.key);
            }
          });
          doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKeysToUncheck, mergedCheckedRowKeysRef.value, {
            cascade: true,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, void 0, "uncheckAll");
        }
        return {
          mergedCheckedRowKeySetRef,
          mergedCheckedRowKeysRef,
          mergedInderminateRowKeySetRef,
          someRowsCheckedRef,
          allRowsCheckedRef,
          headerCheckboxDisabledRef,
          doUpdateCheckedRowKeys,
          doCheckAll,
          doUncheckAll,
          doCheck,
          doUncheck
        };
      }
      function getMultiplePriority(sorter) {
        if (typeof sorter === "object" && typeof sorter.multiple === "number") {
          return sorter.multiple;
        }
        return false;
      }
      function getSortFunction(sorter, columnKey) {
        if (columnKey && (sorter === void 0 || sorter === "default" || typeof sorter === "object" && sorter.compare === "default")) {
          return getDefaultSorterFn(columnKey);
        }
        if (typeof sorter === "function") {
          return sorter;
        }
        if (sorter && typeof sorter === "object" && sorter.compare && sorter.compare !== "default") {
          return sorter.compare;
        }
        return false;
      }
      function getDefaultSorterFn(columnKey) {
        return (row1, row2) => {
          const value1 = row1[columnKey];
          const value2 = row2[columnKey];
          if (typeof value1 === "number" && typeof value2 === "number") {
            return value1 - value2;
          } else if (typeof value1 === "string" && typeof value2 === "string") {
            return value1.localeCompare(value2);
          }
          return 0;
        };
      }
      function useSorter(props, { dataRelatedColsRef, filteredDataRef }) {
        const defaultSortState = [];
        dataRelatedColsRef.value.forEach((column) => {
          var _a;
          if (column.sorter !== void 0) {
            updateSortStatesByNewSortState(defaultSortState, {
              columnKey: column.key,
              sorter: column.sorter,
              order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false
            });
          }
        });
        const uncontrolledSortStateRef = vue.ref(defaultSortState);
        const mergedSortStateRef = vue.computed(() => {
          const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter((column) => column.type !== "selection" && column.sorter !== void 0 && (column.sortOrder === "ascend" || column.sortOrder === "descend" || column.sortOrder === false));
          const columnToSort = columnsWithControlledSortOrder.filter((col) => col.sortOrder !== false);
          if (columnToSort.length) {
            return columnToSort.map((column) => {
              return {
                columnKey: column.key,
                // column to sort has controlled sorter
                // sorter && sort order won't be undefined
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                order: column.sortOrder,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                sorter: column.sorter
              };
            });
          }
          if (columnsWithControlledSortOrder.length)
            return [];
          const { value: uncontrolledSortState } = uncontrolledSortStateRef;
          if (Array.isArray(uncontrolledSortState)) {
            return uncontrolledSortState;
          } else if (uncontrolledSortState) {
            return [uncontrolledSortState];
          } else {
            return [];
          }
        });
        const sortedDataRef = vue.computed(() => {
          const activeSorters = mergedSortStateRef.value.slice().sort((a2, b) => {
            const item1Priority = getMultiplePriority(a2.sorter) || 0;
            const item2Priority = getMultiplePriority(b.sorter) || 0;
            return item2Priority - item1Priority;
          });
          if (activeSorters.length) {
            const filteredData = filteredDataRef.value.slice();
            return filteredData.sort((tmNode1, tmNode2) => {
              let compareResult = 0;
              activeSorters.some((sorterState) => {
                const { columnKey, sorter, order } = sorterState;
                const compareFn = getSortFunction(sorter, columnKey);
                if (compareFn && order) {
                  compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);
                  if (compareResult !== 0) {
                    compareResult = compareResult * getFlagOfOrder(order);
                    return true;
                  }
                }
                return false;
              });
              return compareResult;
            });
          }
          return filteredDataRef.value;
        });
        function getUpdatedSorterState(sortState) {
          let currentSortState = mergedSortStateRef.value.slice();
          if (sortState && getMultiplePriority(sortState.sorter) !== false) {
            currentSortState = currentSortState.filter((sortState2) => getMultiplePriority(sortState2.sorter) !== false);
            updateSortStatesByNewSortState(currentSortState, sortState);
            return currentSortState;
          } else if (sortState) {
            return sortState;
          }
          return null;
        }
        function deriveNextSorter(sortState) {
          const nextSorterState = getUpdatedSorterState(sortState);
          doUpdateSorter(nextSorterState);
        }
        function doUpdateSorter(sortState) {
          const { "onUpdate:sorter": _onUpdateSorter, onUpdateSorter, onSorterChange } = props;
          if (_onUpdateSorter) {
            call(_onUpdateSorter, sortState);
          }
          if (onUpdateSorter) {
            call(onUpdateSorter, sortState);
          }
          if (onSorterChange) {
            call(onSorterChange, sortState);
          }
          uncontrolledSortStateRef.value = sortState;
        }
        function sort(columnKey, order = "ascend") {
          if (!columnKey) {
            clearSorter();
          } else {
            const columnToSort = dataRelatedColsRef.value.find((column) => column.type !== "selection" && column.type !== "expand" && column.key === columnKey);
            if (!(columnToSort === null || columnToSort === void 0 ? void 0 : columnToSort.sorter))
              return;
            const sorter = columnToSort.sorter;
            deriveNextSorter({
              columnKey,
              sorter,
              order
            });
          }
        }
        function clearSorter() {
          doUpdateSorter(null);
        }
        function updateSortStatesByNewSortState(sortStates, sortState) {
          const index = sortStates.findIndex((state) => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);
          if (index !== void 0 && index >= 0) {
            sortStates[index] = sortState;
          } else {
            sortStates.push(sortState);
          }
        }
        return {
          clearSorter,
          sort,
          sortedDataRef,
          mergedSortStateRef,
          deriveNextSorter
        };
      }
      function useTableData(props, { dataRelatedColsRef }) {
        const selectionColumnRef = vue.computed(() => {
          const getSelectionColumn = (cols) => {
            for (let i = 0; i < cols.length; ++i) {
              const col = cols[i];
              if ("children" in col) {
                return getSelectionColumn(col.children);
              } else if (col.type === "selection") {
                return col;
              }
            }
            return null;
          };
          return getSelectionColumn(props.columns);
        });
        const treeMateRef = vue.computed(() => {
          const { childrenKey } = props;
          return createTreeMate(props.data, {
            ignoreEmptyChildren: true,
            getKey: props.rowKey,
            getChildren: (rowData) => rowData[childrenKey],
            getDisabled: (rowData) => {
              var _a, _b;
              if ((_b = (_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.disabled) === null || _b === void 0 ? void 0 : _b.call(_a, rowData)) {
                return true;
              }
              return false;
            }
          });
        });
        const childTriggerColIndexRef = useMemo(() => {
          const { columns } = props;
          const { length } = columns;
          let firstContentfulColIndex = null;
          for (let i = 0; i < length; ++i) {
            const col = columns[i];
            if (!col.type && firstContentfulColIndex === null) {
              firstContentfulColIndex = i;
            }
            if ("tree" in col && col.tree) {
              return i;
            }
          }
          return firstContentfulColIndex || 0;
        });
        const uncontrolledFilterStateRef = vue.ref({});
        const uncontrolledCurrentPageRef = vue.ref(1);
        const uncontrolledPageSizeRef = vue.ref(10);
        const mergedFilterStateRef = vue.computed(() => {
          const columnsWithControlledFilter = dataRelatedColsRef.value.filter((column) => {
            return column.filterOptionValues !== void 0 || column.filterOptionValue !== void 0;
          });
          const controlledFilterState = {};
          columnsWithControlledFilter.forEach((column) => {
            var _a;
            if (column.type === "selection" || column.type === "expand")
              return;
            if (column.filterOptionValues === void 0) {
              controlledFilterState[column.key] = (_a = column.filterOptionValue) !== null && _a !== void 0 ? _a : null;
            } else {
              controlledFilterState[column.key] = column.filterOptionValues;
            }
          });
          const activeFilters = Object.assign(createShallowClonedObject(uncontrolledFilterStateRef.value), controlledFilterState);
          return activeFilters;
        });
        const filteredDataRef = vue.computed(() => {
          const mergedFilterState = mergedFilterStateRef.value;
          const { columns } = props;
          function createDefaultFilter(columnKey) {
            return (filterOptionValue, row) => !!~String(row[columnKey]).indexOf(String(filterOptionValue));
          }
          const { value: { treeNodes: data } } = treeMateRef;
          const columnEntries = [];
          columns.forEach((column) => {
            if (column.type === "selection" || column.type === "expand" || "children" in column) {
              return;
            }
            columnEntries.push([column.key, column]);
          });
          return data ? data.filter((tmNode) => {
            const { rawNode: row } = tmNode;
            for (const [columnKey, column] of columnEntries) {
              let activeFilterOptionValues = mergedFilterState[columnKey];
              if (activeFilterOptionValues == null)
                continue;
              if (!Array.isArray(activeFilterOptionValues)) {
                activeFilterOptionValues = [activeFilterOptionValues];
              }
              if (!activeFilterOptionValues.length)
                continue;
              const filter2 = column.filter === "default" ? createDefaultFilter(columnKey) : column.filter;
              if (column && typeof filter2 === "function") {
                if (column.filterMode === "and") {
                  if (activeFilterOptionValues.some((filterOptionValue) => !filter2(filterOptionValue, row))) {
                    return false;
                  }
                } else {
                  if (activeFilterOptionValues.some((filterOptionValue) => filter2(filterOptionValue, row))) {
                    continue;
                  } else {
                    return false;
                  }
                }
              }
            }
            return true;
          }) : [];
        });
        const { sortedDataRef, deriveNextSorter, mergedSortStateRef, sort, clearSorter } = useSorter(props, {
          dataRelatedColsRef,
          filteredDataRef
        });
        dataRelatedColsRef.value.forEach((column) => {
          var _a;
          if (column.filter) {
            const defaultFilterOptionValues = column.defaultFilterOptionValues;
            if (column.filterMultiple) {
              uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues || [];
            } else if (defaultFilterOptionValues !== void 0) {
              uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues === null ? [] : defaultFilterOptionValues;
            } else {
              uncontrolledFilterStateRef.value[column.key] = (_a = column.defaultFilterOptionValue) !== null && _a !== void 0 ? _a : null;
            }
          }
        });
        const controlledCurrentPageRef = vue.computed(() => {
          const { pagination } = props;
          if (pagination === false)
            return void 0;
          return pagination.page;
        });
        const controlledPageSizeRef = vue.computed(() => {
          const { pagination } = props;
          if (pagination === false)
            return void 0;
          return pagination.pageSize;
        });
        const _mergedCurrentPageRef = useMergedState(controlledCurrentPageRef, uncontrolledCurrentPageRef);
        const mergedPageSizeRef = useMergedState(controlledPageSizeRef, uncontrolledPageSizeRef);
        const boundedMergedCurrentPageRef = useMemo(() => {
          const page2 = _mergedCurrentPageRef.value;
          return props.remote ? page2 : Math.max(1, Math.min(Math.ceil(filteredDataRef.value.length / mergedPageSizeRef.value), page2));
        });
        const mergedPageCountRef = vue.computed(() => {
          const { pagination } = props;
          if (pagination) {
            const { pageCount } = pagination;
            if (pageCount !== void 0)
              return pageCount;
          }
          return void 0;
        });
        const paginatedDataRef = vue.computed(() => {
          if (props.remote)
            return treeMateRef.value.treeNodes;
          if (!props.pagination)
            return sortedDataRef.value;
          const pageSize = mergedPageSizeRef.value;
          const startIndex = (boundedMergedCurrentPageRef.value - 1) * pageSize;
          return sortedDataRef.value.slice(startIndex, startIndex + pageSize);
        });
        const rawPaginatedDataRef = vue.computed(() => {
          return paginatedDataRef.value.map((tmNode) => tmNode.rawNode);
        });
        function mergedOnUpdatePage(page2) {
          const { pagination } = props;
          if (pagination) {
            const { onChange, "onUpdate:page": _onUpdatePage, onUpdatePage } = pagination;
            if (onChange)
              call(onChange, page2);
            if (onUpdatePage)
              call(onUpdatePage, page2);
            if (_onUpdatePage)
              call(_onUpdatePage, page2);
            doUpdatePage(page2);
          }
        }
        function mergedOnUpdatePageSize(pageSize) {
          const { pagination } = props;
          if (pagination) {
            const { onPageSizeChange, "onUpdate:pageSize": _onUpdatePageSize, onUpdatePageSize } = pagination;
            if (onPageSizeChange)
              call(onPageSizeChange, pageSize);
            if (onUpdatePageSize)
              call(onUpdatePageSize, pageSize);
            if (_onUpdatePageSize)
              call(_onUpdatePageSize, pageSize);
            doUpdatePageSize(pageSize);
          }
        }
        const mergedItemCountRef = vue.computed(() => {
          if (props.remote) {
            const { pagination } = props;
            if (pagination) {
              const { itemCount } = pagination;
              if (itemCount !== void 0)
                return itemCount;
            }
            return void 0;
          }
          return filteredDataRef.value.length;
        });
        const mergedPaginationRef = vue.computed(() => {
          return Object.assign(Object.assign({}, props.pagination), {
            // reset deprecated methods
            onChange: void 0,
            onUpdatePage: void 0,
            onUpdatePageSize: void 0,
            onPageSizeChange: void 0,
            "onUpdate:page": mergedOnUpdatePage,
            "onUpdate:pageSize": mergedOnUpdatePageSize,
            // writing merged props after pagination to avoid
            // pagination[key] === undefined
            // key still exists but value is undefined
            page: boundedMergedCurrentPageRef.value,
            pageSize: mergedPageSizeRef.value,
            pageCount: mergedItemCountRef.value === void 0 ? mergedPageCountRef.value : void 0,
            itemCount: mergedItemCountRef.value
          });
        });
        function doUpdatePage(page2) {
          const { "onUpdate:page": _onUpdatePage, onPageChange, onUpdatePage } = props;
          if (onUpdatePage)
            call(onUpdatePage, page2);
          if (_onUpdatePage)
            call(_onUpdatePage, page2);
          if (onPageChange)
            call(onPageChange, page2);
          uncontrolledCurrentPageRef.value = page2;
        }
        function doUpdatePageSize(pageSize) {
          const { "onUpdate:pageSize": _onUpdatePageSize, onPageSizeChange, onUpdatePageSize } = props;
          if (onPageSizeChange)
            call(onPageSizeChange, pageSize);
          if (onUpdatePageSize)
            call(onUpdatePageSize, pageSize);
          if (_onUpdatePageSize)
            call(_onUpdatePageSize, pageSize);
          uncontrolledPageSizeRef.value = pageSize;
        }
        function doUpdateFilters(filters2, sourceColumn) {
          const { onUpdateFilters, "onUpdate:filters": _onUpdateFilters, onFiltersChange } = props;
          if (onUpdateFilters)
            call(onUpdateFilters, filters2, sourceColumn);
          if (_onUpdateFilters)
            call(_onUpdateFilters, filters2, sourceColumn);
          if (onFiltersChange)
            call(onFiltersChange, filters2, sourceColumn);
          uncontrolledFilterStateRef.value = filters2;
        }
        function onUnstableColumnResize(resizedWidth, limitedWidth, column, getColumnWidth) {
          var _a;
          (_a = props.onUnstableColumnResize) === null || _a === void 0 ? void 0 : _a.call(props, resizedWidth, limitedWidth, column, getColumnWidth);
        }
        function page(page2) {
          doUpdatePage(page2);
        }
        function clearFilter() {
          clearFilters();
        }
        function clearFilters() {
          filters({});
        }
        function filters(filters2) {
          filter(filters2);
        }
        function filter(filters2) {
          if (!filters2) {
            uncontrolledFilterStateRef.value = {};
          } else if (filters2) {
            uncontrolledFilterStateRef.value = createShallowClonedObject(filters2);
          } else
            ;
        }
        return {
          treeMateRef,
          mergedCurrentPageRef: boundedMergedCurrentPageRef,
          mergedPaginationRef,
          paginatedDataRef,
          rawPaginatedDataRef,
          mergedFilterStateRef,
          mergedSortStateRef,
          hoverKeyRef: vue.ref(null),
          selectionColumnRef,
          childTriggerColIndexRef,
          doUpdateFilters,
          deriveNextSorter,
          doUpdatePageSize,
          doUpdatePage,
          onUnstableColumnResize,
          // exported methods
          filter,
          filters,
          clearFilter,
          clearFilters,
          clearSorter,
          page,
          sort
        };
      }
      function useScroll(props, { mainTableInstRef, mergedCurrentPageRef, bodyWidthRef, scrollPartRef }) {
        let scrollLeft = 0;
        const leftActiveFixedColKeyRef = vue.ref(null);
        const leftActiveFixedChildrenColKeysRef = vue.ref([]);
        const rightActiveFixedColKeyRef = vue.ref(null);
        const rightActiveFixedChildrenColKeysRef = vue.ref([]);
        const styleScrollXRef = vue.computed(() => {
          return formatLength(props.scrollX);
        });
        const leftFixedColumnsRef = vue.computed(() => {
          return props.columns.filter((column) => column.fixed === "left");
        });
        const rightFixedColumnsRef = vue.computed(() => {
          return props.columns.filter((column) => column.fixed === "right");
        });
        const fixedColumnLeftMapRef = vue.computed(() => {
          const columns = {};
          let left = 0;
          function traverse2(cols) {
            cols.forEach((col) => {
              const positionInfo = { start: left, end: 0 };
              columns[getColKey(col)] = positionInfo;
              if ("children" in col) {
                traverse2(col.children);
                positionInfo.end = left;
              } else {
                left += getNumberColWidth(col) || 0;
                positionInfo.end = left;
              }
            });
          }
          traverse2(leftFixedColumnsRef.value);
          return columns;
        });
        const fixedColumnRightMapRef = vue.computed(() => {
          const columns = {};
          let right = 0;
          function traverse2(cols) {
            for (let i = cols.length - 1; i >= 0; --i) {
              const col = cols[i];
              const positionInfo = { start: right, end: 0 };
              columns[getColKey(col)] = positionInfo;
              if ("children" in col) {
                traverse2(col.children);
                positionInfo.end = right;
              } else {
                right += getNumberColWidth(col) || 0;
                positionInfo.end = right;
              }
            }
          }
          traverse2(rightFixedColumnsRef.value);
          return columns;
        });
        function deriveActiveLeftFixedColumn() {
          var _a, _b;
          const { value: leftFixedColumns } = leftFixedColumnsRef;
          let leftWidth = 0;
          const { value: fixedColumnLeftMap } = fixedColumnLeftMapRef;
          let leftActiveFixedColKey = null;
          for (let i = 0; i < leftFixedColumns.length; ++i) {
            const key = getColKey(leftFixedColumns[i]);
            if (scrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {
              leftActiveFixedColKey = key;
              leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
            } else {
              break;
            }
          }
          leftActiveFixedColKeyRef.value = leftActiveFixedColKey;
        }
        function deriveActiveLeftFixedChildrenColumns() {
          leftActiveFixedChildrenColKeysRef.value = [];
          let activeLeftFixedColumn = props.columns.find((col) => getColKey(col) === leftActiveFixedColKeyRef.value);
          while (activeLeftFixedColumn && "children" in activeLeftFixedColumn) {
            const length = activeLeftFixedColumn.children.length;
            if (length === 0)
              break;
            const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];
            leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));
            activeLeftFixedColumn = nextActiveLeftFixedColumn;
          }
        }
        function deriveActiveRightFixedColumn() {
          var _a, _b;
          const { value: rightFixedColumns } = rightFixedColumnsRef;
          const scrollWidth = Number(props.scrollX);
          const { value: tableWidth } = bodyWidthRef;
          if (tableWidth === null)
            return;
          let rightWidth = 0;
          let rightActiveFixedColKey = null;
          const { value: fixedColumnRightMap } = fixedColumnRightMapRef;
          for (let i = rightFixedColumns.length - 1; i >= 0; --i) {
            const key = getColKey(rightFixedColumns[i]);
            if (Math.round(scrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {
              rightActiveFixedColKey = key;
              rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
            } else {
              break;
            }
          }
          rightActiveFixedColKeyRef.value = rightActiveFixedColKey;
        }
        function deriveActiveRightFixedChildrenColumns() {
          rightActiveFixedChildrenColKeysRef.value = [];
          let activeRightFixedColumn = props.columns.find((col) => getColKey(col) === rightActiveFixedColKeyRef.value);
          while (activeRightFixedColumn && "children" in activeRightFixedColumn && activeRightFixedColumn.children.length) {
            const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];
            rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));
            activeRightFixedColumn = nextActiveRightFixedColumn;
          }
        }
        function getScrollElements() {
          const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;
          const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;
          return {
            header,
            body
          };
        }
        function scrollMainTableBodyToTop() {
          const { body } = getScrollElements();
          if (body) {
            body.scrollTop = 0;
          }
        }
        function handleTableHeaderScroll() {
          if (scrollPartRef.value === "head") {
            beforeNextFrameOnce(syncScrollState);
          }
        }
        function handleTableBodyScroll(e) {
          var _a;
          (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          if (scrollPartRef.value === "body") {
            beforeNextFrameOnce(syncScrollState);
          }
        }
        function syncScrollState() {
          const { header, body } = getScrollElements();
          if (!body)
            return;
          const { value: tableWidth } = bodyWidthRef;
          if (tableWidth === null)
            return;
          const { value: scrollPart } = scrollPartRef;
          if (props.maxHeight || props.flexHeight) {
            if (!header)
              return;
            if (scrollPart === "head") {
              scrollLeft = header.scrollLeft;
              body.scrollLeft = scrollLeft;
            } else {
              scrollLeft = body.scrollLeft;
              header.scrollLeft = scrollLeft;
            }
          } else {
            scrollLeft = body.scrollLeft;
          }
          deriveActiveLeftFixedColumn();
          deriveActiveLeftFixedChildrenColumns();
          deriveActiveRightFixedColumn();
          deriveActiveRightFixedChildrenColumns();
        }
        function setHeaderScrollLeft(left) {
          const { header } = getScrollElements();
          if (!header)
            return;
          header.scrollLeft = left;
          syncScrollState();
        }
        vue.watch(mergedCurrentPageRef, () => {
          scrollMainTableBodyToTop();
        });
        return {
          styleScrollXRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          leftFixedColumnsRef,
          rightFixedColumnsRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          syncScrollState,
          handleTableBodyScroll,
          handleTableHeaderScroll,
          setHeaderScrollLeft
        };
      }
      function useResizable() {
        const resizableWidthsRef = vue.ref({});
        function getResizableWidth(key) {
          return resizableWidthsRef.value[key];
        }
        function doUpdateResizableWidth(column, width) {
          if (isColumnResizable(column) && "key" in column) {
            resizableWidthsRef.value[column.key] = width;
          }
        }
        function clearResizableWidth() {
          resizableWidthsRef.value = {};
        }
        return {
          getResizableWidth,
          doUpdateResizableWidth,
          clearResizableWidth
        };
      }
      function getRowsAndCols(columns, getResizableWidth) {
        const rows = [];
        const cols = [];
        const dataRelatedCols = [];
        const rowItemMap = /* @__PURE__ */ new WeakMap();
        let maxDepth = -1;
        let totalRowSpan = 0;
        let hasEllipsis = false;
        function ensureMaxDepth(columns2, currentDepth) {
          if (currentDepth > maxDepth) {
            rows[currentDepth] = [];
            maxDepth = currentDepth;
          }
          for (const column of columns2) {
            if ("children" in column) {
              ensureMaxDepth(column.children, currentDepth + 1);
            } else {
              const key = "key" in column ? column.key : void 0;
              cols.push({
                key: getColKey(column),
                style: createCustomWidthStyle(column, key !== void 0 ? formatLength(getResizableWidth(key)) : void 0),
                column
              });
              totalRowSpan += 1;
              if (!hasEllipsis) {
                hasEllipsis = !!column.ellipsis;
              }
              dataRelatedCols.push(column);
            }
          }
        }
        ensureMaxDepth(columns, 0);
        let currentLeafIndex = 0;
        function ensureColLayout(columns2, currentDepth) {
          let hideUntilIndex = 0;
          columns2.forEach((column, index) => {
            var _a;
            if ("children" in column) {
              const cachedCurrentLeafIndex = currentLeafIndex;
              const rowItem = {
                column,
                colSpan: 0,
                rowSpan: 1,
                isLast: false
              };
              ensureColLayout(column.children, currentDepth + 1);
              column.children.forEach((childColumn) => {
                var _a2, _b;
                rowItem.colSpan += (_b = (_a2 = rowItemMap.get(childColumn)) === null || _a2 === void 0 ? void 0 : _a2.colSpan) !== null && _b !== void 0 ? _b : 0;
              });
              if (cachedCurrentLeafIndex + rowItem.colSpan === totalRowSpan) {
                rowItem.isLast = true;
              }
              rowItemMap.set(column, rowItem);
              rows[currentDepth].push(rowItem);
            } else {
              if (currentLeafIndex < hideUntilIndex) {
                currentLeafIndex += 1;
                return;
              }
              let colSpan = 1;
              if ("titleColSpan" in column) {
                colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
              }
              if (colSpan > 1) {
                hideUntilIndex = currentLeafIndex + colSpan;
              }
              const isLast = currentLeafIndex + colSpan === totalRowSpan;
              const rowItem = {
                column,
                colSpan,
                rowSpan: maxDepth - currentDepth + 1,
                isLast
              };
              rowItemMap.set(column, rowItem);
              rows[currentDepth].push(rowItem);
              currentLeafIndex += 1;
            }
          });
        }
        ensureColLayout(columns, 0);
        return {
          hasEllipsis,
          rows,
          cols,
          dataRelatedCols
        };
      }
      function useGroupHeader(props, getResizableWidth) {
        const rowsAndCols = vue.computed(() => getRowsAndCols(props.columns, getResizableWidth));
        return {
          rowsRef: vue.computed(() => rowsAndCols.value.rows),
          colsRef: vue.computed(() => rowsAndCols.value.cols),
          hasEllipsisRef: vue.computed(() => rowsAndCols.value.hasEllipsis),
          dataRelatedColsRef: vue.computed(() => rowsAndCols.value.dataRelatedCols)
        };
      }
      function useExpand(props, treeMateRef) {
        const renderExpandRef = useMemo(() => {
          for (const col of props.columns) {
            if (col.type === "expand") {
              return col.renderExpand;
            }
          }
        });
        const expandableRef = useMemo(() => {
          let expandable;
          for (const col of props.columns) {
            if (col.type === "expand") {
              expandable = col.expandable;
              break;
            }
          }
          return expandable;
        });
        const uncontrolledExpandedRowKeysRef = vue.ref(props.defaultExpandAll ? (renderExpandRef === null || renderExpandRef === void 0 ? void 0 : renderExpandRef.value) ? (() => {
          const expandedKeys = [];
          treeMateRef.value.treeNodes.forEach((tmNode) => {
            var _a;
            if ((_a = expandableRef.value) === null || _a === void 0 ? void 0 : _a.call(expandableRef, tmNode.rawNode)) {
              expandedKeys.push(tmNode.key);
            }
          });
          return expandedKeys;
        })() : treeMateRef.value.getNonLeafKeys() : props.defaultExpandedRowKeys);
        const controlledExpandedRowKeysRef = vue.toRef(props, "expandedRowKeys");
        const stickyExpandedRowsRef = vue.toRef(props, "stickyExpandedRows");
        const mergedExpandedRowKeysRef = useMergedState(controlledExpandedRowKeysRef, uncontrolledExpandedRowKeysRef);
        function doUpdateExpandedRowKeys(expandedKeys) {
          const { onUpdateExpandedRowKeys, "onUpdate:expandedRowKeys": _onUpdateExpandedRowKeys } = props;
          if (onUpdateExpandedRowKeys) {
            call(onUpdateExpandedRowKeys, expandedKeys);
          }
          if (_onUpdateExpandedRowKeys) {
            call(_onUpdateExpandedRowKeys, expandedKeys);
          }
          uncontrolledExpandedRowKeysRef.value = expandedKeys;
        }
        return {
          stickyExpandedRowsRef,
          mergedExpandedRowKeysRef,
          renderExpandRef,
          expandableRef,
          doUpdateExpandedRowKeys
        };
      }
      const fixedColumnStyle = createFixedColumnStyle();
      const style$T = c$1([cB("data-table", `
 width: 100%;
 font-size: var(--n-font-size);
 display: flex;
 flex-direction: column;
 position: relative;
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 --n-merged-th-color-hover: var(--n-th-color-hover);
 --n-merged-td-color-hover: var(--n-td-color-hover);
 --n-merged-td-color-striped: var(--n-td-color-striped);
 `, [cB("data-table-wrapper", `
 flex-grow: 1;
 display: flex;
 flex-direction: column;
 `), cM("flex-height", [c$1(">", [cB("data-table-wrapper", [c$1(">", [cB("data-table-base-table", `
 display: flex;
 flex-direction: column;
 flex-grow: 1;
 `, [c$1(">", [cB("data-table-base-table-body", "flex-basis: 0;", [
        // last-child means there is no empty icon
        // body is a scrollbar, we need to override height 100%
        c$1("&:last-child", "flex-grow: 1;")
      ])])])])])])]), c$1(">", [cB("data-table-loading-wrapper", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [fadeInScaleUpTransition({
        originalTransform: "translateX(-50%) translateY(-50%)"
      })])]), cB("data-table-expand-placeholder", `
 margin-right: 8px;
 display: inline-block;
 width: 16px;
 height: 1px;
 `), cB("data-table-indent", `
 display: inline-block;
 height: 1px;
 `), cB("data-table-expand-trigger", `
 display: inline-flex;
 margin-right: 8px;
 cursor: pointer;
 font-size: 16px;
 vertical-align: -0.2em;
 position: relative;
 width: 16px;
 height: 16px;
 color: var(--n-td-text-color);
 transition: color .3s var(--n-bezier);
 `, [cM("expanded", [cB("icon", "transform: rotate(90deg);", [iconSwitchTransition({
        originalTransform: "rotate(90deg)"
      })]), cB("base-icon", "transform: rotate(90deg);", [iconSwitchTransition({
        originalTransform: "rotate(90deg)"
      })])]), cB("base-loading", `
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("base-icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cB("data-table-thead", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-merged-th-color);
 `), cB("data-table-tr", `
 box-sizing: border-box;
 background-clip: padding-box;
 transition: background-color .3s var(--n-bezier);
 `, [cB("data-table-expand", `
 position: sticky;
 left: 0;
 overflow: hidden;
 margin: calc(var(--n-th-padding) * -1);
 padding: var(--n-th-padding);
 box-sizing: border-box;
 `), cM("striped", "background-color: var(--n-merged-td-color-striped);", [cB("data-table-td", "background-color: var(--n-merged-td-color-striped);")]), cNotM("summary", [c$1("&:hover", "background-color: var(--n-merged-td-color-hover);", [c$1(">", [cB("data-table-td", "background-color: var(--n-merged-td-color-hover);")])])])]), cB("data-table-th", `
 padding: var(--n-th-padding);
 position: relative;
 text-align: start;
 box-sizing: border-box;
 background-color: var(--n-merged-th-color);
 border-color: var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 color: var(--n-th-text-color);
 transition:
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 font-weight: var(--n-th-font-weight);
 `, [cM("filterable", `
 padding-right: 36px;
 `, [cM("sortable", `
 padding-right: calc(var(--n-th-padding) + 36px);
 `)]), fixedColumnStyle, cM("selection", `
 padding: 0;
 text-align: center;
 line-height: 0;
 z-index: 3;
 `), cE("title-wrapper", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 max-width: 100%;
 `, [cE("title", `
 flex: 1;
 min-width: 0;
 `)]), cE("ellipsis", `
 display: inline-block;
 vertical-align: bottom;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 `), cM("hover", `
 background-color: var(--n-merged-th-color-hover);
 `), cM("sortable", `
 cursor: pointer;
 `, [cE("ellipsis", `
 max-width: calc(100% - 18px);
 `), c$1("&:hover", `
 background-color: var(--n-merged-th-color-hover);
 `)]), cB("data-table-sorter", `
 height: var(--n-sorter-size);
 width: var(--n-sorter-size);
 margin-left: 4px;
 position: relative;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 vertical-align: -0.2em;
 color: var(--n-th-icon-color);
 transition: color .3s var(--n-bezier);
 `, [cB("base-icon", "transition: transform .3s var(--n-bezier)"), cM("desc", [cB("base-icon", `
 transform: rotate(0deg);
 `)]), cM("asc", [cB("base-icon", `
 transform: rotate(-180deg);
 `)]), cM("asc, desc", `
 color: var(--n-th-icon-color-active);
 `)]), cB("data-table-resize-button", `
 width: var(--n-resizable-container-size);
 position: absolute;
 top: 0;
 right: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 cursor: col-resize;
 user-select: none;
 `, [c$1("&::after", `
 width: var(--n-resizable-size);
 height: 50%;
 position: absolute;
 top: 50%;
 left: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 background-color: var(--n-merged-border-color);
 transform: translateY(-50%);
 transition: background-color .3s var(--n-bezier);
 z-index: 1;
 content: '';
 `), cM("active", [c$1("&::after", ` 
 background-color: var(--n-th-icon-color-active);
 `)]), c$1("&:hover::after", `
 background-color: var(--n-th-icon-color-active);
 `)]), cB("data-table-filter", `
 position: absolute;
 z-index: auto;
 right: 0;
 width: 36px;
 top: 0;
 bottom: 0;
 cursor: pointer;
 display: flex;
 justify-content: center;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: var(--n-filter-size);
 color: var(--n-th-icon-color);
 `, [c$1("&:hover", `
 background-color: var(--n-th-button-color-hover);
 `), cM("show", `
 background-color: var(--n-th-button-color-hover);
 `), cM("active", `
 background-color: var(--n-th-button-color-hover);
 color: var(--n-th-icon-color-active);
 `)])]), cB("data-table-td", `
 padding: var(--n-td-padding);
 text-align: start;
 box-sizing: border-box;
 border: none;
 background-color: var(--n-merged-td-color);
 color: var(--n-td-text-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cM("expand", [cB("data-table-expand-trigger", `
 margin-right: 0;
 `)]), cM("last-row", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [
        // make sure there is no overlap between bottom border and
        // fixed column box shadow
        c$1("&::after", `
 bottom: 0 !important;
 `),
        c$1("&::before", `
 bottom: 0 !important;
 `)
      ]), cM("summary", `
 background-color: var(--n-merged-th-color);
 `), cM("hover", `
 background-color: var(--n-merged-td-color-hover);
 `), cE("ellipsis", `
 display: inline-block;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 vertical-align: bottom;
 `), cM("selection, expand", `
 text-align: center;
 padding: 0;
 line-height: 0;
 `), fixedColumnStyle]), cB("data-table-empty", `
 box-sizing: border-box;
 padding: var(--n-empty-padding);
 flex-grow: 1;
 flex-shrink: 0;
 opacity: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: opacity .3s var(--n-bezier);
 `, [cM("hide", `
 opacity: 0;
 `)]), cE("pagination", `
 margin: var(--n-pagination-margin);
 display: flex;
 justify-content: flex-end;
 `), cB("data-table-wrapper", `
 position: relative;
 opacity: 1;
 transition: opacity .3s var(--n-bezier), border-color .3s var(--n-bezier);
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 line-height: var(--n-line-height);
 `), cM("loading", [cB("data-table-wrapper", `
 opacity: var(--n-opacity-loading);
 pointer-events: none;
 `)]), cM("single-column", [cB("data-table-td", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [c$1("&::after, &::before", `
 bottom: 0 !important;
 `)])]), cNotM("single-line", [cB("data-table-th", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last", `
 border-right: 0 solid var(--n-merged-border-color);
 `)]), cB("data-table-td", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last-col", `
 border-right: 0 solid var(--n-merged-border-color);
 `)])]), cM("bordered", [cB("data-table-wrapper", `
 border: 1px solid var(--n-merged-border-color);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 overflow: hidden;
 `)]), cB("data-table-base-table", [cM("transition-disabled", [cB("data-table-th", [c$1("&::after, &::before", "transition: none;")]), cB("data-table-td", [c$1("&::after, &::before", "transition: none;")])])]), cM("bottom-bordered", [cB("data-table-td", [cM("last-row", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)])]), cB("data-table-table", `
 font-variant-numeric: tabular-nums;
 width: 100%;
 word-break: break-word;
 transition: background-color .3s var(--n-bezier);
 border-collapse: separate;
 border-spacing: 0;
 background-color: var(--n-merged-td-color);
 `), cB("data-table-base-table-header", `
 border-top-left-radius: calc(var(--n-border-radius) - 1px);
 border-top-right-radius: calc(var(--n-border-radius) - 1px);
 z-index: 3;
 overflow: scroll;
 flex-shrink: 0;
 transition: border-color .3s var(--n-bezier);
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), cB("data-table-check-extra", `
 transition: color .3s var(--n-bezier);
 color: var(--n-th-icon-color);
 position: absolute;
 font-size: 14px;
 right: -4px;
 top: 50%;
 transform: translateY(-50%);
 z-index: 1;
 `)]), cB("data-table-filter-menu", [cB("scrollbar", `
 max-height: 240px;
 `), cE("group", `
 display: flex;
 flex-direction: column;
 padding: 12px 12px 0 12px;
 `, [cB("checkbox", `
 margin-bottom: 12px;
 margin-right: 0;
 `), cB("radio", `
 margin-bottom: 12px;
 margin-right: 0;
 `)]), cE("action", `
 padding: var(--n-action-padding);
 display: flex;
 flex-wrap: nowrap;
 justify-content: space-evenly;
 border-top: 1px solid var(--n-action-divider-color);
 `, [cB("button", [c$1("&:not(:last-child)", `
 margin: var(--n-action-button-margin);
 `), c$1("&:last-child", `
 margin-right: 0;
 `)])]), cB("divider", `
 margin: 0 !important;
 `)]), insideModal(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 --n-merged-th-color-hover: var(--n-th-color-hover-modal);
 --n-merged-td-color-hover: var(--n-td-color-hover-modal);
 --n-merged-td-color-striped: var(--n-td-color-striped-modal);
 `)), insidePopover(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 --n-merged-th-color-hover: var(--n-th-color-hover-popover);
 --n-merged-td-color-hover: var(--n-td-color-hover-popover);
 --n-merged-td-color-striped: var(--n-td-color-striped-popover);
 `))]);
      function createFixedColumnStyle() {
        return [cM("fixed-left", `
 left: 0;
 position: sticky;
 z-index: 2;
 `, [c$1("&::after", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 right: -36px;
 `)]), cM("fixed-right", `
 right: 0;
 position: sticky;
 z-index: 1;
 `, [c$1("&::before", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 left: -36px;
 `)])];
      }
      const DataTable = vue.defineComponent({
        name: "DataTable",
        alias: ["AdvancedTable"],
        props: dataTableProps,
        setup(props, { slots }) {
          const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const mergedBottomBorderedRef = vue.computed(() => {
            const { bottomBordered } = props;
            if (mergedBorderedRef.value)
              return false;
            if (bottomBordered !== void 0)
              return bottomBordered;
            return true;
          });
          const themeRef = useTheme("DataTable", "-data-table", style$T, dataTableLight$1, props, mergedClsPrefixRef);
          const bodyWidthRef = vue.ref(null);
          const scrollPartRef = vue.ref("body");
          vue.onDeactivated(() => {
            scrollPartRef.value = "body";
          });
          const mainTableInstRef = vue.ref(null);
          const { getResizableWidth, clearResizableWidth, doUpdateResizableWidth } = useResizable();
          const { rowsRef, colsRef, dataRelatedColsRef, hasEllipsisRef } = useGroupHeader(props, getResizableWidth);
          const { treeMateRef, mergedCurrentPageRef, paginatedDataRef, rawPaginatedDataRef, selectionColumnRef, hoverKeyRef, mergedPaginationRef, mergedFilterStateRef, mergedSortStateRef, childTriggerColIndexRef, doUpdatePage, doUpdateFilters, onUnstableColumnResize, deriveNextSorter, filter, filters, clearFilter, clearFilters, clearSorter, page, sort } = useTableData(props, { dataRelatedColsRef });
          const { doCheckAll, doUncheckAll, doCheck, doUncheck, headerCheckboxDisabledRef, someRowsCheckedRef, allRowsCheckedRef, mergedCheckedRowKeySetRef, mergedInderminateRowKeySetRef } = useCheck(props, {
            selectionColumnRef,
            treeMateRef,
            paginatedDataRef
          });
          const { stickyExpandedRowsRef, mergedExpandedRowKeysRef, renderExpandRef, expandableRef, doUpdateExpandedRowKeys } = useExpand(props, treeMateRef);
          const { handleTableBodyScroll, handleTableHeaderScroll, syncScrollState, setHeaderScrollLeft, leftActiveFixedColKeyRef, leftActiveFixedChildrenColKeysRef, rightActiveFixedColKeyRef, rightActiveFixedChildrenColKeysRef, leftFixedColumnsRef, rightFixedColumnsRef, fixedColumnLeftMapRef, fixedColumnRightMapRef } = useScroll(props, {
            scrollPartRef,
            bodyWidthRef,
            mainTableInstRef,
            mergedCurrentPageRef
          });
          const { localeRef } = useLocale("DataTable");
          const mergedTableLayoutRef = vue.computed(() => {
            if (props.virtualScroll || props.flexHeight || props.maxHeight !== void 0 || hasEllipsisRef.value) {
              return "fixed";
            }
            return props.tableLayout;
          });
          vue.provide(dataTableInjectionKey, {
            props,
            treeMateRef,
            renderExpandIconRef: vue.toRef(props, "renderExpandIcon"),
            loadingKeySetRef: vue.ref(/* @__PURE__ */ new Set()),
            slots,
            indentRef: vue.toRef(props, "indent"),
            childTriggerColIndexRef,
            bodyWidthRef,
            componentId: createId(),
            hoverKeyRef,
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            scrollXRef: vue.computed(() => props.scrollX),
            rowsRef,
            colsRef,
            paginatedDataRef,
            leftActiveFixedColKeyRef,
            leftActiveFixedChildrenColKeysRef,
            rightActiveFixedColKeyRef,
            rightActiveFixedChildrenColKeysRef,
            leftFixedColumnsRef,
            rightFixedColumnsRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef,
            mergedCurrentPageRef,
            someRowsCheckedRef,
            allRowsCheckedRef,
            mergedSortStateRef,
            mergedFilterStateRef,
            loadingRef: vue.toRef(props, "loading"),
            rowClassNameRef: vue.toRef(props, "rowClassName"),
            mergedCheckedRowKeySetRef,
            mergedExpandedRowKeysRef,
            mergedInderminateRowKeySetRef,
            localeRef,
            scrollPartRef,
            expandableRef,
            stickyExpandedRowsRef,
            rowKeyRef: vue.toRef(props, "rowKey"),
            renderExpandRef,
            summaryRef: vue.toRef(props, "summary"),
            virtualScrollRef: vue.toRef(props, "virtualScroll"),
            rowPropsRef: vue.toRef(props, "rowProps"),
            stripedRef: vue.toRef(props, "striped"),
            checkOptionsRef: vue.computed(() => {
              const { value: selectionColumn } = selectionColumnRef;
              return selectionColumn === null || selectionColumn === void 0 ? void 0 : selectionColumn.options;
            }),
            rawPaginatedDataRef,
            filterMenuCssVarsRef: vue.computed(() => {
              const { self: { actionDividerColor, actionPadding, actionButtonMargin } } = themeRef.value;
              return {
                "--n-action-padding": actionPadding,
                "--n-action-button-margin": actionButtonMargin,
                "--n-action-divider-color": actionDividerColor
              };
            }),
            onLoadRef: vue.toRef(props, "onLoad"),
            mergedTableLayoutRef,
            maxHeightRef: vue.toRef(props, "maxHeight"),
            minHeightRef: vue.toRef(props, "minHeight"),
            flexHeightRef: vue.toRef(props, "flexHeight"),
            headerCheckboxDisabledRef,
            paginationBehaviorOnFilterRef: vue.toRef(props, "paginationBehaviorOnFilter"),
            summaryPlacementRef: vue.toRef(props, "summaryPlacement"),
            scrollbarPropsRef: vue.toRef(props, "scrollbarProps"),
            syncScrollState,
            doUpdatePage,
            doUpdateFilters,
            getResizableWidth,
            onUnstableColumnResize,
            clearResizableWidth,
            doUpdateResizableWidth,
            deriveNextSorter,
            doCheck,
            doUncheck,
            doCheckAll,
            doUncheckAll,
            doUpdateExpandedRowKeys,
            handleTableHeaderScroll,
            handleTableBodyScroll,
            setHeaderScrollLeft,
            renderCell: vue.toRef(props, "renderCell")
          });
          const exposedMethods = {
            filter,
            filters,
            clearFilters,
            clearSorter,
            page,
            sort,
            clearFilter,
            scrollTo: (arg0, arg1) => {
              var _a;
              (_a = mainTableInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
            }
          };
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { borderColor, tdColorHover, thColor, thColorHover, tdColor, tdTextColor, thTextColor, thFontWeight, thButtonColorHover, thIconColor, thIconColorActive, filterSize, borderRadius, lineHeight: lineHeight2, tdColorModal, thColorModal, borderColorModal, thColorHoverModal, tdColorHoverModal, borderColorPopover, thColorPopover, tdColorPopover, tdColorHoverPopover, thColorHoverPopover, paginationMargin, emptyPadding, boxShadowAfter, boxShadowBefore, sorterSize, resizableContainerSize, resizableSize, loadingColor, loadingSize, opacityLoading, tdColorStriped, tdColorStripedModal, tdColorStripedPopover, [createKey("fontSize", size2)]: fontSize2, [createKey("thPadding", size2)]: thPadding, [createKey("tdPadding", size2)]: tdPadding } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-th-padding": thPadding,
              "--n-td-padding": tdPadding,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-line-height": lineHeight2,
              "--n-border-color": borderColor,
              "--n-border-color-modal": borderColorModal,
              "--n-border-color-popover": borderColorPopover,
              "--n-th-color": thColor,
              "--n-th-color-hover": thColorHover,
              "--n-th-color-modal": thColorModal,
              "--n-th-color-hover-modal": thColorHoverModal,
              "--n-th-color-popover": thColorPopover,
              "--n-th-color-hover-popover": thColorHoverPopover,
              "--n-td-color": tdColor,
              "--n-td-color-hover": tdColorHover,
              "--n-td-color-modal": tdColorModal,
              "--n-td-color-hover-modal": tdColorHoverModal,
              "--n-td-color-popover": tdColorPopover,
              "--n-td-color-hover-popover": tdColorHoverPopover,
              "--n-th-text-color": thTextColor,
              "--n-td-text-color": tdTextColor,
              "--n-th-font-weight": thFontWeight,
              "--n-th-button-color-hover": thButtonColorHover,
              "--n-th-icon-color": thIconColor,
              "--n-th-icon-color-active": thIconColorActive,
              "--n-filter-size": filterSize,
              "--n-pagination-margin": paginationMargin,
              "--n-empty-padding": emptyPadding,
              "--n-box-shadow-before": boxShadowBefore,
              "--n-box-shadow-after": boxShadowAfter,
              "--n-sorter-size": sorterSize,
              "--n-resizable-container-size": resizableContainerSize,
              "--n-resizable-size": resizableSize,
              "--n-loading-size": loadingSize,
              "--n-loading-color": loadingColor,
              "--n-opacity-loading": opacityLoading,
              "--n-td-color-striped": tdColorStriped,
              "--n-td-color-striped-modal": tdColorStripedModal,
              "--n-td-color-striped-popover": tdColorStripedPopover
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("data-table", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
          const mergedShowPaginationRef = vue.computed(() => {
            if (!props.pagination)
              return false;
            if (props.paginateSinglePage)
              return true;
            const mergedPagination = mergedPaginationRef.value;
            const { pageCount } = mergedPagination;
            if (pageCount !== void 0)
              return pageCount > 1;
            return mergedPagination.itemCount && mergedPagination.pageSize && mergedPagination.itemCount > mergedPagination.pageSize;
          });
          return Object.assign({ mainTableInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, paginatedData: paginatedDataRef, mergedBordered: mergedBorderedRef, mergedBottomBordered: mergedBottomBorderedRef, mergedPagination: mergedPaginationRef, mergedShowPagination: mergedShowPaginationRef, cssVars: inlineThemeDisabled ? void 0 : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
        },
        render() {
          const { mergedClsPrefix, themeClass, onRender, $slots, spinProps: spinProps2 } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-data-table`,
              themeClass,
              {
                [`${mergedClsPrefix}-data-table--bordered`]: this.mergedBordered,
                [`${mergedClsPrefix}-data-table--bottom-bordered`]: this.mergedBottomBordered,
                [`${mergedClsPrefix}-data-table--single-line`]: this.singleLine,
                [`${mergedClsPrefix}-data-table--single-column`]: this.singleColumn,
                [`${mergedClsPrefix}-data-table--loading`]: this.loading,
                [`${mergedClsPrefix}-data-table--flex-height`]: this.flexHeight
              }
            ], style: this.cssVars },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-data-table-wrapper` },
              vue.h(MainTable, { ref: "mainTableInstRef" })
            ),
            this.mergedShowPagination ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-data-table__pagination` },
              vue.h(NPagination, Object.assign({ theme: this.mergedTheme.peers.Pagination, themeOverrides: this.mergedTheme.peerOverrides.Pagination, disabled: this.loading }, this.mergedPagination))
            ) : null,
            vue.h(vue.Transition, { name: "fade-in-scale-up-transition" }, {
              default: () => {
                return this.loading ? vue.h("div", { class: `${mergedClsPrefix}-data-table-loading-wrapper` }, resolveSlot($slots.loading, () => [
                  vue.h(NBaseLoading, Object.assign({ clsPrefix: mergedClsPrefix, strokeWidth: 20 }, spinProps2))
                ])) : null;
              }
            })
          );
        }
      });
      const commonVars$7 = {
        itemFontSize: "12px",
        itemHeight: "36px",
        itemWidth: "52px",
        panelActionPadding: "8px 0"
      };
      const self$I = (vars) => {
        const { popoverColor, textColor2, primaryColor, hoverColor, dividerColor, opacityDisabled, boxShadow2, borderRadius, iconColor, iconColorDisabled } = vars;
        return Object.assign(Object.assign({}, commonVars$7), {
          panelColor: popoverColor,
          panelBoxShadow: boxShadow2,
          panelDividerColor: dividerColor,
          itemTextColor: textColor2,
          itemTextColorActive: primaryColor,
          itemColorHover: hoverColor,
          itemOpacityDisabled: opacityDisabled,
          itemBorderRadius: borderRadius,
          borderRadius,
          iconColor,
          iconColorDisabled
        });
      };
      const timePickerLight = createTheme({
        name: "TimePicker",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1,
          Button: buttonLight$1,
          Input: inputLight$1
        },
        self: self$I
      });
      const timePickerLight$1 = timePickerLight;
      const timePickerDark = {
        name: "TimePicker",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1,
          Button: buttonDark$1,
          Input: inputDark$1
        },
        self: self$I
      };
      const timePickerDark$1 = timePickerDark;
      const commonVars$6 = {
        itemSize: "24px",
        itemCellWidth: "38px",
        itemCellHeight: "32px",
        scrollItemWidth: "80px",
        scrollItemHeight: "40px",
        panelExtraFooterPadding: "8px 12px",
        panelActionPadding: "8px 12px",
        calendarTitlePadding: "0",
        calendarTitleHeight: "28px",
        arrowSize: "14px",
        panelHeaderPadding: "8px 12px",
        calendarDaysHeight: "32px",
        calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
        // type
        calendarLeftPaddingDate: "6px 12px 4px 12px",
        calendarLeftPaddingDatetime: "4px 12px",
        calendarLeftPaddingDaterange: "6px 12px 4px 12px",
        calendarLeftPaddingDatetimerange: "4px 12px",
        calendarLeftPaddingMonth: "0",
        calendarLeftPaddingYear: "0",
        calendarLeftPaddingQuarter: "0",
        calendarLeftPaddingMonthrange: "0",
        calendarLeftPaddingQuarterrange: "0",
        calendarLeftPaddingYearrange: "0",
        calendarRightPaddingDate: "6px 12px 4px 12px",
        calendarRightPaddingDatetime: "4px 12px",
        calendarRightPaddingDaterange: "6px 12px 4px 12px",
        calendarRightPaddingDatetimerange: "4px 12px",
        calendarRightPaddingMonth: "0",
        calendarRightPaddingYear: "0",
        calendarRightPaddingQuarter: "0",
        calendarRightPaddingMonthrange: "0",
        calendarRightPaddingQuarterrange: "0",
        calendarRightPaddingYearrange: "0"
      };
      const self$H = (vars) => {
        const { hoverColor, fontSize: fontSize2, textColor2, textColorDisabled, popoverColor, primaryColor, borderRadiusSmall, iconColor, iconColorDisabled, textColor1, dividerColor, boxShadow2, borderRadius, fontWeightStrong } = vars;
        return Object.assign(Object.assign({}, commonVars$6), {
          itemFontSize: fontSize2,
          calendarDaysFontSize: fontSize2,
          calendarTitleFontSize: fontSize2,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemTextColorActive: popoverColor,
          itemTextColorCurrent: primaryColor,
          itemColorIncluded: changeColor(primaryColor, { alpha: 0.1 }),
          itemColorHover: hoverColor,
          itemColorDisabled: hoverColor,
          itemColorActive: primaryColor,
          itemBorderRadius: borderRadiusSmall,
          panelColor: popoverColor,
          panelTextColor: textColor2,
          arrowColor: iconColor,
          calendarTitleTextColor: textColor1,
          calendarTitleColorHover: hoverColor,
          calendarDaysTextColor: textColor2,
          panelHeaderDividerColor: dividerColor,
          calendarDaysDividerColor: dividerColor,
          calendarDividerColor: dividerColor,
          panelActionDividerColor: dividerColor,
          panelBoxShadow: boxShadow2,
          panelBorderRadius: borderRadius,
          calendarTitleFontWeight: fontWeightStrong,
          scrollItemBorderRadius: borderRadius,
          iconColor,
          iconColorDisabled
        });
      };
      const datePickerLight = createTheme({
        name: "DatePicker",
        common: commonLight,
        peers: {
          Input: inputLight$1,
          Button: buttonLight$1,
          TimePicker: timePickerLight$1,
          Scrollbar: scrollbarLight$1
        },
        self: self$H
      });
      const datePickerLight$1 = datePickerLight;
      const datePickerDark = {
        name: "DatePicker",
        common: commonDark,
        peers: {
          Input: inputDark$1,
          Button: buttonDark$1,
          TimePicker: timePickerDark$1,
          Scrollbar: scrollbarDark$1
        },
        self(vars) {
          const { popoverColor, hoverColor, primaryColor } = vars;
          const commonSelf = self$H(vars);
          commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
          commonSelf.itemColorIncluded = changeColor(primaryColor, { alpha: 0.15 });
          commonSelf.itemColorHover = composite(popoverColor, hoverColor);
          return commonSelf;
        }
      };
      const datePickerDark$1 = datePickerDark;
      function uniCalendarValidation(props, mergedValueRef) {
        const timePickerValidatorRef = vue.computed(() => {
          const { isTimeDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null || Array.isArray(value))
            return void 0;
          return isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value);
        });
        const isHourDisabledRef = vue.computed(() => {
          var _a;
          return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
        });
        const isMinuteDisabledRef = vue.computed(() => {
          var _a;
          return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
        });
        const isSecondDisabledRef = vue.computed(() => {
          var _a;
          return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
        });
        const isDateInvalidRef = vue.computed(() => {
          const { type: type2, isDateDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null || Array.isArray(value) || !["date", "datetime"].includes(type2) || !isDateDisabled) {
            return false;
          }
          return isDateDisabled(value);
        });
        const isTimeInvalidRef = vue.computed(() => {
          const { type: type2 } = props;
          const { value } = mergedValueRef;
          if (value === null || !(type2 !== "datetime") || Array.isArray(value)) {
            return false;
          }
          const time2 = new Date(value);
          const hour = time2.getHours();
          const minute = time2.getMinutes();
          const second = time2.getMinutes();
          return (isHourDisabledRef.value ? isHourDisabledRef.value(hour) : false) || (isMinuteDisabledRef.value ? isMinuteDisabledRef.value(minute, hour) : false) || (isSecondDisabledRef.value ? isSecondDisabledRef.value(second, minute, hour) : false);
        });
        const isDateTimeInvalidRef = vue.computed(() => {
          return isDateInvalidRef.value || isTimeInvalidRef.value;
        });
        const isValueInvalidRef = vue.computed(() => {
          const { type: type2 } = props;
          if (type2 === "date")
            return isDateInvalidRef.value;
          if (type2 === "datetime")
            return isDateTimeInvalidRef.value;
          return false;
        });
        return {
          // date & datetime
          isValueInvalidRef,
          isDateInvalidRef,
          // datetime only
          isTimeInvalidRef,
          isDateTimeInvalidRef,
          isHourDisabledRef,
          isMinuteDisabledRef,
          isSecondDisabledRef
        };
      }
      function dualCalendarValidation(props, mergedValueRef) {
        const timePickerValidatorRef = vue.computed(() => {
          const { isTimeDisabled } = props;
          const { value } = mergedValueRef;
          if (!Array.isArray(value) || !isTimeDisabled) {
            return [void 0, void 0];
          }
          return [
            isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[0], "start", value),
            isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[1], "end", value)
          ];
        });
        const timeValidator = {
          isStartHourDisabledRef: vue.computed(() => {
            var _a;
            return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
          }),
          isEndHourDisabledRef: vue.computed(() => {
            var _a;
            return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
          }),
          isStartMinuteDisabledRef: vue.computed(() => {
            var _a;
            return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
          }),
          isEndMinuteDisabledRef: vue.computed(() => {
            var _a;
            return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
          }),
          isStartSecondDisabledRef: vue.computed(() => {
            var _a;
            return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
          }),
          isEndSecondDisabledRef: vue.computed(() => {
            var _a;
            return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
          })
        };
        const isStartDateInvalidRef = vue.computed(() => {
          const { type: type2, isDateDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null || !Array.isArray(value) || !["daterange", "datetimerange"].includes(type2) || !isDateDisabled) {
            return false;
          }
          return isDateDisabled(value[0], "start", value);
        });
        const isEndDateInvalidRef = vue.computed(() => {
          const { type: type2, isDateDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null || !Array.isArray(value) || !["daterange", "datetimerange"].includes(type2) || !isDateDisabled) {
            return false;
          }
          return isDateDisabled(value[1], "end", value);
        });
        const isStartTimeInvalidRef = vue.computed(() => {
          const { type: type2 } = props;
          const { value } = mergedValueRef;
          if (value === null || !Array.isArray(value) || type2 !== "datetimerange") {
            return false;
          }
          const startHours = getHours(value[0]);
          const startMinutes = getMinutes(value[0]);
          const startSeconds = getSeconds(value[0]);
          const { isStartHourDisabledRef, isStartMinuteDisabledRef, isStartSecondDisabledRef } = timeValidator;
          const startTimeInvalid = (isStartHourDisabledRef.value ? isStartHourDisabledRef.value(startHours) : false) || (isStartMinuteDisabledRef.value ? isStartMinuteDisabledRef.value(startMinutes, startHours) : false) || (isStartSecondDisabledRef.value ? isStartSecondDisabledRef.value(startSeconds, startMinutes, startHours) : false);
          return startTimeInvalid;
        });
        const isEndTimeInvalidRef = vue.computed(() => {
          const { type: type2 } = props;
          const { value } = mergedValueRef;
          if (value === null || !Array.isArray(value) || type2 !== "datetimerange") {
            return false;
          }
          const endHours = getHours(value[1]);
          const endMinutes = getMinutes(value[1]);
          const endSeconds = getSeconds(value[1]);
          const { isEndHourDisabledRef, isEndMinuteDisabledRef, isEndSecondDisabledRef } = timeValidator;
          const endTimeInvalid = (isEndHourDisabledRef.value ? isEndHourDisabledRef.value(endHours) : false) || (isEndMinuteDisabledRef.value ? isEndMinuteDisabledRef.value(endMinutes, endHours) : false) || (isEndSecondDisabledRef.value ? isEndSecondDisabledRef.value(endSeconds, endMinutes, endHours) : false);
          return endTimeInvalid;
        });
        const isStartValueInvalidRef = vue.computed(() => {
          return isStartDateInvalidRef.value || isStartTimeInvalidRef.value;
        });
        const isEndValueInvalidRef = vue.computed(() => {
          return isEndDateInvalidRef.value || isEndTimeInvalidRef.value;
        });
        const isRangeInvalidRef = vue.computed(() => {
          return isStartValueInvalidRef.value || isEndValueInvalidRef.value;
        });
        return Object.assign(Object.assign({}, timeValidator), {
          isStartDateInvalidRef,
          isEndDateInvalidRef,
          isStartTimeInvalidRef,
          isEndTimeInvalidRef,
          isStartValueInvalidRef,
          isEndValueInvalidRef,
          isRangeInvalidRef
        });
      }
      const datePickerInjectionKey = createInjectionKey("n-date-picker");
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var cloneObject$1 = { exports: {} };
      var interopRequireDefault = { exports: {} };
      (function(module2) {
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }
        module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      })(interopRequireDefault);
      var interopRequireDefaultExports = interopRequireDefault.exports;
      var assign$1 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = assign2;
        function assign2(target, object2) {
          if (target == null) {
            throw new TypeError("assign requires that input parameter not be null or undefined");
          }
          for (var property2 in object2) {
            if (Object.prototype.hasOwnProperty.call(object2, property2)) {
              target[property2] = object2[property2];
            }
          }
          return target;
        }
        module2.exports = exports2.default;
      })(assign$1, assign$1.exports);
      var assignExports = assign$1.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = cloneObject2;
        var _index = _interopRequireDefault(assignExports);
        function cloneObject2(object2) {
          return (0, _index.default)({}, object2);
        }
        module2.exports = exports2.default;
      })(cloneObject$1, cloneObject$1.exports);
      var cloneObjectExports = cloneObject$1.exports;
      const cloneObject = /* @__PURE__ */ getDefaultExportFromCjs(cloneObjectExports);
      var format$3 = { exports: {} };
      var isValid = { exports: {} };
      var isDate$1 = { exports: {} };
      var _typeof = { exports: {} };
      (function(module2) {
        function _typeof2(o) {
          "@babel/helpers - typeof";
          return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(o);
        }
        module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      })(_typeof);
      var _typeofExports = _typeof.exports;
      var requiredArgs = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = requiredArgs2;
        function requiredArgs2(required2, args) {
          if (args.length < required2) {
            throw new TypeError(required2 + " argument" + (required2 > 1 ? "s" : "") + " required, but only " + args.length + " present");
          }
        }
        module2.exports = exports2.default;
      })(requiredArgs, requiredArgs.exports);
      var requiredArgsExports = requiredArgs.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = isDate2;
        var _typeof2 = _interopRequireDefault(_typeofExports);
        var _index = _interopRequireDefault(requiredArgsExports);
        function isDate2(value) {
          (0, _index.default)(1, arguments);
          return value instanceof Date || (0, _typeof2.default)(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
        }
        module2.exports = exports2.default;
      })(isDate$1, isDate$1.exports);
      var isDateExports = isDate$1.exports;
      var toDate$1 = { exports: {} };
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = toDate2;
        var _typeof2 = _interopRequireDefault(_typeofExports);
        var _index = _interopRequireDefault(requiredArgsExports);
        function toDate2(argument) {
          (0, _index.default)(1, arguments);
          var argStr = Object.prototype.toString.call(argument);
          if (argument instanceof Date || (0, _typeof2.default)(argument) === "object" && argStr === "[object Date]") {
            return new Date(argument.getTime());
          } else if (typeof argument === "number" || argStr === "[object Number]") {
            return new Date(argument);
          } else {
            if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
              console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
              console.warn(new Error().stack);
            }
            return /* @__PURE__ */ new Date(NaN);
          }
        }
        module2.exports = exports2.default;
      })(toDate$1, toDate$1.exports);
      var toDateExports = toDate$1.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = isValid2;
        var _index = _interopRequireDefault(isDateExports);
        var _index2 = _interopRequireDefault(toDateExports);
        var _index3 = _interopRequireDefault(requiredArgsExports);
        function isValid2(dirtyDate) {
          (0, _index3.default)(1, arguments);
          if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== "number") {
            return false;
          }
          var date2 = (0, _index2.default)(dirtyDate);
          return !isNaN(Number(date2));
        }
        module2.exports = exports2.default;
      })(isValid, isValid.exports);
      var isValidExports = isValid.exports;
      var subMilliseconds = { exports: {} };
      var addMilliseconds = { exports: {} };
      var toInteger$1 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = toInteger2;
        function toInteger2(dirtyNumber) {
          if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
            return NaN;
          }
          var number2 = Number(dirtyNumber);
          if (isNaN(number2)) {
            return number2;
          }
          return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
        }
        module2.exports = exports2.default;
      })(toInteger$1, toInteger$1.exports);
      var toIntegerExports = toInteger$1.exports;
      const toInteger = /* @__PURE__ */ getDefaultExportFromCjs(toIntegerExports);
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = addMilliseconds2;
        var _index = _interopRequireDefault(toIntegerExports);
        var _index2 = _interopRequireDefault(toDateExports);
        var _index3 = _interopRequireDefault(requiredArgsExports);
        function addMilliseconds2(dirtyDate, dirtyAmount) {
          (0, _index3.default)(2, arguments);
          var timestamp = (0, _index2.default)(dirtyDate).getTime();
          var amount = (0, _index.default)(dirtyAmount);
          return new Date(timestamp + amount);
        }
        module2.exports = exports2.default;
      })(addMilliseconds, addMilliseconds.exports);
      var addMillisecondsExports = addMilliseconds.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = subMilliseconds2;
        var _index = _interopRequireDefault(addMillisecondsExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        var _index3 = _interopRequireDefault(toIntegerExports);
        function subMilliseconds2(dirtyDate, dirtyAmount) {
          (0, _index2.default)(2, arguments);
          var amount = (0, _index3.default)(dirtyAmount);
          return (0, _index.default)(dirtyDate, -amount);
        }
        module2.exports = exports2.default;
      })(subMilliseconds, subMilliseconds.exports);
      var subMillisecondsExports = subMilliseconds.exports;
      var formatters$2 = { exports: {} };
      var getUTCDayOfYear = { exports: {} };
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = getUTCDayOfYear2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        var MILLISECONDS_IN_DAY2 = 864e5;
        function getUTCDayOfYear2(dirtyDate) {
          (0, _index2.default)(1, arguments);
          var date2 = (0, _index.default)(dirtyDate);
          var timestamp = date2.getTime();
          date2.setUTCMonth(0, 1);
          date2.setUTCHours(0, 0, 0, 0);
          var startOfYearTimestamp = date2.getTime();
          var difference = timestamp - startOfYearTimestamp;
          return Math.floor(difference / MILLISECONDS_IN_DAY2) + 1;
        }
        module2.exports = exports2.default;
      })(getUTCDayOfYear, getUTCDayOfYear.exports);
      var getUTCDayOfYearExports = getUTCDayOfYear.exports;
      var getUTCISOWeek = { exports: {} };
      var startOfUTCISOWeek = { exports: {} };
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = startOfUTCISOWeek2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        function startOfUTCISOWeek2(dirtyDate) {
          (0, _index2.default)(1, arguments);
          var weekStartsOn = 1;
          var date2 = (0, _index.default)(dirtyDate);
          var day = date2.getUTCDay();
          var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
          date2.setUTCDate(date2.getUTCDate() - diff);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
        module2.exports = exports2.default;
      })(startOfUTCISOWeek, startOfUTCISOWeek.exports);
      var startOfUTCISOWeekExports = startOfUTCISOWeek.exports;
      var startOfUTCISOWeekYear = { exports: {} };
      var getUTCISOWeekYear = { exports: {} };
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = getUTCISOWeekYear2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        var _index3 = _interopRequireDefault(startOfUTCISOWeekExports);
        function getUTCISOWeekYear2(dirtyDate) {
          (0, _index2.default)(1, arguments);
          var date2 = (0, _index.default)(dirtyDate);
          var year = date2.getUTCFullYear();
          var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
          fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
          fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
          var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
          var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
          fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
          fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
          var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
          if (date2.getTime() >= startOfNextYear.getTime()) {
            return year + 1;
          } else if (date2.getTime() >= startOfThisYear.getTime()) {
            return year;
          } else {
            return year - 1;
          }
        }
        module2.exports = exports2.default;
      })(getUTCISOWeekYear, getUTCISOWeekYear.exports);
      var getUTCISOWeekYearExports = getUTCISOWeekYear.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = startOfUTCISOWeekYear2;
        var _index = _interopRequireDefault(getUTCISOWeekYearExports);
        var _index2 = _interopRequireDefault(startOfUTCISOWeekExports);
        var _index3 = _interopRequireDefault(requiredArgsExports);
        function startOfUTCISOWeekYear2(dirtyDate) {
          (0, _index3.default)(1, arguments);
          var year = (0, _index.default)(dirtyDate);
          var fourthOfJanuary = /* @__PURE__ */ new Date(0);
          fourthOfJanuary.setUTCFullYear(year, 0, 4);
          fourthOfJanuary.setUTCHours(0, 0, 0, 0);
          var date2 = (0, _index2.default)(fourthOfJanuary);
          return date2;
        }
        module2.exports = exports2.default;
      })(startOfUTCISOWeekYear, startOfUTCISOWeekYear.exports);
      var startOfUTCISOWeekYearExports = startOfUTCISOWeekYear.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = getUTCISOWeek2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(startOfUTCISOWeekExports);
        var _index3 = _interopRequireDefault(startOfUTCISOWeekYearExports);
        var _index4 = _interopRequireDefault(requiredArgsExports);
        var MILLISECONDS_IN_WEEK2 = 6048e5;
        function getUTCISOWeek2(dirtyDate) {
          (0, _index4.default)(1, arguments);
          var date2 = (0, _index.default)(dirtyDate);
          var diff = (0, _index2.default)(date2).getTime() - (0, _index3.default)(date2).getTime();
          return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
        }
        module2.exports = exports2.default;
      })(getUTCISOWeek, getUTCISOWeek.exports);
      var getUTCISOWeekExports = getUTCISOWeek.exports;
      var getUTCWeek = { exports: {} };
      var startOfUTCWeek = { exports: {} };
      var defaultOptions$1 = {};
      Object.defineProperty(defaultOptions$1, "__esModule", {
        value: true
      });
      defaultOptions$1.getDefaultOptions = getDefaultOptions;
      defaultOptions$1.setDefaultOptions = setDefaultOptions;
      var defaultOptions = {};
      function getDefaultOptions() {
        return defaultOptions;
      }
      function setDefaultOptions(newOptions) {
        defaultOptions = newOptions;
      }
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = startOfUTCWeek2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        var _index3 = _interopRequireDefault(toIntegerExports);
        var _index4 = defaultOptions$1;
        function startOfUTCWeek2(dirtyDate, options) {
          var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
          (0, _index2.default)(1, arguments);
          var defaultOptions2 = (0, _index4.getDefaultOptions)();
          var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
          }
          var date2 = (0, _index.default)(dirtyDate);
          var day = date2.getUTCDay();
          var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
          date2.setUTCDate(date2.getUTCDate() - diff);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
        module2.exports = exports2.default;
      })(startOfUTCWeek, startOfUTCWeek.exports);
      var startOfUTCWeekExports = startOfUTCWeek.exports;
      var startOfUTCWeekYear = { exports: {} };
      var getUTCWeekYear = { exports: {} };
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = getUTCWeekYear2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        var _index3 = _interopRequireDefault(startOfUTCWeekExports);
        var _index4 = _interopRequireDefault(toIntegerExports);
        var _index5 = defaultOptions$1;
        function getUTCWeekYear2(dirtyDate, options) {
          var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
          (0, _index2.default)(1, arguments);
          var date2 = (0, _index.default)(dirtyDate);
          var year = date2.getUTCFullYear();
          var defaultOptions2 = (0, _index5.getDefaultOptions)();
          var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
          if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
          }
          var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
          firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
          firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
          var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
          var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
          firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
          firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
          var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
          if (date2.getTime() >= startOfNextYear.getTime()) {
            return year + 1;
          } else if (date2.getTime() >= startOfThisYear.getTime()) {
            return year;
          } else {
            return year - 1;
          }
        }
        module2.exports = exports2.default;
      })(getUTCWeekYear, getUTCWeekYear.exports);
      var getUTCWeekYearExports = getUTCWeekYear.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = startOfUTCWeekYear2;
        var _index = _interopRequireDefault(getUTCWeekYearExports);
        var _index2 = _interopRequireDefault(requiredArgsExports);
        var _index3 = _interopRequireDefault(startOfUTCWeekExports);
        var _index4 = _interopRequireDefault(toIntegerExports);
        var _index5 = defaultOptions$1;
        function startOfUTCWeekYear2(dirtyDate, options) {
          var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
          (0, _index2.default)(1, arguments);
          var defaultOptions2 = (0, _index5.getDefaultOptions)();
          var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
          var year = (0, _index.default)(dirtyDate, options);
          var firstWeek = /* @__PURE__ */ new Date(0);
          firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
          firstWeek.setUTCHours(0, 0, 0, 0);
          var date2 = (0, _index3.default)(firstWeek, options);
          return date2;
        }
        module2.exports = exports2.default;
      })(startOfUTCWeekYear, startOfUTCWeekYear.exports);
      var startOfUTCWeekYearExports = startOfUTCWeekYear.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = getUTCWeek2;
        var _index = _interopRequireDefault(toDateExports);
        var _index2 = _interopRequireDefault(startOfUTCWeekExports);
        var _index3 = _interopRequireDefault(startOfUTCWeekYearExports);
        var _index4 = _interopRequireDefault(requiredArgsExports);
        var MILLISECONDS_IN_WEEK2 = 6048e5;
        function getUTCWeek2(dirtyDate, options) {
          (0, _index4.default)(1, arguments);
          var date2 = (0, _index.default)(dirtyDate);
          var diff = (0, _index2.default)(date2, options).getTime() - (0, _index3.default)(date2, options).getTime();
          return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
        }
        module2.exports = exports2.default;
      })(getUTCWeek, getUTCWeek.exports);
      var getUTCWeekExports = getUTCWeek.exports;
      var addLeadingZeros$1 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = addLeadingZeros2;
        function addLeadingZeros2(number2, targetLength) {
          var sign = number2 < 0 ? "-" : "";
          var output = Math.abs(number2).toString();
          while (output.length < targetLength) {
            output = "0" + output;
          }
          return sign + output;
        }
        module2.exports = exports2.default;
      })(addLeadingZeros$1, addLeadingZeros$1.exports);
      var addLeadingZerosExports = addLeadingZeros$1.exports;
      var lightFormatters = { exports: {} };
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(addLeadingZerosExports);
        var formatters2 = {
          // Year
          y: function y(date2, token) {
            var signedYear = date2.getUTCFullYear();
            var year = signedYear > 0 ? signedYear : 1 - signedYear;
            return (0, _index.default)(token === "yy" ? year % 100 : year, token.length);
          },
          // Month
          M: function M(date2, token) {
            var month = date2.getUTCMonth();
            return token === "M" ? String(month + 1) : (0, _index.default)(month + 1, 2);
          },
          // Day of the month
          d: function d(date2, token) {
            return (0, _index.default)(date2.getUTCDate(), token.length);
          },
          // AM or PM
          a: function a2(date2, token) {
            var dayPeriodEnumValue = date2.getUTCHours() / 12 >= 1 ? "pm" : "am";
            switch (token) {
              case "a":
              case "aa":
                return dayPeriodEnumValue.toUpperCase();
              case "aaa":
                return dayPeriodEnumValue;
              case "aaaaa":
                return dayPeriodEnumValue[0];
              case "aaaa":
              default:
                return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
            }
          },
          // Hour [1-12]
          h: function h2(date2, token) {
            return (0, _index.default)(date2.getUTCHours() % 12 || 12, token.length);
          },
          // Hour [0-23]
          H: function H(date2, token) {
            return (0, _index.default)(date2.getUTCHours(), token.length);
          },
          // Minute
          m: function m(date2, token) {
            return (0, _index.default)(date2.getUTCMinutes(), token.length);
          },
          // Second
          s: function s(date2, token) {
            return (0, _index.default)(date2.getUTCSeconds(), token.length);
          },
          // Fraction of second
          S: function S(date2, token) {
            var numberOfDigits = token.length;
            var milliseconds = date2.getUTCMilliseconds();
            var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
            return (0, _index.default)(fractionalSeconds, token.length);
          }
        };
        var _default = formatters2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(lightFormatters, lightFormatters.exports);
      var lightFormattersExports = lightFormatters.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(getUTCDayOfYearExports);
        var _index2 = _interopRequireDefault(getUTCISOWeekExports);
        var _index3 = _interopRequireDefault(getUTCISOWeekYearExports);
        var _index4 = _interopRequireDefault(getUTCWeekExports);
        var _index5 = _interopRequireDefault(getUTCWeekYearExports);
        var _index6 = _interopRequireDefault(addLeadingZerosExports);
        var _index7 = _interopRequireDefault(lightFormattersExports);
        var dayPeriodEnum2 = {
          am: "am",
          pm: "pm",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        };
        var formatters2 = {
          // Era
          G: function G(date2, token, localize2) {
            var era = date2.getUTCFullYear() > 0 ? 1 : 0;
            switch (token) {
              case "G":
              case "GG":
              case "GGG":
                return localize2.era(era, {
                  width: "abbreviated"
                });
              case "GGGGG":
                return localize2.era(era, {
                  width: "narrow"
                });
              case "GGGG":
              default:
                return localize2.era(era, {
                  width: "wide"
                });
            }
          },
          // Year
          y: function y(date2, token, localize2) {
            if (token === "yo") {
              var signedYear = date2.getUTCFullYear();
              var year = signedYear > 0 ? signedYear : 1 - signedYear;
              return localize2.ordinalNumber(year, {
                unit: "year"
              });
            }
            return _index7.default.y(date2, token);
          },
          // Local week-numbering year
          Y: function Y(date2, token, localize2, options) {
            var signedWeekYear = (0, _index5.default)(date2, options);
            var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
            if (token === "YY") {
              var twoDigitYear = weekYear % 100;
              return (0, _index6.default)(twoDigitYear, 2);
            }
            if (token === "Yo") {
              return localize2.ordinalNumber(weekYear, {
                unit: "year"
              });
            }
            return (0, _index6.default)(weekYear, token.length);
          },
          // ISO week-numbering year
          R: function R(date2, token) {
            var isoWeekYear = (0, _index3.default)(date2);
            return (0, _index6.default)(isoWeekYear, token.length);
          },
          // Extended year. This is a single number designating the year of this calendar system.
          // The main difference between `y` and `u` localizers are B.C. years:
          // | Year | `y` | `u` |
          // |------|-----|-----|
          // | AC 1 |   1 |   1 |
          // | BC 1 |   1 |   0 |
          // | BC 2 |   2 |  -1 |
          // Also `yy` always returns the last two digits of a year,
          // while `uu` pads single digit years to 2 characters and returns other years unchanged.
          u: function u(date2, token) {
            var year = date2.getUTCFullYear();
            return (0, _index6.default)(year, token.length);
          },
          // Quarter
          Q: function Q(date2, token, localize2) {
            var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
            switch (token) {
              case "Q":
                return String(quarter);
              case "QQ":
                return (0, _index6.default)(quarter, 2);
              case "Qo":
                return localize2.ordinalNumber(quarter, {
                  unit: "quarter"
                });
              case "QQQ":
                return localize2.quarter(quarter, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "QQQQQ":
                return localize2.quarter(quarter, {
                  width: "narrow",
                  context: "formatting"
                });
              case "QQQQ":
              default:
                return localize2.quarter(quarter, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Stand-alone quarter
          q: function q(date2, token, localize2) {
            var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
            switch (token) {
              case "q":
                return String(quarter);
              case "qq":
                return (0, _index6.default)(quarter, 2);
              case "qo":
                return localize2.ordinalNumber(quarter, {
                  unit: "quarter"
                });
              case "qqq":
                return localize2.quarter(quarter, {
                  width: "abbreviated",
                  context: "standalone"
                });
              case "qqqqq":
                return localize2.quarter(quarter, {
                  width: "narrow",
                  context: "standalone"
                });
              case "qqqq":
              default:
                return localize2.quarter(quarter, {
                  width: "wide",
                  context: "standalone"
                });
            }
          },
          // Month
          M: function M(date2, token, localize2) {
            var month = date2.getUTCMonth();
            switch (token) {
              case "M":
              case "MM":
                return _index7.default.M(date2, token);
              case "Mo":
                return localize2.ordinalNumber(month + 1, {
                  unit: "month"
                });
              case "MMM":
                return localize2.month(month, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "MMMMM":
                return localize2.month(month, {
                  width: "narrow",
                  context: "formatting"
                });
              case "MMMM":
              default:
                return localize2.month(month, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Stand-alone month
          L: function L(date2, token, localize2) {
            var month = date2.getUTCMonth();
            switch (token) {
              case "L":
                return String(month + 1);
              case "LL":
                return (0, _index6.default)(month + 1, 2);
              case "Lo":
                return localize2.ordinalNumber(month + 1, {
                  unit: "month"
                });
              case "LLL":
                return localize2.month(month, {
                  width: "abbreviated",
                  context: "standalone"
                });
              case "LLLLL":
                return localize2.month(month, {
                  width: "narrow",
                  context: "standalone"
                });
              case "LLLL":
              default:
                return localize2.month(month, {
                  width: "wide",
                  context: "standalone"
                });
            }
          },
          // Local week of year
          w: function w(date2, token, localize2, options) {
            var week = (0, _index4.default)(date2, options);
            if (token === "wo") {
              return localize2.ordinalNumber(week, {
                unit: "week"
              });
            }
            return (0, _index6.default)(week, token.length);
          },
          // ISO week of year
          I: function I(date2, token, localize2) {
            var isoWeek = (0, _index2.default)(date2);
            if (token === "Io") {
              return localize2.ordinalNumber(isoWeek, {
                unit: "week"
              });
            }
            return (0, _index6.default)(isoWeek, token.length);
          },
          // Day of the month
          d: function d(date2, token, localize2) {
            if (token === "do") {
              return localize2.ordinalNumber(date2.getUTCDate(), {
                unit: "date"
              });
            }
            return _index7.default.d(date2, token);
          },
          // Day of year
          D: function D(date2, token, localize2) {
            var dayOfYear = (0, _index.default)(date2);
            if (token === "Do") {
              return localize2.ordinalNumber(dayOfYear, {
                unit: "dayOfYear"
              });
            }
            return (0, _index6.default)(dayOfYear, token.length);
          },
          // Day of week
          E: function E(date2, token, localize2) {
            var dayOfWeek = date2.getUTCDay();
            switch (token) {
              case "E":
              case "EE":
              case "EEE":
                return localize2.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "EEEEE":
                return localize2.day(dayOfWeek, {
                  width: "narrow",
                  context: "formatting"
                });
              case "EEEEEE":
                return localize2.day(dayOfWeek, {
                  width: "short",
                  context: "formatting"
                });
              case "EEEE":
              default:
                return localize2.day(dayOfWeek, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Local day of week
          e: function e(date2, token, localize2, options) {
            var dayOfWeek = date2.getUTCDay();
            var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
            switch (token) {
              case "e":
                return String(localDayOfWeek);
              case "ee":
                return (0, _index6.default)(localDayOfWeek, 2);
              case "eo":
                return localize2.ordinalNumber(localDayOfWeek, {
                  unit: "day"
                });
              case "eee":
                return localize2.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "eeeee":
                return localize2.day(dayOfWeek, {
                  width: "narrow",
                  context: "formatting"
                });
              case "eeeeee":
                return localize2.day(dayOfWeek, {
                  width: "short",
                  context: "formatting"
                });
              case "eeee":
              default:
                return localize2.day(dayOfWeek, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Stand-alone local day of week
          c: function c2(date2, token, localize2, options) {
            var dayOfWeek = date2.getUTCDay();
            var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
            switch (token) {
              case "c":
                return String(localDayOfWeek);
              case "cc":
                return (0, _index6.default)(localDayOfWeek, token.length);
              case "co":
                return localize2.ordinalNumber(localDayOfWeek, {
                  unit: "day"
                });
              case "ccc":
                return localize2.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "standalone"
                });
              case "ccccc":
                return localize2.day(dayOfWeek, {
                  width: "narrow",
                  context: "standalone"
                });
              case "cccccc":
                return localize2.day(dayOfWeek, {
                  width: "short",
                  context: "standalone"
                });
              case "cccc":
              default:
                return localize2.day(dayOfWeek, {
                  width: "wide",
                  context: "standalone"
                });
            }
          },
          // ISO day of week
          i: function i(date2, token, localize2) {
            var dayOfWeek = date2.getUTCDay();
            var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
            switch (token) {
              case "i":
                return String(isoDayOfWeek);
              case "ii":
                return (0, _index6.default)(isoDayOfWeek, token.length);
              case "io":
                return localize2.ordinalNumber(isoDayOfWeek, {
                  unit: "day"
                });
              case "iii":
                return localize2.day(dayOfWeek, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "iiiii":
                return localize2.day(dayOfWeek, {
                  width: "narrow",
                  context: "formatting"
                });
              case "iiiiii":
                return localize2.day(dayOfWeek, {
                  width: "short",
                  context: "formatting"
                });
              case "iiii":
              default:
                return localize2.day(dayOfWeek, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // AM or PM
          a: function a2(date2, token, localize2) {
            var hours = date2.getUTCHours();
            var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
            switch (token) {
              case "a":
              case "aa":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "aaa":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                }).toLowerCase();
              case "aaaaa":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "narrow",
                  context: "formatting"
                });
              case "aaaa":
              default:
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // AM, PM, midnight, noon
          b: function b(date2, token, localize2) {
            var hours = date2.getUTCHours();
            var dayPeriodEnumValue;
            if (hours === 12) {
              dayPeriodEnumValue = dayPeriodEnum2.noon;
            } else if (hours === 0) {
              dayPeriodEnumValue = dayPeriodEnum2.midnight;
            } else {
              dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
            }
            switch (token) {
              case "b":
              case "bb":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "bbb":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                }).toLowerCase();
              case "bbbbb":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "narrow",
                  context: "formatting"
                });
              case "bbbb":
              default:
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // in the morning, in the afternoon, in the evening, at night
          B: function B(date2, token, localize2) {
            var hours = date2.getUTCHours();
            var dayPeriodEnumValue;
            if (hours >= 17) {
              dayPeriodEnumValue = dayPeriodEnum2.evening;
            } else if (hours >= 12) {
              dayPeriodEnumValue = dayPeriodEnum2.afternoon;
            } else if (hours >= 4) {
              dayPeriodEnumValue = dayPeriodEnum2.morning;
            } else {
              dayPeriodEnumValue = dayPeriodEnum2.night;
            }
            switch (token) {
              case "B":
              case "BB":
              case "BBB":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "abbreviated",
                  context: "formatting"
                });
              case "BBBBB":
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "narrow",
                  context: "formatting"
                });
              case "BBBB":
              default:
                return localize2.dayPeriod(dayPeriodEnumValue, {
                  width: "wide",
                  context: "formatting"
                });
            }
          },
          // Hour [1-12]
          h: function h2(date2, token, localize2) {
            if (token === "ho") {
              var hours = date2.getUTCHours() % 12;
              if (hours === 0)
                hours = 12;
              return localize2.ordinalNumber(hours, {
                unit: "hour"
              });
            }
            return _index7.default.h(date2, token);
          },
          // Hour [0-23]
          H: function H(date2, token, localize2) {
            if (token === "Ho") {
              return localize2.ordinalNumber(date2.getUTCHours(), {
                unit: "hour"
              });
            }
            return _index7.default.H(date2, token);
          },
          // Hour [0-11]
          K: function K(date2, token, localize2) {
            var hours = date2.getUTCHours() % 12;
            if (token === "Ko") {
              return localize2.ordinalNumber(hours, {
                unit: "hour"
              });
            }
            return (0, _index6.default)(hours, token.length);
          },
          // Hour [1-24]
          k: function k(date2, token, localize2) {
            var hours = date2.getUTCHours();
            if (hours === 0)
              hours = 24;
            if (token === "ko") {
              return localize2.ordinalNumber(hours, {
                unit: "hour"
              });
            }
            return (0, _index6.default)(hours, token.length);
          },
          // Minute
          m: function m(date2, token, localize2) {
            if (token === "mo") {
              return localize2.ordinalNumber(date2.getUTCMinutes(), {
                unit: "minute"
              });
            }
            return _index7.default.m(date2, token);
          },
          // Second
          s: function s(date2, token, localize2) {
            if (token === "so") {
              return localize2.ordinalNumber(date2.getUTCSeconds(), {
                unit: "second"
              });
            }
            return _index7.default.s(date2, token);
          },
          // Fraction of second
          S: function S(date2, token) {
            return _index7.default.S(date2, token);
          },
          // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
          X: function X(date2, token, _localize, options) {
            var originalDate = options._originalDate || date2;
            var timezoneOffset = originalDate.getTimezoneOffset();
            if (timezoneOffset === 0) {
              return "Z";
            }
            switch (token) {
              case "X":
                return formatTimezoneWithOptionalMinutes2(timezoneOffset);
              case "XXXX":
              case "XX":
                return formatTimezone2(timezoneOffset);
              case "XXXXX":
              case "XXX":
              default:
                return formatTimezone2(timezoneOffset, ":");
            }
          },
          // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
          x: function x(date2, token, _localize, options) {
            var originalDate = options._originalDate || date2;
            var timezoneOffset = originalDate.getTimezoneOffset();
            switch (token) {
              case "x":
                return formatTimezoneWithOptionalMinutes2(timezoneOffset);
              case "xxxx":
              case "xx":
                return formatTimezone2(timezoneOffset);
              case "xxxxx":
              case "xxx":
              default:
                return formatTimezone2(timezoneOffset, ":");
            }
          },
          // Timezone (GMT)
          O: function O(date2, token, _localize, options) {
            var originalDate = options._originalDate || date2;
            var timezoneOffset = originalDate.getTimezoneOffset();
            switch (token) {
              case "O":
              case "OO":
              case "OOO":
                return "GMT" + formatTimezoneShort2(timezoneOffset, ":");
              case "OOOO":
              default:
                return "GMT" + formatTimezone2(timezoneOffset, ":");
            }
          },
          // Timezone (specific non-location)
          z: function z(date2, token, _localize, options) {
            var originalDate = options._originalDate || date2;
            var timezoneOffset = originalDate.getTimezoneOffset();
            switch (token) {
              case "z":
              case "zz":
              case "zzz":
                return "GMT" + formatTimezoneShort2(timezoneOffset, ":");
              case "zzzz":
              default:
                return "GMT" + formatTimezone2(timezoneOffset, ":");
            }
          },
          // Seconds timestamp
          t: function t(date2, token, _localize, options) {
            var originalDate = options._originalDate || date2;
            var timestamp = Math.floor(originalDate.getTime() / 1e3);
            return (0, _index6.default)(timestamp, token.length);
          },
          // Milliseconds timestamp
          T: function T(date2, token, _localize, options) {
            var originalDate = options._originalDate || date2;
            var timestamp = originalDate.getTime();
            return (0, _index6.default)(timestamp, token.length);
          }
        };
        function formatTimezoneShort2(offset, dirtyDelimiter) {
          var sign = offset > 0 ? "-" : "+";
          var absOffset = Math.abs(offset);
          var hours = Math.floor(absOffset / 60);
          var minutes = absOffset % 60;
          if (minutes === 0) {
            return sign + String(hours);
          }
          var delimiter = dirtyDelimiter || "";
          return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
        }
        function formatTimezoneWithOptionalMinutes2(offset, dirtyDelimiter) {
          if (offset % 60 === 0) {
            var sign = offset > 0 ? "-" : "+";
            return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
          }
          return formatTimezone2(offset, dirtyDelimiter);
        }
        function formatTimezone2(offset, dirtyDelimiter) {
          var delimiter = dirtyDelimiter || "";
          var sign = offset > 0 ? "-" : "+";
          var absOffset = Math.abs(offset);
          var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
          var minutes = (0, _index6.default)(absOffset % 60, 2);
          return sign + hours + delimiter + minutes;
        }
        var _default = formatters2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(formatters$2, formatters$2.exports);
      var formattersExports = formatters$2.exports;
      var longFormatters = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var dateLongFormatter2 = function dateLongFormatter3(pattern2, formatLong2) {
          switch (pattern2) {
            case "P":
              return formatLong2.date({
                width: "short"
              });
            case "PP":
              return formatLong2.date({
                width: "medium"
              });
            case "PPP":
              return formatLong2.date({
                width: "long"
              });
            case "PPPP":
            default:
              return formatLong2.date({
                width: "full"
              });
          }
        };
        var timeLongFormatter2 = function timeLongFormatter3(pattern2, formatLong2) {
          switch (pattern2) {
            case "p":
              return formatLong2.time({
                width: "short"
              });
            case "pp":
              return formatLong2.time({
                width: "medium"
              });
            case "ppp":
              return formatLong2.time({
                width: "long"
              });
            case "pppp":
            default:
              return formatLong2.time({
                width: "full"
              });
          }
        };
        var dateTimeLongFormatter2 = function dateTimeLongFormatter3(pattern2, formatLong2) {
          var matchResult = pattern2.match(/(P+)(p+)?/) || [];
          var datePattern = matchResult[1];
          var timePattern = matchResult[2];
          if (!timePattern) {
            return dateLongFormatter2(pattern2, formatLong2);
          }
          var dateTimeFormat;
          switch (datePattern) {
            case "P":
              dateTimeFormat = formatLong2.dateTime({
                width: "short"
              });
              break;
            case "PP":
              dateTimeFormat = formatLong2.dateTime({
                width: "medium"
              });
              break;
            case "PPP":
              dateTimeFormat = formatLong2.dateTime({
                width: "long"
              });
              break;
            case "PPPP":
            default:
              dateTimeFormat = formatLong2.dateTime({
                width: "full"
              });
              break;
          }
          return dateTimeFormat.replace("{{date}}", dateLongFormatter2(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter2(timePattern, formatLong2));
        };
        var longFormatters2 = {
          p: timeLongFormatter2,
          P: dateTimeLongFormatter2
        };
        var _default = longFormatters2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(longFormatters, longFormatters.exports);
      var longFormattersExports = longFormatters.exports;
      var getTimezoneOffsetInMilliseconds$1 = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = getTimezoneOffsetInMilliseconds2;
        function getTimezoneOffsetInMilliseconds2(date2) {
          var utcDate = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
          utcDate.setUTCFullYear(date2.getFullYear());
          return date2.getTime() - utcDate.getTime();
        }
        module2.exports = exports2.default;
      })(getTimezoneOffsetInMilliseconds$1, getTimezoneOffsetInMilliseconds$1.exports);
      var getTimezoneOffsetInMillisecondsExports = getTimezoneOffsetInMilliseconds$1.exports;
      const getTimezoneOffsetInMilliseconds = /* @__PURE__ */ getDefaultExportFromCjs(getTimezoneOffsetInMillisecondsExports);
      var protectedTokens = {};
      Object.defineProperty(protectedTokens, "__esModule", {
        value: true
      });
      protectedTokens.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
      protectedTokens.isProtectedWeekYearToken = isProtectedWeekYearToken;
      protectedTokens.throwProtectedError = throwProtectedError;
      var protectedDayOfYearTokens = ["D", "DD"];
      var protectedWeekYearTokens = ["YY", "YYYY"];
      function isProtectedDayOfYearToken(token) {
        return protectedDayOfYearTokens.indexOf(token) !== -1;
      }
      function isProtectedWeekYearToken(token) {
        return protectedWeekYearTokens.indexOf(token) !== -1;
      }
      function throwProtectedError(token, format2, input) {
        if (token === "YYYY") {
          throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        } else if (token === "YY") {
          throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        } else if (token === "D") {
          throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        } else if (token === "DD") {
          throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
        }
      }
      var defaultLocale = { exports: {} };
      var enUS = { exports: {} };
      var formatDistance = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var formatDistanceLocale2 = {
          lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
          },
          xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
          },
          halfAMinute: "half a minute",
          lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
          },
          xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
          },
          aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
          },
          xHours: {
            one: "1 hour",
            other: "{{count}} hours"
          },
          xDays: {
            one: "1 day",
            other: "{{count}} days"
          },
          aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
          },
          xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
          },
          aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
          },
          xMonths: {
            one: "1 month",
            other: "{{count}} months"
          },
          aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
          },
          xYears: {
            one: "1 year",
            other: "{{count}} years"
          },
          overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
          },
          almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
          }
        };
        var formatDistance2 = function formatDistance3(token, count, options) {
          var result;
          var tokenValue = formatDistanceLocale2[token];
          if (typeof tokenValue === "string") {
            result = tokenValue;
          } else if (count === 1) {
            result = tokenValue.one;
          } else {
            result = tokenValue.other.replace("{{count}}", count.toString());
          }
          if (options !== null && options !== void 0 && options.addSuffix) {
            if (options.comparison && options.comparison > 0) {
              return "in " + result;
            } else {
              return result + " ago";
            }
          }
          return result;
        };
        var _default = formatDistance2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(formatDistance, formatDistance.exports);
      var formatDistanceExports = formatDistance.exports;
      var formatLong = { exports: {} };
      var buildFormatLongFn = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = buildFormatLongFn2;
        function buildFormatLongFn2(args) {
          return function() {
            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var width = options.width ? String(options.width) : args.defaultWidth;
            var format2 = args.formats[width] || args.formats[args.defaultWidth];
            return format2;
          };
        }
        module2.exports = exports2.default;
      })(buildFormatLongFn, buildFormatLongFn.exports);
      var buildFormatLongFnExports = buildFormatLongFn.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(buildFormatLongFnExports);
        var dateFormats2 = {
          full: "EEEE, MMMM do, y",
          long: "MMMM do, y",
          medium: "MMM d, y",
          short: "MM/dd/yyyy"
        };
        var timeFormats2 = {
          full: "h:mm:ss a zzzz",
          long: "h:mm:ss a z",
          medium: "h:mm:ss a",
          short: "h:mm a"
        };
        var dateTimeFormats2 = {
          full: "{{date}} 'at' {{time}}",
          long: "{{date}} 'at' {{time}}",
          medium: "{{date}}, {{time}}",
          short: "{{date}}, {{time}}"
        };
        var formatLong2 = {
          date: (0, _index.default)({
            formats: dateFormats2,
            defaultWidth: "full"
          }),
          time: (0, _index.default)({
            formats: timeFormats2,
            defaultWidth: "full"
          }),
          dateTime: (0, _index.default)({
            formats: dateTimeFormats2,
            defaultWidth: "full"
          })
        };
        var _default = formatLong2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(formatLong, formatLong.exports);
      var formatLongExports = formatLong.exports;
      var formatRelative = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var formatRelativeLocale2 = {
          lastWeek: "'last' eeee 'at' p",
          yesterday: "'yesterday at' p",
          today: "'today at' p",
          tomorrow: "'tomorrow at' p",
          nextWeek: "eeee 'at' p",
          other: "P"
        };
        var formatRelative2 = function formatRelative3(token, _date, _baseDate, _options) {
          return formatRelativeLocale2[token];
        };
        var _default = formatRelative2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(formatRelative, formatRelative.exports);
      var formatRelativeExports = formatRelative.exports;
      var localize = { exports: {} };
      var buildLocalizeFn = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = buildLocalizeFn2;
        function buildLocalizeFn2(args) {
          return function(dirtyIndex, options) {
            var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
            var valuesArray;
            if (context === "formatting" && args.formattingValues) {
              var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
              var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
              valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
            } else {
              var _defaultWidth = args.defaultWidth;
              var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
              valuesArray = args.values[_width] || args.values[_defaultWidth];
            }
            var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
            return valuesArray[index];
          };
        }
        module2.exports = exports2.default;
      })(buildLocalizeFn, buildLocalizeFn.exports);
      var buildLocalizeFnExports = buildLocalizeFn.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(buildLocalizeFnExports);
        var eraValues2 = {
          narrow: ["B", "A"],
          abbreviated: ["BC", "AD"],
          wide: ["Before Christ", "Anno Domini"]
        };
        var quarterValues2 = {
          narrow: ["1", "2", "3", "4"],
          abbreviated: ["Q1", "Q2", "Q3", "Q4"],
          wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
        };
        var monthValues2 = {
          narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
          abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        };
        var dayValues2 = {
          narrow: ["S", "M", "T", "W", "T", "F", "S"],
          short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        };
        var dayPeriodValues2 = {
          narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
          },
          abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
          },
          wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
          }
        };
        var formattingDayPeriodValues2 = {
          narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
          },
          abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
          },
          wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
          }
        };
        var ordinalNumber2 = function ordinalNumber3(dirtyNumber, _options) {
          var number2 = Number(dirtyNumber);
          var rem100 = number2 % 100;
          if (rem100 > 20 || rem100 < 10) {
            switch (rem100 % 10) {
              case 1:
                return number2 + "st";
              case 2:
                return number2 + "nd";
              case 3:
                return number2 + "rd";
            }
          }
          return number2 + "th";
        };
        var localize2 = {
          ordinalNumber: ordinalNumber2,
          era: (0, _index.default)({
            values: eraValues2,
            defaultWidth: "wide"
          }),
          quarter: (0, _index.default)({
            values: quarterValues2,
            defaultWidth: "wide",
            argumentCallback: function argumentCallback(quarter) {
              return quarter - 1;
            }
          }),
          month: (0, _index.default)({
            values: monthValues2,
            defaultWidth: "wide"
          }),
          day: (0, _index.default)({
            values: dayValues2,
            defaultWidth: "wide"
          }),
          dayPeriod: (0, _index.default)({
            values: dayPeriodValues2,
            defaultWidth: "wide",
            formattingValues: formattingDayPeriodValues2,
            defaultFormattingWidth: "wide"
          })
        };
        var _default = localize2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(localize, localize.exports);
      var localizeExports = localize.exports;
      var match = { exports: {} };
      var buildMatchFn = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = buildMatchFn2;
        function buildMatchFn2(args) {
          return function(string2) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var width = options.width;
            var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
            var matchResult = string2.match(matchPattern);
            if (!matchResult) {
              return null;
            }
            var matchedString = matchResult[0];
            var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
            var key = Array.isArray(parsePatterns) ? findIndex2(parsePatterns, function(pattern2) {
              return pattern2.test(matchedString);
            }) : findKey2(parsePatterns, function(pattern2) {
              return pattern2.test(matchedString);
            });
            var value;
            value = args.valueCallback ? args.valueCallback(key) : key;
            value = options.valueCallback ? options.valueCallback(value) : value;
            var rest = string2.slice(matchedString.length);
            return {
              value,
              rest
            };
          };
        }
        function findKey2(object2, predicate) {
          for (var key in object2) {
            if (object2.hasOwnProperty(key) && predicate(object2[key])) {
              return key;
            }
          }
          return void 0;
        }
        function findIndex2(array2, predicate) {
          for (var key = 0; key < array2.length; key++) {
            if (predicate(array2[key])) {
              return key;
            }
          }
          return void 0;
        }
        module2.exports = exports2.default;
      })(buildMatchFn, buildMatchFn.exports);
      var buildMatchFnExports = buildMatchFn.exports;
      var buildMatchPatternFn = { exports: {} };
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = buildMatchPatternFn2;
        function buildMatchPatternFn2(args) {
          return function(string2) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var matchResult = string2.match(args.matchPattern);
            if (!matchResult)
              return null;
            var matchedString = matchResult[0];
            var parseResult = string2.match(args.parsePattern);
            if (!parseResult)
              return null;
            var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
            value = options.valueCallback ? options.valueCallback(value) : value;
            var rest = string2.slice(matchedString.length);
            return {
              value,
              rest
            };
          };
        }
        module2.exports = exports2.default;
      })(buildMatchPatternFn, buildMatchPatternFn.exports);
      var buildMatchPatternFnExports = buildMatchPatternFn.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(buildMatchFnExports);
        var _index2 = _interopRequireDefault(buildMatchPatternFnExports);
        var matchOrdinalNumberPattern2 = /^(\d+)(th|st|nd|rd)?/i;
        var parseOrdinalNumberPattern2 = /\d+/i;
        var matchEraPatterns2 = {
          narrow: /^(b|a)/i,
          abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
          wide: /^(before christ|before common era|anno domini|common era)/i
        };
        var parseEraPatterns2 = {
          any: [/^b/i, /^(a|c)/i]
        };
        var matchQuarterPatterns2 = {
          narrow: /^[1234]/i,
          abbreviated: /^q[1234]/i,
          wide: /^[1234](th|st|nd|rd)? quarter/i
        };
        var parseQuarterPatterns2 = {
          any: [/1/i, /2/i, /3/i, /4/i]
        };
        var matchMonthPatterns2 = {
          narrow: /^[jfmasond]/i,
          abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
          wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
        };
        var parseMonthPatterns2 = {
          narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
          any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
        };
        var matchDayPatterns2 = {
          narrow: /^[smtwf]/i,
          short: /^(su|mo|tu|we|th|fr|sa)/i,
          abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
          wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
        };
        var parseDayPatterns2 = {
          narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
          any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
        };
        var matchDayPeriodPatterns2 = {
          narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
          any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
        };
        var parseDayPeriodPatterns2 = {
          any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
          }
        };
        var match2 = {
          ordinalNumber: (0, _index2.default)({
            matchPattern: matchOrdinalNumberPattern2,
            parsePattern: parseOrdinalNumberPattern2,
            valueCallback: function valueCallback(value) {
              return parseInt(value, 10);
            }
          }),
          era: (0, _index.default)({
            matchPatterns: matchEraPatterns2,
            defaultMatchWidth: "wide",
            parsePatterns: parseEraPatterns2,
            defaultParseWidth: "any"
          }),
          quarter: (0, _index.default)({
            matchPatterns: matchQuarterPatterns2,
            defaultMatchWidth: "wide",
            parsePatterns: parseQuarterPatterns2,
            defaultParseWidth: "any",
            valueCallback: function valueCallback(index) {
              return index + 1;
            }
          }),
          month: (0, _index.default)({
            matchPatterns: matchMonthPatterns2,
            defaultMatchWidth: "wide",
            parsePatterns: parseMonthPatterns2,
            defaultParseWidth: "any"
          }),
          day: (0, _index.default)({
            matchPatterns: matchDayPatterns2,
            defaultMatchWidth: "wide",
            parsePatterns: parseDayPatterns2,
            defaultParseWidth: "any"
          }),
          dayPeriod: (0, _index.default)({
            matchPatterns: matchDayPeriodPatterns2,
            defaultMatchWidth: "any",
            parsePatterns: parseDayPeriodPatterns2,
            defaultParseWidth: "any"
          })
        };
        var _default = match2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(match, match.exports);
      var matchExports = match.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(formatDistanceExports);
        var _index2 = _interopRequireDefault(formatLongExports);
        var _index3 = _interopRequireDefault(formatRelativeExports);
        var _index4 = _interopRequireDefault(localizeExports);
        var _index5 = _interopRequireDefault(matchExports);
        var locale2 = {
          code: "en-US",
          formatDistance: _index.default,
          formatLong: _index2.default,
          formatRelative: _index3.default,
          localize: _index4.default,
          match: _index5.default,
          options: {
            weekStartsOn: 0,
            firstWeekContainsDate: 1
          }
        };
        var _default = locale2;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(enUS, enUS.exports);
      var enUSExports = enUS.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = void 0;
        var _index = _interopRequireDefault(enUSExports);
        var _default = _index.default;
        exports2.default = _default;
        module2.exports = exports2.default;
      })(defaultLocale, defaultLocale.exports);
      var defaultLocaleExports = defaultLocale.exports;
      (function(module2, exports2) {
        var _interopRequireDefault = interopRequireDefaultExports.default;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = format2;
        var _index = _interopRequireDefault(isValidExports);
        var _index2 = _interopRequireDefault(subMillisecondsExports);
        var _index3 = _interopRequireDefault(toDateExports);
        var _index4 = _interopRequireDefault(formattersExports);
        var _index5 = _interopRequireDefault(longFormattersExports);
        var _index6 = _interopRequireDefault(getTimezoneOffsetInMillisecondsExports);
        var _index7 = protectedTokens;
        var _index8 = _interopRequireDefault(toIntegerExports);
        var _index9 = _interopRequireDefault(requiredArgsExports);
        var _index10 = defaultOptions$1;
        var _index11 = _interopRequireDefault(defaultLocaleExports);
        var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
        var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
        var escapedStringRegExp2 = /^'([^]*?)'?$/;
        var doubleQuoteRegExp2 = /''/g;
        var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
        function format2(dirtyDate, dirtyFormatStr, options) {
          var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
          (0, _index9.default)(2, arguments);
          var formatStr = String(dirtyFormatStr);
          var defaultOptions2 = (0, _index10.getDefaultOptions)();
          var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : _index11.default;
          var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
          if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
            throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
          }
          var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
          if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
            throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
          }
          if (!locale2.localize) {
            throw new RangeError("locale must contain localize property");
          }
          if (!locale2.formatLong) {
            throw new RangeError("locale must contain formatLong property");
          }
          var originalDate = (0, _index3.default)(dirtyDate);
          if (!(0, _index.default)(originalDate)) {
            throw new RangeError("Invalid time value");
          }
          var timezoneOffset = (0, _index6.default)(originalDate);
          var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
          var formatterOptions = {
            firstWeekContainsDate,
            weekStartsOn,
            locale: locale2,
            _originalDate: originalDate
          };
          var result = formatStr.match(longFormattingTokensRegExp2).map(function(substring) {
            var firstCharacter = substring[0];
            if (firstCharacter === "p" || firstCharacter === "P") {
              var longFormatter = _index5.default[firstCharacter];
              return longFormatter(substring, locale2.formatLong);
            }
            return substring;
          }).join("").match(formattingTokensRegExp2).map(function(substring) {
            if (substring === "''") {
              return "'";
            }
            var firstCharacter = substring[0];
            if (firstCharacter === "'") {
              return cleanEscapedString2(substring);
            }
            var formatter = _index4.default[firstCharacter];
            if (formatter) {
              if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
                (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
              }
              if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
                (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
              }
              return formatter(utcDate, substring, locale2.localize, formatterOptions);
            }
            if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
              throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
            }
            return substring;
          }).join("");
          return result;
        }
        function cleanEscapedString2(input) {
          var matched = input.match(escapedStringRegExp2);
          if (!matched) {
            return input;
          }
          return matched[1].replace(doubleQuoteRegExp2, "'");
        }
        module2.exports = exports2.default;
      })(format$3, format$3.exports);
      var formatExports = format$3.exports;
      const dateFnsFormat = /* @__PURE__ */ getDefaultExportFromCjs(formatExports);
      function tzIntlTimeZoneName(length, date2, options) {
        var dtf = getDTF(length, options.timeZone, options.locale);
        return dtf.formatToParts ? partsTimeZone(dtf, date2) : hackyTimeZone(dtf, date2);
      }
      function partsTimeZone(dtf, date2) {
        var formatted = dtf.formatToParts(date2);
        for (var i = formatted.length - 1; i >= 0; --i) {
          if (formatted[i].type === "timeZoneName") {
            return formatted[i].value;
          }
        }
      }
      function hackyTimeZone(dtf, date2) {
        var formatted = dtf.format(date2).replace(/\u200E/g, "");
        var tzNameMatch = / [\w-+ ]+$/.exec(formatted);
        return tzNameMatch ? tzNameMatch[0].substr(1) : "";
      }
      function getDTF(length, timeZone, locale2) {
        if (locale2 && !locale2.code) {
          throw new Error(
            "date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`"
          );
        }
        return new Intl.DateTimeFormat(locale2 ? [locale2.code, "en-US"] : void 0, {
          timeZone,
          timeZoneName: length
        });
      }
      function tzTokenizeDate(date2, timeZone) {
        var dtf = getDateTimeFormat(timeZone);
        return dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
      }
      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };
      function partsOffset(dtf, date2) {
        try {
          var formatted = dtf.formatToParts(date2);
          var filled = [];
          for (var i = 0; i < formatted.length; i++) {
            var pos = typeToPos[formatted[i].type];
            if (pos >= 0) {
              filled[pos] = parseInt(formatted[i].value, 10);
            }
          }
          return filled;
        } catch (error) {
          if (error instanceof RangeError) {
            return [NaN];
          }
          throw error;
        }
      }
      function hackyOffset(dtf, date2) {
        var formatted = dtf.format(date2).replace(/\u200E/g, "");
        var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
        return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
      }
      var dtfCache = {};
      function getDateTimeFormat(timeZone) {
        if (!dtfCache[timeZone]) {
          var testDateFormatted = new Intl.DateTimeFormat("en-US", {
            hour12: false,
            timeZone: "America/New_York",
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
          var hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "06/25/2014 00:00:00";
          dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
            hour12: false,
            timeZone,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          }) : new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });
        }
        return dtfCache[timeZone];
      }
      function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
        var utcDate = /* @__PURE__ */ new Date(0);
        utcDate.setUTCFullYear(fullYear, month, day);
        utcDate.setUTCHours(hour, minute, second, millisecond);
        return utcDate;
      }
      var MILLISECONDS_IN_HOUR$1 = 36e5;
      var MILLISECONDS_IN_MINUTE$2 = 6e4;
      var patterns$1 = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-]\d{2})$/,
        timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
      };
      function tzParseTimezone(timezoneString, date2, isUtcDate) {
        var token;
        var absoluteOffset;
        if (!timezoneString) {
          return 0;
        }
        token = patterns$1.timezoneZ.exec(timezoneString);
        if (token) {
          return 0;
        }
        var hours;
        token = patterns$1.timezoneHH.exec(timezoneString);
        if (token) {
          hours = parseInt(token[1], 10);
          if (!validateTimezone(hours)) {
            return NaN;
          }
          return -(hours * MILLISECONDS_IN_HOUR$1);
        }
        token = patterns$1.timezoneHHMM.exec(timezoneString);
        if (token) {
          hours = parseInt(token[1], 10);
          var minutes = parseInt(token[2], 10);
          if (!validateTimezone(hours, minutes)) {
            return NaN;
          }
          absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
          return hours > 0 ? -absoluteOffset : absoluteOffset;
        }
        if (isValidTimezoneIANAString(timezoneString)) {
          date2 = new Date(date2 || Date.now());
          var utcDate = isUtcDate ? date2 : toUtcDate(date2);
          var offset = calcOffset(utcDate, timezoneString);
          var fixedOffset = isUtcDate ? offset : fixOffset(date2, offset, timezoneString);
          return -fixedOffset;
        }
        return NaN;
      }
      function toUtcDate(date2) {
        return newDateUTC(
          date2.getFullYear(),
          date2.getMonth(),
          date2.getDate(),
          date2.getHours(),
          date2.getMinutes(),
          date2.getSeconds(),
          date2.getMilliseconds()
        );
      }
      function calcOffset(date2, timezoneString) {
        var tokens = tzTokenizeDate(date2, timezoneString);
        var asUTC = newDateUTC(
          tokens[0],
          tokens[1] - 1,
          tokens[2],
          tokens[3] % 24,
          tokens[4],
          tokens[5],
          0
        ).getTime();
        var asTS = date2.getTime();
        var over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return asUTC - asTS;
      }
      function fixOffset(date2, offset, timezoneString) {
        var localTS = date2.getTime();
        var utcGuess = localTS - offset;
        var o2 = calcOffset(new Date(utcGuess), timezoneString);
        if (offset === o2) {
          return offset;
        }
        utcGuess -= o2 - offset;
        var o3 = calcOffset(new Date(utcGuess), timezoneString);
        if (o2 === o3) {
          return o2;
        }
        return Math.max(o2, o3);
      }
      function validateTimezone(hours, minutes) {
        return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
      }
      var validIANATimezoneCache = {};
      function isValidTimezoneIANAString(timeZoneString) {
        if (validIANATimezoneCache[timeZoneString])
          return true;
        try {
          new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
          validIANATimezoneCache[timeZoneString] = true;
          return true;
        } catch (error) {
          return false;
        }
      }
      var MILLISECONDS_IN_MINUTE$1 = 60 * 1e3;
      var formatters = {
        // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
        X: function(date2, token, localize2, options) {
          var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date2);
          if (timezoneOffset === 0) {
            return "Z";
          }
          switch (token) {
            case "X":
              return formatTimezoneWithOptionalMinutes(timezoneOffset);
            case "XXXX":
            case "XX":
              return formatTimezone(timezoneOffset);
            case "XXXXX":
            case "XXX":
            default:
              return formatTimezone(timezoneOffset, ":");
          }
        },
        // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
        x: function(date2, token, localize2, options) {
          var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date2);
          switch (token) {
            case "x":
              return formatTimezoneWithOptionalMinutes(timezoneOffset);
            case "xxxx":
            case "xx":
              return formatTimezone(timezoneOffset);
            case "xxxxx":
            case "xxx":
            default:
              return formatTimezone(timezoneOffset, ":");
          }
        },
        // Timezone (GMT)
        O: function(date2, token, localize2, options) {
          var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date2);
          switch (token) {
            case "O":
            case "OO":
            case "OOO":
              return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            case "OOOO":
            default:
              return "GMT" + formatTimezone(timezoneOffset, ":");
          }
        },
        // Timezone (specific non-location)
        z: function(date2, token, localize2, options) {
          var originalDate = options._originalDate || date2;
          switch (token) {
            case "z":
            case "zz":
            case "zzz":
              return tzIntlTimeZoneName("short", originalDate, options);
            case "zzzz":
            default:
              return tzIntlTimeZoneName("long", originalDate, options);
          }
        }
      };
      function getTimeZoneOffset(timeZone, originalDate) {
        var timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE$1 : originalDate.getTimezoneOffset();
        if (Number.isNaN(timeZoneOffset)) {
          throw new RangeError("Invalid time zone specified: " + timeZone);
        }
        return timeZoneOffset;
      }
      function addLeadingZeros(number2, targetLength) {
        var sign = number2 < 0 ? "-" : "";
        var output = Math.abs(number2).toString();
        while (output.length < targetLength) {
          output = "0" + output;
        }
        return sign + output;
      }
      function formatTimezone(offset, dirtyDelimeter) {
        var delimeter = dirtyDelimeter || "";
        var sign = offset > 0 ? "-" : "+";
        var absOffset = Math.abs(offset);
        var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
        var minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
        return sign + hours + delimeter + minutes;
      }
      function formatTimezoneWithOptionalMinutes(offset, dirtyDelimeter) {
        if (offset % 60 === 0) {
          var sign = offset > 0 ? "-" : "+";
          return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
        }
        return formatTimezone(offset, dirtyDelimeter);
      }
      function formatTimezoneShort(offset, dirtyDelimeter) {
        var sign = offset > 0 ? "-" : "+";
        var absOffset = Math.abs(offset);
        var hours = Math.floor(absOffset / 60);
        var minutes = absOffset % 60;
        if (minutes === 0) {
          return sign + String(hours);
        }
        var delimeter = dirtyDelimeter || "";
        return sign + String(hours) + delimeter + addLeadingZeros(minutes, 2);
      }
      const formatters$1 = formatters;
      var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
      var MILLISECONDS_IN_HOUR = 36e5;
      var MILLISECONDS_IN_MINUTE = 6e4;
      var DEFAULT_ADDITIONAL_DIGITS = 2;
      var patterns = {
        dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
        datePattern: /^([0-9W+-]+)(.*)/,
        plainTime: /:/,
        // year tokens
        YY: /^(\d{2})$/,
        YYY: [
          /^([+-]\d{2})$/,
          // 0 additional digits
          /^([+-]\d{3})$/,
          // 1 additional digit
          /^([+-]\d{4})$/
          // 2 additional digits
        ],
        YYYY: /^(\d{4})/,
        YYYYY: [
          /^([+-]\d{4})/,
          // 0 additional digits
          /^([+-]\d{5})/,
          // 1 additional digit
          /^([+-]\d{6})/
          // 2 additional digits
        ],
        // date tokens
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        // time zone tokens (to identify the presence of a tz)
        timeZone: tzPattern
      };
      function toDate(argument, dirtyOptions) {
        if (arguments.length < 1) {
          throw new TypeError("1 argument required, but only " + arguments.length + " present");
        }
        if (argument === null) {
          return /* @__PURE__ */ new Date(NaN);
        }
        var options = dirtyOptions || {};
        var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);
        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
          throw new RangeError("additionalDigits must be 0, 1 or 2");
        }
        if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
          return new Date(argument.getTime());
        } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
          return new Date(argument);
        } else if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
          return /* @__PURE__ */ new Date(NaN);
        }
        var dateStrings = splitDateString(argument);
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        var year = parseYearResult.year;
        var restDateString = parseYearResult.restDateString;
        var date2 = parseDate$1(restDateString, year);
        if (isNaN(date2)) {
          return /* @__PURE__ */ new Date(NaN);
        }
        if (date2) {
          var timestamp = date2.getTime();
          var time2 = 0;
          var offset;
          if (dateStrings.time) {
            time2 = parseTime(dateStrings.time);
            if (isNaN(time2)) {
              return /* @__PURE__ */ new Date(NaN);
            }
          }
          if (dateStrings.timeZone || options.timeZone) {
            offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time2));
            if (isNaN(offset)) {
              return /* @__PURE__ */ new Date(NaN);
            }
          } else {
            offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time2));
            offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time2 + offset));
          }
          return new Date(timestamp + time2 + offset);
        } else {
          return /* @__PURE__ */ new Date(NaN);
        }
      }
      function splitDateString(dateString) {
        var dateStrings = {};
        var parts = patterns.dateTimePattern.exec(dateString);
        var timeString;
        if (!parts) {
          parts = patterns.datePattern.exec(dateString);
          if (parts) {
            dateStrings.date = parts[1];
            timeString = parts[2];
          } else {
            dateStrings.date = null;
            timeString = dateString;
          }
        } else {
          dateStrings.date = parts[1];
          timeString = parts[3];
        }
        if (timeString) {
          var token = patterns.timeZone.exec(timeString);
          if (token) {
            dateStrings.time = timeString.replace(token[1], "");
            dateStrings.timeZone = token[1].trim();
          } else {
            dateStrings.time = timeString;
          }
        }
        return dateStrings;
      }
      function parseYear(dateString, additionalDigits) {
        var patternYYY = patterns.YYY[additionalDigits];
        var patternYYYYY = patterns.YYYYY[additionalDigits];
        var token;
        token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
        if (token) {
          var yearString = token[1];
          return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
          };
        }
        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
        if (token) {
          var centuryString = token[1];
          return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
          };
        }
        return {
          year: null
        };
      }
      function parseDate$1(dateString, year) {
        if (year === null) {
          return null;
        }
        var token;
        var date2;
        var month;
        var week;
        if (dateString.length === 0) {
          date2 = /* @__PURE__ */ new Date(0);
          date2.setUTCFullYear(year);
          return date2;
        }
        token = patterns.MM.exec(dateString);
        if (token) {
          date2 = /* @__PURE__ */ new Date(0);
          month = parseInt(token[1], 10) - 1;
          if (!validateDate(year, month)) {
            return /* @__PURE__ */ new Date(NaN);
          }
          date2.setUTCFullYear(year, month);
          return date2;
        }
        token = patterns.DDD.exec(dateString);
        if (token) {
          date2 = /* @__PURE__ */ new Date(0);
          var dayOfYear = parseInt(token[1], 10);
          if (!validateDayOfYearDate(year, dayOfYear)) {
            return /* @__PURE__ */ new Date(NaN);
          }
          date2.setUTCFullYear(year, 0, dayOfYear);
          return date2;
        }
        token = patterns.MMDD.exec(dateString);
        if (token) {
          date2 = /* @__PURE__ */ new Date(0);
          month = parseInt(token[1], 10) - 1;
          var day = parseInt(token[2], 10);
          if (!validateDate(year, month, day)) {
            return /* @__PURE__ */ new Date(NaN);
          }
          date2.setUTCFullYear(year, month, day);
          return date2;
        }
        token = patterns.Www.exec(dateString);
        if (token) {
          week = parseInt(token[1], 10) - 1;
          if (!validateWeekDate(year, week)) {
            return /* @__PURE__ */ new Date(NaN);
          }
          return dayOfISOWeekYear(year, week);
        }
        token = patterns.WwwD.exec(dateString);
        if (token) {
          week = parseInt(token[1], 10) - 1;
          var dayOfWeek = parseInt(token[2], 10) - 1;
          if (!validateWeekDate(year, week, dayOfWeek)) {
            return /* @__PURE__ */ new Date(NaN);
          }
          return dayOfISOWeekYear(year, week, dayOfWeek);
        }
        return null;
      }
      function parseTime(timeString) {
        var token;
        var hours;
        var minutes;
        token = patterns.HH.exec(timeString);
        if (token) {
          hours = parseFloat(token[1].replace(",", "."));
          if (!validateTime(hours)) {
            return NaN;
          }
          return hours % 24 * MILLISECONDS_IN_HOUR;
        }
        token = patterns.HHMM.exec(timeString);
        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseFloat(token[2].replace(",", "."));
          if (!validateTime(hours, minutes)) {
            return NaN;
          }
          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
        }
        token = patterns.HHMMSS.exec(timeString);
        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseInt(token[2], 10);
          var seconds = parseFloat(token[3].replace(",", "."));
          if (!validateTime(hours, minutes, seconds)) {
            return NaN;
          }
          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1e3;
        }
        return null;
      }
      function dayOfISOWeekYear(isoWeekYear, week, day) {
        week = week || 0;
        day = day || 0;
        var date2 = /* @__PURE__ */ new Date(0);
        date2.setUTCFullYear(isoWeekYear, 0, 4);
        var fourthOfJanuaryDay = date2.getUTCDay() || 7;
        var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
        date2.setUTCDate(date2.getUTCDate() + diff);
        return date2;
      }
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function isLeapYearIndex(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }
      function validateDate(year, month, date2) {
        if (month < 0 || month > 11) {
          return false;
        }
        if (date2 != null) {
          if (date2 < 1) {
            return false;
          }
          var isLeapYear = isLeapYearIndex(year);
          if (isLeapYear && date2 > DAYS_IN_MONTH_LEAP_YEAR[month]) {
            return false;
          }
          if (!isLeapYear && date2 > DAYS_IN_MONTH[month]) {
            return false;
          }
        }
        return true;
      }
      function validateDayOfYearDate(year, dayOfYear) {
        if (dayOfYear < 1) {
          return false;
        }
        var isLeapYear = isLeapYearIndex(year);
        if (isLeapYear && dayOfYear > 366) {
          return false;
        }
        if (!isLeapYear && dayOfYear > 365) {
          return false;
        }
        return true;
      }
      function validateWeekDate(year, week, day) {
        if (week < 0 || week > 52) {
          return false;
        }
        if (day != null && (day < 0 || day > 6)) {
          return false;
        }
        return true;
      }
      function validateTime(hours, minutes, seconds) {
        if (hours != null && (hours < 0 || hours >= 25)) {
          return false;
        }
        if (minutes != null && (minutes < 0 || minutes >= 60)) {
          return false;
        }
        if (seconds != null && (seconds < 0 || seconds >= 60)) {
          return false;
        }
        return true;
      }
      var tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
      function format$2(dirtyDate, dirtyFormatStr, dirtyOptions) {
        var formatStr = String(dirtyFormatStr);
        var options = dirtyOptions || {};
        var matches = formatStr.match(tzFormattingTokensRegExp);
        if (matches) {
          var date2 = toDate(dirtyDate, options);
          formatStr = matches.reduce(function(result, token) {
            if (token[0] === "'") {
              return result;
            }
            var pos = result.indexOf(token);
            var precededByQuotedSection = result[pos - 1] === "'";
            var replaced = result.replace(
              token,
              "'" + formatters$1[token[0]](date2, token, null, options) + "'"
            );
            return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
          }, formatStr);
        }
        return dateFnsFormat(dirtyDate, formatStr, options);
      }
      function utcToZonedTime(dirtyDate, timeZone, options) {
        var date2 = toDate(dirtyDate, options);
        var offsetMilliseconds = tzParseTimezone(timeZone, date2, true);
        var d = new Date(date2.getTime() - offsetMilliseconds);
        var resultDate = /* @__PURE__ */ new Date(0);
        resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
        resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
        return resultDate;
      }
      function formatInTimeZone(date2, timeZone, formatStr, options) {
        var extendedOptions = cloneObject(options);
        extendedOptions.timeZone = timeZone;
        return format$2(utcToZonedTime(date2, timeZone), formatStr, extendedOptions);
      }
      const time = {
        amHours: [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "10",
          "11"
        ],
        pmHours: [
          "12",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "10",
          "11"
        ],
        hours: [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "20",
          "21",
          "22",
          "23"
        ],
        minutes: [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59"
        ],
        seconds: [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59"
        ],
        period: ["AM", "PM"]
      };
      function getFixValue(value) {
        return `00${value}`.slice(-2);
      }
      function getTimeUnits(defaultValue, stepOrList, isHourWithAmPm) {
        if (Array.isArray(stepOrList)) {
          return (isHourWithAmPm === "am" ? stepOrList.filter((v) => v < 12) : isHourWithAmPm === "pm" ? stepOrList.filter((v) => v >= 12).map((v) => v === 12 ? 12 : v - 12) : stepOrList).map((v) => getFixValue(v));
        } else if (typeof stepOrList === "number") {
          if (isHourWithAmPm === "am") {
            return defaultValue.filter((hour) => {
              const hourAsNumber = Number(hour);
              return hourAsNumber < 12 && hourAsNumber % stepOrList === 0;
            });
          } else if (isHourWithAmPm === "pm") {
            return defaultValue.filter((hour) => {
              const hourAsNumber = Number(hour);
              return hourAsNumber >= 12 && hourAsNumber % stepOrList === 0;
            }).map((hour) => {
              const hourAsNumber = Number(hour);
              return getFixValue(hourAsNumber === 12 ? 12 : hourAsNumber - 12);
            });
          }
          return defaultValue.filter((hour) => {
            return Number(hour) % stepOrList === 0;
          });
        } else {
          return isHourWithAmPm === "am" ? defaultValue.filter((hour) => Number(hour) < 12) : isHourWithAmPm === "pm" ? defaultValue.map((hour) => Number(hour)).filter((hour) => Number(hour) >= 12).map((v) => getFixValue(v === 12 ? 12 : v - 12)) : defaultValue;
        }
      }
      function isTimeInStep(value, type2, stepOrList) {
        if (!stepOrList) {
          return true;
        } else if (typeof stepOrList === "number") {
          return value % stepOrList === 0;
        } else {
          return stepOrList.includes(value);
        }
      }
      function findSimilarTime(value, type2, stepOrList) {
        const list = getTimeUnits(time[type2], stepOrList).map(Number);
        let lowerBound, upperBound;
        for (let i = 0; i < list.length; ++i) {
          const v = list[i];
          if (v === value)
            return v;
          else if (v > value) {
            upperBound = v;
            break;
          }
          lowerBound = v;
        }
        if (lowerBound === void 0) {
          if (!upperBound) {
            throwError("time-picker", "Please set 'hours' or 'minutes' or 'seconds' props");
          }
          return upperBound;
        }
        if (upperBound === void 0) {
          return lowerBound;
        }
        return upperBound - value > value - lowerBound ? lowerBound : upperBound;
      }
      function getAmPm(value) {
        return getHours(value) < 12 ? "am" : "pm";
      }
      const timePickerInjectionKey = createInjectionKey("n-time-picker");
      const PanelCol = vue.defineComponent({
        name: "TimePickerPanelCol",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          data: {
            type: Array,
            required: true
          },
          activeValue: {
            type: Number,
            default: null
          },
          // It should be required but vue's type seems to have bugs
          onItemClick: Function
        },
        render() {
          const { activeValue, onItemClick, clsPrefix } = this;
          return this.data.map((item) => {
            const { label, disabled, value } = item;
            const active = activeValue === value;
            return vue.h("div", { key: label, "data-active": active ? "" : null, class: [
              `${clsPrefix}-time-picker-col__item`,
              active && `${clsPrefix}-time-picker-col__item--active`,
              disabled && `${clsPrefix}-time-picker-col__item--disabled`
            ], onClick: onItemClick && !disabled ? () => {
              onItemClick(value);
            } : void 0 }, label);
          });
        }
      });
      const timePickerPanelProps = {
        actions: {
          type: Array,
          default: () => ["now", "confirm"]
        },
        showHour: {
          type: Boolean,
          default: true
        },
        showMinute: {
          type: Boolean,
          default: true
        },
        showSecond: {
          type: Boolean,
          default: true
        },
        showPeriod: {
          type: Boolean,
          default: true
        },
        isHourInvalid: Boolean,
        isMinuteInvalid: Boolean,
        isSecondInvalid: Boolean,
        isAmPmInvalid: Boolean,
        isValueInvalid: Boolean,
        hourValue: {
          type: Number,
          default: null
        },
        minuteValue: {
          type: Number,
          default: null
        },
        secondValue: {
          type: Number,
          default: null
        },
        amPmValue: {
          type: String,
          default: null
        },
        isHourDisabled: Function,
        isMinuteDisabled: Function,
        isSecondDisabled: Function,
        onHourClick: {
          type: Function,
          required: true
        },
        onMinuteClick: {
          type: Function,
          required: true
        },
        onSecondClick: {
          type: Function,
          required: true
        },
        onAmPmClick: {
          type: Function,
          required: true
        },
        onNowClick: Function,
        nowText: String,
        confirmText: String,
        transitionDisabled: Boolean,
        onConfirmClick: Function,
        onFocusin: Function,
        onFocusout: Function,
        onFocusDetectorFocus: Function,
        onKeydown: Function,
        hours: [Number, Array],
        minutes: [Number, Array],
        seconds: [Number, Array],
        use12Hours: Boolean
      };
      const Panel = vue.defineComponent({
        name: "TimePickerPanel",
        props: timePickerPanelProps,
        setup(props) {
          const {
            mergedThemeRef,
            mergedClsPrefixRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(timePickerInjectionKey);
          const hoursRef = vue.computed(() => {
            const { isHourDisabled, hours, use12Hours, amPmValue } = props;
            if (!use12Hours) {
              return getTimeUnits(time.hours, hours).map((hour) => {
                return {
                  label: hour,
                  value: Number(hour),
                  disabled: isHourDisabled ? isHourDisabled(Number(hour)) : false
                };
              });
            } else {
              const mergedAmPmValue = amPmValue !== null && amPmValue !== void 0 ? amPmValue : getAmPm(Date.now());
              return getTimeUnits(time.hours, hours, mergedAmPmValue).map((hour) => {
                const hourAs12FormattedNumber = Number(hour);
                const hourAs24FormattedNumber = mergedAmPmValue === "pm" && hourAs12FormattedNumber !== 12 ? hourAs12FormattedNumber + 12 : hourAs12FormattedNumber;
                return {
                  label: hour,
                  value: hourAs24FormattedNumber,
                  disabled: isHourDisabled ? isHourDisabled(hourAs24FormattedNumber) : false
                };
              });
            }
          });
          const minutesRef = vue.computed(() => {
            const { isMinuteDisabled, minutes } = props;
            return getTimeUnits(time.minutes, minutes).map((minute) => {
              return {
                label: minute,
                value: Number(minute),
                disabled: isMinuteDisabled ? isMinuteDisabled(Number(minute), props.hourValue) : false
              };
            });
          });
          const secondsRef = vue.computed(() => {
            const { isSecondDisabled, seconds } = props;
            return getTimeUnits(time.seconds, seconds).map((second) => {
              return {
                label: second,
                value: Number(second),
                disabled: isSecondDisabled ? isSecondDisabled(Number(second), props.minuteValue, props.hourValue) : false
              };
            });
          });
          const amPmRef = vue.computed(() => {
            const { isHourDisabled } = props;
            let amDisabled = true;
            let pmDisabled = true;
            for (let i = 0; i < 12; ++i) {
              if (!(isHourDisabled === null || isHourDisabled === void 0 ? void 0 : isHourDisabled(i))) {
                amDisabled = false;
                break;
              }
            }
            for (let i = 12; i < 24; ++i) {
              if (!(isHourDisabled === null || isHourDisabled === void 0 ? void 0 : isHourDisabled(i))) {
                pmDisabled = false;
                break;
              }
            }
            return [
              {
                label: "AM",
                value: "am",
                disabled: amDisabled
              },
              {
                label: "PM",
                value: "pm",
                disabled: pmDisabled
              }
            ];
          });
          return {
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            hours: hoursRef,
            minutes: minutesRef,
            seconds: secondsRef,
            amPm: amPmRef,
            hourScrollRef: vue.ref(null),
            minuteScrollRef: vue.ref(null),
            secondScrollRef: vue.ref(null),
            amPmScrollRef: vue.ref(null)
          };
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme } = this;
          return vue.h(
            "div",
            { tabindex: 0, class: `${mergedClsPrefix}-time-picker-panel`, onFocusin: this.onFocusin, onFocusout: this.onFocusout, onKeydown: this.onKeydown },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-time-picker-cols` },
              this.showHour ? vue.h(
                "div",
                { class: [
                  `${mergedClsPrefix}-time-picker-col`,
                  this.isHourInvalid && `${mergedClsPrefix}-time-picker-col--invalid`,
                  this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`
                ] },
                vue.h(NScrollbar, { ref: "hourScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => [
                    vue.h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.hours, activeValue: this.hourValue, onItemClick: this.onHourClick }),
                    vue.h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                  ]
                })
              ) : null,
              this.showMinute ? vue.h(
                "div",
                { class: [
                  `${mergedClsPrefix}-time-picker-col`,
                  this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`,
                  this.isMinuteInvalid && `${mergedClsPrefix}-time-picker-col--invalid`
                ] },
                vue.h(NScrollbar, { ref: "minuteScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => [
                    vue.h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.minutes, activeValue: this.minuteValue, onItemClick: this.onMinuteClick }),
                    vue.h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                  ]
                })
              ) : null,
              this.showSecond ? vue.h(
                "div",
                { class: [
                  `${mergedClsPrefix}-time-picker-col`,
                  this.isSecondInvalid && `${mergedClsPrefix}-time-picker-col--invalid`,
                  this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`
                ] },
                vue.h(NScrollbar, { ref: "secondScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => [
                    vue.h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.seconds, activeValue: this.secondValue, onItemClick: this.onSecondClick }),
                    vue.h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                  ]
                })
              ) : null,
              this.use12Hours ? vue.h(
                "div",
                { class: [
                  `${mergedClsPrefix}-time-picker-col`,
                  this.isAmPmInvalid && `${mergedClsPrefix}-time-picker-col--invalid`,
                  this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`
                ] },
                vue.h(NScrollbar, { ref: "amPmScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => [
                    vue.h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.amPm, activeValue: this.amPmValue, onItemClick: this.onAmPmClick }),
                    vue.h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                  ]
                })
              ) : null
            ),
            ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-time-picker-actions` },
              ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("now")) ? vue.h(NButton, { size: "tiny", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.onNowClick }, { default: () => this.nowText }) : null,
              ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? vue.h(NButton, { size: "tiny", type: "primary", class: `${mergedClsPrefix}-time-picker-actions__confirm`, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, disabled: this.isValueInvalid, onClick: this.onConfirmClick }, { default: () => this.confirmText }) : null
            ) : null,
            vue.h(FocusDetector, { onFocus: this.onFocusDetectorFocus })
          );
        }
      });
      const style$S = c$1([cB("time-picker", `
 z-index: auto;
 position: relative;
 `, [cB("time-picker-icon", `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cM("disabled", [cB("time-picker-icon", `
 color: var(--n-icon-color-disabled-override);
 `)])]), cB("time-picker-panel", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 font-size: var(--n-item-font-size);
 border-radius: var(--n-border-radius);
 margin: 4px 0;
 min-width: 104px;
 overflow: hidden;
 background-color: var(--n-panel-color);
 box-shadow: var(--n-panel-box-shadow);
 `, [fadeInScaleUpTransition(), cB("time-picker-actions", `
 padding: var(--n-panel-action-padding);
 align-items: center;
 display: flex;
 justify-content: space-evenly;
 `), cB("time-picker-cols", `
 height: calc(var(--n-item-height) * 6);
 display: flex;
 position: relative;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-panel-divider-color);
 `), cB("time-picker-col", `
 flex-grow: 1;
 min-width: var(--n-item-width);
 height: calc(var(--n-item-height) * 6);
 flex-direction: column;
 transition: box-shadow .3s var(--n-bezier);
 `, [cM("transition-disabled", [cE("item", "transition: none;", [c$1("&::before", "transition: none;")])]), cE("padding", `
 height: calc(var(--n-item-height) * 5);
 `), c$1("&:first-child", "min-width: calc(var(--n-item-width) + 4px);", [cE("item", [c$1("&::before", "left: 4px;")])]), cE("item", `
 cursor: pointer;
 height: var(--n-item-height);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 background: #0000;
 text-decoration-color: #0000;
 color: var(--n-item-text-color);
 z-index: 0;
 box-sizing: border-box;
 padding-top: 4px;
 position: relative;
 `, [c$1("&::before", `
 content: "";
 transition: background-color .3s var(--n-bezier);
 z-index: -1;
 position: absolute;
 left: 0;
 right: 4px;
 top: 4px;
 bottom: 0;
 border-radius: var(--n-item-border-radius);
 `), cNotM("disabled", [c$1("&:hover::before", `
 background-color: var(--n-item-color-hover);
 `)]), cM("active", `
 color: var(--n-item-text-color-active);
 `, [c$1("&::before", `
 background-color: var(--n-item-color-hover);
 `)]), cM("disabled", `
 opacity: var(--n-item-opacity-disabled);
 cursor: not-allowed;
 `)]), cM("invalid", [cE("item", [cM("active", `
 text-decoration: line-through;
 text-decoration-color: var(--n-item-text-color-active);
 `)])])])])]);
      function validateUnits(value, max) {
        if (value === void 0) {
          return true;
        }
        if (Array.isArray(value)) {
          return value.every((v) => v >= 0 && v <= max);
        } else {
          return value >= 0 && value <= max;
        }
      }
      const timePickerProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        bordered: {
          type: Boolean,
          default: void 0
        },
        actions: Array,
        defaultValue: {
          type: Number,
          default: null
        },
        defaultFormattedValue: String,
        placeholder: String,
        placement: {
          type: String,
          default: "bottom-start"
        },
        value: Number,
        format: {
          type: String,
          default: "HH:mm:ss"
        },
        valueFormat: String,
        formattedValue: String,
        isHourDisabled: Function,
        size: String,
        isMinuteDisabled: Function,
        isSecondDisabled: Function,
        inputReadonly: Boolean,
        clearable: Boolean,
        status: String,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        onUpdateFormattedValue: [Function, Array],
        "onUpdate:formattedValue": [Function, Array],
        onBlur: [Function, Array],
        onConfirm: [Function, Array],
        onClear: Function,
        onFocus: [Function, Array],
        // https://www.iana.org/time-zones
        timeZone: String,
        showIcon: {
          type: Boolean,
          default: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        show: {
          type: Boolean,
          default: void 0
        },
        hours: {
          type: [Number, Array],
          validator: (value) => validateUnits(value, 23)
        },
        minutes: {
          type: [Number, Array],
          validator: (value) => validateUnits(value, 59)
        },
        seconds: {
          type: [Number, Array],
          validator: (value) => validateUnits(value, 59)
        },
        use12Hours: Boolean,
        // private
        stateful: {
          type: Boolean,
          default: true
        },
        // deprecated
        onChange: [Function, Array]
      });
      const NTimePicker = vue.defineComponent({
        name: "TimePicker",
        props: timePickerProps,
        setup(props) {
          const { mergedBorderedRef, mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const { localeRef, dateLocaleRef } = useLocale("TimePicker");
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const themeRef = useTheme("TimePicker", "-time-picker", style$S, timePickerLight$1, props, mergedClsPrefixRef);
          const keyboardState = useKeyboard$1();
          const inputInstRef = vue.ref(null);
          const panelInstRef = vue.ref(null);
          const dateFnsOptionsRef = vue.computed(() => {
            return {
              locale: dateLocaleRef.value.locale
            };
          });
          function getTimestampFromFormattedValue(value) {
            if (value === null)
              return null;
            return strictParse(value, props.valueFormat || props.format, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value).getTime();
          }
          const { defaultValue, defaultFormattedValue } = props;
          const uncontrolledValueRef = vue.ref(defaultFormattedValue !== void 0 ? getTimestampFromFormattedValue(defaultFormattedValue) : defaultValue);
          const mergedValueRef = vue.computed(() => {
            const { formattedValue } = props;
            if (formattedValue !== void 0) {
              return getTimestampFromFormattedValue(formattedValue);
            }
            const { value } = props;
            if (value !== void 0) {
              return value;
            }
            return uncontrolledValueRef.value;
          });
          const mergedFormatRef = vue.computed(() => {
            const { timeZone } = props;
            if (timeZone) {
              return (date2, format2, options) => {
                return formatInTimeZone(date2, timeZone, format2, options);
              };
            } else {
              return (date2, _format, options) => {
                return format$4(date2, _format, options);
              };
            }
          });
          const displayTimeStringRef = vue.ref("");
          vue.watch(() => props.timeZone, () => {
            const mergedValue = mergedValueRef.value;
            displayTimeStringRef.value = mergedValue === null ? "" : mergedFormatRef.value(mergedValue, props.format, dateFnsOptionsRef.value);
          }, {
            immediate: true
          });
          const uncontrolledShowRef = vue.ref(false);
          const controlledShowRef = vue.toRef(props, "show");
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const memorizedValueRef = vue.ref(mergedValueRef.value);
          const transitionDisabledRef = vue.ref(false);
          const localizedNowRef = vue.computed(() => {
            return localeRef.value.now;
          });
          const localizedPlaceholderRef = vue.computed(() => {
            if (props.placeholder !== void 0)
              return props.placeholder;
            return localeRef.value.placeholder;
          });
          const localizedNegativeTextRef = vue.computed(() => {
            return localeRef.value.negativeText;
          });
          const localizedPositiveTextRef = vue.computed(() => {
            return localeRef.value.positiveText;
          });
          const hourInFormatRef = vue.computed(() => {
            return /H|h|K|k/.test(props.format);
          });
          const minuteInFormatRef = vue.computed(() => {
            return props.format.includes("m");
          });
          const secondInFormatRef = vue.computed(() => {
            return props.format.includes("s");
          });
          const isHourInvalidRef = vue.computed(() => {
            const { isHourDisabled } = props;
            if (hourValueRef.value === null)
              return false;
            if (!isTimeInStep(hourValueRef.value, "hours", props.hours))
              return true;
            if (!isHourDisabled)
              return false;
            return isHourDisabled(hourValueRef.value);
          });
          const isMinuteInvalidRef = vue.computed(() => {
            const { value: minuteValue } = minuteValueRef;
            const { value: hourValue } = hourValueRef;
            if (minuteValue === null || hourValue === null)
              return false;
            if (!isTimeInStep(minuteValue, "minutes", props.minutes))
              return true;
            const { isMinuteDisabled } = props;
            if (!isMinuteDisabled)
              return false;
            return isMinuteDisabled(minuteValue, hourValue);
          });
          const isSecondInvalidRef = vue.computed(() => {
            const { value: minuteValue } = minuteValueRef;
            const { value: hourValue } = hourValueRef;
            const { value: secondValue } = secondValueRef;
            if (secondValue === null || minuteValue === null || hourValue === null) {
              return false;
            }
            if (!isTimeInStep(secondValue, "seconds", props.seconds))
              return true;
            const { isSecondDisabled } = props;
            if (!isSecondDisabled)
              return false;
            return isSecondDisabled(secondValue, minuteValue, hourValue);
          });
          const isValueInvalidRef = vue.computed(() => {
            return isHourInvalidRef.value || isMinuteInvalidRef.value || isSecondInvalidRef.value;
          });
          const mergedAttrSizeRef = vue.computed(() => {
            return props.format.length + 4;
          });
          const amPmValueRef = vue.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
              return null;
            return getHours(value) < 12 ? "am" : "pm";
          });
          const hourValueRef = vue.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
              return null;
            return Number(mergedFormatRef.value(value, "HH", dateFnsOptionsRef.value));
          });
          const minuteValueRef = vue.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
              return null;
            return Number(mergedFormatRef.value(value, "mm", dateFnsOptionsRef.value));
          });
          const secondValueRef = vue.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
              return null;
            return Number(mergedFormatRef.value(value, "ss", dateFnsOptionsRef.value));
          });
          function doUpdateFormattedValue(value, timestampValue) {
            const { onUpdateFormattedValue, "onUpdate:formattedValue": _onUpdateFormattedValue } = props;
            if (onUpdateFormattedValue) {
              call(onUpdateFormattedValue, value, timestampValue);
            }
            if (_onUpdateFormattedValue) {
              call(_onUpdateFormattedValue, value, timestampValue);
            }
          }
          function createFormattedValue(value) {
            return value === null ? null : mergedFormatRef.value(value, props.valueFormat || props.format);
          }
          function doUpdateValue(value) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue, onChange } = props;
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            const formattedValue = createFormattedValue(value);
            if (onUpdateValue) {
              call(onUpdateValue, value, formattedValue);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value, formattedValue);
            }
            if (onChange)
              call(onChange, value, formattedValue);
            doUpdateFormattedValue(formattedValue, value);
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
          }
          function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
          }
          function doConfirm() {
            const { onConfirm } = props;
            if (onConfirm) {
              call(onConfirm, mergedValueRef.value, createFormattedValue(mergedValueRef.value));
            }
          }
          function handleTimeInputClear(e) {
            var _a;
            e.stopPropagation();
            doUpdateValue(null);
            deriveInputValue(null);
            (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          function handleFocusDetectorFocus() {
            closePanel({
              returnFocus: true
            });
          }
          function handleInputKeydown(e) {
            if (e.key === "Escape" && mergedShowRef.value) {
              markEventEffectPerformed(e);
            }
          }
          function handleMenuKeydown(e) {
            var _a;
            switch (e.key) {
              case "Escape":
                if (mergedShowRef.value) {
                  markEventEffectPerformed(e);
                  closePanel({
                    returnFocus: true
                  });
                }
                break;
              case "Tab":
                if (keyboardState.shift && e.target === ((_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el)) {
                  e.preventDefault();
                  closePanel({
                    returnFocus: true
                  });
                }
                break;
            }
          }
          function disableTransitionOneTick() {
            transitionDisabledRef.value = true;
            void vue.nextTick(() => {
              transitionDisabledRef.value = false;
            });
          }
          function handleTriggerClick(e) {
            if (mergedDisabledRef.value || happensIn(e, "clear"))
              return;
            if (!mergedShowRef.value) {
              openPanel();
            }
          }
          function handleHourClick(hour) {
            if (typeof hour === "string")
              return;
            if (mergedValueRef.value === null) {
              doUpdateValue(getTime(setHours(startOfHour(/* @__PURE__ */ new Date()), hour)));
            } else {
              doUpdateValue(getTime(setHours(mergedValueRef.value, hour)));
            }
          }
          function handleMinuteClick(minute) {
            if (typeof minute === "string")
              return;
            if (mergedValueRef.value === null) {
              doUpdateValue(getTime(setMinutes(startOfMinute(/* @__PURE__ */ new Date()), minute)));
            } else {
              doUpdateValue(getTime(setMinutes(mergedValueRef.value, minute)));
            }
          }
          function handleSecondClick(second) {
            if (typeof second === "string")
              return;
            if (mergedValueRef.value === null) {
              doUpdateValue(getTime(setSeconds(startOfSecond(/* @__PURE__ */ new Date()), second)));
            } else {
              doUpdateValue(getTime(setSeconds(mergedValueRef.value, second)));
            }
          }
          function handleAmPmClick(amPm) {
            const { value: mergedValue } = mergedValueRef;
            if (mergedValue === null) {
              const now2 = /* @__PURE__ */ new Date();
              const hours = getHours(now2);
              if (amPm === "pm" && hours < 12) {
                doUpdateValue(getTime(setHours(now2, hours + 12)));
              } else if (amPm === "am" && hours >= 12) {
                doUpdateValue(getTime(setHours(now2, hours - 12)));
              }
              doUpdateValue(getTime(now2));
            } else {
              const hours = getHours(mergedValue);
              if (amPm === "pm" && hours < 12) {
                doUpdateValue(getTime(setHours(mergedValue, hours + 12)));
              } else if (amPm === "am" && hours >= 12) {
                doUpdateValue(getTime(setHours(mergedValue, hours - 12)));
              }
            }
          }
          function deriveInputValue(time2) {
            if (time2 === void 0)
              time2 = mergedValueRef.value;
            if (time2 === null)
              displayTimeStringRef.value = "";
            else {
              displayTimeStringRef.value = mergedFormatRef.value(time2, props.format, dateFnsOptionsRef.value);
            }
          }
          function handleTimeInputFocus(e) {
            if (isInternalFocusSwitch(e))
              return;
            doFocus(e);
          }
          function handleTimeInputBlur(e) {
            var _a;
            if (isInternalFocusSwitch(e))
              return;
            if (mergedShowRef.value) {
              const panelEl = (_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;
              if (!(panelEl === null || panelEl === void 0 ? void 0 : panelEl.contains(e.relatedTarget))) {
                deriveInputValue();
                doBlur(e);
                closePanel({
                  returnFocus: false
                });
              }
            } else {
              deriveInputValue();
              doBlur(e);
            }
          }
          function handleTimeInputActivate() {
            if (mergedDisabledRef.value)
              return;
            if (!mergedShowRef.value) {
              openPanel();
            }
          }
          function handleTimeInputDeactivate() {
            if (mergedDisabledRef.value)
              return;
            deriveInputValue();
            closePanel({
              returnFocus: false
            });
          }
          function scrollTimer() {
            if (!panelInstRef.value)
              return;
            const { hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef } = panelInstRef.value;
            [hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef].forEach((itemScrollRef) => {
              var _a;
              if (!itemScrollRef)
                return;
              const activeItemEl = (_a = itemScrollRef.contentRef) === null || _a === void 0 ? void 0 : _a.querySelector("[data-active]");
              if (activeItemEl) {
                itemScrollRef.scrollTo({
                  top: activeItemEl.offsetTop
                });
              }
            });
          }
          function doUpdateShow(value) {
            uncontrolledShowRef.value = value;
            const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow)
              call(onUpdateShow, value);
            if (_onUpdateShow)
              call(_onUpdateShow, value);
          }
          function isInternalFocusSwitch(e) {
            var _a, _b, _c;
            return !!(((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) || ((_c = panelInstRef.value) === null || _c === void 0 ? void 0 : _c.$el.contains(e.relatedTarget)));
          }
          function openPanel() {
            memorizedValueRef.value = mergedValueRef.value;
            doUpdateShow(true);
            void vue.nextTick(scrollTimer);
          }
          function handleClickOutside(e) {
            var _a, _b;
            if (mergedShowRef.value && !((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(getPreciseEventTarget(e)))) {
              closePanel({
                returnFocus: false
              });
            }
          }
          function closePanel({ returnFocus }) {
            var _a;
            if (mergedShowRef.value) {
              doUpdateShow(false);
              if (returnFocus) {
                (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              }
            }
          }
          function handleTimeInputUpdateValue(v) {
            if (v === "") {
              doUpdateValue(null);
              return;
            }
            const time2 = strictParse(v, props.format, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
            displayTimeStringRef.value = v;
            if (isValid$1(time2)) {
              const { value: mergedValue } = mergedValueRef;
              if (mergedValue !== null) {
                const newTime = set(mergedValue, {
                  hours: getHours(time2),
                  minutes: getMinutes(time2),
                  seconds: getSeconds(time2)
                });
                doUpdateValue(getTime(newTime));
              } else {
                doUpdateValue(getTime(time2));
              }
            }
          }
          function handleCancelClick() {
            doUpdateValue(memorizedValueRef.value);
            doUpdateShow(false);
          }
          function handleNowClick() {
            const now2 = /* @__PURE__ */ new Date();
            const getNowTime = {
              hours: getHours,
              minutes: getMinutes,
              seconds: getSeconds
            };
            const [mergeHours, mergeMinutes, mergeSeconds] = ["hours", "minutes", "seconds"].map((i) => !props[i] || isTimeInStep(getNowTime[i](now2), i, props[i]) ? getNowTime[i](now2) : findSimilarTime(getNowTime[i](now2), i, props[i]));
            const newValue = setSeconds(setMinutes(setHours(mergedValueRef.value ? mergedValueRef.value : getTime(now2), mergeHours), mergeMinutes), mergeSeconds);
            doUpdateValue(getTime(newValue));
          }
          function handleConfirmClick() {
            deriveInputValue();
            doConfirm();
            closePanel({
              returnFocus: true
            });
          }
          function handleMenuFocusOut(e) {
            if (isInternalFocusSwitch(e))
              return;
            deriveInputValue();
            doBlur(e);
            closePanel({
              returnFocus: false
            });
          }
          vue.watch(mergedValueRef, (value) => {
            deriveInputValue(value);
            disableTransitionOneTick();
            void vue.nextTick(scrollTimer);
          });
          vue.watch(mergedShowRef, () => {
            if (isValueInvalidRef.value) {
              doUpdateValue(memorizedValueRef.value);
            }
          });
          vue.provide(timePickerInjectionKey, {
            mergedThemeRef: themeRef,
            mergedClsPrefixRef
          });
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          const triggerCssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { iconColor, iconColorDisabled } } = themeRef.value;
            return {
              "--n-icon-color-override": iconColor,
              "--n-icon-color-disabled-override": iconColorDisabled,
              "--n-bezier": cubicBezierEaseInOut2
            };
          });
          const triggerThemeClassHandle = inlineThemeDisabled ? useThemeClass("time-picker-trigger", void 0, triggerCssVarsRef, props) : void 0;
          const cssVarsRef = vue.computed(() => {
            const { self: { panelColor, itemTextColor, itemTextColorActive, itemColorHover, panelDividerColor, panelBoxShadow, itemOpacityDisabled, borderRadius, itemFontSize, itemWidth, itemHeight, panelActionPadding, itemBorderRadius }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-item-color-hover": itemColorHover,
              "--n-item-font-size": itemFontSize,
              "--n-item-height": itemHeight,
              "--n-item-opacity-disabled": itemOpacityDisabled,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-active": itemTextColorActive,
              "--n-item-width": itemWidth,
              "--n-panel-action-padding": panelActionPadding,
              "--n-panel-box-shadow": panelBoxShadow,
              "--n-panel-color": panelColor,
              "--n-panel-divider-color": panelDividerColor,
              "--n-item-border-radius": itemBorderRadius
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("time-picker", void 0, cssVarsRef, props) : void 0;
          return {
            focus: exposedMethods.focus,
            blur: exposedMethods.blur,
            mergedStatus: mergedStatusRef,
            mergedBordered: mergedBorderedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            isMounted: isMounted(),
            inputInstRef,
            panelInstRef,
            adjustedTo: useAdjustedTo(props),
            mergedShow: mergedShowRef,
            localizedNow: localizedNowRef,
            localizedPlaceholder: localizedPlaceholderRef,
            localizedNegativeText: localizedNegativeTextRef,
            localizedPositiveText: localizedPositiveTextRef,
            hourInFormat: hourInFormatRef,
            minuteInFormat: minuteInFormatRef,
            secondInFormat: secondInFormatRef,
            mergedAttrSize: mergedAttrSizeRef,
            displayTimeString: displayTimeStringRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            isValueInvalid: isValueInvalidRef,
            isHourInvalid: isHourInvalidRef,
            isMinuteInvalid: isMinuteInvalidRef,
            isSecondInvalid: isSecondInvalidRef,
            transitionDisabled: transitionDisabledRef,
            hourValue: hourValueRef,
            minuteValue: minuteValueRef,
            secondValue: secondValueRef,
            amPmValue: amPmValueRef,
            handleInputKeydown,
            handleTimeInputFocus,
            handleTimeInputBlur,
            handleNowClick,
            handleConfirmClick,
            handleTimeInputUpdateValue,
            handleMenuFocusOut,
            handleCancelClick,
            handleClickOutside,
            handleTimeInputActivate,
            handleTimeInputDeactivate,
            handleHourClick,
            handleMinuteClick,
            handleSecondClick,
            handleAmPmClick,
            handleTimeInputClear,
            handleFocusDetectorFocus,
            handleMenuKeydown,
            handleTriggerClick,
            mergedTheme: themeRef,
            triggerCssVars: inlineThemeDisabled ? void 0 : triggerCssVarsRef,
            triggerThemeClass: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.themeClass,
            triggerOnRender: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.onRender,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix, $slots, triggerOnRender } = this;
          triggerOnRender === null || triggerOnRender === void 0 ? void 0 : triggerOnRender();
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-time-picker`, this.triggerThemeClass], style: this.triggerCssVars },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h(NInput, { ref: "inputInstRef", status: this.mergedStatus, value: this.displayTimeString, bordered: this.mergedBordered, passivelyActivated: true, attrSize: this.mergedAttrSize, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, stateful: this.stateful, size: this.mergedSize, placeholder: this.localizedPlaceholder, clearable: this.clearable, disabled: this.mergedDisabled, textDecoration: this.isValueInvalid ? "line-through" : void 0, onFocus: this.handleTimeInputFocus, onBlur: this.handleTimeInputBlur, onActivate: this.handleTimeInputActivate, onDeactivate: this.handleTimeInputDeactivate, onUpdateValue: this.handleTimeInputUpdateValue, onClear: this.handleTimeInputClear, internalDeactivateOnEnter: true, internalForceFocus: this.mergedShow, readonly: this.inputReadonly || this.mergedDisabled, onClick: this.handleTriggerClick, onKeydown: this.handleInputKeydown }, this.showIcon ? {
                    [this.clearable ? "clear-icon-placeholder" : "suffix"]: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-time-picker-icon` }, {
                      default: () => $slots.icon ? $slots.icon() : vue.h(TimeIcon, null)
                    })
                  } : null)
                }),
                vue.h(VFollower, { teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, show: this.mergedShow, to: this.adjustedTo, containerClass: this.namespace, placement: this.placement }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                    default: () => {
                      var _a;
                      if (this.mergedShow) {
                        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                        return vue.withDirectives(vue.h(Panel, { ref: "panelInstRef", actions: this.actions, class: this.themeClass, style: this.cssVars, seconds: this.seconds, minutes: this.minutes, hours: this.hours, transitionDisabled: this.transitionDisabled, hourValue: this.hourValue, showHour: this.hourInFormat, isHourInvalid: this.isHourInvalid, isHourDisabled: this.isHourDisabled, minuteValue: this.minuteValue, showMinute: this.minuteInFormat, isMinuteInvalid: this.isMinuteInvalid, isMinuteDisabled: this.isMinuteDisabled, secondValue: this.secondValue, amPmValue: this.amPmValue, showSecond: this.secondInFormat, isSecondInvalid: this.isSecondInvalid, isSecondDisabled: this.isSecondDisabled, isValueInvalid: this.isValueInvalid, nowText: this.localizedNow, confirmText: this.localizedPositiveText, use12Hours: this.use12Hours, onFocusout: this.handleMenuFocusOut, onKeydown: this.handleMenuKeydown, onHourClick: this.handleHourClick, onMinuteClick: this.handleMinuteClick, onSecondClick: this.handleSecondClick, onAmPmClick: this.handleAmPmClick, onNowClick: this.handleNowClick, onConfirmClick: this.handleConfirmClick, onFocusDetectorFocus: this.handleFocusDetectorFocus }), [
                          [
                            clickoutside$1,
                            this.handleClickOutside,
                            void 0,
                            { capture: true }
                          ]
                        ]);
                      }
                      return null;
                    }
                  })
                })
              ]
            })
          );
        }
      });
      const TIME_FORMAT = "HH:mm:ss";
      const usePanelCommonProps = {
        active: Boolean,
        dateFormat: String,
        timeFormat: {
          type: String,
          value: TIME_FORMAT
        },
        value: {
          type: [Array, Number],
          default: null
        },
        shortcuts: Object,
        defaultTime: [Number, String, Array],
        onClear: Function,
        onConfirm: Function,
        onClose: Function,
        onTabOut: Function,
        onUpdateValue: {
          type: Function,
          required: true
        },
        themeClass: String,
        onRender: Function,
        panel: Boolean
      };
      function usePanelCommon(props) {
        const {
          dateLocaleRef,
          timePickerSizeRef,
          timePickerPropsRef,
          localeRef,
          mergedClsPrefixRef,
          mergedThemeRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = vue.inject(datePickerInjectionKey);
        const dateFnsOptionsRef = vue.computed(() => {
          return {
            locale: dateLocaleRef.value.locale
          };
        });
        const selfRef = vue.ref(null);
        const keyboardState = useKeyboard$1();
        function doClear() {
          const { onClear } = props;
          if (onClear)
            onClear();
        }
        function doConfirm() {
          const { onConfirm, value } = props;
          if (onConfirm)
            onConfirm(value);
        }
        function doUpdateValue(value, doUpdate) {
          const { onUpdateValue } = props;
          onUpdateValue(value, doUpdate);
        }
        function doClose(disableUpdateOnClose = false) {
          const { onClose } = props;
          if (onClose)
            onClose(disableUpdateOnClose);
        }
        function doTabOut() {
          const { onTabOut } = props;
          if (onTabOut)
            onTabOut();
        }
        function handleClearClick() {
          doUpdateValue(null, true);
          doClose(true);
          doClear();
        }
        function handleFocusDetectorFocus() {
          doTabOut();
        }
        function disableTransitionOneTick() {
          if (props.active || props.panel) {
            void vue.nextTick(() => {
              const { value: selfEl } = selfRef;
              if (!selfEl)
                return;
              const dateEls = selfEl.querySelectorAll("[data-n-date]");
              dateEls.forEach((el) => {
                el.classList.add("transition-disabled");
              });
              void selfEl.offsetWidth;
              dateEls.forEach((el) => {
                el.classList.remove("transition-disabled");
              });
            });
          }
        }
        function handlePanelKeyDown(e) {
          if (e.key === "Tab" && e.target === selfRef.value && keyboardState.shift) {
            e.preventDefault();
            doTabOut();
          }
        }
        function handlePanelFocus(e) {
          const { value: el } = selfRef;
          if (keyboardState.tab && e.target === el && (el === null || el === void 0 ? void 0 : el.contains(e.relatedTarget))) {
            doTabOut();
          }
        }
        let cachedValue = null;
        let cached = false;
        function cachePendingValue() {
          cachedValue = props.value;
          cached = true;
        }
        function clearPendingValue() {
          cached = false;
        }
        function restorePendingValue() {
          if (cached) {
            doUpdateValue(cachedValue, false);
            cached = false;
          }
        }
        function getShortcutValue(shortcut) {
          if (typeof shortcut === "function") {
            return shortcut();
          }
          return shortcut;
        }
        const showMonthYearPanel = vue.ref(false);
        function handleOpenQuickSelectMonthPanel() {
          showMonthYearPanel.value = !showMonthYearPanel.value;
        }
        return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          dateFnsOptions: dateFnsOptionsRef,
          timePickerSize: timePickerSizeRef,
          timePickerProps: timePickerPropsRef,
          selfRef,
          locale: localeRef,
          doConfirm,
          doClose,
          doUpdateValue,
          doTabOut,
          handleClearClick,
          handleFocusDetectorFocus,
          disableTransitionOneTick,
          handlePanelKeyDown,
          handlePanelFocus,
          cachePendingValue,
          clearPendingValue,
          restorePendingValue,
          getShortcutValue,
          handleShortcutMouseleave: restorePendingValue,
          showMonthYearPanel,
          handleOpenQuickSelectMonthPanel
        };
      }
      const useCalendarProps = Object.assign(Object.assign({}, usePanelCommonProps), { actions: {
        type: Array,
        default: () => ["now", "clear", "confirm"]
      } });
      function useCalendar(props, type2) {
        const panelCommon = usePanelCommon(props);
        const {
          isValueInvalidRef,
          isDateDisabledRef,
          isDateInvalidRef,
          isTimeInvalidRef,
          isDateTimeInvalidRef,
          isHourDisabledRef,
          isMinuteDisabledRef,
          isSecondDisabledRef,
          localeRef,
          firstDayOfWeekRef,
          datePickerSlots
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = vue.inject(datePickerInjectionKey);
        const validation2 = {
          isValueInvalid: isValueInvalidRef,
          isDateDisabled: isDateDisabledRef,
          isDateInvalid: isDateInvalidRef,
          isTimeInvalid: isTimeInvalidRef,
          isDateTimeInvalid: isDateTimeInvalidRef,
          isHourDisabled: isHourDisabledRef,
          isMinuteDisabled: isMinuteDisabledRef,
          isSecondDisabled: isSecondDisabledRef
        };
        const mergedDateFormatRef = vue.computed(() => props.dateFormat || localeRef.value.dateFormat);
        const dateInputValueRef = vue.ref(props.value === null || Array.isArray(props.value) ? "" : format$4(props.value, mergedDateFormatRef.value));
        const calendarValueRef = vue.ref(props.value === null || Array.isArray(props.value) ? Date.now() : props.value);
        const yearVlRef = vue.ref(null);
        const yearScrollbarRef = vue.ref(null);
        const monthScrollbarRef = vue.ref(null);
        const nowRef = vue.ref(Date.now());
        const dateArrayRef = vue.computed(() => {
          var _a;
          return dateArray(calendarValueRef.value, props.value, nowRef.value, (_a = firstDayOfWeekRef.value) !== null && _a !== void 0 ? _a : localeRef.value.firstDayOfWeek);
        });
        const monthArrayRef = vue.computed(() => {
          const { value } = props;
          return monthArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value);
        });
        const yearArrayRef = vue.computed(() => {
          const { value } = props;
          return yearArray(Array.isArray(value) ? null : value, nowRef.value);
        });
        const quarterArrayRef = vue.computed(() => {
          const { value } = props;
          return quarterArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value);
        });
        const weekdaysRef = vue.computed(() => {
          return dateArrayRef.value.slice(0, 7).map((dateItem2) => {
            const { ts } = dateItem2;
            return format$4(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
          });
        });
        const calendarMonthRef = vue.computed(() => {
          return format$4(calendarValueRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
        });
        const calendarYearRef = vue.computed(() => {
          return format$4(calendarValueRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
        });
        vue.watch(calendarValueRef, (value, oldValue) => {
          if (type2 === "date" || type2 === "datetime") {
            if (!isSameMonth(value, oldValue)) {
              panelCommon.disableTransitionOneTick();
            }
          }
        });
        vue.watch(vue.computed(() => props.value), (value) => {
          if (value !== null && !Array.isArray(value)) {
            dateInputValueRef.value = format$4(value, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
            calendarValueRef.value = value;
          } else {
            dateInputValueRef.value = "";
          }
        });
        function sanitizeValue(value) {
          if (type2 === "datetime")
            return getTime(startOfSecond(value));
          if (type2 === "month")
            return getTime(startOfMonth(value));
          if (type2 === "year")
            return getTime(startOfYear(value));
          if (type2 === "quarter")
            return getTime(startOfQuarter(value));
          return getTime(startOfDay(value));
        }
        function mergedIsDateDisabled(ts) {
          const { isDateDisabled: { value: isDateDisabled } } = validation2;
          if (!isDateDisabled)
            return false;
          return isDateDisabled(ts);
        }
        function handleDateInput(value) {
          const date2 = strictParse(value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date2)) {
            if (props.value === null) {
              panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), props.panel);
            } else if (!Array.isArray(props.value)) {
              const newDateTime = set(props.value, {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), props.panel);
            }
          } else {
            dateInputValueRef.value = value;
          }
        }
        function handleDateInputBlur() {
          const date2 = strictParse(dateInputValueRef.value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date2)) {
            if (props.value === null) {
              panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), false);
            } else if (!Array.isArray(props.value)) {
              const newDateTime = set(props.value, {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), false);
            }
          } else {
            deriveDateInputValue();
          }
        }
        function clearSelectedDateTime() {
          panelCommon.doUpdateValue(null, true);
          dateInputValueRef.value = "";
          panelCommon.doClose(true);
          panelCommon.handleClearClick();
        }
        function handleNowClick() {
          panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), true);
          const now2 = Date.now();
          calendarValueRef.value = now2;
          panelCommon.doClose(true);
          if (props.panel && (type2 === "month" || type2 === "quarter" || type2 === "year")) {
            panelCommon.disableTransitionOneTick();
            justifyColumnsScrollState(now2);
          }
        }
        function handleDateClick(dateItem2) {
          if (mergedIsDateDisabled(dateItem2.ts)) {
            return;
          }
          let newValue;
          if (props.value !== null && !Array.isArray(props.value)) {
            newValue = props.value;
          } else {
            newValue = Date.now();
          }
          if (type2 === "datetime" && props.defaultTime !== null && !Array.isArray(props.defaultTime)) {
            const time2 = getDefaultTime(props.defaultTime);
            if (time2) {
              newValue = getTime(set(newValue, time2));
            }
          }
          newValue = getTime(dateItem2.type === "quarter" && dateItem2.dateObject.quarter ? setQuarter(setYear(newValue, dateItem2.dateObject.year), dateItem2.dateObject.quarter) : set(newValue, dateItem2.dateObject));
          panelCommon.doUpdateValue(sanitizeValue(newValue), props.panel || type2 === "date" || type2 === "year");
          switch (type2) {
            case "date":
              panelCommon.doClose();
              break;
            case "year":
              if (props.panel) {
                panelCommon.disableTransitionOneTick();
              }
              panelCommon.doClose();
              break;
            case "month":
              panelCommon.disableTransitionOneTick();
              justifyColumnsScrollState(newValue);
              break;
            case "quarter":
              panelCommon.disableTransitionOneTick();
              justifyColumnsScrollState(newValue);
              break;
          }
        }
        function handleQuickMonthClick(dateItem2, updatePanelValue) {
          let newValue;
          if (props.value !== null && !Array.isArray(props.value)) {
            newValue = props.value;
          } else {
            newValue = Date.now();
          }
          newValue = getTime(dateItem2.type === "month" ? setMonth(newValue, dateItem2.dateObject.month) : setYear(newValue, dateItem2.dateObject.year));
          updatePanelValue(newValue);
          justifyColumnsScrollState(newValue);
        }
        function onUpdateCalendarValue(value) {
          calendarValueRef.value = value;
        }
        function deriveDateInputValue(time2) {
          if (props.value === null || Array.isArray(props.value)) {
            dateInputValueRef.value = "";
            return;
          }
          if (time2 === void 0) {
            time2 = props.value;
          }
          dateInputValueRef.value = format$4(time2, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
        }
        function handleConfirmClick() {
          if (validation2.isDateInvalid.value || validation2.isTimeInvalid.value) {
            return;
          }
          panelCommon.doConfirm();
          closeCalendar();
        }
        function closeCalendar() {
          if (props.active) {
            panelCommon.doClose();
          }
        }
        function nextYear() {
          calendarValueRef.value = getTime(addYears(calendarValueRef.value, 1));
        }
        function prevYear() {
          calendarValueRef.value = getTime(addYears(calendarValueRef.value, -1));
        }
        function nextMonth() {
          calendarValueRef.value = getTime(addMonths(calendarValueRef.value, 1));
        }
        function prevMonth() {
          calendarValueRef.value = getTime(addMonths(calendarValueRef.value, -1));
        }
        function virtualListContainer() {
          const { value } = yearVlRef;
          return value === null || value === void 0 ? void 0 : value.listElRef;
        }
        function virtualListContent() {
          const { value } = yearVlRef;
          return value === null || value === void 0 ? void 0 : value.itemsElRef;
        }
        function handleVirtualListScroll(e) {
          var _a;
          (_a = yearScrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
        }
        function handleTimePickerChange(value) {
          if (value === null)
            return;
          panelCommon.doUpdateValue(value, props.panel);
        }
        function handleSingleShortcutMouseenter(shortcut) {
          panelCommon.cachePendingValue();
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (typeof shortcutValue !== "number")
            return;
          panelCommon.doUpdateValue(shortcutValue, false);
        }
        function handleSingleShortcutClick(shortcut) {
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (typeof shortcutValue !== "number")
            return;
          panelCommon.doUpdateValue(shortcutValue, props.panel);
          panelCommon.clearPendingValue();
          handleConfirmClick();
        }
        function justifyColumnsScrollState(value) {
          const { value: mergedValue } = props;
          if (monthScrollbarRef.value) {
            const monthIndex = value === void 0 ? mergedValue === null ? getMonth(Date.now()) : getMonth(mergedValue) : getMonth(value);
            monthScrollbarRef.value.scrollTo({ top: monthIndex * MONTH_ITEM_HEIGHT });
          }
          if (yearVlRef.value) {
            const yearIndex = (value === void 0 ? mergedValue === null ? getYear(Date.now()) : getYear(mergedValue) : getYear(value)) - START_YEAR;
            yearVlRef.value.scrollTo({ top: yearIndex * MONTH_ITEM_HEIGHT });
          }
        }
        const childComponentRefs = {
          monthScrollbarRef,
          yearScrollbarRef,
          yearVlRef
        };
        return Object.assign(Object.assign(Object.assign(Object.assign({
          dateArray: dateArrayRef,
          monthArray: monthArrayRef,
          yearArray: yearArrayRef,
          quarterArray: quarterArrayRef,
          calendarYear: calendarYearRef,
          calendarMonth: calendarMonthRef,
          weekdays: weekdaysRef,
          mergedIsDateDisabled,
          nextYear,
          prevYear,
          nextMonth,
          prevMonth,
          handleNowClick,
          handleConfirmClick,
          handleSingleShortcutMouseenter,
          handleSingleShortcutClick
        }, validation2), panelCommon), childComponentRefs), {
          // datetime only
          handleDateClick,
          handleDateInputBlur,
          handleDateInput,
          handleTimePickerChange,
          clearSelectedDateTime,
          virtualListContainer,
          virtualListContent,
          handleVirtualListScroll,
          timePickerSize: panelCommon.timePickerSize,
          dateInputValue: dateInputValueRef,
          datePickerSlots,
          handleQuickMonthClick,
          justifyColumnsScrollState,
          calendarValue: calendarValueRef,
          onUpdateCalendarValue
        });
      }
      const MonthPanel = vue.defineComponent({
        name: "MonthPanel",
        props: Object.assign(Object.assign({}, useCalendarProps), {
          type: {
            type: String,
            required: true
          },
          // panelHeader prop
          useAsQuickJump: Boolean
        }),
        setup(props) {
          const useCalendarRef = useCalendar(props, props.type);
          const getRenderContent = (item) => {
            switch (item.type) {
              case "year":
                return item.dateObject.year;
              case "month":
                return item.dateObject.month + 1;
              case "quarter":
                return `Q${item.dateObject.quarter}`;
            }
          };
          const { useAsQuickJump } = props;
          const renderItem = (item, i, mergedClsPrefix) => {
            const { mergedIsDateDisabled, handleDateClick, handleQuickMonthClick } = useCalendarRef;
            return vue.h("div", { "data-n-date": true, key: i, class: [
              `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`,
              {
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`]: item.isCurrent,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`]: item.selected,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`]: !useAsQuickJump && mergedIsDateDisabled(item.ts)
              }
            ], onClick: () => {
              useAsQuickJump ? handleQuickMonthClick(item, (value) => {
                props.onUpdateValue(value, false);
              }) : handleDateClick(item);
            } }, getRenderContent(item));
          };
          vue.onMounted(() => {
            useCalendarRef.justifyColumnsScrollState();
          });
          return Object.assign(Object.assign({}, useCalendarRef), { renderItem });
        },
        render() {
          const { mergedClsPrefix, mergedTheme, shortcuts, actions, renderItem, type: type2, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: 0, class: [
              `${mergedClsPrefix}-date-panel`,
              `${mergedClsPrefix}-date-panel--month`,
              !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
              this.themeClass
            ], onFocus: this.handlePanelFocus, onKeydown: this.handlePanelKeyDown },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-month-calendar` },
              vue.h(NScrollbar, { ref: "yearScrollbarRef", class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: this.virtualListContainer, content: this.virtualListContent, horizontalRailStyle: { zIndex: 1 }, verticalRailStyle: { zIndex: 1 } }, {
                default: () => vue.h(VVirtualList, { ref: "yearVlRef", items: this.yearArray, itemSize: MONTH_ITEM_HEIGHT, showScrollbar: false, keyField: "ts", onScroll: this.handleVirtualListScroll, paddingBottom: 4 }, {
                  default: ({ item, index }) => {
                    return renderItem(item, index, mergedClsPrefix);
                  }
                })
              }),
              type2 === "month" || type2 === "quarter" ? vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col` },
                vue.h(NScrollbar, { ref: "monthScrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => [
                    (type2 === "month" ? this.monthArray : this.quarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix)),
                    vue.h("div", { class: `${mergedClsPrefix}-date-panel-${type2}-calendar__padding` })
                  ]
                })
              ) : null
            ),
            this.datePickerSlots.footer ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, {
              default: this.datePickerSlots.footer
            }) : null,
            (actions === null || actions === void 0 ? void 0 : actions.length) || shortcuts ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-actions` },
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts && Object.keys(shortcuts).map((key) => {
                const shortcut = shortcuts[key];
                return Array.isArray(shortcut) ? null : vue.h(XButton, { size: "tiny", onMouseenter: () => {
                  this.handleSingleShortcutMouseenter(shortcut);
                }, onClick: () => {
                  this.handleSingleShortcutClick(shortcut);
                }, onMouseleave: () => {
                  this.handleShortcutMouseleave();
                } }, { default: () => key });
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                (actions === null || actions === void 0 ? void 0 : actions.includes("clear")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear }) : null,
                (actions === null || actions === void 0 ? void 0 : actions.includes("now")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleNowClick }, { default: () => this.locale.now }) : null,
                (actions === null || actions === void 0 ? void 0 : actions.includes("confirm")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isDateInvalid, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm }) : null
              )
            ) : null,
            vue.h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })
          );
        }
      });
      const PanelHeader = vue.defineComponent({
        props: {
          mergedClsPrefix: {
            type: String,
            required: true
          },
          value: Number,
          monthBeforeYear: {
            type: Boolean,
            required: true
          },
          calendarMonth: {
            type: String,
            required: true
          },
          calendarYear: {
            type: String,
            required: true
          },
          onUpdateValue: {
            type: Function,
            required: true
          }
        },
        setup() {
          const triggerRef = vue.ref(null);
          const monthPanelRef = vue.ref(null);
          const showRef = vue.ref(false);
          function handleClickOutside(e) {
            var _a;
            if (showRef.value && !((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
              showRef.value = false;
            }
          }
          function handleHeaderClick() {
            showRef.value = !showRef.value;
          }
          return {
            show: showRef,
            triggerRef,
            monthPanelRef,
            handleHeaderClick,
            handleClickOutside
          };
        },
        render() {
          const { handleClickOutside, mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-date-panel-month__month-year`, ref: "triggerRef" },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h("div", { class: [
                    `${mergedClsPrefix}-date-panel-month__text`,
                    this.show && `${mergedClsPrefix}-date-panel-month__text--active`
                  ], onClick: this.handleHeaderClick }, this.monthBeforeYear ? [this.calendarMonth, " ", this.calendarYear] : [this.calendarYear, " ", this.calendarMonth])
                }),
                vue.h(VFollower, { show: this.show, teleportDisabled: true }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: true }, {
                    default: () => this.show ? vue.withDirectives(vue.h(MonthPanel, {
                      ref: "monthPanelRef",
                      onUpdateValue: this.onUpdateValue,
                      actions: [],
                      // month and year click show month type
                      type: "month",
                      key: "month",
                      useAsQuickJump: true,
                      value: this.value
                    }), [
                      [
                        clickoutside$1,
                        handleClickOutside,
                        void 0,
                        { capture: true }
                      ]
                    ]) : null
                  })
                })
              ]
            })
          );
        }
      });
      const DatetimePanel = vue.defineComponent({
        name: "DateTimePanel",
        props: useCalendarProps,
        setup(props) {
          return useCalendar(props, "datetime");
        },
        render() {
          var _a, _b, _c, _d;
          const { mergedClsPrefix, mergedTheme, shortcuts, timePickerProps: timePickerProps2, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: 0, class: [
              `${mergedClsPrefix}-date-panel`,
              `${mergedClsPrefix}-date-panel--datetime`,
              !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
              this.themeClass
            ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-header` },
              vue.h(NInput, { value: this.dateInputValue, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, stateful: false, size: this.timePickerSize, class: `${mergedClsPrefix}-date-panel-date-input`, textDecoration: this.isDateInvalid ? "line-through" : "", placeholder: this.locale.selectDate, onBlur: this.handleDateInputBlur, onUpdateValue: this.handleDateInput }),
              vue.h(NTimePicker, Object.assign({ size: this.timePickerSize, placeholder: this.locale.selectTime, format: this.timeFormat }, Array.isArray(timePickerProps2) ? void 0 : timePickerProps2, { showIcon: false, to: false, theme: mergedTheme.peers.TimePicker, themeOverrides: mergedTheme.peerOverrides.TimePicker, value: Array.isArray(this.value) ? null : this.value, isHourDisabled: this.isHourDisabled, isMinuteDisabled: this.isMinuteDisabled, isSecondDisabled: this.isSecondDisabled, onUpdateValue: this.handleTimePickerChange, stateful: false }))
            ),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-calendar` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month` },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.prevYear }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.prevMonth }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])),
                vue.h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.calendarValue, onUpdateValue: this.onUpdateCalendarValue, mergedClsPrefix, calendarMonth: this.calendarMonth, calendarYear: this.calendarYear }),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.nextMonth }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.nextYear }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => vue.h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday))),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.dateArray.map((dateItem2, i) => vue.h(
                "div",
                { "data-n-date": true, key: i, class: [
                  `${mergedClsPrefix}-date-panel-date`,
                  {
                    [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
                    [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
                    [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
                    [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts)
                  }
                ], onClick: () => {
                  this.handleDateClick(dateItem2);
                } },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                dateItem2.dateObject.date,
                dateItem2.isCurrentDate ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` }) : null
              )))
            ),
            this.datePickerSlots.footer ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer()) : null,
            ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-actions` },
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts && Object.keys(shortcuts).map((key) => {
                const shortcut = shortcuts[key];
                return Array.isArray(shortcut) ? null : vue.h(XButton, { size: "tiny", onMouseenter: () => {
                  this.handleSingleShortcutMouseenter(shortcut);
                }, onClick: () => {
                  this.handleSingleShortcutClick(shortcut);
                }, onMouseleave: () => {
                  this.handleShortcutMouseleave();
                } }, { default: () => key });
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.clearSelectedDateTime }, { default: () => this.locale.clear }) : null,
                ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("now")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleNowClick }, { default: () => this.locale.now }) : null,
                ((_d = this.actions) === null || _d === void 0 ? void 0 : _d.includes("confirm")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isDateInvalid, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm }) : null
              )
            ) : null,
            vue.h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })
          );
        }
      });
      const useDualCalendarProps = Object.assign(Object.assign({}, usePanelCommonProps), { defaultCalendarStartTime: Number, defaultCalendarEndTime: Number, bindCalendarMonths: Boolean, actions: {
        type: Array,
        default: () => ["clear", "confirm"]
      } });
      function useDualCalendar(props, type2) {
        var _a, _b;
        const {
          isDateDisabledRef,
          isStartHourDisabledRef,
          isEndHourDisabledRef,
          isStartMinuteDisabledRef,
          isEndMinuteDisabledRef,
          isStartSecondDisabledRef,
          isEndSecondDisabledRef,
          isStartDateInvalidRef,
          isEndDateInvalidRef,
          isStartTimeInvalidRef,
          isEndTimeInvalidRef,
          isStartValueInvalidRef,
          isEndValueInvalidRef,
          isRangeInvalidRef,
          localeRef,
          rangesRef,
          closeOnSelectRef,
          updateValueOnCloseRef,
          firstDayOfWeekRef,
          datePickerSlots
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } = vue.inject(datePickerInjectionKey);
        const validation2 = {
          isDateDisabled: isDateDisabledRef,
          isStartHourDisabled: isStartHourDisabledRef,
          isEndHourDisabled: isEndHourDisabledRef,
          isStartMinuteDisabled: isStartMinuteDisabledRef,
          isEndMinuteDisabled: isEndMinuteDisabledRef,
          isStartSecondDisabled: isStartSecondDisabledRef,
          isEndSecondDisabled: isEndSecondDisabledRef,
          isStartDateInvalid: isStartDateInvalidRef,
          isEndDateInvalid: isEndDateInvalidRef,
          isStartTimeInvalid: isStartTimeInvalidRef,
          isEndTimeInvalid: isEndTimeInvalidRef,
          isStartValueInvalid: isStartValueInvalidRef,
          isEndValueInvalid: isEndValueInvalidRef,
          isRangeInvalid: isRangeInvalidRef
        };
        const panelCommon = usePanelCommon(props);
        const startDatesElRef = vue.ref(null);
        const endDatesElRef = vue.ref(null);
        const startYearScrollbarRef = vue.ref(null);
        const endYearScrollbarRef = vue.ref(null);
        const startYearVlRef = vue.ref(null);
        const endYearVlRef = vue.ref(null);
        const startMonthScrollbarRef = vue.ref(null);
        const endMonthScrollbarRef = vue.ref(null);
        const { value } = props;
        const defaultCalendarStartTime = (_a = props.defaultCalendarStartTime) !== null && _a !== void 0 ? _a : Array.isArray(value) && typeof value[0] === "number" ? value[0] : Date.now();
        const startCalendarDateTimeRef = vue.ref(defaultCalendarStartTime);
        const endCalendarDateTimeRef = vue.ref((_b = props.defaultCalendarEndTime) !== null && _b !== void 0 ? _b : Array.isArray(value) && typeof value[1] === "number" ? value[1] : getTime(addMonths(defaultCalendarStartTime, 1)));
        adjustCalendarTimes(true);
        const nowRef = vue.ref(Date.now());
        const isSelectingRef = vue.ref(false);
        const memorizedStartDateTimeRef = vue.ref(0);
        const mergedDateFormatRef = vue.computed(() => props.dateFormat || localeRef.value.dateFormat);
        const startDateInput = vue.ref(Array.isArray(value) ? format$4(value[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value) : "");
        const endDateInputRef = vue.ref(Array.isArray(value) ? format$4(value[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value) : "");
        const selectingPhaseRef = vue.computed(() => {
          if (isSelectingRef.value)
            return "end";
          else
            return "start";
        });
        const startDateArrayRef = vue.computed(() => {
          var _a2;
          return dateArray(startCalendarDateTimeRef.value, props.value, nowRef.value, (_a2 = firstDayOfWeekRef.value) !== null && _a2 !== void 0 ? _a2 : localeRef.value.firstDayOfWeek);
        });
        const endDateArrayRef = vue.computed(() => {
          var _a2;
          return dateArray(endCalendarDateTimeRef.value, props.value, nowRef.value, (_a2 = firstDayOfWeekRef.value) !== null && _a2 !== void 0 ? _a2 : localeRef.value.firstDayOfWeek);
        });
        const weekdaysRef = vue.computed(() => {
          return startDateArrayRef.value.slice(0, 7).map((dateItem2) => {
            const { ts } = dateItem2;
            return format$4(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
          });
        });
        const startCalendarMonthRef = vue.computed(() => {
          return format$4(startCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
        });
        const endCalendarMonthRef = vue.computed(() => {
          return format$4(endCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
        });
        const startCalendarYearRef = vue.computed(() => {
          return format$4(startCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
        });
        const endCalendarYearRef = vue.computed(() => {
          return format$4(endCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
        });
        const startTimeValueRef = vue.computed(() => {
          const { value: value2 } = props;
          if (Array.isArray(value2))
            return value2[0];
          return null;
        });
        const endTimeValueRef = vue.computed(() => {
          const { value: value2 } = props;
          if (Array.isArray(value2))
            return value2[1];
          return null;
        });
        const shortcutsRef = vue.computed(() => {
          const { shortcuts } = props;
          return shortcuts || rangesRef.value;
        });
        const startYearArrayRef = vue.computed(() => {
          return yearArray(pluckValueFromRange(props.value, "start"), nowRef.value);
        });
        const endYearArrayRef = vue.computed(() => {
          return yearArray(pluckValueFromRange(props.value, "end"), nowRef.value);
        });
        const startQuarterArrayRef = vue.computed(() => {
          const startValue = pluckValueFromRange(props.value, "start");
          return quarterArray(startValue !== null && startValue !== void 0 ? startValue : Date.now(), startValue, nowRef.value);
        });
        const endQuarterArrayRef = vue.computed(() => {
          const endValue = pluckValueFromRange(props.value, "end");
          return quarterArray(endValue !== null && endValue !== void 0 ? endValue : Date.now(), endValue, nowRef.value);
        });
        const startMonthArrayRef = vue.computed(() => {
          const startValue = pluckValueFromRange(props.value, "start");
          return monthArray(startValue !== null && startValue !== void 0 ? startValue : Date.now(), startValue, nowRef.value);
        });
        const endMonthArrayRef = vue.computed(() => {
          const endValue = pluckValueFromRange(props.value, "end");
          return monthArray(endValue !== null && endValue !== void 0 ? endValue : Date.now(), endValue, nowRef.value);
        });
        vue.watch(vue.computed(() => props.value), (value2) => {
          if (value2 !== null && Array.isArray(value2)) {
            const [startMoment, endMoment] = value2;
            startDateInput.value = format$4(startMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
            endDateInputRef.value = format$4(endMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
            if (!isSelectingRef.value) {
              syncCalendarTimeWithValue(value2);
            }
          } else {
            startDateInput.value = "";
            endDateInputRef.value = "";
          }
        });
        function handleCalendarChange(value2, oldValue) {
          if (type2 === "daterange" || type2 === "datetimerange") {
            if (getYear(value2) !== getYear(oldValue) || getMonth(value2) !== getMonth(oldValue)) {
              panelCommon.disableTransitionOneTick();
            }
          }
        }
        vue.watch(startCalendarDateTimeRef, handleCalendarChange);
        vue.watch(endCalendarDateTimeRef, handleCalendarChange);
        function adjustCalendarTimes(byStartCalendarTime) {
          const startTime = startOfMonth(startCalendarDateTimeRef.value);
          const endTime = startOfMonth(endCalendarDateTimeRef.value);
          if (props.bindCalendarMonths || startTime >= endTime) {
            if (byStartCalendarTime) {
              endCalendarDateTimeRef.value = getTime(addMonths(startTime, 1));
            } else {
              startCalendarDateTimeRef.value = getTime(addMonths(endTime, -1));
            }
          }
        }
        function startCalendarNextYear() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 12));
          adjustCalendarTimes(true);
        }
        function startCalendarPrevYear() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -12));
          adjustCalendarTimes(true);
        }
        function startCalendarNextMonth() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 1));
          adjustCalendarTimes(true);
        }
        function startCalendarPrevMonth() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -1));
          adjustCalendarTimes(true);
        }
        function endCalendarNextYear() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 12));
          adjustCalendarTimes(false);
        }
        function endCalendarPrevYear() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -12));
          adjustCalendarTimes(false);
        }
        function endCalendarNextMonth() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 1));
          adjustCalendarTimes(false);
        }
        function endCalendarPrevMonth() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -1));
          adjustCalendarTimes(false);
        }
        function onUpdateStartCalendarValue(value2) {
          startCalendarDateTimeRef.value = value2;
          adjustCalendarTimes(true);
        }
        function onUpdateEndCalendarValue(value2) {
          endCalendarDateTimeRef.value = value2;
          adjustCalendarTimes(false);
        }
        function mergedIsDateDisabled(ts) {
          const isDateDisabled = isDateDisabledRef.value;
          if (!isDateDisabled)
            return false;
          if (!Array.isArray(props.value))
            return isDateDisabled(ts, "start", null);
          if (selectingPhaseRef.value === "start") {
            return isDateDisabled(ts, "start", null);
          } else {
            const { value: memorizedStartDateTime } = memorizedStartDateTimeRef;
            if (ts < memorizedStartDateTimeRef.value) {
              return isDateDisabled(ts, "start", [
                memorizedStartDateTime,
                memorizedStartDateTime
              ]);
            } else {
              return isDateDisabled(ts, "end", [
                memorizedStartDateTime,
                memorizedStartDateTime
              ]);
            }
          }
        }
        function syncCalendarTimeWithValue(value2) {
          if (value2 === null)
            return;
          const [startMoment, endMoment] = value2;
          startCalendarDateTimeRef.value = startMoment;
          if (startOfMonth(endMoment) <= startOfMonth(startMoment)) {
            endCalendarDateTimeRef.value = getTime(startOfMonth(addMonths(startMoment, 1)));
          } else {
            endCalendarDateTimeRef.value = getTime(startOfMonth(endMoment));
          }
        }
        function handleDateClick(dateItem2) {
          if (!isSelectingRef.value) {
            isSelectingRef.value = true;
            memorizedStartDateTimeRef.value = dateItem2.ts;
            changeStartEndTime(dateItem2.ts, dateItem2.ts, "done");
          } else {
            isSelectingRef.value = false;
            const { value: value2 } = props;
            if (props.panel && Array.isArray(value2)) {
              changeStartEndTime(value2[0], value2[1], "done");
            } else {
              if (closeOnSelectRef.value && type2 === "daterange") {
                if (updateValueOnCloseRef.value) {
                  closeCalendar();
                } else {
                  handleConfirmClick();
                }
              }
            }
          }
        }
        function handleDateMouseEnter(dateItem2) {
          if (isSelectingRef.value) {
            if (mergedIsDateDisabled(dateItem2.ts))
              return;
            if (dateItem2.ts >= memorizedStartDateTimeRef.value) {
              changeStartEndTime(memorizedStartDateTimeRef.value, dateItem2.ts, "wipPreview");
            } else {
              changeStartEndTime(dateItem2.ts, memorizedStartDateTimeRef.value, "wipPreview");
            }
          }
        }
        function handleConfirmClick() {
          if (isRangeInvalidRef.value) {
            return;
          }
          panelCommon.doConfirm();
          closeCalendar();
        }
        function closeCalendar() {
          isSelectingRef.value = false;
          if (props.active) {
            panelCommon.doClose();
          }
        }
        function changeStartDateTime(time2) {
          if (typeof time2 !== "number") {
            time2 = getTime(time2);
          }
          if (props.value === null) {
            panelCommon.doUpdateValue([time2, time2], props.panel);
          } else if (Array.isArray(props.value)) {
            panelCommon.doUpdateValue([time2, Math.max(props.value[1], time2)], props.panel);
          }
        }
        function changeEndDateTime(time2) {
          if (typeof time2 !== "number") {
            time2 = getTime(time2);
          }
          if (props.value === null) {
            panelCommon.doUpdateValue([time2, time2], props.panel);
          } else if (Array.isArray(props.value)) {
            panelCommon.doUpdateValue([Math.min(props.value[0], time2), time2], props.panel);
          }
        }
        function changeStartEndTime(startTime, endTime, source) {
          if (typeof startTime !== "number") {
            startTime = getTime(startTime);
          }
          if (source !== "shortcutPreview") {
            let startDefaultTime;
            let endDefaultTime;
            if (type2 === "datetimerange") {
              const { defaultTime } = props;
              if (Array.isArray(defaultTime)) {
                startDefaultTime = getDefaultTime(defaultTime[0]);
                endDefaultTime = getDefaultTime(defaultTime[1]);
              } else {
                startDefaultTime = getDefaultTime(defaultTime);
                endDefaultTime = startDefaultTime;
              }
            }
            if (startDefaultTime) {
              startTime = getTime(set(startTime, startDefaultTime));
            }
            if (endDefaultTime) {
              endTime = getTime(set(endTime, endDefaultTime));
            }
          }
          panelCommon.doUpdateValue([startTime, endTime], props.panel && source === "done");
        }
        function sanitizeValue(datetime) {
          if (type2 === "datetimerange") {
            return getTime(startOfSecond(datetime));
          } else if (type2 === "monthrange") {
            return getTime(startOfMonth(datetime));
          } else {
            return getTime(startOfDay(datetime));
          }
        }
        function handleStartDateInput(value2) {
          const date2 = strictParse(value2, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date2)) {
            if (!props.value) {
              const newValue = set(/* @__PURE__ */ new Date(), {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeStartDateTime(sanitizeValue(getTime(newValue)));
            } else if (Array.isArray(props.value)) {
              const newValue = set(props.value[0], {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeStartDateTime(sanitizeValue(getTime(newValue)));
            }
          } else {
            startDateInput.value = value2;
          }
        }
        function handleEndDateInput(value2) {
          const date2 = strictParse(value2, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date2)) {
            if (props.value === null) {
              const newValue = set(/* @__PURE__ */ new Date(), {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeEndDateTime(sanitizeValue(getTime(newValue)));
            } else if (Array.isArray(props.value)) {
              const newValue = set(props.value[1], {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeEndDateTime(sanitizeValue(getTime(newValue)));
            }
          } else {
            endDateInputRef.value = value2;
          }
        }
        function handleStartDateInputBlur() {
          const date2 = strictParse(startDateInput.value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
          const { value: value2 } = props;
          if (isValid$1(date2)) {
            if (value2 === null) {
              const newValue = set(/* @__PURE__ */ new Date(), {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeStartDateTime(sanitizeValue(getTime(newValue)));
            } else if (Array.isArray(value2)) {
              const newValue = set(value2[0], {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeStartDateTime(sanitizeValue(getTime(newValue)));
            }
          } else {
            refreshDisplayDateString();
          }
        }
        function handleEndDateInputBlur() {
          const date2 = strictParse(endDateInputRef.value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
          const { value: value2 } = props;
          if (isValid$1(date2)) {
            if (value2 === null) {
              const newValue = set(/* @__PURE__ */ new Date(), {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeEndDateTime(sanitizeValue(getTime(newValue)));
            } else if (Array.isArray(value2)) {
              const newValue = set(value2[1], {
                year: getYear(date2),
                month: getMonth(date2),
                date: getDate(date2)
              });
              changeEndDateTime(sanitizeValue(getTime(newValue)));
            }
          } else {
            refreshDisplayDateString();
          }
        }
        function refreshDisplayDateString(times) {
          const { value: value2 } = props;
          if (value2 === null || !Array.isArray(value2)) {
            startDateInput.value = "";
            endDateInputRef.value = "";
            return;
          }
          if (times === void 0) {
            times = value2;
          }
          startDateInput.value = format$4(times[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
          endDateInputRef.value = format$4(times[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
        }
        function handleStartTimePickerChange(value2) {
          if (value2 === null)
            return;
          changeStartDateTime(value2);
        }
        function handleEndTimePickerChange(value2) {
          if (value2 === null)
            return;
          changeEndDateTime(value2);
        }
        function handleRangeShortcutMouseenter(shortcut) {
          panelCommon.cachePendingValue();
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (!Array.isArray(shortcutValue))
            return;
          changeStartEndTime(shortcutValue[0], shortcutValue[1], "shortcutPreview");
        }
        function handleRangeShortcutClick(shortcut) {
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (!Array.isArray(shortcutValue))
            return;
          changeStartEndTime(shortcutValue[0], shortcutValue[1], "done");
          panelCommon.clearPendingValue();
          handleConfirmClick();
        }
        function justifyColumnsScrollState(value2, type3) {
          const mergedValue = value2 === void 0 ? props.value : value2;
          if (value2 === void 0 || type3 === "start") {
            if (startMonthScrollbarRef.value) {
              const monthIndex = !Array.isArray(mergedValue) ? getMonth(Date.now()) : getMonth(mergedValue[0]);
              startMonthScrollbarRef.value.scrollTo({
                debounce: false,
                index: monthIndex,
                elSize: MONTH_ITEM_HEIGHT
              });
            }
            if (startYearVlRef.value) {
              const yearIndex = (!Array.isArray(mergedValue) ? getYear(Date.now()) : getYear(mergedValue[0])) - START_YEAR;
              startYearVlRef.value.scrollTo({ index: yearIndex, debounce: false });
            }
          }
          if (value2 === void 0 || type3 === "end") {
            if (endMonthScrollbarRef.value) {
              const monthIndex = !Array.isArray(mergedValue) ? getMonth(Date.now()) : getMonth(mergedValue[1]);
              endMonthScrollbarRef.value.scrollTo({
                debounce: false,
                index: monthIndex,
                elSize: MONTH_ITEM_HEIGHT
              });
            }
            if (endYearVlRef.value) {
              const yearIndex = (!Array.isArray(mergedValue) ? getYear(Date.now()) : getYear(mergedValue[1])) - START_YEAR;
              endYearVlRef.value.scrollTo({ index: yearIndex, debounce: false });
            }
          }
        }
        function handleColItemClick(dateItem2, clickType) {
          const { value: value2 } = props;
          const noCurrentValue = !Array.isArray(value2);
          const itemTs = dateItem2.type === "year" && type2 !== "yearrange" ? noCurrentValue ? set(dateItem2.ts, {
            month: getMonth(type2 === "quarterrange" ? startOfQuarter(/* @__PURE__ */ new Date()) : /* @__PURE__ */ new Date())
          }).valueOf() : set(dateItem2.ts, {
            month: getMonth(type2 === "quarterrange" ? startOfQuarter(value2[clickType === "start" ? 0 : 1]) : value2[clickType === "start" ? 0 : 1])
          }).valueOf() : dateItem2.ts;
          if (noCurrentValue) {
            const partialValue = sanitizeValue(itemTs);
            const nextValue2 = [partialValue, partialValue];
            panelCommon.doUpdateValue(nextValue2, props.panel);
            justifyColumnsScrollState(nextValue2, "start");
            justifyColumnsScrollState(nextValue2, "end");
            panelCommon.disableTransitionOneTick();
            return;
          }
          const nextValue = [value2[0], value2[1]];
          let otherPartsChanged = false;
          if (clickType === "start") {
            nextValue[0] = sanitizeValue(itemTs);
            if (nextValue[0] > nextValue[1]) {
              nextValue[1] = nextValue[0];
              otherPartsChanged = true;
            }
          } else {
            nextValue[1] = sanitizeValue(itemTs);
            if (nextValue[0] > nextValue[1]) {
              nextValue[0] = nextValue[1];
              otherPartsChanged = true;
            }
          }
          panelCommon.doUpdateValue(nextValue, props.panel);
          switch (type2) {
            case "monthrange":
            case "quarterrange":
              panelCommon.disableTransitionOneTick();
              if (otherPartsChanged) {
                justifyColumnsScrollState(nextValue, "start");
                justifyColumnsScrollState(nextValue, "end");
              } else {
                justifyColumnsScrollState(nextValue, clickType);
              }
              break;
            case "yearrange":
              panelCommon.disableTransitionOneTick();
              justifyColumnsScrollState(nextValue, "start");
              justifyColumnsScrollState(nextValue, "end");
          }
        }
        function handleStartYearVlScroll() {
          var _a2;
          (_a2 = startYearScrollbarRef.value) === null || _a2 === void 0 ? void 0 : _a2.sync();
        }
        function handleEndYearVlScroll() {
          var _a2;
          (_a2 = endYearScrollbarRef.value) === null || _a2 === void 0 ? void 0 : _a2.sync();
        }
        function virtualListContainer(type3) {
          var _a2, _b2;
          if (type3 === "start") {
            return (_a2 = startYearVlRef.value) === null || _a2 === void 0 ? void 0 : _a2.listElRef;
          } else {
            return (_b2 = endYearVlRef.value) === null || _b2 === void 0 ? void 0 : _b2.listElRef;
          }
        }
        function virtualListContent(type3) {
          var _a2, _b2;
          if (type3 === "start") {
            return (_a2 = startYearVlRef.value) === null || _a2 === void 0 ? void 0 : _a2.itemsElRef;
          } else {
            return (_b2 = endYearVlRef.value) === null || _b2 === void 0 ? void 0 : _b2.itemsElRef;
          }
        }
        const childComponentRefs = {
          startYearVlRef,
          endYearVlRef,
          startMonthScrollbarRef,
          endMonthScrollbarRef,
          startYearScrollbarRef,
          endYearScrollbarRef
        };
        return Object.assign(Object.assign(Object.assign(Object.assign({
          startDatesElRef,
          endDatesElRef,
          handleDateClick,
          handleColItemClick,
          handleDateMouseEnter,
          handleConfirmClick,
          startCalendarPrevYear,
          startCalendarPrevMonth,
          startCalendarNextYear,
          startCalendarNextMonth,
          endCalendarPrevYear,
          endCalendarPrevMonth,
          endCalendarNextMonth,
          endCalendarNextYear,
          mergedIsDateDisabled,
          changeStartEndTime,
          ranges: rangesRef,
          startCalendarMonth: startCalendarMonthRef,
          startCalendarYear: startCalendarYearRef,
          endCalendarMonth: endCalendarMonthRef,
          endCalendarYear: endCalendarYearRef,
          weekdays: weekdaysRef,
          startDateArray: startDateArrayRef,
          endDateArray: endDateArrayRef,
          startYearArray: startYearArrayRef,
          startMonthArray: startMonthArrayRef,
          startQuarterArray: startQuarterArrayRef,
          endYearArray: endYearArrayRef,
          endMonthArray: endMonthArrayRef,
          endQuarterArray: endQuarterArrayRef,
          isSelecting: isSelectingRef,
          handleRangeShortcutMouseenter,
          handleRangeShortcutClick
        }, panelCommon), validation2), childComponentRefs), {
          // datetimerangeonly
          startDateDisplayString: startDateInput,
          endDateInput: endDateInputRef,
          timePickerSize: panelCommon.timePickerSize,
          startTimeValue: startTimeValueRef,
          endTimeValue: endTimeValueRef,
          datePickerSlots,
          shortcuts: shortcutsRef,
          startCalendarDateTime: startCalendarDateTimeRef,
          endCalendarDateTime: endCalendarDateTimeRef,
          justifyColumnsScrollState,
          handleFocusDetectorFocus: panelCommon.handleFocusDetectorFocus,
          handleStartTimePickerChange,
          handleEndTimePickerChange,
          handleStartDateInput,
          handleStartDateInputBlur,
          handleEndDateInput,
          handleEndDateInputBlur,
          handleStartYearVlScroll,
          handleEndYearVlScroll,
          virtualListContainer,
          virtualListContent,
          onUpdateStartCalendarValue,
          onUpdateEndCalendarValue
        });
      }
      const DatetimerangePanel = vue.defineComponent({
        name: "DateTimeRangePanel",
        props: useDualCalendarProps,
        setup(props) {
          return useDualCalendar(props, "datetimerange");
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, timePickerProps: timePickerProps2, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: 0, class: [
              `${mergedClsPrefix}-date-panel`,
              `${mergedClsPrefix}-date-panel--datetimerange`,
              !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
              this.themeClass
            ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-header` },
              vue.h(NInput, { value: this.startDateDisplayString, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, size: this.timePickerSize, stateful: false, class: `${mergedClsPrefix}-date-panel-date-input`, textDecoration: this.isStartValueInvalid ? "line-through" : "", placeholder: this.locale.selectDate, onBlur: this.handleStartDateInputBlur, onUpdateValue: this.handleStartDateInput }),
              vue.h(NTimePicker, Object.assign({ placeholder: this.locale.selectTime, format: this.timeFormat, size: this.timePickerSize }, Array.isArray(timePickerProps2) ? timePickerProps2[0] : timePickerProps2, { value: this.startTimeValue, to: false, showIcon: false, disabled: this.isSelecting, theme: mergedTheme.peers.TimePicker, themeOverrides: mergedTheme.peerOverrides.TimePicker, stateful: false, isHourDisabled: this.isStartHourDisabled, isMinuteDisabled: this.isStartMinuteDisabled, isSecondDisabled: this.isStartSecondDisabled, onUpdateValue: this.handleStartTimePickerChange })),
              vue.h(NInput, { value: this.endDateInput, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, stateful: false, size: this.timePickerSize, class: `${mergedClsPrefix}-date-panel-date-input`, textDecoration: this.isEndValueInvalid ? "line-through" : "", placeholder: this.locale.selectDate, onBlur: this.handleEndDateInputBlur, onUpdateValue: this.handleEndDateInput }),
              vue.h(NTimePicker, Object.assign({ placeholder: this.locale.selectTime, format: this.timeFormat, size: this.timePickerSize }, Array.isArray(timePickerProps2) ? timePickerProps2[1] : timePickerProps2, { disabled: this.isSelecting, showIcon: false, theme: mergedTheme.peers.TimePicker, themeOverrides: mergedTheme.peerOverrides.TimePicker, to: false, stateful: false, value: this.endTimeValue, isHourDisabled: this.isEndHourDisabled, isMinuteDisabled: this.isEndMinuteDisabled, isSecondDisabled: this.isEndSecondDisabled, onUpdateValue: this.handleEndTimePickerChange }))
            ),
            vue.h(
              "div",
              { ref: "startDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month` },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.startCalendarPrevYear }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.startCalendarPrevMonth }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])),
                vue.h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.startCalendarDateTime, onUpdateValue: this.onUpdateStartCalendarValue, mergedClsPrefix, calendarMonth: this.startCalendarMonth, calendarYear: this.startCalendarYear }),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.startCalendarNextMonth }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.startCalendarNextYear }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => vue.h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday))),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.startDateArray.map((dateItem2, i) => {
                const disabled = this.mergedIsDateDisabled(dateItem2.ts);
                return vue.h(
                  "div",
                  { "data-n-date": true, key: i, class: [
                    `${mergedClsPrefix}-date-panel-date`,
                    {
                      [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
                      [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
                      [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
                      [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
                      [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
                      [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
                      [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
                    }
                  ], onClick: disabled ? void 0 : () => {
                    this.handleDateClick(dateItem2);
                  }, onMouseenter: disabled ? void 0 : () => {
                    this.handleDateMouseEnter(dateItem2);
                  } },
                  vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                  dateItem2.dateObject.date,
                  dateItem2.isCurrentDate ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` }) : null
                );
              }))
            ),
            vue.h("div", { class: `${mergedClsPrefix}-date-panel__vertical-divider` }),
            vue.h(
              "div",
              { ref: "endDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month` },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.endCalendarPrevYear }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.endCalendarPrevMonth }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])),
                vue.h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.endCalendarDateTime, onUpdateValue: this.onUpdateEndCalendarValue, mergedClsPrefix, calendarMonth: this.endCalendarMonth, calendarYear: this.endCalendarYear }),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.endCalendarNextMonth }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.endCalendarNextYear }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => vue.h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday))),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.endDateArray.map((dateItem2, i) => {
                const disabled = this.mergedIsDateDisabled(dateItem2.ts);
                return vue.h(
                  "div",
                  { "data-n-date": true, key: i, class: [
                    `${mergedClsPrefix}-date-panel-date`,
                    {
                      [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
                      [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
                      [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
                      [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
                      [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
                      [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
                      [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
                    }
                  ], onClick: disabled ? void 0 : () => {
                    this.handleDateClick(dateItem2);
                  }, onMouseenter: disabled ? void 0 : () => {
                    this.handleDateMouseEnter(dateItem2);
                  } },
                  vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                  dateItem2.dateObject.date,
                  dateItem2.isCurrentDate ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` }) : null
                );
              }))
            ),
            this.datePickerSlots.footer ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer()) : null,
            ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-actions` },
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts && Object.keys(shortcuts).map((key) => {
                const shortcut = shortcuts[key];
                return Array.isArray(shortcut) || typeof shortcut === "function" ? vue.h(XButton, { size: "tiny", onMouseenter: () => {
                  this.handleRangeShortcutMouseenter(shortcut);
                }, onClick: () => {
                  this.handleRangeShortcutClick(shortcut);
                }, onMouseleave: () => {
                  this.handleShortcutMouseleave();
                } }, { default: () => key }) : null;
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear }) : null,
                ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isRangeInvalid || this.isSelecting, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm }) : null
              )
            ) : null,
            vue.h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })
          );
        }
      });
      const DatePanel = vue.defineComponent({
        name: "DatePanel",
        props: useCalendarProps,
        setup(props) {
          return useCalendar(props, "date");
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: 0, class: [
              `${mergedClsPrefix}-date-panel`,
              `${mergedClsPrefix}-date-panel--date`,
              !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
              this.themeClass
            ], onFocus: this.handlePanelFocus, onKeydown: this.handlePanelKeyDown },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-calendar` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month` },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.prevYear }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.prevMonth }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])),
                vue.h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.calendarValue, onUpdateValue: this.onUpdateCalendarValue, mergedClsPrefix, calendarMonth: this.calendarMonth, calendarYear: this.calendarYear }),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.nextMonth }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.nextYear }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => vue.h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday))),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.dateArray.map((dateItem2, i) => vue.h(
                "div",
                { "data-n-date": true, key: i, class: [
                  `${mergedClsPrefix}-date-panel-date`,
                  {
                    [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
                    [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
                    [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
                    [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts)
                  }
                ], onClick: () => {
                  this.handleDateClick(dateItem2);
                } },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                dateItem2.dateObject.date,
                dateItem2.isCurrentDate ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` }) : null
              )))
            ),
            this.datePickerSlots.footer ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer()) : null,
            ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-actions` },
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts && Object.keys(shortcuts).map((key) => {
                const shortcut = shortcuts[key];
                return Array.isArray(shortcut) ? null : vue.h(XButton, { size: "tiny", onMouseenter: () => {
                  this.handleSingleShortcutMouseenter(shortcut);
                }, onClick: () => {
                  this.handleSingleShortcutClick(shortcut);
                }, onMouseleave: () => {
                  this.handleShortcutMouseleave();
                } }, { default: () => key });
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear }) : null,
                ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("now")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleNowClick }, { default: () => this.locale.now }) : null
              )
            ) : null,
            vue.h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })
          );
        }
      });
      const DaterangePanel = vue.defineComponent({
        name: "DateRangePanel",
        props: useDualCalendarProps,
        setup(props) {
          return useDualCalendar(props, "daterange");
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: 0, class: [
              `${mergedClsPrefix}-date-panel`,
              `${mergedClsPrefix}-date-panel--daterange`,
              !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
              this.themeClass
            ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
            vue.h(
              "div",
              { ref: "startDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month` },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.startCalendarPrevYear }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.startCalendarPrevMonth }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])),
                vue.h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.startCalendarDateTime, onUpdateValue: this.onUpdateStartCalendarValue, mergedClsPrefix, calendarMonth: this.startCalendarMonth, calendarYear: this.startCalendarYear }),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.startCalendarNextMonth }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.startCalendarNextYear }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => vue.h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday))),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.startDateArray.map((dateItem2, i) => vue.h(
                "div",
                { "data-n-date": true, key: i, class: [
                  `${mergedClsPrefix}-date-panel-date`,
                  {
                    [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
                    [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
                    [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
                    [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
                    [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
                    [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
                    [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts)
                  }
                ], onClick: () => {
                  this.handleDateClick(dateItem2);
                }, onMouseenter: () => {
                  this.handleDateMouseEnter(dateItem2);
                } },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                dateItem2.dateObject.date,
                dateItem2.isCurrentDate ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` }) : null
              )))
            ),
            vue.h("div", { class: `${mergedClsPrefix}-date-panel__vertical-divider` }),
            vue.h(
              "div",
              { ref: "endDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month` },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.endCalendarPrevYear }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.endCalendarPrevMonth }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])),
                vue.h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.endCalendarDateTime, onUpdateValue: this.onUpdateEndCalendarValue, mergedClsPrefix, calendarMonth: this.endCalendarMonth, calendarYear: this.endCalendarYear }),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.endCalendarNextMonth }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])),
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.endCalendarNextYear }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => vue.h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday))),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.endDateArray.map((dateItem2, i) => vue.h(
                "div",
                { "data-n-date": true, key: i, class: [
                  `${mergedClsPrefix}-date-panel-date`,
                  {
                    [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
                    [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
                    [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
                    [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
                    [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
                    [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
                    [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts)
                  }
                ], onClick: () => {
                  this.handleDateClick(dateItem2);
                }, onMouseenter: () => {
                  this.handleDateMouseEnter(dateItem2);
                } },
                vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                dateItem2.dateObject.date,
                dateItem2.isCurrentDate ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` }) : null
              )))
            ),
            this.datePickerSlots.footer ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer()) : null,
            ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-actions` },
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts && Object.keys(shortcuts).map((key) => {
                const shortcut = shortcuts[key];
                return Array.isArray(shortcut) || typeof shortcut === "function" ? vue.h(XButton, { size: "tiny", onMouseenter: () => {
                  this.handleRangeShortcutMouseenter(shortcut);
                }, onClick: () => {
                  this.handleRangeShortcutClick(shortcut);
                }, onMouseleave: () => {
                  this.handleShortcutMouseleave();
                } }, { default: () => key }) : null;
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear }) : null,
                ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? vue.h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isRangeInvalid || this.isSelecting, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm }) : null
              )
            ) : null,
            vue.h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })
          );
        }
      });
      const MonthRangePanel = vue.defineComponent({
        name: "MonthRangePanel",
        props: Object.assign(Object.assign({}, useDualCalendarProps), { type: {
          type: String,
          required: true
        } }),
        setup(props) {
          const useCalendarRef = useDualCalendar(props, props.type);
          const renderItem = (item, i, mergedClsPrefix, type2) => {
            const { handleColItemClick } = useCalendarRef;
            const disabled = false;
            return vue.h("div", { "data-n-date": true, key: i, class: [
              `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`,
              {
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`]: item.isCurrent,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`]: item.selected,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`]: disabled
              }
            ], onClick: () => {
              handleColItemClick(item, type2);
            } }, item.type === "month" ? item.dateObject.month + 1 : item.type === "quarter" ? `Q${item.dateObject.quarter}` : item.dateObject.year);
          };
          vue.onMounted(() => {
            useCalendarRef.justifyColumnsScrollState();
          });
          return Object.assign(Object.assign({}, useCalendarRef), { renderItem });
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, type: type2, renderItem, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { ref: "selfRef", tabindex: 0, class: [
              `${mergedClsPrefix}-date-panel`,
              `${mergedClsPrefix}-date-panel--daterange`,
              !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
              this.themeClass
            ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
            vue.h(
              "div",
              { ref: "startDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month-calendar` },
                vue.h(NScrollbar, { ref: "startYearScrollbarRef", class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: () => this.virtualListContainer("start"), content: () => this.virtualListContent("start"), horizontalRailStyle: { zIndex: 1 }, verticalRailStyle: { zIndex: 1 } }, {
                  default: () => vue.h(VVirtualList, { ref: "startYearVlRef", items: this.startYearArray, itemSize: MONTH_ITEM_HEIGHT, showScrollbar: false, keyField: "ts", onScroll: this.handleStartYearVlScroll, paddingBottom: 4 }, {
                    default: ({ item, index }) => {
                      return renderItem(item, index, mergedClsPrefix, "start");
                    }
                  })
                }),
                type2 === "monthrange" || type2 === "quarterrange" ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col` },
                  vue.h(NScrollbar, { ref: "startMonthScrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                    default: () => [
                      (type2 === "monthrange" ? this.startMonthArray : this.startQuarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix, "start")),
                      type2 === "monthrange" && vue.h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__padding` })
                    ]
                  })
                ) : null
              )
            ),
            vue.h("div", { class: `${mergedClsPrefix}-date-panel__vertical-divider` }),
            vue.h(
              "div",
              { ref: "endDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-month-calendar` },
                vue.h(NScrollbar, { ref: "endYearScrollbarRef", class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: () => this.virtualListContainer("end"), content: () => this.virtualListContent("end"), horizontalRailStyle: { zIndex: 1 }, verticalRailStyle: { zIndex: 1 } }, {
                  default: () => vue.h(VVirtualList, { ref: "endYearVlRef", items: this.endYearArray, itemSize: MONTH_ITEM_HEIGHT, showScrollbar: false, keyField: "ts", onScroll: this.handleEndYearVlScroll, paddingBottom: 4 }, {
                    default: ({ item, index }) => {
                      return renderItem(item, index, mergedClsPrefix, "end");
                    }
                  })
                }),
                type2 === "monthrange" || type2 === "quarterrange" ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col` },
                  vue.h(NScrollbar, { ref: "endMonthScrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                    default: () => [
                      (type2 === "monthrange" ? this.endMonthArray : this.endQuarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix, "end")),
                      type2 === "monthrange" && vue.h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__padding` })
                    ]
                  })
                ) : null
              )
            ),
            this.datePickerSlots.footer ? vue.h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, vue.renderSlot(this.datePickerSlots, "footer")) : null,
            ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-date-panel-actions` },
              vue.h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts && Object.keys(shortcuts).map((key) => {
                const shortcut = shortcuts[key];
                return Array.isArray(shortcut) || typeof shortcut === "function" ? vue.h(XButton, { size: "tiny", onMouseenter: () => {
                  this.handleRangeShortcutMouseenter(shortcut);
                }, onClick: () => {
                  this.handleRangeShortcutClick(shortcut);
                }, onMouseleave: () => {
                  this.handleShortcutMouseleave();
                } }, { default: () => key }) : null;
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? vue.h(XButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear }) : null,
                ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? vue.h(XButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isRangeInvalid, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm }) : null
              )
            ) : null,
            vue.h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })
          );
        }
      });
      const style$R = c$1([cB("date-picker", `
 position: relative;
 z-index: auto;
 `, [cB("date-picker-icon", `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cB("icon", `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cM("disabled", [cB("date-picker-icon", `
 color: var(--n-icon-color-disabled-override);
 `), cB("icon", `
 color: var(--n-icon-color-disabled-override);
 `)])]), cB("date-panel", `
 width: fit-content;
 outline: none;
 margin: 4px 0;
 display: grid;
 grid-template-columns: 0fr;
 border-radius: var(--n-panel-border-radius);
 background-color: var(--n-panel-color);
 color: var(--n-panel-text-color);
 `, [fadeInScaleUpTransition(), cM("shadow", `
 box-shadow: var(--n-panel-box-shadow);
 `), cB("date-panel-calendar", {
        padding: "var(--n-calendar-left-padding)",
        display: "grid",
        gridTemplateColumns: "1fr",
        gridArea: "left-calendar"
      }, [cM("end", {
        padding: "var(--n-calendar-right-padding)",
        gridArea: "right-calendar"
      })]), cB("date-panel-month-calendar", {
        display: "flex",
        gridArea: "left-calendar"
      }, [cE("picker-col", `
 min-width: var(--n-scroll-item-width);
 height: calc(var(--n-scroll-item-height) * 6);
 user-select: none;
 -webkit-user-select: none;
 `, [c$1("&:first-child", `
 min-width: calc(var(--n-scroll-item-width) + 4px);
 `, [cE("picker-col-item", [c$1("&::before", "left: 4px;")])]), cE("padding", `
 height: calc(var(--n-scroll-item-height) * 5)
 `)]), cE("picker-col-item", `
 z-index: 0;
 cursor: pointer;
 height: var(--n-scroll-item-height);
 box-sizing: border-box;
 padding-top: 4px;
 display: flex;
 align-items: center;
 justify-content: center;
 position: relative;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background: #0000;
 color: var(--n-item-text-color);
 `, [c$1("&::before", `
 z-index: -1;
 content: "";
 position: absolute;
 left: 0;
 right: 4px;
 top: 4px;
 bottom: 0;
 border-radius: var(--n-scroll-item-border-radius);
 transition: 
 background-color .3s var(--n-bezier);
 `), cNotM("disabled", [c$1("&:hover::before", `
 background-color: var(--n-item-color-hover);
 `), cM("selected", `
 color: var(--n-item-color-active);
 `, [c$1("&::before", "background-color: var(--n-item-color-hover);")])]), cM("disabled", `
 color: var(--n-item-text-color-disabled);
 cursor: not-allowed;
 `, [cM("selected", [c$1("&::before", `
 background-color: var(--n-item-color-disabled);
 `)])])])]), cM("date", {
        gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
      }), cM("daterange", {
        gridTemplateAreas: `
 "left-calendar divider right-calendar"
 "footer footer footer"
 "action action action"
 `
      }), cM("datetime", {
        gridTemplateAreas: `
 "header"
 "left-calendar"
 "footer"
 "action"
 `
      }), cM("datetimerange", {
        gridTemplateAreas: `
 "header header header"
 "left-calendar divider right-calendar"
 "footer footer footer"
 "action action action"
 `
      }), cM("month", {
        gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
      }), cB("date-panel-footer", {
        gridArea: "footer"
      }), cB("date-panel-actions", {
        gridArea: "action"
      }), cB("date-panel-header", {
        gridArea: "header"
      }), cB("date-panel-header", `
 box-sizing: border-box;
 width: 100%;
 align-items: center;
 padding: var(--n-panel-header-padding);
 display: flex;
 justify-content: space-between;
 border-bottom: 1px solid var(--n-panel-header-divider-color);
 `, [c$1(">", [c$1("*:not(:last-child)", {
        marginRight: "10px"
      }), c$1("*", {
        flex: 1,
        width: 0
      }), cB("time-picker", {
        zIndex: 1
      })])]), cB("date-panel-month", `
 box-sizing: border-box;
 display: grid;
 grid-template-columns: var(--n-calendar-title-grid-template-columns);
 align-items: center;
 justify-items: center;
 padding: var(--n-calendar-title-padding);
 height: var(--n-calendar-title-height);
 `, [cE("prev, next, fast-prev, fast-next", `
 line-height: 0;
 cursor: pointer;
 width: var(--n-arrow-size);
 height: var(--n-arrow-size);
 color: var(--n-arrow-color);
 `), cE("month-year", `
 user-select: none;
 -webkit-user-select: none;
 flex-grow: 1;
 position: relative;
 `, [cE("text", `
 font-size: var(--n-calendar-title-font-size);
 line-height: var(--n-calendar-title-font-size);
 font-weight: var(--n-calendar-title-font-weight);
 padding: 6px 8px;
 text-align: center;
 color: var(--n-calendar-title-text-color);
 cursor: pointer;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-panel-border-radius);
 `, [cM("active", `
 background-color: var(--n-calendar-title-color-hover);
 `), c$1("&:hover", `
 background-color: var(--n-calendar-title-color-hover);
 `)])])]), cB("date-panel-weekdays", `
 display: grid;
 margin: auto;
 grid-template-columns: repeat(7, var(--n-item-cell-width));
 grid-template-rows: repeat(1, var(--n-item-cell-height));
 align-items: center;
 justify-items: center;
 margin-bottom: 4px;
 border-bottom: 1px solid var(--n-calendar-days-divider-color);
 `, [cE("day", `
 user-select: none;
 -webkit-user-select: none;
 line-height: 15px;
 width: var(--n-item-size);
 text-align: center;
 font-size: var(--n-calendar-days-font-size);
 color: var(--n-item-text-color);
 `)]), cB("date-panel-dates", `
 margin: auto;
 display: grid;
 grid-template-columns: repeat(7, var(--n-item-cell-width));
 grid-template-rows: repeat(6, var(--n-item-cell-height));
 align-items: center;
 justify-items: center;
 flex-wrap: wrap;
 `, [cB("date-panel-date", `
 user-select: none;
 -webkit-user-select: none;
 position: relative;
 width: var(--n-item-size);
 height: var(--n-item-size);
 line-height: var(--n-item-size);
 text-align: center;
 font-size: var(--n-item-font-size);
 border-radius: var(--n-item-border-radius);
 z-index: 0;
 cursor: pointer;
 transition:
 background-color .2s var(--n-bezier),
 color .2s var(--n-bezier);
 `, [cE("trigger", `
 position: absolute;
 left: calc(var(--n-item-size) / 2 - var(--n-item-cell-width) / 2);
 top: calc(var(--n-item-size) / 2 - var(--n-item-cell-height) / 2);
 width: var(--n-item-cell-width);
 height: var(--n-item-cell-height);
 `), cNotM("disabled", [cNotM("selected", [c$1("&:hover", {
        backgroundColor: "var(--n-item-color-hover)"
      })])]), cM("current", [cE("sup", `
 position: absolute;
 top: 2px;
 right: 2px;
 content: "";
 height: 4px;
 width: 4px;
 border-radius: 2px;
 background-color: var(--n-item-color-active);
 transition:
 background-color .2s var(--n-bezier);
 `)]), c$1("&::after", `
 content: "";
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 transition: background-color .3s var(--n-bezier);
 `), cM("covered, start, end", [cNotM("excluded", [c$1("&::before", `
 content: "";
 z-index: -2;
 position: absolute;
 left: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 right: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 top: 0;
 bottom: 0;
 background-color: var(--n-item-color-included);
 `), c$1("&:nth-child(7n + 1)::before", {
        borderTopLeftRadius: "var(--n-item-border-radius)",
        borderBottomLeftRadius: "var(--n-item-border-radius)"
      }), c$1("&:nth-child(7n + 7)::before", {
        borderTopRightRadius: "var(--n-item-border-radius)",
        borderBottomRightRadius: "var(--n-item-border-radius)"
      })])]), cM("selected", {
        color: "var(--n-item-text-color-active)"
      }, [c$1("&::after", {
        backgroundColor: "var(--n-item-color-active)"
      }), cM("start", [c$1("&::before", {
        left: "50%"
      })]), cM("end", [c$1("&::before", {
        right: "50%"
      })]), cE("sup", {
        backgroundColor: "var(--n-panel-color)"
      })]), cM("excluded", {
        color: "var(--n-item-text-color-disabled)"
      }, [cM("selected", [c$1("&::after", {
        backgroundColor: "var(--n-item-color-disabled)"
      })])]), cM("disabled", {
        cursor: "not-allowed",
        color: "var(--n-item-text-color-disabled)"
      }, [cM("covered", [c$1("&::before", {
        backgroundColor: "var(--n-item-color-disabled)"
      })]), cM("selected", [c$1("&::before", {
        backgroundColor: "var(--n-item-color-disabled)"
      }), c$1("&::after", {
        backgroundColor: "var(--n-item-color-disabled)"
      })])])])]), cE("vertical-divider", `
 grid-area: divider;
 height: 100%;
 width: 1px;
 background-color: var(--n-calendar-divider-color);
 `), cB("date-panel-footer", {
        borderTop: "1px solid var(--n-panel-action-divider-color)",
        padding: "var(--n-panel-extra-footer-padding)"
      }), cB("date-panel-actions", `
 flex: 1;
 padding: var(--n-panel-action-padding);
 display: flex;
 align-items: center;
 justify-content: space-between;
 border-top: 1px solid var(--n-panel-action-divider-color);
 `, [cE("prefix, suffix", `
 display: flex;
 margin-bottom: -8px;
 `), cE("suffix", `
 align-self: flex-end;
 `), cE("prefix", `
 flex-wrap: wrap;
 `), cB("button", `
 margin-bottom: 8px;
 `, [c$1("&:not(:last-child)", `
 margin-right: 8px;
 `)])])]), c$1("[data-n-date].transition-disabled", {
        transition: "none !important"
      }, [c$1("&::before, &::after", {
        transition: "none !important"
      })])]);
      const datePickerProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        bordered: {
          type: Boolean,
          default: void 0
        },
        clearable: Boolean,
        updateValueOnClose: Boolean,
        defaultValue: [Number, Array],
        defaultFormattedValue: [String, Array],
        defaultTime: [Number, String, Array],
        disabled: {
          type: Boolean,
          default: void 0
        },
        placement: {
          type: String,
          default: "bottom-start"
        },
        value: [Number, Array],
        formattedValue: [String, Array],
        size: String,
        type: {
          type: String,
          default: "date"
        },
        valueFormat: String,
        separator: String,
        placeholder: String,
        startPlaceholder: String,
        endPlaceholder: String,
        format: String,
        dateFormat: String,
        timeFormat: String,
        actions: Array,
        shortcuts: Object,
        isDateDisabled: Function,
        isTimeDisabled: Function,
        show: {
          type: Boolean,
          default: void 0
        },
        panel: Boolean,
        ranges: Object,
        firstDayOfWeek: Number,
        inputReadonly: Boolean,
        closeOnSelect: Boolean,
        status: String,
        timePickerProps: [Object, Array],
        onClear: Function,
        onConfirm: Function,
        defaultCalendarStartTime: Number,
        defaultCalendarEndTime: Number,
        bindCalendarMonths: Boolean,
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        "onUpdate:formattedValue": [Function, Array],
        onUpdateFormattedValue: [Function, Array],
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onFocus: [Function, Array],
        onBlur: [Function, Array],
        // deprecated
        onChange: [Function, Array]
      });
      const DatePicker = vue.defineComponent({
        name: "DatePicker",
        props: datePickerProps,
        setup(props, { slots }) {
          var _a;
          const { localeRef, dateLocaleRef } = useLocale("DatePicker");
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const { mergedComponentPropsRef, mergedClsPrefixRef, mergedBorderedRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const panelInstRef = vue.ref(null);
          const triggerElRef = vue.ref(null);
          const inputInstRef = vue.ref(null);
          const uncontrolledShowRef = vue.ref(false);
          const controlledShowRef = vue.toRef(props, "show");
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const dateFnsOptionsRef = vue.computed(() => {
            return {
              locale: dateLocaleRef.value.locale
            };
          });
          const mergedFormatRef = vue.computed(() => {
            const { format: format2 } = props;
            if (format2)
              return format2;
            switch (props.type) {
              case "date":
              case "daterange":
                return localeRef.value.dateFormat;
              case "datetime":
              case "datetimerange":
                return localeRef.value.dateTimeFormat;
              case "year":
              case "yearrange":
                return localeRef.value.yearTypeFormat;
              case "month":
              case "monthrange":
                return localeRef.value.monthTypeFormat;
              case "quarter":
              case "quarterrange":
                return localeRef.value.quarterFormat;
            }
          });
          const mergedValueFormatRef = vue.computed(() => {
            var _a2;
            return (_a2 = props.valueFormat) !== null && _a2 !== void 0 ? _a2 : mergedFormatRef.value;
          });
          function getTimestampValue(value) {
            if (value === null)
              return null;
            const { value: mergedValueFormat } = mergedValueFormatRef;
            const { value: dateFnsOptions } = dateFnsOptionsRef;
            if (Array.isArray(value)) {
              return [
                strictParse(value[0], mergedValueFormat, /* @__PURE__ */ new Date(), dateFnsOptions).getTime(),
                strictParse(value[1], mergedValueFormat, /* @__PURE__ */ new Date(), dateFnsOptions).getTime()
              ];
            }
            return strictParse(value, mergedValueFormat, /* @__PURE__ */ new Date(), dateFnsOptions).getTime();
          }
          const { defaultFormattedValue, defaultValue } = props;
          const uncontrolledValueRef = vue.ref((_a = defaultFormattedValue !== void 0 ? getTimestampValue(defaultFormattedValue) : defaultValue) !== null && _a !== void 0 ? _a : null);
          const controlledValueRef = vue.computed(() => {
            const { formattedValue } = props;
            if (formattedValue !== void 0) {
              return getTimestampValue(formattedValue);
            }
            return props.value;
          });
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const pendingValueRef = vue.ref(null);
          vue.watchEffect(() => {
            pendingValueRef.value = mergedValueRef.value;
          });
          const singleInputValueRef = vue.ref("");
          const rangeStartInputValueRef = vue.ref("");
          const rangeEndInputValueRef = vue.ref("");
          const themeRef = useTheme("DatePicker", "-date-picker", style$R, datePickerLight$1, props, mergedClsPrefixRef);
          const timePickerSizeRef = vue.computed(() => {
            var _a2, _b;
            return ((_b = (_a2 = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a2 === void 0 ? void 0 : _a2.DatePicker) === null || _b === void 0 ? void 0 : _b.timePickerSize) || "small";
          });
          const isRangeRef = vue.computed(() => {
            return [
              "daterange",
              "datetimerange",
              "monthrange",
              "quarterrange",
              "yearrange"
            ].includes(props.type);
          });
          const localizedPlacehoderRef = vue.computed(() => {
            const { placeholder } = props;
            if (placeholder === void 0) {
              const { type: type2 } = props;
              switch (type2) {
                case "date":
                  return localeRef.value.datePlaceholder;
                case "datetime":
                  return localeRef.value.datetimePlaceholder;
                case "month":
                  return localeRef.value.monthPlaceholder;
                case "year":
                  return localeRef.value.yearPlaceholder;
                case "quarter":
                  return localeRef.value.quarterPlaceholder;
                default:
                  return "";
              }
            } else {
              return placeholder;
            }
          });
          const localizedStartPlaceholderRef = vue.computed(() => {
            if (props.startPlaceholder === void 0) {
              if (props.type === "daterange") {
                return localeRef.value.startDatePlaceholder;
              } else if (props.type === "datetimerange") {
                return localeRef.value.startDatetimePlaceholder;
              } else if (props.type === "monthrange") {
                return localeRef.value.startMonthPlaceholder;
              }
              return "";
            } else {
              return props.startPlaceholder;
            }
          });
          const localizedEndPlaceholderRef = vue.computed(() => {
            if (props.endPlaceholder === void 0) {
              if (props.type === "daterange") {
                return localeRef.value.endDatePlaceholder;
              } else if (props.type === "datetimerange") {
                return localeRef.value.endDatetimePlaceholder;
              } else if (props.type === "monthrange") {
                return localeRef.value.endMonthPlaceholder;
              }
              return "";
            } else {
              return props.endPlaceholder;
            }
          });
          const mergedActionsRef = vue.computed(() => {
            const { actions, type: type2, clearable } = props;
            if (actions === null)
              return [];
            if (actions !== void 0)
              return actions;
            const result = clearable ? ["clear"] : [];
            switch (type2) {
              case "date": {
                result.push("now");
                return result;
              }
              case "datetime": {
                result.push("now", "confirm");
                return result;
              }
              case "daterange": {
                result.push("confirm");
                return result;
              }
              case "datetimerange": {
                result.push("confirm");
                return result;
              }
              case "month": {
                result.push("now", "confirm");
                return result;
              }
              case "year": {
                result.push("now");
                return result;
              }
              case "quarter": {
                result.push("now", "confirm");
                return result;
              }
              case "monthrange":
              case "yearrange":
              case "quarterrange": {
                result.push("confirm");
                return result;
              }
              default: {
                warn$2("date-picker", "The type is wrong, n-date-picker's type only supports `date`, `datetime`, `daterange` and `datetimerange`.");
                break;
              }
            }
          });
          function getFormattedValue(value) {
            if (value === null)
              return null;
            if (Array.isArray(value)) {
              const { value: mergedValueFormat } = mergedValueFormatRef;
              const { value: dateFnsOptions } = dateFnsOptionsRef;
              return [
                format$4(value[0], mergedValueFormat, dateFnsOptions),
                format$4(value[1], mergedValueFormat, dateFnsOptionsRef.value)
              ];
            } else {
              return format$4(value, mergedValueFormatRef.value, dateFnsOptionsRef.value);
            }
          }
          function doUpdatePendingValue(value) {
            pendingValueRef.value = value;
          }
          function doUpdateFormattedValue(value, timestampValue) {
            const { "onUpdate:formattedValue": _onUpdateFormattedValue, onUpdateFormattedValue } = props;
            if (_onUpdateFormattedValue) {
              call(_onUpdateFormattedValue, value, timestampValue);
            }
            if (onUpdateFormattedValue) {
              call(onUpdateFormattedValue, value, timestampValue);
            }
          }
          function doUpdateValue(value, options) {
            const { "onUpdate:value": _onUpdateValue, onUpdateValue, onChange } = props;
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            const formattedValue = getFormattedValue(value);
            if (options.doConfirm) {
              doConfirm(value, formattedValue);
            }
            if (onUpdateValue) {
              call(onUpdateValue, value, formattedValue);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value, formattedValue);
            }
            if (onChange)
              call(onChange, value, formattedValue);
            uncontrolledValueRef.value = value;
            doUpdateFormattedValue(formattedValue, value);
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function doClear() {
            const { onClear } = props;
            onClear === null || onClear === void 0 ? void 0 : onClear();
          }
          function doConfirm(value, formattedValue) {
            const { onConfirm } = props;
            if (onConfirm)
              onConfirm(value, formattedValue);
          }
          function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
          }
          function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
          }
          function doUpdateShow(show) {
            const { "onUpdate:show": _onUpdateShow, onUpdateShow } = props;
            if (_onUpdateShow)
              call(_onUpdateShow, show);
            if (onUpdateShow)
              call(onUpdateShow, show);
            uncontrolledShowRef.value = show;
          }
          function handleKeydown(e) {
            if (e.key === "Escape") {
              if (mergedShowRef.value) {
                markEventEffectPerformed(e);
                closeCalendar({
                  returnFocus: true
                });
              }
            }
          }
          function handleInputKeydown(e) {
            if (e.key === "Escape" && mergedShowRef.value) {
              markEventEffectPerformed(e);
            }
          }
          function handleClear() {
            var _a2;
            doUpdateShow(false);
            (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.deactivate();
            doClear();
          }
          function handlePanelClear() {
            var _a2;
            (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.deactivate();
            doClear();
          }
          function handlePanelTabOut() {
            closeCalendar({
              returnFocus: true
            });
          }
          function handleClickOutside(e) {
            var _a2;
            if (mergedShowRef.value && !((_a2 = triggerElRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)))) {
              closeCalendar({
                returnFocus: false
              });
            }
          }
          function handlePanelClose(disableUpdateOnClose) {
            closeCalendar({
              returnFocus: true,
              disableUpdateOnClose
            });
          }
          function handlePanelUpdateValue(value, doUpdate) {
            if (doUpdate) {
              doUpdateValue(value, { doConfirm: false });
            } else {
              doUpdatePendingValue(value);
            }
          }
          function handlePanelConfirm() {
            const pendingValue = pendingValueRef.value;
            doUpdateValue(Array.isArray(pendingValue) ? [pendingValue[0], pendingValue[1]] : pendingValue, { doConfirm: true });
          }
          function deriveInputState() {
            const { value } = pendingValueRef;
            if (isRangeRef.value) {
              if (Array.isArray(value) || value === null) {
                deriveRangeInputState(value);
              }
            } else {
              if (!Array.isArray(value)) {
                deriveSingleInputState(value);
              }
            }
          }
          function deriveSingleInputState(value) {
            if (value === null) {
              singleInputValueRef.value = "";
            } else {
              singleInputValueRef.value = format$4(value, mergedFormatRef.value, dateFnsOptionsRef.value);
            }
          }
          function deriveRangeInputState(values) {
            if (values === null) {
              rangeStartInputValueRef.value = "";
              rangeEndInputValueRef.value = "";
            } else {
              const dateFnsOptions = dateFnsOptionsRef.value;
              rangeStartInputValueRef.value = format$4(values[0], mergedFormatRef.value, dateFnsOptions);
              rangeEndInputValueRef.value = format$4(values[1], mergedFormatRef.value, dateFnsOptions);
            }
          }
          function handleInputActivate() {
            if (!mergedShowRef.value) {
              openCalendar();
            }
          }
          function handleInputBlur(e) {
            var _a2;
            if (!((_a2 = panelInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el.contains(e.relatedTarget))) {
              doBlur(e);
              deriveInputState();
              closeCalendar({
                returnFocus: false
              });
            }
          }
          function handleInputDeactivate() {
            if (mergedDisabledRef.value)
              return;
            deriveInputState();
            closeCalendar({
              returnFocus: false
            });
          }
          function handleSingleUpdateValue(v) {
            if (v === "") {
              doUpdateValue(null, { doConfirm: false });
              pendingValueRef.value = null;
              singleInputValueRef.value = "";
              return;
            }
            const newSelectedDateTime = strictParse(v, mergedFormatRef.value, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
            if (isValid$1(newSelectedDateTime)) {
              doUpdateValue(getTime(newSelectedDateTime), { doConfirm: false });
              deriveInputState();
            } else {
              singleInputValueRef.value = v;
            }
          }
          function handleRangeUpdateValue(v) {
            if (v[0] === "" && v[1] === "") {
              doUpdateValue(null, { doConfirm: false });
              pendingValueRef.value = null;
              rangeStartInputValueRef.value = "";
              rangeEndInputValueRef.value = "";
              return;
            }
            const [startTime, endTime] = v;
            const newStartTime = strictParse(startTime, mergedFormatRef.value, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
            const newEndTime = strictParse(endTime, mergedFormatRef.value, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
            if (isValid$1(newStartTime) && isValid$1(newEndTime)) {
              doUpdateValue([getTime(newStartTime), getTime(newEndTime)], {
                doConfirm: false
              });
              deriveInputState();
            } else {
              [rangeStartInputValueRef.value, rangeEndInputValueRef.value] = v;
            }
          }
          function handleTriggerClick(e) {
            if (mergedDisabledRef.value)
              return;
            if (happensIn(e, "clear"))
              return;
            if (!mergedShowRef.value) {
              openCalendar();
            }
          }
          function handleInputFocus(e) {
            if (mergedDisabledRef.value)
              return;
            doFocus(e);
          }
          function openCalendar() {
            if (mergedDisabledRef.value || mergedShowRef.value)
              return;
            doUpdateShow(true);
          }
          function closeCalendar({ returnFocus, disableUpdateOnClose }) {
            var _a2;
            if (mergedShowRef.value) {
              doUpdateShow(false);
              if (props.type !== "date" && props.updateValueOnClose && !disableUpdateOnClose) {
                handlePanelConfirm();
              }
              if (returnFocus) {
                (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
              }
            }
          }
          vue.watch(pendingValueRef, () => {
            deriveInputState();
          });
          deriveInputState();
          vue.watch(mergedShowRef, (value) => {
            if (!value) {
              pendingValueRef.value = mergedValueRef.value;
            }
          });
          const uniVaidation = uniCalendarValidation(props, pendingValueRef);
          const dualValidation = dualCalendarValidation(props, pendingValueRef);
          vue.provide(datePickerInjectionKey, Object.assign(Object.assign(Object.assign({
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            timePickerSizeRef,
            localeRef,
            dateLocaleRef,
            firstDayOfWeekRef: vue.toRef(props, "firstDayOfWeek"),
            isDateDisabledRef: vue.toRef(props, "isDateDisabled"),
            rangesRef: vue.toRef(props, "ranges"),
            timePickerPropsRef: vue.toRef(props, "timePickerProps"),
            closeOnSelectRef: vue.toRef(props, "closeOnSelect"),
            updateValueOnCloseRef: vue.toRef(props, "updateValueOnClose")
          }, uniVaidation), dualValidation), { datePickerSlots: slots }));
          const exposedMethods = {
            focus: () => {
              var _a2;
              (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
            },
            blur: () => {
              var _a2;
              (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
            }
          };
          const triggerCssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { iconColor, iconColorDisabled } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-icon-color-override": iconColor,
              "--n-icon-color-disabled-override": iconColorDisabled
            };
          });
          const triggerThemeClassHandle = inlineThemeDisabled ? useThemeClass("date-picker-trigger", void 0, triggerCssVarsRef, props) : void 0;
          const cssVarsRef = vue.computed(() => {
            const { type: type2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { calendarTitleFontSize, calendarDaysFontSize, itemFontSize, itemTextColor, itemColorDisabled, itemColorIncluded, itemColorHover, itemColorActive, itemBorderRadius, itemTextColorDisabled, itemTextColorActive, panelColor, panelTextColor, arrowColor, calendarTitleTextColor, panelActionDividerColor, panelHeaderDividerColor, calendarDaysDividerColor, panelBoxShadow, panelBorderRadius, calendarTitleFontWeight, panelExtraFooterPadding, panelActionPadding, itemSize, itemCellWidth, itemCellHeight, scrollItemWidth, scrollItemHeight, calendarTitlePadding, calendarTitleHeight, calendarDaysHeight, calendarDaysTextColor, arrowSize: arrowSize2, panelHeaderPadding, calendarDividerColor, calendarTitleGridTempateColumns, iconColor, iconColorDisabled, scrollItemBorderRadius, calendarTitleColorHover, [createKey("calendarLeftPadding", type2)]: calendarLeftPadding, [createKey("calendarRightPadding", type2)]: calendarRightPadding } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-panel-border-radius": panelBorderRadius,
              "--n-panel-color": panelColor,
              "--n-panel-box-shadow": panelBoxShadow,
              "--n-panel-text-color": panelTextColor,
              // panel header
              "--n-panel-header-padding": panelHeaderPadding,
              "--n-panel-header-divider-color": panelHeaderDividerColor,
              // panel calendar
              "--n-calendar-left-padding": calendarLeftPadding,
              "--n-calendar-right-padding": calendarRightPadding,
              "--n-calendar-title-color-hover": calendarTitleColorHover,
              "--n-calendar-title-height": calendarTitleHeight,
              "--n-calendar-title-padding": calendarTitlePadding,
              "--n-calendar-title-font-size": calendarTitleFontSize,
              "--n-calendar-title-font-weight": calendarTitleFontWeight,
              "--n-calendar-title-text-color": calendarTitleTextColor,
              "--n-calendar-title-grid-template-columns": calendarTitleGridTempateColumns,
              "--n-calendar-days-height": calendarDaysHeight,
              "--n-calendar-days-divider-color": calendarDaysDividerColor,
              "--n-calendar-days-font-size": calendarDaysFontSize,
              "--n-calendar-days-text-color": calendarDaysTextColor,
              "--n-calendar-divider-color": calendarDividerColor,
              // panel action
              "--n-panel-action-padding": panelActionPadding,
              "--n-panel-extra-footer-padding": panelExtraFooterPadding,
              "--n-panel-action-divider-color": panelActionDividerColor,
              // panel item
              "--n-item-font-size": itemFontSize,
              "--n-item-border-radius": itemBorderRadius,
              "--n-item-size": itemSize,
              "--n-item-cell-width": itemCellWidth,
              "--n-item-cell-height": itemCellHeight,
              "--n-item-text-color": itemTextColor,
              "--n-item-color-included": itemColorIncluded,
              "--n-item-color-disabled": itemColorDisabled,
              "--n-item-color-hover": itemColorHover,
              "--n-item-color-active": itemColorActive,
              "--n-item-text-color-disabled": itemTextColorDisabled,
              "--n-item-text-color-active": itemTextColorActive,
              // scroll item
              "--n-scroll-item-width": scrollItemWidth,
              "--n-scroll-item-height": scrollItemHeight,
              "--n-scroll-item-border-radius": scrollItemBorderRadius,
              // panel arrow
              "--n-arrow-size": arrowSize2,
              "--n-arrow-color": arrowColor,
              // icon in trigger
              "--n-icon-color": iconColor,
              "--n-icon-color-disabled": iconColorDisabled
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("date-picker", vue.computed(() => {
            return props.type;
          }), cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedStatus: mergedStatusRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            namespace: namespaceRef,
            uncontrolledValue: uncontrolledValueRef,
            pendingValue: pendingValueRef,
            panelInstRef,
            triggerElRef,
            inputInstRef,
            isMounted: isMounted(),
            displayTime: singleInputValueRef,
            displayStartTime: rangeStartInputValueRef,
            displayEndTime: rangeEndInputValueRef,
            mergedShow: mergedShowRef,
            adjustedTo: useAdjustedTo(props),
            isRange: isRangeRef,
            localizedStartPlaceholder: localizedStartPlaceholderRef,
            localizedEndPlaceholder: localizedEndPlaceholderRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            localizedPlacehoder: localizedPlacehoderRef,
            isValueInvalid: uniVaidation.isValueInvalidRef,
            isStartValueInvalid: dualValidation.isStartValueInvalidRef,
            isEndValueInvalid: dualValidation.isEndValueInvalidRef,
            handleInputKeydown,
            handleClickOutside,
            handleKeydown,
            handleClear,
            handlePanelClear,
            handleTriggerClick,
            handleInputActivate,
            handleInputDeactivate,
            handleInputFocus,
            handleInputBlur,
            handlePanelTabOut,
            handlePanelClose,
            handleRangeUpdateValue,
            handleSingleUpdateValue,
            handlePanelUpdateValue,
            handlePanelConfirm,
            mergedTheme: themeRef,
            actions: mergedActionsRef,
            triggerCssVars: inlineThemeDisabled ? void 0 : triggerCssVarsRef,
            triggerThemeClass: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.themeClass,
            triggerOnRender: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.onRender,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const { clearable, triggerOnRender, mergedClsPrefix, $slots } = this;
          const commonPanelProps = {
            onUpdateValue: this.handlePanelUpdateValue,
            onTabOut: this.handlePanelTabOut,
            onClose: this.handlePanelClose,
            onClear: this.handlePanelClear,
            onKeydown: this.handleKeydown,
            onConfirm: this.handlePanelConfirm,
            ref: "panelInstRef",
            value: this.pendingValue,
            active: this.mergedShow,
            actions: this.actions,
            shortcuts: this.shortcuts,
            style: this.cssVars,
            defaultTime: this.defaultTime,
            themeClass: this.themeClass,
            panel: this.panel,
            onRender: this.onRender
          };
          const renderPanel = () => {
            const { type: type2 } = this;
            return type2 === "datetime" ? vue.h(DatetimePanel, Object.assign({}, commonPanelProps), $slots) : type2 === "daterange" ? vue.h(DaterangePanel, Object.assign({}, commonPanelProps, { defaultCalendarStartTime: this.defaultCalendarStartTime, defaultCalendarEndTime: this.defaultCalendarEndTime, bindCalendarMonths: this.bindCalendarMonths }), $slots) : type2 === "datetimerange" ? vue.h(DatetimerangePanel, Object.assign({}, commonPanelProps, { defaultCalendarStartTime: this.defaultCalendarStartTime, defaultCalendarEndTime: this.defaultCalendarEndTime, bindCalendarMonths: this.bindCalendarMonths }), $slots) : type2 === "month" || type2 === "year" || type2 === "quarter" ? vue.h(MonthPanel, Object.assign({}, commonPanelProps, { type: type2, key: type2 })) : type2 === "monthrange" || type2 === "yearrange" || type2 === "quarterrange" ? vue.h(MonthRangePanel, Object.assign({}, commonPanelProps, { type: type2 })) : vue.h(DatePanel, Object.assign({}, commonPanelProps), $slots);
          };
          if (this.panel) {
            return renderPanel();
          }
          triggerOnRender === null || triggerOnRender === void 0 ? void 0 : triggerOnRender();
          const commonInputProps = {
            bordered: this.mergedBordered,
            size: this.mergedSize,
            passivelyActivated: true,
            disabled: this.mergedDisabled,
            readonly: this.inputReadonly || this.mergedDisabled,
            clearable,
            onClear: this.handleClear,
            onClick: this.handleTriggerClick,
            onKeydown: this.handleInputKeydown,
            onActivate: this.handleInputActivate,
            onDeactivate: this.handleInputDeactivate,
            onFocus: this.handleInputFocus,
            onBlur: this.handleInputBlur
          };
          return vue.h(
            "div",
            { ref: "triggerElRef", class: [
              `${mergedClsPrefix}-date-picker`,
              this.mergedDisabled && `${mergedClsPrefix}-date-picker--disabled`,
              this.isRange && `${mergedClsPrefix}-date-picker--range`,
              this.triggerThemeClass
            ], style: this.triggerCssVars, onKeydown: this.handleKeydown },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => this.isRange ? vue.h(NInput, Object.assign({ ref: "inputInstRef", status: this.mergedStatus, value: [this.displayStartTime, this.displayEndTime], placeholder: [
                    this.localizedStartPlaceholder,
                    this.localizedEndPlaceholder
                  ], textDecoration: [
                    this.isStartValueInvalid ? "line-through" : "",
                    this.isEndValueInvalid ? "line-through" : ""
                  ], pair: true, onUpdateValue: this.handleRangeUpdateValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, internalForceFocus: this.mergedShow, internalDeactivateOnEnter: true }, commonInputProps), {
                    separator: () => this.separator === void 0 ? resolveSlot($slots.separator, () => [
                      vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-date-picker-icon` }, {
                        default: () => vue.h(ToIcon, null)
                      })
                    ]) : this.separator,
                    [clearable ? "clear-icon-placeholder" : "suffix"]: () => resolveSlot($slots["date-icon"], () => [
                      vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-date-picker-icon` }, {
                        default: () => vue.h(DateIcon, null)
                      })
                    ])
                  }) : vue.h(NInput, Object.assign({ ref: "inputInstRef", status: this.mergedStatus, value: this.displayTime, placeholder: this.localizedPlacehoder, textDecoration: this.isValueInvalid && !this.isRange ? "line-through" : "", onUpdateValue: this.handleSingleUpdateValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, internalForceFocus: this.mergedShow, internalDeactivateOnEnter: true }, commonInputProps), {
                    [clearable ? "clear-icon-placeholder" : "suffix"]: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-date-picker-icon` }, {
                      default: () => resolveSlot($slots["date-icon"], () => [
                        vue.h(DateIcon, null)
                      ])
                    })
                  })
                }),
                vue.h(VFollower, { show: this.mergedShow, containerClass: this.namespace, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, placement: this.placement }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                    default: () => {
                      if (!this.mergedShow)
                        return null;
                      return vue.withDirectives(renderPanel(), [
                        [
                          clickoutside$1,
                          this.handleClickOutside,
                          void 0,
                          { capture: true }
                        ]
                      ]);
                    }
                  })
                })
              ]
            })
          );
        }
      });
      const commonVariables$7 = {
        thPaddingBorderedSmall: "8px 12px",
        thPaddingBorderedMedium: "12px 16px",
        thPaddingBorderedLarge: "16px 24px",
        thPaddingSmall: "0",
        thPaddingMedium: "0",
        thPaddingLarge: "0",
        tdPaddingBorderedSmall: "8px 12px",
        tdPaddingBorderedMedium: "12px 16px",
        tdPaddingBorderedLarge: "16px 24px",
        tdPaddingSmall: "0 0 8px 0",
        tdPaddingMedium: "0 0 12px 0",
        tdPaddingLarge: "0 0 16px 0"
      };
      const self$G = (vars) => {
        const { tableHeaderColor, textColor2, textColor1, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontWeightStrong, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
        return Object.assign(Object.assign({}, commonVariables$7), {
          lineHeight: lineHeight2,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          titleTextColor: textColor1,
          thColor: composite(cardColor, tableHeaderColor),
          thColorModal: composite(modalColor, tableHeaderColor),
          thColorPopover: composite(popoverColor, tableHeaderColor),
          thTextColor: textColor1,
          thFontWeight: fontWeightStrong,
          tdTextColor: textColor2,
          tdColor: cardColor,
          tdColorModal: modalColor,
          tdColorPopover: popoverColor,
          borderColor: composite(cardColor, dividerColor),
          borderColorModal: composite(modalColor, dividerColor),
          borderColorPopover: composite(popoverColor, dividerColor),
          borderRadius
        });
      };
      const descriptionsLight = {
        name: "Descriptions",
        common: commonLight,
        self: self$G
      };
      const descriptionsLight$1 = descriptionsLight;
      const descriptionsDark = {
        name: "Descriptions",
        common: commonDark,
        self: self$G
      };
      const descriptionsDark$1 = descriptionsDark;
      const DESCRIPTION_ITEM_FLAG = "DESCRIPTION_ITEM_FLAG";
      function isDescriptionsItem(vNode) {
        if (typeof vNode === "object" && vNode && !Array.isArray(vNode)) {
          return vNode.type && vNode.type[DESCRIPTION_ITEM_FLAG];
        }
        return false;
      }
      const style$Q = c$1([cB("descriptions", {
        fontSize: "var(--n-font-size)"
      }, [cB("descriptions-separator", `
 display: inline-block;
 margin: 0 8px 0 2px;
 `), cB("descriptions-table-wrapper", [cB("descriptions-table", [cB("descriptions-table-row", [cB("descriptions-table-header", {
        padding: "var(--n-th-padding)"
      }), cB("descriptions-table-content", {
        padding: "var(--n-td-padding)"
      })])])]), cNotM("bordered", [cB("descriptions-table-wrapper", [cB("descriptions-table", [cB("descriptions-table-row", [c$1("&:last-child", [cB("descriptions-table-content", {
        paddingBottom: 0
      })])])])])]), cM("left-label-placement", [cB("descriptions-table-content", [c$1("> *", {
        verticalAlign: "top"
      })])]), cM("left-label-align", [c$1("th", {
        textAlign: "left"
      })]), cM("center-label-align", [c$1("th", {
        textAlign: "center"
      })]), cM("right-label-align", [c$1("th", {
        textAlign: "right"
      })]), cM("bordered", [cB("descriptions-table-wrapper", `
 border-radius: var(--n-border-radius);
 overflow: hidden;
 background: var(--n-merged-td-color);
 border: 1px solid var(--n-merged-border-color);
 `, [cB("descriptions-table", [cB("descriptions-table-row", [c$1("&:not(:last-child)", [cB("descriptions-table-content", {
        borderBottom: "1px solid var(--n-merged-border-color)"
      }), cB("descriptions-table-header", {
        borderBottom: "1px solid var(--n-merged-border-color)"
      })]), cB("descriptions-table-header", `
 font-weight: 400;
 background-clip: padding-box;
 background-color: var(--n-merged-th-color);
 `, [c$1("&:not(:last-child)", {
        borderRight: "1px solid var(--n-merged-border-color)"
      })]), cB("descriptions-table-content", [c$1("&:not(:last-child)", {
        borderRight: "1px solid var(--n-merged-border-color)"
      })])])])])]), cB("descriptions-header", `
 font-weight: var(--n-th-font-weight);
 font-size: 18px;
 transition: color .3s var(--n-bezier);
 line-height: var(--n-line-height);
 margin-bottom: 16px;
 color: var(--n-title-text-color);
 `), cB("descriptions-table-wrapper", `
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cB("descriptions-table", `
 width: 100%;
 border-collapse: separate;
 border-spacing: 0;
 box-sizing: border-box;
 `, [cB("descriptions-table-row", `
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [cB("descriptions-table-header", `
 font-weight: var(--n-th-font-weight);
 line-height: var(--n-line-height);
 display: table-cell;
 box-sizing: border-box;
 color: var(--n-th-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cB("descriptions-table-content", `
 vertical-align: top;
 line-height: var(--n-line-height);
 display: table-cell;
 box-sizing: border-box;
 color: var(--n-td-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE("content", `
 transition: color .3s var(--n-bezier);
 display: inline-block;
 color: var(--n-td-text-color);
 `)]), cE("label", `
 font-weight: var(--n-th-font-weight);
 transition: color .3s var(--n-bezier);
 display: inline-block;
 margin-right: 14px;
 color: var(--n-th-text-color);
 `)])])])]), cB("descriptions-table-wrapper", `
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 `), insideModal(cB("descriptions-table-wrapper", `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB("descriptions-table-wrapper", `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);
      const descriptionsProps = Object.assign(Object.assign({}, useTheme.props), { title: String, column: {
        type: Number,
        default: 3
      }, columns: Number, labelPlacement: {
        type: String,
        default: "top"
      }, labelAlign: {
        type: String,
        default: "left"
      }, separator: {
        type: String,
        default: ":"
      }, size: {
        type: String,
        default: "medium"
      }, bordered: Boolean, labelStyle: [Object, String], contentStyle: [Object, String] });
      const Descriptions = vue.defineComponent({
        name: "Descriptions",
        props: descriptionsProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Descriptions", "-descriptions", style$Q, descriptionsLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { size: size2, bordered } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { titleTextColor, thColor, thColorModal, thColorPopover, thTextColor, thFontWeight, tdTextColor, tdColor, tdColorModal, tdColorPopover, borderColor, borderColorModal, borderColorPopover, borderRadius, lineHeight: lineHeight2, [createKey("fontSize", size2)]: fontSize2, [createKey(bordered ? "thPaddingBordered" : "thPadding", size2)]: thPadding, [createKey(bordered ? "tdPaddingBordered" : "tdPadding", size2)]: tdPadding } } = themeRef.value;
            return {
              "--n-title-text-color": titleTextColor,
              "--n-th-padding": thPadding,
              "--n-td-padding": tdPadding,
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-th-font-weight": thFontWeight,
              "--n-line-height": lineHeight2,
              "--n-th-text-color": thTextColor,
              "--n-td-text-color": tdTextColor,
              "--n-th-color": thColor,
              "--n-th-color-modal": thColorModal,
              "--n-th-color-popover": thColorPopover,
              "--n-td-color": tdColor,
              "--n-td-color-modal": tdColorModal,
              "--n-td-color-popover": tdColorPopover,
              "--n-border-radius": borderRadius,
              "--n-border-color": borderColor,
              "--n-border-color-modal": borderColorModal,
              "--n-border-color-popover": borderColorPopover
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("descriptions", vue.computed(() => {
            let hash = "";
            const { size: size2, bordered } = props;
            if (bordered)
              hash += "a";
            hash += size2[0];
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            compitableColumn: useCompitable(props, ["columns", "column"]),
            inlineThemeDisabled
          };
        },
        render() {
          const defaultSlots = this.$slots.default;
          const children = defaultSlots ? flatten$3(defaultSlots()) : [];
          children.length;
          const { compitableColumn, labelPlacement, labelAlign, size: size2, bordered, title, cssVars, mergedClsPrefix, separator, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const filteredChildren = children.filter((child) => isDescriptionsItem(child));
          const defaultState = {
            span: 0,
            row: [],
            secondRow: [],
            rows: []
          };
          const itemState = filteredChildren.reduce((state, vNode, index) => {
            const props = vNode.props || {};
            const isLastIteration = filteredChildren.length - 1 === index;
            const itemLabel = [
              "label" in props ? props.label : getVNodeChildren(vNode, "label")
            ];
            const itemChildren = [getVNodeChildren(vNode)];
            const itemSpan = props.span || 1;
            const memorizedSpan = state.span;
            state.span += itemSpan;
            const labelStyle = props.labelStyle || props["label-style"] || this.labelStyle;
            const contentStyle = props.contentStyle || props["content-style"] || this.contentStyle;
            if (labelPlacement === "left") {
              if (bordered) {
                state.row.push(vue.h("th", { class: `${mergedClsPrefix}-descriptions-table-header`, colspan: 1, style: labelStyle }, itemLabel), vue.h("td", { class: `${mergedClsPrefix}-descriptions-table-content`, colspan: isLastIteration ? (compitableColumn - memorizedSpan) * 2 + 1 : itemSpan * 2 - 1, style: contentStyle }, itemChildren));
              } else {
                state.row.push(vue.h(
                  "td",
                  { class: `${mergedClsPrefix}-descriptions-table-content`, colspan: isLastIteration ? (compitableColumn - memorizedSpan) * 2 : itemSpan * 2 },
                  vue.h("span", { class: `${mergedClsPrefix}-descriptions-table-content__label`, style: labelStyle }, [
                    ...itemLabel,
                    separator && vue.h("span", { class: `${mergedClsPrefix}-descriptions-separator` }, separator)
                  ]),
                  vue.h("span", { class: `${mergedClsPrefix}-descriptions-table-content__content`, style: contentStyle }, itemChildren)
                ));
              }
            } else {
              const colspan = isLastIteration ? (compitableColumn - memorizedSpan) * 2 : itemSpan * 2;
              state.row.push(vue.h("th", { class: `${mergedClsPrefix}-descriptions-table-header`, colspan, style: labelStyle }, itemLabel));
              state.secondRow.push(vue.h("td", { class: `${mergedClsPrefix}-descriptions-table-content`, colspan, style: contentStyle }, itemChildren));
            }
            if (state.span >= compitableColumn || isLastIteration) {
              state.span = 0;
              if (state.row.length) {
                state.rows.push(state.row);
                state.row = [];
              }
              if (labelPlacement !== "left") {
                if (state.secondRow.length) {
                  state.rows.push(state.secondRow);
                  state.secondRow = [];
                }
              }
            }
            return state;
          }, defaultState);
          const rows = itemState.rows.map((row) => vue.h("tr", { class: `${mergedClsPrefix}-descriptions-table-row` }, row));
          return vue.h(
            "div",
            { style: cssVars, class: [
              `${mergedClsPrefix}-descriptions`,
              this.themeClass,
              `${mergedClsPrefix}-descriptions--${labelPlacement}-label-placement`,
              `${mergedClsPrefix}-descriptions--${labelAlign}-label-align`,
              `${mergedClsPrefix}-descriptions--${size2}-size`,
              bordered && `${mergedClsPrefix}-descriptions--bordered`
            ] },
            title || this.$slots.header ? vue.h("div", { class: `${mergedClsPrefix}-descriptions-header` }, title || getSlot$1(this, "header")) : null,
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-descriptions-table-wrapper` },
              vue.h(
                "table",
                { class: `${mergedClsPrefix}-descriptions-table` },
                vue.h("tbody", null, rows)
              )
            )
          );
        }
      });
      const descriptionsItemProps = {
        label: String,
        span: {
          type: Number,
          default: 1
        },
        labelStyle: [Object, String],
        contentStyle: [Object, String]
      };
      const DescriptionsItem = vue.defineComponent({
        name: "DescriptionsItem",
        [DESCRIPTION_ITEM_FLAG]: true,
        props: descriptionsItemProps,
        render() {
          return null;
        }
      });
      const commonVars$5 = {
        titleFontSize: "18px",
        padding: "16px 28px 20px 28px",
        iconSize: "28px",
        actionSpace: "12px",
        contentMargin: "8px 0 16px 0",
        iconMargin: "0 4px 0 0",
        iconMarginIconTop: "4px 0 8px 0",
        closeSize: "22px",
        closeIconSize: "18px",
        closeMargin: "20px 26px 0 0",
        closeMarginIconTop: "10px 16px 0 0"
      };
      const self$F = (vars) => {
        const { textColor1, textColor2, modalColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, infoColor, successColor, warningColor, errorColor, primaryColor, dividerColor, borderRadius, fontWeightStrong, lineHeight: lineHeight2, fontSize: fontSize2 } = vars;
        return Object.assign(Object.assign({}, commonVars$5), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          border: `1px solid ${dividerColor}`,
          titleTextColor: textColor1,
          textColor: textColor2,
          color: modalColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeBorderRadius: borderRadius,
          iconColor: primaryColor,
          iconColorInfo: infoColor,
          iconColorSuccess: successColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          borderRadius,
          titleFontWeight: fontWeightStrong
        });
      };
      const dialogLight = createTheme({
        name: "Dialog",
        common: commonLight,
        peers: {
          Button: buttonLight$1
        },
        self: self$F
      });
      const dialogLight$1 = dialogLight;
      const dialogDark = {
        name: "Dialog",
        common: commonDark,
        peers: {
          Button: buttonDark$1
        },
        self: self$F
      };
      const dialogDark$1 = dialogDark;
      const dialogProps = {
        icon: Function,
        type: {
          type: String,
          default: "default"
        },
        title: [String, Function],
        closable: {
          type: Boolean,
          default: true
        },
        negativeText: String,
        positiveText: String,
        positiveButtonProps: Object,
        negativeButtonProps: Object,
        content: [String, Function],
        action: Function,
        showIcon: {
          type: Boolean,
          default: true
        },
        loading: Boolean,
        bordered: Boolean,
        iconPlacement: String,
        onPositiveClick: Function,
        onNegativeClick: Function,
        onClose: Function
      };
      const dialogPropKeys = keysOf(dialogProps);
      const style$P = c$1([cB("dialog", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: relative;
 background: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 margin: auto;
 border-radius: var(--n-border-radius);
 padding: var(--n-padding);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cE("icon", {
        color: "var(--n-icon-color)"
      }), cM("bordered", {
        border: "var(--n-border)"
      }), cM("icon-top", [cE("close", {
        margin: "var(--n-close-margin)"
      }), cE("icon", {
        margin: "var(--n-icon-margin)"
      }), cE("content", {
        textAlign: "center"
      }), cE("title", {
        justifyContent: "center"
      }), cE("action", {
        justifyContent: "center"
      })]), cM("icon-left", [cE("icon", {
        margin: "var(--n-icon-margin)"
      }), cM("closable", [cE("title", `
 padding-right: calc(var(--n-close-size) + 6px);
 `)])]), cE("close", `
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 z-index: 1;
 `), cE("content", `
 font-size: var(--n-font-size);
 margin: var(--n-content-margin);
 position: relative;
 word-break: break-word;
 `, [cM("last", "margin-bottom: 0;")]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("> *:not(:last-child)", {
        marginRight: "var(--n-action-space)"
      })]), cE("icon", {
        fontSize: "var(--n-icon-size)",
        transition: "color .3s var(--n-bezier)"
      }), cE("title", `
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cB("dialog-icon-container", {
        display: "flex",
        justifyContent: "center"
      })]), insideModal(cB("dialog", `
 width: 446px;
 max-width: calc(100vw - 32px);
 `)), cB("dialog", [asModal(`
 width: 446px;
 max-width: calc(100vw - 32px);
 `)])]);
      const iconRenderMap$2 = {
        default: () => vue.h(InfoIcon, null),
        info: () => vue.h(InfoIcon, null),
        success: () => vue.h(SuccessIcon, null),
        warning: () => vue.h(WarningIcon, null),
        error: () => vue.h(ErrorIcon, null)
      };
      const NDialog = vue.defineComponent({
        name: "Dialog",
        alias: [
          "NimbusConfirmCard",
          "Confirm"
          // deprecated
        ],
        props: Object.assign(Object.assign({}, useTheme.props), dialogProps),
        setup(props) {
          const { mergedComponentPropsRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const mergedIconPlacementRef = vue.computed(() => {
            var _a, _b;
            const { iconPlacement } = props;
            return iconPlacement || ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Dialog) === null || _b === void 0 ? void 0 : _b.iconPlacement) || "left";
          });
          function handlePositiveClick(e) {
            const { onPositiveClick } = props;
            if (onPositiveClick)
              onPositiveClick(e);
          }
          function handleNegativeClick(e) {
            const { onNegativeClick } = props;
            if (onNegativeClick)
              onNegativeClick(e);
          }
          function handleCloseClick() {
            const { onClose } = props;
            if (onClose)
              onClose();
          }
          const themeRef = useTheme("Dialog", "-dialog", style$P, dialogLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { type: type2 } = props;
            const iconPlacement = mergedIconPlacementRef.value;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { fontSize: fontSize2, lineHeight: lineHeight2, border, titleTextColor, textColor, color, closeBorderRadius, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, closeIconSize, borderRadius, titleFontWeight, titleFontSize, padding, iconSize, actionSpace, contentMargin, closeSize, [iconPlacement === "top" ? "iconMarginIconTop" : "iconMargin"]: iconMargin, [iconPlacement === "top" ? "closeMarginIconTop" : "closeMargin"]: closeMargin, [createKey("iconColor", type2)]: iconColor } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-icon-color": iconColor,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-close-margin": closeMargin,
              "--n-icon-margin": iconMargin,
              "--n-icon-size": iconSize,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-color": color,
              "--n-text-color": textColor,
              "--n-border-radius": borderRadius,
              "--n-padding": padding,
              "--n-line-height": lineHeight2,
              "--n-border": border,
              "--n-content-margin": contentMargin,
              "--n-title-font-size": titleFontSize,
              "--n-title-font-weight": titleFontWeight,
              "--n-title-text-color": titleTextColor,
              "--n-action-space": actionSpace
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("dialog", vue.computed(() => `${props.type[0]}${mergedIconPlacementRef.value[0]}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedIconPlacement: mergedIconPlacementRef,
            mergedTheme: themeRef,
            handlePositiveClick,
            handleNegativeClick,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { bordered, mergedIconPlacement, cssVars, closable, showIcon, title, content, action, negativeText, positiveText, positiveButtonProps, negativeButtonProps, handlePositiveClick, handleNegativeClick, mergedTheme, loading, type: type2, mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const icon = showIcon ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__icon` }, {
            default: () => resolveWrappedSlot(this.$slots.icon, (children) => children || (this.icon ? render$1(this.icon) : iconRenderMap$2[this.type]()))
          }) : null;
          const actionNode = resolveWrappedSlot(this.$slots.action, (children) => children || positiveText || negativeText || action ? vue.h("div", { class: `${mergedClsPrefix}-dialog__action` }, children || (action ? [render$1(action)] : [
            this.negativeText && vue.h(NButton, Object.assign({ theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, ghost: true, size: "small", onClick: handleNegativeClick }, negativeButtonProps), {
              default: () => render$1(this.negativeText)
            }),
            this.positiveText && vue.h(NButton, Object.assign({ theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "small", type: type2 === "default" ? "primary" : type2, disabled: loading, loading, onClick: handlePositiveClick }, positiveButtonProps), {
              default: () => render$1(this.positiveText)
            })
          ])) : null);
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-dialog`,
              this.themeClass,
              this.closable && `${mergedClsPrefix}-dialog--closable`,
              `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`,
              bordered && `${mergedClsPrefix}-dialog--bordered`
            ], style: cssVars, role: "dialog" },
            closable ? vue.h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__close`, onClick: this.handleCloseClick }) : null,
            showIcon && mergedIconPlacement === "top" ? vue.h("div", { class: `${mergedClsPrefix}-dialog-icon-container` }, icon) : null,
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-dialog__title` },
              showIcon && mergedIconPlacement === "left" ? icon : null,
              resolveSlot(this.$slots.header, () => [render$1(title)])
            ),
            vue.h("div", { class: [
              `${mergedClsPrefix}-dialog__content`,
              actionNode ? "" : `${mergedClsPrefix}-dialog__content--last`
            ] }, resolveSlot(this.$slots.default, () => [render$1(content)])),
            actionNode
          );
        }
      });
      const dialogProviderInjectionKey = createInjectionKey("n-dialog-provider");
      const dialogApiInjectionKey = createInjectionKey("n-dialog-api");
      const dialogReactiveListInjectionKey = createInjectionKey("n-dialog-reactive-list");
      const self$E = (vars) => {
        const { modalColor, textColor2, boxShadow3 } = vars;
        return {
          color: modalColor,
          textColor: textColor2,
          boxShadow: boxShadow3
        };
      };
      const modalLight = createTheme({
        name: "Modal",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1,
          Dialog: dialogLight$1,
          Card: cardLight$1
        },
        self: self$E
      });
      const modalLight$1 = modalLight;
      const modalDark = {
        name: "Modal",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1,
          Dialog: dialogDark$1,
          Card: cardDark$1
        },
        self: self$E
      };
      const modalDark$1 = modalDark;
      const presetProps = Object.assign(Object.assign({}, cardBaseProps), dialogProps);
      const presetPropsKeys = keysOf(presetProps);
      const NModalBodyWrapper = vue.defineComponent({
        name: "ModalBody",
        inheritAttrs: false,
        props: Object.assign(Object.assign({ show: {
          type: Boolean,
          required: true
        }, preset: String, displayDirective: {
          type: String,
          required: true
        }, trapFocus: {
          type: Boolean,
          default: true
        }, autoFocus: {
          type: Boolean,
          default: true
        }, blockScroll: Boolean }, presetProps), {
          renderMask: Function,
          // events
          onClickoutside: Function,
          onBeforeLeave: {
            type: Function,
            required: true
          },
          onAfterLeave: {
            type: Function,
            required: true
          },
          onPositiveClick: {
            type: Function,
            required: true
          },
          onNegativeClick: {
            type: Function,
            required: true
          },
          onClose: {
            type: Function,
            required: true
          },
          onAfterEnter: Function,
          onEsc: Function
        }),
        setup(props) {
          const bodyRef = vue.ref(null);
          const scrollbarRef = vue.ref(null);
          const displayedRef = vue.ref(props.show);
          const transformOriginXRef = vue.ref(null);
          const transformOriginYRef = vue.ref(null);
          vue.watch(vue.toRef(props, "show"), (value) => {
            if (value)
              displayedRef.value = true;
          });
          useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
          const NModal2 = vue.inject(modalInjectionKey);
          function styleTransformOrigin() {
            if (NModal2.transformOriginRef.value === "center") {
              return "";
            }
            const { value: transformOriginX } = transformOriginXRef;
            const { value: transformOriginY } = transformOriginYRef;
            if (transformOriginX === null || transformOriginY === null) {
              return "";
            } else if (scrollbarRef.value) {
              const scrollTop = scrollbarRef.value.containerScrollTop;
              return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
            }
            return "";
          }
          function syncTransformOrigin(el) {
            if (NModal2.transformOriginRef.value === "center") {
              return;
            }
            const mousePosition = NModal2.getMousePosition();
            if (!mousePosition) {
              return;
            }
            if (!scrollbarRef.value)
              return;
            const scrollTop = scrollbarRef.value.containerScrollTop;
            const { offsetLeft, offsetTop } = el;
            if (mousePosition) {
              const top = mousePosition.y;
              const left = mousePosition.x;
              transformOriginXRef.value = -(offsetLeft - left);
              transformOriginYRef.value = -(offsetTop - top - scrollTop);
            }
            el.style.transformOrigin = styleTransformOrigin();
          }
          function handleEnter(el) {
            void vue.nextTick(() => {
              syncTransformOrigin(el);
            });
          }
          function handleBeforeLeave(el) {
            el.style.transformOrigin = styleTransformOrigin();
            props.onBeforeLeave();
          }
          function handleAfterLeave() {
            displayedRef.value = false;
            transformOriginXRef.value = null;
            transformOriginYRef.value = null;
            props.onAfterLeave();
          }
          function handleCloseClick() {
            const { onClose } = props;
            if (onClose) {
              onClose();
            }
          }
          function handleNegativeClick() {
            props.onNegativeClick();
          }
          function handlePositiveClick() {
            props.onPositiveClick();
          }
          const childNodeRef = vue.ref(null);
          vue.watch(childNodeRef, (node) => {
            if (node) {
              void vue.nextTick(() => {
                const el = node.el;
                if (el && bodyRef.value !== el) {
                  bodyRef.value = el;
                }
              });
            }
          });
          vue.provide(modalBodyInjectionKey, bodyRef);
          vue.provide(drawerBodyInjectionKey, null);
          vue.provide(popoverBodyInjectionKey, null);
          return {
            mergedTheme: NModal2.mergedThemeRef,
            appear: NModal2.appearRef,
            isMounted: NModal2.isMountedRef,
            mergedClsPrefix: NModal2.mergedClsPrefixRef,
            bodyRef,
            scrollbarRef,
            displayed: displayedRef,
            childNodeRef,
            handlePositiveClick,
            handleNegativeClick,
            handleCloseClick,
            handleAfterLeave,
            handleBeforeLeave,
            handleEnter
          };
        },
        render() {
          const { $slots, $attrs, handleEnter, handleAfterLeave, handleBeforeLeave, preset, mergedClsPrefix } = this;
          let childNode = null;
          if (!preset) {
            childNode = getFirstSlotVNode($slots);
            if (!childNode) {
              warn$2("modal", "default slot is empty");
              return;
            }
            childNode = vue.cloneVNode(childNode);
            childNode.props = vue.mergeProps({
              class: `${mergedClsPrefix}-modal`
            }, $attrs, childNode.props || {});
          }
          return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(vue.h(
            "div",
            { role: "none", class: `${mergedClsPrefix}-modal-body-wrapper` },
            vue.h(NScrollbar, { ref: "scrollbarRef", theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, contentClass: `${mergedClsPrefix}-modal-scroll-content` }, {
              default: () => {
                var _a;
                return [
                  (_a = this.renderMask) === null || _a === void 0 ? void 0 : _a.call(this),
                  vue.h(FocusTrap, { disabled: !this.trapFocus, active: this.show, onEsc: this.onEsc, autoFocus: this.autoFocus }, {
                    default: () => {
                      var _a2;
                      return vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: (_a2 = this.appear) !== null && _a2 !== void 0 ? _a2 : this.isMounted, onEnter: handleEnter, onAfterEnter: this.onAfterEnter, onAfterLeave: handleAfterLeave, onBeforeLeave: handleBeforeLeave }, {
                        default: () => {
                          const dirs = [
                            [vue.vShow, this.show]
                          ];
                          const { onClickoutside } = this;
                          if (onClickoutside) {
                            dirs.push([
                              clickoutside$1,
                              this.onClickoutside,
                              void 0,
                              { capture: true }
                            ]);
                          }
                          return vue.withDirectives(this.preset === "confirm" || this.preset === "dialog" ? vue.h(NDialog, Object.assign({}, this.$attrs, { class: [
                            `${mergedClsPrefix}-modal`,
                            this.$attrs.class
                          ], ref: "bodyRef", theme: this.mergedTheme.peers.Dialog, themeOverrides: this.mergedTheme.peerOverrides.Dialog }, keep(this.$props, dialogPropKeys), { "aria-modal": "true" }), $slots) : this.preset === "card" ? vue.h(NCard, Object.assign({}, this.$attrs, { ref: "bodyRef", class: [
                            `${mergedClsPrefix}-modal`,
                            this.$attrs.class
                          ], theme: this.mergedTheme.peers.Card, themeOverrides: this.mergedTheme.peerOverrides.Card }, keep(this.$props, cardBasePropKeys), { "aria-modal": "true", role: "dialog" }), $slots) : this.childNodeRef = childNode, dirs);
                        }
                      });
                    }
                  })
                ];
              }
            })
          ), [
            [
              vue.vShow,
              this.displayDirective === "if" || this.displayed || this.show
            ]
          ]) : null;
        }
      });
      const style$O = c$1([cB("modal-container", `
 position: fixed;
 left: 0;
 top: 0;
 height: 0;
 width: 0;
 display: flex;
 `), cB("modal-mask", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background-color: rgba(0, 0, 0, .4);
 `, [fadeInTransition({
        enterDuration: ".25s",
        leaveDuration: ".25s",
        enterCubicBezier: "var(--n-bezier-ease-out)",
        leaveCubicBezier: "var(--n-bezier-ease-out)"
      })]), cB("modal-body-wrapper", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: visible;
 `, [cB("modal-scroll-content", `
 min-height: 100%;
 display: flex;
 position: relative;
 `)]), cB("modal", `
 position: relative;
 align-self: center;
 color: var(--n-text-color);
 margin: auto;
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition({
        duration: ".25s",
        enterScale: ".5"
      })])]);
      const modalProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { show: Boolean, unstableShowMask: {
        type: Boolean,
        default: true
      }, maskClosable: {
        type: Boolean,
        default: true
      }, preset: String, to: [String, Object], displayDirective: {
        type: String,
        default: "if"
      }, transformOrigin: {
        type: String,
        default: "mouse"
      }, zIndex: Number, autoFocus: {
        type: Boolean,
        default: true
      }, trapFocus: {
        type: Boolean,
        default: true
      }, closeOnEsc: {
        type: Boolean,
        default: true
      }, blockScroll: { type: Boolean, default: true } }), presetProps), {
        // events
        onEsc: Function,
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        onAfterEnter: Function,
        onBeforeLeave: Function,
        onAfterLeave: Function,
        onClose: Function,
        onPositiveClick: Function,
        onNegativeClick: Function,
        onMaskClick: Function,
        // private
        internalDialog: Boolean,
        internalAppear: {
          type: Boolean,
          default: void 0
        },
        // deprecated
        overlayStyle: [String, Object],
        onBeforeHide: Function,
        onAfterHide: Function,
        onHide: Function
      });
      const NModal = vue.defineComponent({
        name: "Modal",
        inheritAttrs: false,
        props: modalProps,
        setup(props) {
          const containerRef = vue.ref(null);
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Modal", "-modal", style$O, modalLight$1, props, mergedClsPrefixRef);
          const clickedRef = useClicked(64);
          const clickedPositionRef = useClickPosition();
          const isMountedRef = isMounted();
          const NDialogProvider2 = props.internalDialog ? vue.inject(dialogProviderInjectionKey, null) : null;
          const isComposingRef2 = useIsComposing();
          function doUpdateShow(show) {
            const { onUpdateShow, "onUpdate:show": _onUpdateShow, onHide } = props;
            if (onUpdateShow)
              call(onUpdateShow, show);
            if (_onUpdateShow)
              call(_onUpdateShow, show);
            if (onHide && !show)
              onHide(show);
          }
          function handleCloseClick() {
            const { onClose } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((value) => {
                if (value === false)
                  return;
                doUpdateShow(false);
              });
            } else {
              doUpdateShow(false);
            }
          }
          function handlePositiveClick() {
            const { onPositiveClick } = props;
            if (onPositiveClick) {
              void Promise.resolve(onPositiveClick()).then((value) => {
                if (value === false)
                  return;
                doUpdateShow(false);
              });
            } else {
              doUpdateShow(false);
            }
          }
          function handleNegativeClick() {
            const { onNegativeClick } = props;
            if (onNegativeClick) {
              void Promise.resolve(onNegativeClick()).then((value) => {
                if (value === false)
                  return;
                doUpdateShow(false);
              });
            } else {
              doUpdateShow(false);
            }
          }
          function handleBeforeLeave() {
            const { onBeforeLeave, onBeforeHide } = props;
            if (onBeforeLeave)
              call(onBeforeLeave);
            if (onBeforeHide)
              onBeforeHide();
          }
          function handleAfterLeave() {
            const { onAfterLeave, onAfterHide } = props;
            if (onAfterLeave)
              call(onAfterLeave);
            if (onAfterHide)
              onAfterHide();
          }
          function handleClickoutside(e) {
            var _a;
            const { onMaskClick } = props;
            if (onMaskClick) {
              onMaskClick(e);
            }
            if (props.maskClosable) {
              if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
                doUpdateShow(false);
              }
            }
          }
          function handleEsc(e) {
            var _a;
            (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
            if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
              !isComposingRef2.value && doUpdateShow(false);
            }
          }
          vue.provide(modalInjectionKey, {
            getMousePosition: () => {
              if (NDialogProvider2) {
                const { clickedRef: clickedRef2, clickPositionRef } = NDialogProvider2;
                if (clickedRef2.value && clickPositionRef.value) {
                  return clickPositionRef.value;
                }
              }
              if (clickedRef.value) {
                return clickedPositionRef.value;
              }
              return null;
            },
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            isMountedRef,
            appearRef: vue.toRef(props, "internalAppear"),
            transformOriginRef: vue.toRef(props, "transformOrigin")
          });
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { boxShadow, color, textColor } } = themeRef.value;
            return {
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-box-shadow": boxShadow,
              "--n-color": color,
              "--n-text-color": textColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("theme-class", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            isMounted: isMountedRef,
            containerRef,
            presetProps: vue.computed(() => {
              const pickedProps = keep(props, presetPropsKeys);
              return pickedProps;
            }),
            handleEsc,
            handleAfterLeave,
            handleClickoutside,
            handleBeforeLeave,
            doUpdateShow,
            handleNegativeClick,
            handlePositiveClick,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(LazyTeleport, { to: this.to, show: this.show }, {
            default: () => {
              var _a;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              const { unstableShowMask } = this;
              return vue.withDirectives(vue.h(
                "div",
                { role: "none", ref: "containerRef", class: [
                  `${mergedClsPrefix}-modal-container`,
                  this.themeClass,
                  this.namespace
                ], style: this.cssVars },
                vue.h(NModalBodyWrapper, Object.assign({ style: this.overlayStyle }, this.$attrs, { ref: "bodyWrapper", displayDirective: this.displayDirective, show: this.show, preset: this.preset, autoFocus: this.autoFocus, trapFocus: this.trapFocus, blockScroll: this.blockScroll }, this.presetProps, { onEsc: this.handleEsc, onClose: this.handleCloseClick, onNegativeClick: this.handleNegativeClick, onPositiveClick: this.handlePositiveClick, onBeforeLeave: this.handleBeforeLeave, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave, onClickoutside: unstableShowMask ? void 0 : this.handleClickoutside, renderMask: unstableShowMask ? () => {
                  var _a2;
                  return vue.h(vue.Transition, { name: "fade-in-transition", key: "mask", appear: (_a2 = this.internalAppear) !== null && _a2 !== void 0 ? _a2 : this.isMounted }, {
                    default: () => {
                      return this.show ? vue.h("div", { "aria-hidden": true, ref: "containerRef", class: `${mergedClsPrefix}-modal-mask`, onClick: this.handleClickoutside }) : null;
                    }
                  });
                } : void 0 }), this.$slots)
              ), [
                [
                  zindexable$1,
                  {
                    zIndex: this.zIndex,
                    enabled: this.show
                  }
                ]
              ]);
            }
          });
        }
      });
      const exposedDialogEnvProps = Object.assign(Object.assign({}, dialogProps), { onAfterEnter: Function, onAfterLeave: Function, transformOrigin: String, blockScroll: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, onEsc: Function, autoFocus: {
        type: Boolean,
        default: true
      }, internalStyle: [String, Object], maskClosable: {
        type: Boolean,
        default: true
      }, onPositiveClick: Function, onNegativeClick: Function, onClose: Function, onMaskClick: Function });
      const NDialogEnvironment = vue.defineComponent({
        name: "DialogEnvironment",
        props: Object.assign(Object.assign({}, exposedDialogEnvProps), {
          internalKey: {
            type: String,
            required: true
          },
          to: [String, Object],
          // private
          onInternalAfterLeave: {
            type: Function,
            required: true
          }
        }),
        setup(props) {
          const showRef = vue.ref(true);
          function handleAfterLeave() {
            const { onInternalAfterLeave, internalKey, onAfterLeave } = props;
            if (onInternalAfterLeave)
              onInternalAfterLeave(internalKey);
            if (onAfterLeave)
              onAfterLeave();
          }
          function handlePositiveClick(e) {
            const { onPositiveClick } = props;
            if (onPositiveClick) {
              void Promise.resolve(onPositiveClick(e)).then((result) => {
                if (result === false)
                  return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleNegativeClick(e) {
            const { onNegativeClick } = props;
            if (onNegativeClick) {
              void Promise.resolve(onNegativeClick(e)).then((result) => {
                if (result === false)
                  return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleCloseClick() {
            const { onClose } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((result) => {
                if (result === false)
                  return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleMaskClick(e) {
            const { onMaskClick, maskClosable } = props;
            if (onMaskClick) {
              onMaskClick(e);
              maskClosable && hide();
            }
          }
          function handleEsc() {
            const { onEsc } = props;
            if (onEsc) {
              onEsc();
            }
          }
          function hide() {
            showRef.value = false;
          }
          function handleUpdateShow(value) {
            showRef.value = value;
          }
          return {
            show: showRef,
            hide,
            handleUpdateShow,
            handleAfterLeave,
            handleCloseClick,
            handleNegativeClick,
            handlePositiveClick,
            handleMaskClick,
            handleEsc
          };
        },
        render() {
          const { handlePositiveClick, handleUpdateShow, handleNegativeClick, handleCloseClick, handleAfterLeave, handleMaskClick, handleEsc, to, maskClosable, show } = this;
          return vue.h(NModal, { show, onUpdateShow: handleUpdateShow, onMaskClick: handleMaskClick, onEsc: handleEsc, to, maskClosable, onAfterEnter: this.onAfterEnter, onAfterLeave: handleAfterLeave, closeOnEsc: this.closeOnEsc, blockScroll: this.blockScroll, autoFocus: this.autoFocus, transformOrigin: this.transformOrigin, internalAppear: true, internalDialog: true }, {
            default: () => vue.h(NDialog, Object.assign({}, keep(this.$props, dialogPropKeys), { style: this.internalStyle, onClose: handleCloseClick, onNegativeClick: handleNegativeClick, onPositiveClick: handlePositiveClick }))
          });
        }
      });
      const dialogProviderProps = {
        injectionKey: String,
        to: [String, Object]
      };
      const NDialogProvider = vue.defineComponent({
        name: "DialogProvider",
        props: dialogProviderProps,
        setup() {
          const dialogListRef = vue.ref([]);
          const dialogInstRefs = {};
          function create2(options = {}) {
            const key = createId();
            const dialogReactive = vue.reactive(Object.assign(Object.assign({}, options), { key, destroy: () => {
              dialogInstRefs[`n-dialog-${key}`].hide();
            } }));
            dialogListRef.value.push(dialogReactive);
            return dialogReactive;
          }
          const typedApi = ["info", "success", "warning", "error"].map((type2) => (options) => {
            return create2(Object.assign(Object.assign({}, options), { type: type2 }));
          });
          function handleAfterLeave(key) {
            const { value: dialogList } = dialogListRef;
            dialogList.splice(dialogList.findIndex((dialog) => dialog.key === key), 1);
          }
          function destroyAll() {
            Object.values(dialogInstRefs).forEach((dialogInstRef) => {
              dialogInstRef.hide();
            });
          }
          const api = {
            create: create2,
            destroyAll,
            info: typedApi[0],
            success: typedApi[1],
            warning: typedApi[2],
            error: typedApi[3]
          };
          vue.provide(dialogApiInjectionKey, api);
          vue.provide(dialogProviderInjectionKey, {
            clickedRef: useClicked(64),
            clickPositionRef: useClickPosition()
          });
          vue.provide(dialogReactiveListInjectionKey, dialogListRef);
          return Object.assign(Object.assign({}, api), {
            dialogList: dialogListRef,
            dialogInstRefs,
            handleAfterLeave
          });
        },
        render() {
          var _a, _b;
          return vue.h(vue.Fragment, null, [
            this.dialogList.map((dialog) => vue.h(NDialogEnvironment, omit(dialog, ["destroy", "style"], {
              internalStyle: dialog.style,
              to: this.to,
              ref: (inst) => {
                if (inst === null) {
                  delete this.dialogInstRefs[`n-dialog-${dialog.key}`];
                } else {
                  this.dialogInstRefs[`n-dialog-${dialog.key}`] = inst;
                }
              },
              internalKey: dialog.key,
              onInternalAfterLeave: this.handleAfterLeave
            }))),
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)
          ]);
        }
      });
      function useDialog() {
        const dialog = vue.inject(dialogApiInjectionKey, null);
        if (dialog === null) {
          throwError("use-dialog", "No outer <n-dialog-provider /> founded.");
        }
        return dialog;
      }
      function useDialogReactiveList() {
        const dialogReactiveList = vue.inject(dialogReactiveListInjectionKey, null);
        if (dialogReactiveList === null) {
          throwError("use-dialog-reactive-list", "No outer <n-dialog-provider /> founded.");
        }
        return dialogReactiveList;
      }
      const self$D = (vars) => {
        const { textColor1, dividerColor, fontWeightStrong } = vars;
        return {
          textColor: textColor1,
          color: dividerColor,
          fontWeight: fontWeightStrong
        };
      };
      const dividerLight = {
        name: "Divider",
        common: commonLight,
        self: self$D
      };
      const dividerLight$1 = dividerLight;
      const dividerDark = {
        name: "Divider",
        common: commonDark,
        self: self$D
      };
      const dividerDark$1 = dividerDark;
      const style$N = cB("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [cNotM("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [cNotM("no-title", `
 display: flex;
 align-items: center;
 `)]), cE("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), cM("title-position-left", [cE("line", [cM("left", {
        width: "28px"
      })])]), cM("title-position-right", [cE("line", [cM("right", {
        width: "28px"
      })])]), cM("dashed", [cE("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), cM("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), cE("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), cNotM("dashed", [cE("line", {
        backgroundColor: "var(--n-color)"
      })]), cM("dashed", [cE("line", {
        borderColor: "var(--n-color)"
      })]), cM("vertical", {
        backgroundColor: "var(--n-color)"
      })]);
      const dividerProps = Object.assign(Object.assign({}, useTheme.props), { titlePlacement: {
        type: String,
        default: "center"
      }, dashed: Boolean, vertical: Boolean });
      const NDivider = vue.defineComponent({
        name: "Divider",
        props: dividerProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Divider", "-divider", style$N, dividerLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { color, textColor, fontWeight } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": color,
              "--n-text-color": textColor,
              "--n-font-weight": fontWeight
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("divider", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { $slots, titlePlacement, vertical, dashed, cssVars, mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { role: "separator", class: [
              `${mergedClsPrefix}-divider`,
              this.themeClass,
              {
                [`${mergedClsPrefix}-divider--vertical`]: vertical,
                [`${mergedClsPrefix}-divider--no-title`]: !$slots.default,
                [`${mergedClsPrefix}-divider--dashed`]: dashed,
                [`${mergedClsPrefix}-divider--title-position-${titlePlacement}`]: $slots.default && titlePlacement
              }
            ], style: cssVars },
            !vertical ? vue.h("div", { class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--left` }) : null,
            !vertical && $slots.default ? vue.h(
              vue.Fragment,
              null,
              vue.h("div", { class: `${mergedClsPrefix}-divider__title` }, this.$slots),
              vue.h("div", { class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--right` })
            ) : null
          );
        }
      });
      const self$C = (vars) => {
        const { modalColor, textColor1, textColor2, boxShadow3, lineHeight: lineHeight2, fontWeightStrong, dividerColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadius, primaryColorHover } = vars;
        return {
          bodyPadding: "16px 24px",
          headerPadding: "16px 24px",
          footerPadding: "16px 24px",
          color: modalColor,
          textColor: textColor2,
          titleTextColor: textColor1,
          titleFontSize: "18px",
          titleFontWeight: fontWeightStrong,
          boxShadow: boxShadow3,
          lineHeight: lineHeight2,
          headerBorderBottom: `1px solid ${dividerColor}`,
          footerBorderTop: `1px solid ${dividerColor}`,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeSize: "22px",
          closeIconSize: "18px",
          closeColorHover,
          closeColorPressed,
          closeBorderRadius: borderRadius,
          resizableTriggerColorHover: primaryColorHover
        };
      };
      const drawerLight = createTheme({
        name: "Drawer",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1
        },
        self: self$C
      });
      const drawerLight$1 = drawerLight;
      const drawerDark = {
        name: "Drawer",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1
        },
        self: self$C
      };
      const drawerDark$1 = drawerDark;
      const NDrawerBodyWrapper = vue.defineComponent({
        name: "NDrawerContent",
        inheritAttrs: false,
        props: {
          blockScroll: Boolean,
          show: {
            type: Boolean,
            default: void 0
          },
          displayDirective: {
            type: String,
            required: true
          },
          placement: {
            type: String,
            required: true
          },
          contentStyle: [Object, String],
          nativeScrollbar: {
            type: Boolean,
            required: true
          },
          scrollbarProps: Object,
          trapFocus: {
            type: Boolean,
            default: true
          },
          autoFocus: {
            type: Boolean,
            default: true
          },
          showMask: {
            type: [Boolean, String],
            required: true
          },
          resizable: Boolean,
          onClickoutside: Function,
          onAfterLeave: Function,
          onAfterEnter: Function,
          onEsc: Function
        },
        setup(props) {
          const displayedRef = vue.ref(!!props.show);
          const bodyRef = vue.ref(null);
          const NDrawer = vue.inject(drawerInjectionKey);
          let startPosition = 0;
          let memoizedBodyStyleCursor = "";
          let hoverTimerId = null;
          const isHoverOnResizeTriggerRef = vue.ref(false);
          const isDraggingRef = vue.ref(false);
          const isVertical = vue.computed(() => {
            return props.placement === "top" || props.placement === "bottom";
          });
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
          const handleMousedownResizeTrigger = (e) => {
            isDraggingRef.value = true;
            startPosition = isVertical.value ? e.clientY : e.clientX;
            memoizedBodyStyleCursor = document.body.style.cursor;
            document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
            document.body.addEventListener("mousemove", handleBodyMousemove);
            document.body.addEventListener("mouseleave", handleBodyMouseleave);
            document.body.addEventListener("mouseup", handleBodyMouseup);
          };
          const handleMouseenterResizeTrigger = () => {
            if (hoverTimerId !== null) {
              window.clearTimeout(hoverTimerId);
              hoverTimerId = null;
            }
            if (isDraggingRef.value) {
              isHoverOnResizeTriggerRef.value = true;
            } else {
              hoverTimerId = window.setTimeout(() => {
                isHoverOnResizeTriggerRef.value = true;
              }, 300);
            }
          };
          const handleMouseleaveResizeTrigger = () => {
            if (hoverTimerId !== null) {
              window.clearTimeout(hoverTimerId);
              hoverTimerId = null;
            }
            isHoverOnResizeTriggerRef.value = false;
          };
          const { doUpdateHeight, doUpdateWidth } = NDrawer;
          const handleBodyMousemove = (e) => {
            var _a, _b;
            if (isDraggingRef.value) {
              if (isVertical.value) {
                let height = ((_a = bodyRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
                const increment = startPosition - e.clientY;
                height += props.placement === "bottom" ? increment : -increment;
                doUpdateHeight(height);
                startPosition = e.clientY;
              } else {
                let width = ((_b = bodyRef.value) === null || _b === void 0 ? void 0 : _b.offsetWidth) || 0;
                const increment = startPosition - e.clientX;
                width += props.placement === "right" ? increment : -increment;
                doUpdateWidth(width);
                startPosition = e.clientX;
              }
            }
          };
          const handleBodyMouseup = () => {
            if (isDraggingRef.value) {
              startPosition = 0;
              isDraggingRef.value = false;
              document.body.style.cursor = memoizedBodyStyleCursor;
              document.body.removeEventListener("mousemove", handleBodyMousemove);
              document.body.removeEventListener("mouseup", handleBodyMouseup);
              document.body.removeEventListener("mouseleave", handleBodyMouseleave);
            }
          };
          const handleBodyMouseleave = handleBodyMouseup;
          vue.watchEffect(() => {
            if (props.show)
              displayedRef.value = true;
          });
          vue.watch(() => props.show, (value) => {
            if (!value) {
              handleBodyMouseup();
            }
          });
          vue.onBeforeUnmount(() => {
            handleBodyMouseup();
          });
          const bodyDirectivesRef = vue.computed(() => {
            const { show } = props;
            const directives = [[vue.vShow, show]];
            if (!props.showMask) {
              directives.push([
                clickoutside$1,
                props.onClickoutside,
                void 0,
                { capture: true }
              ]);
            }
            return directives;
          });
          function handleAfterLeave() {
            var _a;
            displayedRef.value = false;
            (_a = props.onAfterLeave) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
          vue.provide(drawerBodyInjectionKey, bodyRef);
          vue.provide(popoverBodyInjectionKey, null);
          vue.provide(modalBodyInjectionKey, null);
          return {
            bodyRef,
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: NDrawer.mergedClsPrefixRef,
            isMounted: NDrawer.isMountedRef,
            mergedTheme: NDrawer.mergedThemeRef,
            displayed: displayedRef,
            transitionName: vue.computed(() => {
              return {
                right: "slide-in-from-right-transition",
                left: "slide-in-from-left-transition",
                top: "slide-in-from-top-transition",
                bottom: "slide-in-from-bottom-transition"
              }[props.placement];
            }),
            handleAfterLeave,
            bodyDirectives: bodyDirectivesRef,
            handleMousedownResizeTrigger,
            handleMouseenterResizeTrigger,
            handleMouseleaveResizeTrigger,
            isDragging: isDraggingRef,
            isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
          };
        },
        render() {
          const { $slots, mergedClsPrefix } = this;
          return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(
            /* Keep the wrapper dom. Make sure the drawer has a host.
              Nor the detached content will disappear without transition */
            vue.h(
              "div",
              { role: "none" },
              vue.h(FocusTrap, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, {
                default: () => vue.h(vue.Transition, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, {
                  default: () => vue.withDirectives(vue.h("div", vue.mergeProps(this.$attrs, {
                    role: "dialog",
                    ref: "bodyRef",
                    "aria-modal": "true",
                    class: [
                      `${mergedClsPrefix}-drawer`,
                      this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                      `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                      /**
                       * When the mouse is pressed to resize the drawer,
                       * disable text selection
                       */
                      this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                      this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
                    ]
                  }), [
                    this.resizable ? vue.h("div", { class: [
                      `${mergedClsPrefix}-drawer__resize-trigger`,
                      (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`
                    ], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null,
                    this.nativeScrollbar ? vue.h("div", { class: `${mergedClsPrefix}-drawer-content-wrapper`, style: this.contentStyle, role: "none" }, $slots) : vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: `${mergedClsPrefix}-drawer-content-wrapper`, theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), $slots)
                  ]), this.bodyDirectives)
                })
              })
            ),
            [
              [
                vue.vShow,
                this.displayDirective === "if" || this.displayed || this.show
              ]
            ]
          ) : null;
        }
      });
      const { cubicBezierEaseIn: cubicBezierEaseIn$3, cubicBezierEaseOut: cubicBezierEaseOut$3 } = commonVariables$m;
      function slideInFromRightTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-right" } = {}) {
        return [
          c$1(`&.${name}-transition-leave-active`, {
            transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
            transition: `transform ${duration} ${cubicBezierEaseOut$3}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
            transform: "translateX(0)"
          }),
          c$1(`&.${name}-transition-enter-from`, {
            transform: "translateX(100%)"
          }),
          c$1(`&.${name}-transition-leave-from`, {
            transform: "translateX(0)"
          }),
          c$1(`&.${name}-transition-leave-to`, {
            transform: "translateX(100%)"
          })
        ];
      }
      const { cubicBezierEaseIn: cubicBezierEaseIn$2, cubicBezierEaseOut: cubicBezierEaseOut$2 } = commonVariables$m;
      function slideInFromLeftTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-left" } = {}) {
        return [
          c$1(`&.${name}-transition-leave-active`, {
            transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
            transition: `transform ${duration} ${cubicBezierEaseOut$2}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
            transform: "translateX(0)"
          }),
          c$1(`&.${name}-transition-enter-from`, {
            transform: "translateX(-100%)"
          }),
          c$1(`&.${name}-transition-leave-from`, {
            transform: "translateX(0)"
          }),
          c$1(`&.${name}-transition-leave-to`, {
            transform: "translateX(-100%)"
          })
        ];
      }
      const { cubicBezierEaseIn: cubicBezierEaseIn$1, cubicBezierEaseOut: cubicBezierEaseOut$1 } = commonVariables$m;
      function slideInFromTopTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-top" } = {}) {
        return [
          c$1(`&.${name}-transition-leave-active`, {
            transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
            transition: `transform ${duration} ${cubicBezierEaseOut$1}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
            transform: "translateY(0)"
          }),
          c$1(`&.${name}-transition-enter-from`, {
            transform: "translateY(-100%)"
          }),
          c$1(`&.${name}-transition-leave-from`, {
            transform: "translateY(0)"
          }),
          c$1(`&.${name}-transition-leave-to`, {
            transform: "translateY(-100%)"
          })
        ];
      }
      const { cubicBezierEaseIn, cubicBezierEaseOut } = commonVariables$m;
      function slideInFromBottomTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-bottom" } = {}) {
        return [
          c$1(`&.${name}-transition-leave-active`, {
            transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
            transition: `transform ${duration} ${cubicBezierEaseOut}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
            transform: "translateY(0)"
          }),
          c$1(`&.${name}-transition-enter-from`, {
            transform: "translateY(100%)"
          }),
          c$1(`&.${name}-transition-leave-from`, {
            transform: "translateY(0)"
          }),
          c$1(`&.${name}-transition-leave-to`, {
            transform: "translateY(100%)"
          })
        ];
      }
      const style$M = c$1([cB("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), cM("native-scrollbar", [cB("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), cE("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB("drawer-content-wrapper", `
 box-sizing: border-box;
 `), cB("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM("native-scrollbar", [cB("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), cB("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), cB("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 `, [cE("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 `, [cE("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 `, [cE("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 `, [cE("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c$1("body", [c$1(">", [cB("drawer-container", {
        position: "fixed"
      })])]), cB("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c$1("> *", {
        pointerEvents: "all"
      })]), cB("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
        enterDuration: "0.2s",
        leaveDuration: "0.2s",
        enterCubicBezier: "var(--n-bezier-in)",
        leaveCubicBezier: "var(--n-bezier-out)"
      })])]);
      const drawerProps = Object.assign(Object.assign({}, useTheme.props), {
        show: Boolean,
        width: [Number, String],
        height: [Number, String],
        placement: {
          type: String,
          default: "right"
        },
        maskClosable: {
          type: Boolean,
          default: true
        },
        showMask: {
          type: [Boolean, String],
          default: true
        },
        to: [String, Object],
        displayDirective: {
          type: String,
          default: "if"
        },
        nativeScrollbar: {
          type: Boolean,
          default: true
        },
        zIndex: Number,
        onMaskClick: Function,
        scrollbarProps: Object,
        contentStyle: [Object, String],
        trapFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        autoFocus: {
          type: Boolean,
          default: true
        },
        closeOnEsc: {
          type: Boolean,
          default: true
        },
        blockScroll: {
          type: Boolean,
          default: true
        },
        resizable: Boolean,
        defaultWidth: {
          type: [Number, String],
          default: 251
        },
        defaultHeight: {
          type: [Number, String],
          default: 251
        },
        onUpdateWidth: [Function, Array],
        onUpdateHeight: [Function, Array],
        "onUpdate:width": [Function, Array],
        "onUpdate:height": [Function, Array],
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        onAfterEnter: Function,
        onAfterLeave: Function,
        /** @deprecated */
        drawerStyle: [String, Object],
        drawerClass: String,
        target: null,
        onShow: Function,
        onHide: Function
      });
      const Drawer = vue.defineComponent({
        name: "Drawer",
        inheritAttrs: false,
        props: drawerProps,
        setup(props) {
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const isMountedRef = isMounted();
          const themeRef = useTheme("Drawer", "-drawer", style$M, drawerLight$1, props, mergedClsPrefixRef);
          const uncontrolledWidthRef = vue.ref(props.defaultWidth);
          const uncontrolledHeightRef = vue.ref(props.defaultHeight);
          const mergedWidthRef = useMergedState(vue.toRef(props, "width"), uncontrolledWidthRef);
          const mergedHeightRef = useMergedState(vue.toRef(props, "height"), uncontrolledHeightRef);
          const styleWidthRef = vue.computed(() => {
            const { placement } = props;
            if (placement === "top" || placement === "bottom")
              return "";
            return formatLength(mergedWidthRef.value);
          });
          const styleHeightRef = vue.computed(() => {
            const { placement } = props;
            if (placement === "left" || placement === "right")
              return "";
            return formatLength(mergedHeightRef.value);
          });
          const doUpdateWidth = (value) => {
            const { onUpdateWidth, "onUpdate:width": _onUpdateWidth } = props;
            if (onUpdateWidth)
              call(onUpdateWidth, value);
            if (_onUpdateWidth)
              call(_onUpdateWidth, value);
            uncontrolledWidthRef.value = value;
          };
          const doUpdateHeight = (value) => {
            const { onUpdateHeight, "onUpdate:width": _onUpdateHeight } = props;
            if (onUpdateHeight)
              call(onUpdateHeight, value);
            if (_onUpdateHeight)
              call(_onUpdateHeight, value);
            uncontrolledHeightRef.value = value;
          };
          const mergedBodyStyleRef = vue.computed(() => {
            return [
              {
                width: styleWidthRef.value,
                height: styleHeightRef.value
              },
              props.drawerStyle || ""
            ];
          });
          function handleMaskClick(e) {
            const { onMaskClick, maskClosable } = props;
            if (maskClosable) {
              doUpdateShow(false);
            }
            if (onMaskClick)
              onMaskClick(e);
          }
          const isComposingRef2 = useIsComposing();
          function handleEsc(e) {
            var _a;
            (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
            if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
              !isComposingRef2.value && doUpdateShow(false);
            }
          }
          function doUpdateShow(show) {
            const { onHide, onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow)
              call(onUpdateShow, show);
            if (_onUpdateShow)
              call(_onUpdateShow, show);
            if (onHide && !show)
              call(onHide, show);
          }
          vue.provide(drawerInjectionKey, {
            isMountedRef,
            mergedThemeRef: themeRef,
            mergedClsPrefixRef,
            doUpdateShow,
            doUpdateHeight,
            doUpdateWidth
          });
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseIn: cubicBezierEaseIn2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { color, textColor, boxShadow, lineHeight: lineHeight2, headerPadding, footerPadding, bodyPadding, titleFontSize, titleTextColor, titleFontWeight, headerBorderBottom, footerBorderTop, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeIconSize, closeSize, closeBorderRadius, resizableTriggerColorHover } } = themeRef.value;
            return {
              "--n-line-height": lineHeight2,
              "--n-color": color,
              "--n-text-color": textColor,
              "--n-box-shadow": boxShadow,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-bezier-out": cubicBezierEaseOut2,
              "--n-bezier-in": cubicBezierEaseIn2,
              "--n-header-padding": headerPadding,
              "--n-body-padding": bodyPadding,
              "--n-footer-padding": footerPadding,
              "--n-title-text-color": titleTextColor,
              "--n-title-font-size": titleFontSize,
              "--n-title-font-weight": titleFontWeight,
              "--n-header-border-bottom": headerBorderBottom,
              "--n-footer-border-top": footerBorderTop,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-size": closeSize,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius,
              "--n-resize-trigger-color-hover": resizableTriggerColorHover
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            mergedBodyStyle: mergedBodyStyleRef,
            handleMaskClick,
            handleEsc,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            isMounted: isMountedRef
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(LazyTeleport, { to: this.to, show: this.show }, {
            default: () => {
              var _a;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return vue.withDirectives(vue.h(
                "div",
                { class: [
                  `${mergedClsPrefix}-drawer-container`,
                  this.namespace,
                  this.themeClass
                ], style: this.cssVars, role: "none" },
                this.showMask ? vue.h(vue.Transition, { name: "fade-in-transition", appear: this.isMounted }, {
                  default: () => this.show ? vue.h("div", { "aria-hidden": true, class: [
                    `${mergedClsPrefix}-drawer-mask`,
                    this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`
                  ], onClick: this.handleMaskClick }) : null
                }) : null,
                vue.h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleMaskClick }), this.$slots)
              ), [[zindexable$1, { zIndex: this.zIndex, enabled: this.show }]]);
            }
          });
        }
      });
      const drawerContentProps = {
        title: {
          type: String
        },
        headerStyle: [Object, String],
        footerStyle: [Object, String],
        bodyStyle: [Object, String],
        bodyContentStyle: [Object, String],
        nativeScrollbar: { type: Boolean, default: true },
        scrollbarProps: Object,
        closable: Boolean
      };
      const DrawerContent = vue.defineComponent({
        name: "DrawerContent",
        props: drawerContentProps,
        setup() {
          const NDrawer = vue.inject(drawerInjectionKey, null);
          if (!NDrawer) {
            throwError("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
          }
          const { doUpdateShow } = NDrawer;
          function handleCloseClick() {
            doUpdateShow(false);
          }
          return {
            handleCloseClick,
            mergedTheme: NDrawer.mergedThemeRef,
            mergedClsPrefix: NDrawer.mergedClsPrefixRef
          };
        },
        render() {
          const { title, mergedClsPrefix, nativeScrollbar, mergedTheme, bodyStyle, bodyContentStyle, headerStyle, footerStyle, scrollbarProps: scrollbarProps2, closable, $slots } = this;
          return vue.h(
            "div",
            { role: "none", class: [
              `${mergedClsPrefix}-drawer-content`,
              nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`
            ] },
            $slots.header || title || closable ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-drawer-header`, style: headerStyle, role: "none" },
              vue.h("div", { class: `${mergedClsPrefix}-drawer-header__main`, role: "heading", "aria-level": "1" }, $slots.header !== void 0 ? $slots.header() : title),
              closable && vue.h(NBaseClose, { onClick: this.handleCloseClick, clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-drawer-header__close`, absolute: true })
            ) : null,
            nativeScrollbar ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-drawer-body`, style: bodyStyle, role: "none" },
              vue.h("div", { class: `${mergedClsPrefix}-drawer-body-content-wrapper`, style: bodyContentStyle, role: "none" }, $slots)
            ) : vue.h(NScrollbar, Object.assign({ themeOverrides: mergedTheme.peerOverrides.Scrollbar, theme: mergedTheme.peers.Scrollbar }, scrollbarProps2, { class: `${mergedClsPrefix}-drawer-body`, contentClass: `${mergedClsPrefix}-drawer-body-content-wrapper`, contentStyle: bodyContentStyle }), $slots),
            $slots.footer ? vue.h("div", { class: `${mergedClsPrefix}-drawer-footer`, style: footerStyle, role: "none" }, $slots.footer()) : null
          );
        }
      });
      const commonVariables$6 = {
        actionMargin: "0 0 0 20px",
        actionMarginRtl: "0 20px 0 0"
      };
      const dynamicInputDark = {
        name: "DynamicInput",
        common: commonDark,
        peers: {
          Input: inputDark$1,
          Button: buttonDark$1
        },
        self() {
          return commonVariables$6;
        }
      };
      const dynamicInputDark$1 = dynamicInputDark;
      const self$B = () => {
        return commonVariables$6;
      };
      const dynamicInputLight = createTheme({
        name: "DynamicInput",
        common: commonLight,
        peers: {
          Input: inputLight$1,
          Button: buttonLight$1
        },
        self: self$B
      });
      const dynamicInputLight$1 = dynamicInputLight;
      const dynamicInputInjectionKey = createInjectionKey("n-dynamic-input");
      const NDynamicInputInputPreset = vue.defineComponent({
        name: "DynamicInputInputPreset",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          value: {
            type: String,
            default: ""
          },
          disabled: Boolean,
          parentPath: String,
          path: String,
          onUpdateValue: {
            type: Function,
            required: true
          }
        },
        setup() {
          const {
            mergedThemeRef,
            placeholderRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(dynamicInputInjectionKey);
          return {
            mergedTheme: mergedThemeRef,
            placeholder: placeholderRef
          };
        },
        render() {
          const { mergedTheme, placeholder, value, clsPrefix, onUpdateValue, disabled } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-dynamic-input-preset-input` },
            vue.h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value, placeholder, onUpdateValue, disabled })
          );
        }
      });
      const NDynamicInputPairPreset = vue.defineComponent({
        name: "DynamicInputPairPreset",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          value: {
            type: Object,
            default: () => ({
              key: "",
              value: ""
            })
          },
          disabled: Boolean,
          parentPath: String,
          path: String,
          onUpdateValue: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const { mergedThemeRef, keyPlaceholderRef, valuePlaceholderRef } = vue.inject(dynamicInputInjectionKey);
          return {
            mergedTheme: mergedThemeRef,
            keyPlaceholder: keyPlaceholderRef,
            valuePlaceholder: valuePlaceholderRef,
            handleKeyInput(key) {
              props.onUpdateValue({
                key,
                value: props.value.value
              });
            },
            handleValueInput(value) {
              props.onUpdateValue({
                key: props.value.key,
                value
              });
            }
          };
        },
        render() {
          const { mergedTheme, keyPlaceholder, valuePlaceholder, value, clsPrefix, disabled } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-dynamic-input-preset-pair` },
            vue.h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.key, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: keyPlaceholder, onUpdateValue: this.handleKeyInput, disabled }),
            vue.h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.value, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: valuePlaceholder, onUpdateValue: this.handleValueInput, disabled })
          );
        }
      });
      const style$L = cB("dynamic-input", {
        width: "100%"
      }, [cB("dynamic-input-item", `
 margin-bottom: 10px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB("dynamic-input-preset-input", {
        flex: 1,
        alignItems: "center"
      }), cB("dynamic-input-preset-pair", `
 flex: 1;
 display: flex;
 align-items: center;
 `, [cB("dynamic-input-pair-input", [c$1("&:first-child", {
        "margin-right": "12px"
      })])]), cE("action", `
 align-self: flex-start;
 display: flex;
 justify-content: flex-end;
 flex-shrink: 0;
 flex-grow: 0;
 margin: var(--action-margin);
 `, [cM("icon", {
        cursor: "pointer"
      })]), c$1("&:last-child", {
        marginBottom: 0
      })]), cB("form-item", `
 padding-top: 0 !important;
 margin-right: 0 !important;
 `, [cB("form-item-blank", {
        paddingTop: "0 !important"
      })])]);
      const globalDataKeyMap = /* @__PURE__ */ new WeakMap();
      const dynamicInputProps = Object.assign(Object.assign({}, useTheme.props), {
        max: Number,
        min: {
          type: Number,
          default: 0
        },
        value: Array,
        // TODO: make it robust for different types
        defaultValue: {
          type: Array,
          default: () => []
        },
        preset: {
          type: String,
          default: "input"
        },
        keyField: String,
        itemStyle: [String, Object],
        // for preset pair
        keyPlaceholder: {
          type: String,
          default: ""
        },
        valuePlaceholder: {
          type: String,
          default: ""
        },
        // for preset input
        placeholder: {
          type: String,
          default: ""
        },
        disabled: Boolean,
        showSortButton: Boolean,
        createButtonProps: Object,
        onCreate: Function,
        onRemove: Function,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        // deprecated
        onClear: Function,
        onInput: [Function, Array]
      });
      const DynamicInput = vue.defineComponent({
        name: "DynamicInput",
        props: dynamicInputProps,
        setup(props, { slots }) {
          const { mergedComponentPropsRef, mergedClsPrefixRef, mergedRtlRef, inlineThemeDisabled } = useConfig();
          const NFormItem2 = vue.inject(formItemInjectionKey, null);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const themeRef = useTheme("DynamicInput", "-dynamic-input", style$L, dynamicInputLight$1, props, mergedClsPrefixRef);
          const insertionDisabledRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue)) {
              const { max } = props;
              return max !== void 0 && mergedValue.length >= max;
            }
            return false;
          });
          const removeDisabledRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue))
              return mergedValue.length <= props.min;
            return true;
          });
          const buttonSizeRef = vue.computed(() => {
            var _a, _b;
            return (_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DynamicInput) === null || _b === void 0 ? void 0 : _b.buttonSize;
          });
          function doUpdateValue(value) {
            const { onInput, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
            if (onInput)
              call(onInput, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            if (onUpdateValue)
              call(onUpdateValue, value);
            uncontrolledValueRef.value = value;
          }
          function ensureKey(value, index) {
            if (value === void 0 || value === null)
              return index;
            if (typeof value !== "object")
              return index;
            const rawValue = vue.isProxy(value) ? vue.toRaw(value) : value;
            let key = globalDataKeyMap.get(rawValue);
            if (key === void 0) {
              globalDataKeyMap.set(rawValue, key = createId());
            }
            return key;
          }
          function handleValueChange(index, value) {
            const { value: mergedValue } = mergedValueRef;
            const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
            const originalItem = newValue[index];
            newValue[index] = value;
            if (originalItem && value && typeof originalItem === "object" && typeof value === "object") {
              const rawOriginal = vue.isProxy(originalItem) ? vue.toRaw(originalItem) : originalItem;
              const rawNew = vue.isProxy(value) ? vue.toRaw(value) : value;
              const originalKey = globalDataKeyMap.get(rawOriginal);
              if (originalKey !== void 0) {
                globalDataKeyMap.set(rawNew, originalKey);
              }
            }
            doUpdateValue(newValue);
          }
          function handleCreateClick() {
            createItem(-1);
          }
          function createItem(index) {
            const { value: mergedValue } = mergedValueRef;
            const { onCreate } = props;
            const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
            if (onCreate) {
              newValue.splice(index + 1, 0, onCreate(index + 1));
              doUpdateValue(newValue);
            } else if (slots.default) {
              newValue.splice(index + 1, 0, null);
              doUpdateValue(newValue);
            } else {
              switch (props.preset) {
                case "input":
                  newValue.splice(index + 1, 0, "");
                  doUpdateValue(newValue);
                  break;
                case "pair":
                  newValue.splice(index + 1, 0, { key: "", value: "" });
                  doUpdateValue(newValue);
                  break;
              }
            }
          }
          function remove(index) {
            const { value: mergedValue } = mergedValueRef;
            if (!Array.isArray(mergedValue))
              return;
            const { min } = props;
            if (mergedValue.length <= min)
              return;
            const { onRemove } = props;
            if (onRemove) {
              onRemove(index);
            }
            const newValue = Array.from(mergedValue);
            newValue.splice(index, 1);
            doUpdateValue(newValue);
          }
          function swap(array2, currentIndex, targetIndex) {
            if (currentIndex < 0 || targetIndex < 0 || currentIndex >= array2.length || targetIndex >= array2.length) {
              return;
            }
            if (currentIndex === targetIndex)
              return;
            const currentItem = array2[currentIndex];
            array2[currentIndex] = array2[targetIndex];
            array2[targetIndex] = currentItem;
          }
          function move2(type2, index) {
            const { value: mergedValue } = mergedValueRef;
            if (!Array.isArray(mergedValue))
              return;
            const newValue = Array.from(mergedValue);
            if (type2 === "up") {
              swap(newValue, index, index - 1);
            }
            if (type2 === "down") {
              swap(newValue, index, index + 1);
            }
            doUpdateValue(newValue);
          }
          vue.provide(dynamicInputInjectionKey, {
            mergedThemeRef: themeRef,
            keyPlaceholderRef: vue.toRef(props, "keyPlaceholder"),
            valuePlaceholderRef: vue.toRef(props, "valuePlaceholder"),
            placeholderRef: vue.toRef(props, "placeholder")
          });
          const rtlEnabledRef = useRtl("DynamicInput", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { self: { actionMargin, actionMarginRtl } } = themeRef.value;
            return {
              "--action-margin": actionMargin,
              "--action-margin-rtl": actionMarginRtl
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-input", void 0, cssVarsRef, props) : void 0;
          return {
            locale: useLocale("DynamicInput").localeRef,
            rtlEnabled: rtlEnabledRef,
            buttonSize: buttonSizeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            NFormItem: NFormItem2,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            insertionDisabled: insertionDisabledRef,
            removeDisabled: removeDisabledRef,
            handleCreateClick,
            ensureKey,
            handleValueChange,
            remove,
            move: move2,
            createItem,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { $slots, buttonSize, mergedClsPrefix, mergedValue, locale: locale2, mergedTheme, keyField, itemStyle, preset, showSortButton, NFormItem: NFormItem2, ensureKey, handleValueChange, remove, createItem, move: move2, onRender, disabled } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", { class: [
            `${mergedClsPrefix}-dynamic-input`,
            this.rtlEnabled && `${mergedClsPrefix}-dynamic-input--rtl`,
            this.themeClass
          ], style: this.cssVars }, !Array.isArray(mergedValue) || mergedValue.length === 0 ? vue.h(NButton, Object.assign({ block: true, ghost: true, dashed: true, size: buttonSize }, this.createButtonProps, { disabled: this.insertionDisabled || disabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleCreateClick }), {
            default: () => resolveSlot($slots["create-button-default"], () => [
              locale2.create
            ]),
            icon: () => resolveSlot($slots["create-button-icon"], () => [
              vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(AddIcon, null) })
            ])
          }) : mergedValue.map((_, index) => vue.h(
            "div",
            { key: keyField ? _[keyField] : ensureKey(_, index), "data-key": keyField ? _[keyField] : ensureKey(_, index), class: `${mergedClsPrefix}-dynamic-input-item`, style: itemStyle },
            resolveSlotWithProps($slots.default, {
              value: mergedValue[index],
              index
            }, () => {
              return [
                preset === "input" ? vue.h(NDynamicInputInputPreset, { disabled, clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem2 ? NFormItem2.path.value : void 0, path: (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.path.value) ? `${NFormItem2.path.value}[${index}]` : void 0, onUpdateValue: (v) => {
                  handleValueChange(index, v);
                } }) : preset === "pair" ? vue.h(NDynamicInputPairPreset, { disabled, clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem2 ? NFormItem2.path.value : void 0, path: (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.path.value) ? `${NFormItem2.path.value}[${index}]` : void 0, onUpdateValue: (v) => {
                  handleValueChange(index, v);
                } }) : null
              ];
            }),
            resolveSlotWithProps($slots.action, {
              value: mergedValue[index],
              index,
              create: createItem,
              remove,
              move: move2
            }, () => [
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-dynamic-input-item__action` },
                vue.h(NButtonGroup, { size: buttonSize }, {
                  default: () => [
                    vue.h(NButton, { disabled: this.removeDisabled || disabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, circle: true, onClick: () => {
                      remove(index);
                    } }, {
                      icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(RemoveIcon, null) })
                    }),
                    vue.h(NButton, { disabled: this.insertionDisabled || disabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => {
                      createItem(index);
                    } }, {
                      icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(AddIcon, null) })
                    }),
                    showSortButton ? vue.h(NButton, { disabled: index === 0 || disabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => {
                      move2("up", index);
                    } }, {
                      icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                        default: () => vue.h(ArrowUpIcon, null)
                      })
                    }) : null,
                    showSortButton ? vue.h(NButton, { disabled: index === mergedValue.length - 1 || disabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => {
                      move2("down", index);
                    } }, {
                      icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(ArrowDownIcon, null) })
                    }) : null
                  ]
                })
              )
            ])
          )));
        }
      });
      const commonVars$4 = {
        gapSmall: "4px 8px",
        gapMedium: "8px 12px",
        gapLarge: "12px 16px"
      };
      const spaceDark = {
        name: "Space",
        self() {
          return commonVars$4;
        }
      };
      const spaceDark$1 = spaceDark;
      const self$A = () => {
        return commonVars$4;
      };
      const spaceLight = {
        name: "Space",
        self: self$A
      };
      const spaceLight$1 = spaceLight;
      let supportFlexGap;
      const ensureSupportFlexGap = () => {
        if (!isBrowser$2)
          return true;
        if (supportFlexGap === void 0) {
          const flex = document.createElement("div");
          flex.style.display = "flex";
          flex.style.flexDirection = "column";
          flex.style.rowGap = "1px";
          flex.appendChild(document.createElement("div"));
          flex.appendChild(document.createElement("div"));
          document.body.appendChild(flex);
          const isSupported = flex.scrollHeight === 1;
          document.body.removeChild(flex);
          return supportFlexGap = isSupported;
        }
        return supportFlexGap;
      };
      const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
        align: String,
        justify: {
          type: String,
          default: "start"
        },
        inline: Boolean,
        vertical: Boolean,
        size: {
          type: [String, Number, Array],
          default: "medium"
        },
        wrapItem: {
          type: Boolean,
          default: true
        },
        itemStyle: [String, Object],
        wrap: {
          type: Boolean,
          default: true
        },
        // internal
        internalUseGap: {
          type: Boolean,
          default: void 0
        }
      });
      const NSpace = vue.defineComponent({
        name: "Space",
        props: spaceProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Space", "-space", void 0, spaceLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
          return {
            useGap: ensureSupportFlexGap(),
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            margin: vue.computed(() => {
              const { size: size2 } = props;
              if (Array.isArray(size2)) {
                return {
                  horizontal: size2[0],
                  vertical: size2[1]
                };
              }
              if (typeof size2 === "number") {
                return {
                  horizontal: size2,
                  vertical: size2
                };
              }
              const { self: { [createKey("gap", size2)]: gap } } = themeRef.value;
              const { row, col } = getGap(gap);
              return {
                horizontal: depx(col),
                vertical: depx(row)
              };
            })
          };
        },
        render() {
          const { vertical, align, inline, justify, itemStyle, margin, wrap, mergedClsPrefix, rtlEnabled, useGap, wrapItem, internalUseGap } = this;
          const children = flatten$3(getSlot$1(this));
          if (!children.length)
            return null;
          const horizontalMargin = `${margin.horizontal}px`;
          const semiHorizontalMargin = `${margin.horizontal / 2}px`;
          const verticalMargin = `${margin.vertical}px`;
          const semiVerticalMargin = `${margin.vertical / 2}px`;
          const lastIndex = children.length - 1;
          const isJustifySpace = justify.startsWith("space-");
          return vue.h("div", { role: "none", class: [
            `${mergedClsPrefix}-space`,
            rtlEnabled && `${mergedClsPrefix}-space--rtl`
          ], style: {
            display: inline ? "inline-flex" : "flex",
            flexDirection: vertical ? "column" : "row",
            justifyContent: ["start", "end"].includes(justify) ? "flex-" + justify : justify,
            flexWrap: !wrap || vertical ? "nowrap" : "wrap",
            marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            alignItems: align,
            gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
          } }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => vue.h("div", { role: "none", style: [
            itemStyle,
            {
              maxWidth: "100%"
            },
            useGap ? "" : vertical ? {
              marginBottom: index !== lastIndex ? verticalMargin : ""
            } : rtlEnabled ? {
              marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
              marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
              paddingTop: semiVerticalMargin,
              paddingBottom: semiVerticalMargin
            } : {
              marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
              marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
              paddingTop: semiVerticalMargin,
              paddingBottom: semiVerticalMargin
            }
          ] }, child)));
        }
      });
      const dynamicTagsDark = {
        name: "DynamicTags",
        common: commonDark,
        peers: {
          Input: inputDark$1,
          Button: buttonDark$1,
          Tag: tagDark$1,
          Space: spaceDark$1
        },
        self() {
          return {
            inputWidth: "64px"
          };
        }
      };
      const dynamicTagsDark$1 = dynamicTagsDark;
      const dynamicTagsLight = createTheme({
        name: "DynamicTags",
        common: commonLight,
        peers: {
          Input: inputLight$1,
          Button: buttonLight$1,
          Tag: tagLight$1,
          Space: spaceLight$1
        },
        self() {
          return {
            inputWidth: "64px"
          };
        }
      });
      const dynamicTagsLight$1 = dynamicTagsLight;
      const style$K = cB("dynamic-tags", [cB("input", {
        minWidth: "var(--n-input-width)"
      })]);
      const dynamicTagsProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), {
        size: {
          type: String,
          default: "medium"
        },
        closable: {
          type: Boolean,
          default: true
        },
        defaultValue: {
          type: Array,
          default: () => []
        },
        value: Array,
        inputStyle: [String, Object],
        inputProps: Object,
        max: Number,
        tagStyle: [String, Object],
        renderTag: Function,
        onCreate: {
          type: Function,
          default: (label) => label
        },
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        // deprecated
        onChange: [Function, Array]
      });
      const DynamicTags = vue.defineComponent({
        name: "DynamicTags",
        props: dynamicTagsProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const { localeRef } = useLocale("DynamicTags");
          const formItem = useFormItem(props);
          const { mergedDisabledRef } = formItem;
          const inputValueRef = vue.ref("");
          const showInputRef = vue.ref(false);
          const inputForceFocusedRef = vue.ref(true);
          const inputInstRef = vue.ref(null);
          const themeRef = useTheme("DynamicTags", "-dynamic-tags", style$K, dynamicTagsLight$1, props, mergedClsPrefixRef);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const localizedAddRef = vue.computed(() => {
            return localeRef.value.add;
          });
          const inputSizeRef = vue.computed(() => {
            return smallerSize(props.size);
          });
          const triggerDisabledRef = vue.computed(() => {
            return mergedDisabledRef.value || !!props.max && mergedValueRef.value.length >= props.max;
          });
          function doChange(value) {
            const { onChange, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onChange)
              call(onChange, value);
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function handleCloseClick(index) {
            const tags = mergedValueRef.value.slice(0);
            tags.splice(index, 1);
            doChange(tags);
          }
          function handleInputKeyUp(e) {
            switch (e.key) {
              case "Enter":
                handleInputConfirm();
            }
          }
          function handleInputConfirm(externalValue) {
            const nextValue = externalValue !== null && externalValue !== void 0 ? externalValue : inputValueRef.value;
            if (nextValue) {
              const tags = mergedValueRef.value.slice(0);
              tags.push(props.onCreate(nextValue));
              doChange(tags);
            }
            showInputRef.value = false;
            inputForceFocusedRef.value = true;
            inputValueRef.value = "";
          }
          function handleInputBlur() {
            handleInputConfirm();
          }
          function handleAddClick() {
            showInputRef.value = true;
            void vue.nextTick(() => {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              inputForceFocusedRef.value = false;
            });
          }
          const cssVarsRef = vue.computed(() => {
            const { self: { inputWidth } } = themeRef.value;
            return {
              "--n-input-width": inputWidth
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-tags", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            inputInstRef,
            localizedAdd: localizedAddRef,
            inputSize: inputSizeRef,
            inputValue: inputValueRef,
            showInput: showInputRef,
            inputForceFocused: inputForceFocusedRef,
            mergedValue: mergedValueRef,
            mergedDisabled: mergedDisabledRef,
            triggerDisabled: triggerDisabledRef,
            handleInputKeyUp,
            handleAddClick,
            handleInputBlur,
            handleCloseClick,
            handleInputConfirm,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedTheme, cssVars, mergedClsPrefix, onRender, renderTag } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(NSpace, { class: [`${mergedClsPrefix}-dynamic-tags`, this.themeClass], size: "small", style: cssVars, theme: mergedTheme.peers.Space, themeOverrides: mergedTheme.peerOverrides.Space, itemStyle: "display: flex;" }, {
            default: () => {
              const { mergedTheme: mergedTheme2, tagStyle, type: type2, round: round2, size: size2, color, closable, mergedDisabled, showInput, inputValue, inputStyle, inputSize, inputForceFocused, triggerDisabled, handleInputKeyUp, handleInputBlur, handleAddClick, handleCloseClick, handleInputConfirm, $slots } = this;
              return this.mergedValue.map((tag, index) => renderTag ? renderTag(tag, index) : vue.h(NTag, { key: index, theme: mergedTheme2.peers.Tag, themeOverrides: mergedTheme2.peerOverrides.Tag, style: tagStyle, type: type2, round: round2, size: size2, color, closable, disabled: mergedDisabled, onClose: () => {
                handleCloseClick(index);
              } }, {
                default: () => typeof tag === "string" ? tag : tag.label
              })).concat(showInput ? $slots.input ? $slots.input({
                submit: handleInputConfirm,
                deactivate: handleInputBlur
              }) : vue.h(NInput, Object.assign({ placeholder: "", size: inputSize, style: inputStyle, autosize: true }, this.inputProps, { ref: "inputInstRef", value: inputValue, onUpdateValue: (v) => {
                this.inputValue = v;
              }, theme: mergedTheme2.peers.Input, themeOverrides: mergedTheme2.peerOverrides.Input, onKeyup: handleInputKeyUp, onBlur: handleInputBlur, internalForceFocus: inputForceFocused })) : $slots.trigger ? $slots.trigger({
                activate: handleAddClick,
                disabled: triggerDisabled
              }) : vue.h(NButton, { dashed: true, disabled: triggerDisabled, theme: mergedTheme2.peers.Button, themeOverrides: mergedTheme2.peerOverrides.Button, size: inputSize, onClick: handleAddClick }, {
                icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(AddIcon, null) })
              }));
            }
          });
        }
      });
      const elementDark = {
        name: "Element",
        common: commonDark
      };
      const elementDark$1 = elementDark;
      const elementLight = {
        name: "Element",
        common: commonLight
      };
      const elementLight$1 = elementLight;
      const elementProps = Object.assign(Object.assign({}, useTheme.props), { tag: {
        type: String,
        default: "div"
      } });
      const NElement = vue.defineComponent({
        name: "Element",
        alias: ["El"],
        props: elementProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Element", "-element", void 0, elementLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: common2 } = themeRef.value;
            return Object.keys(common2).reduce((prevValue, key) => {
              prevValue[`--${kebabCase$1(key)}`] = common2[key];
              return prevValue;
            }, {});
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("element", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { tag, mergedClsPrefix, cssVars, themeClass, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(tag, {
            role: "none",
            class: [`${mergedClsPrefix}-element`, themeClass],
            style: cssVars
          }, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots));
        }
      });
      const commonVariables$5 = {
        feedbackPadding: "4px 0 0 2px",
        feedbackHeightSmall: "24px",
        feedbackHeightMedium: "24px",
        feedbackHeightLarge: "26px",
        feedbackFontSizeSmall: "13px",
        feedbackFontSizeMedium: "14px",
        feedbackFontSizeLarge: "14px",
        labelFontSizeLeftSmall: "14px",
        labelFontSizeLeftMedium: "14px",
        labelFontSizeLeftLarge: "15px",
        labelFontSizeTopSmall: "13px",
        labelFontSizeTopMedium: "14px",
        labelFontSizeTopLarge: "14px",
        labelHeightSmall: "24px",
        labelHeightMedium: "26px",
        labelHeightLarge: "28px",
        labelPaddingVertical: "0 0 6px 2px",
        labelPaddingHorizontal: "0 12px 0 0",
        labelTextAlignVertical: "left",
        labelTextAlignHorizontal: "right",
        labelFontWeight: "400"
      };
      const self$z = (vars) => {
        const { heightSmall, heightMedium, heightLarge, textColor1, errorColor, warningColor, lineHeight: lineHeight2, textColor3 } = vars;
        return Object.assign(Object.assign({}, commonVariables$5), { blankHeightSmall: heightSmall, blankHeightMedium: heightMedium, blankHeightLarge: heightLarge, lineHeight: lineHeight2, labelTextColor: textColor1, asteriskColor: errorColor, feedbackTextColorError: errorColor, feedbackTextColorWarning: warningColor, feedbackTextColor: textColor3 });
      };
      const formLight = {
        name: "Form",
        common: commonLight,
        self: self$z
      };
      const formLight$1 = formLight;
      const formItemDark = {
        name: "Form",
        common: commonDark,
        self: self$z
      };
      const formDark = formItemDark;
      const style$J = cB("form", [cM("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
        width: "auto",
        marginRight: "18px"
      }, [c$1("&:last-child", {
        marginRight: 0
      })])])]);
      const formInjectionKey = createInjectionKey("n-form");
      const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
      var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const formProps = Object.assign(Object.assign({}, useTheme.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: {
        type: String,
        default: "top"
      }, model: {
        type: Object,
        default: () => {
        }
      }, rules: Object, disabled: Boolean, size: String, showRequireMark: {
        type: Boolean,
        default: void 0
      }, requireMarkPlacement: String, showFeedback: {
        type: Boolean,
        default: true
      }, onSubmit: {
        type: Function,
        default: (e) => {
          e.preventDefault();
        }
      }, showLabel: {
        type: Boolean,
        default: void 0
      }, validateMessages: Object });
      const Form = vue.defineComponent({
        name: "Form",
        props: formProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          useTheme("Form", "-form", style$J, formLight$1, props, mergedClsPrefixRef);
          const formItems = {};
          const maxChildLabelWidthRef = vue.ref(void 0);
          const deriveMaxChildLabelWidth = (currentWidth) => {
            const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
            if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
              maxChildLabelWidthRef.value = currentWidth;
            }
          };
          function validate(validateCallback, shouldRuleBeApplied = () => true) {
            return __awaiter$6(this, void 0, void 0, function* () {
              yield new Promise((resolve, reject) => {
                const formItemValidationPromises = [];
                for (const key of keysOf(formItems)) {
                  const formItemInstances = formItems[key];
                  for (const formItemInstance of formItemInstances) {
                    if (formItemInstance.path) {
                      formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                    }
                  }
                }
                void Promise.all(formItemValidationPromises).then((results) => {
                  if (results.some((result) => !result.valid)) {
                    const errors = results.filter((result) => result.errors).map((result) => result.errors);
                    if (validateCallback) {
                      validateCallback(errors);
                    }
                    reject(errors);
                  } else {
                    if (validateCallback)
                      validateCallback();
                    resolve();
                  }
                });
              });
            });
          }
          function restoreValidation() {
            for (const key of keysOf(formItems)) {
              const formItemInstances = formItems[key];
              for (const formItemInstance of formItemInstances) {
                formItemInstance.restoreValidation();
              }
            }
          }
          vue.provide(formInjectionKey, {
            props,
            maxChildLabelWidthRef,
            deriveMaxChildLabelWidth
          });
          vue.provide(formItemInstsInjectionKey, { formItems });
          const formExposedMethod = {
            validate,
            restoreValidation
          };
          return Object.assign(formExposedMethod, {
            mergedClsPrefix: mergedClsPrefixRef
          });
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h("form", { class: [
            `${mergedClsPrefix}-form`,
            this.inline && `${mergedClsPrefix}-form--inline`
          ], onSubmit: this.onSubmit }, this.$slots);
        }
      });
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper2);
          }
          function Wrapper2() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper2.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper2, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && process.env && false) {
        warning = function warning2(type2, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e) {
              return typeof e === "string";
            })) {
              console.warn(type2, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format$1(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len2 = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x) {
            if (x === "%%") {
              return "%";
            }
            if (i >= len2) {
              return x;
            }
            switch (x) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
                break;
              default:
                return x;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type2) {
        return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
      }
      function isEmptyValue(value, type2) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type2 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type2) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v = value;
        for (var i = 0; i < path.length; i++) {
          if (v == void 0) {
            return v;
          }
          v = v[path[i]];
        }
        return v;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s in source) {
            if (source.hasOwnProperty(s)) {
              var value = source[s];
              if (typeof value === "object" && typeof target[s] === "object") {
                target[s] = _extends({}, target[s], value);
              } else {
                target[s] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required2(rule, value, source, errors, options, type2) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
          errors.push(format$1(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format$1(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b = function b2(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
        };
        var protocol2 = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol2 + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer2(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float2(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array2(value) {
          return Array.isArray(value);
        },
        regexp: function regexp2(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date2(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number2(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object2(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method2(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex2(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type2(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len2 = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len2) {
          if (val !== rule.len) {
            errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern2(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method = function method2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number = function number2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp = function regexp2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer = function integer2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array = function array2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object = function object2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable = function enumerable2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern = function pattern2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date = function date2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required = function required2(rule, value, callback, source, options) {
        var errors = [];
        var type2 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type2);
        callback(errors);
      };
      var type = function type2(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators$2 = {
        string,
        method,
        number,
        "boolean": _boolean,
        regexp,
        integer,
        "float": floatFn,
        array,
        object,
        "enum": enumerable,
        pattern,
        date,
        url: type,
        hex: type,
        email: type,
        required,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o, oc) {
          var _this2 = this;
          if (o === void 0) {
            o = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
            throw new Error(format$1("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators$2.required;
          }
          return validators$2[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type2, validator2) {
        if (typeof validator2 !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators$2[type2] = validator2;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators$2;
      function formItemSize(props) {
        const NForm = vue.inject(formInjectionKey, null);
        return {
          mergedSize: vue.computed(() => {
            if (props.size !== void 0)
              return props.size;
            if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.size) !== void 0)
              return NForm.props.size;
            return "medium";
          })
        };
      }
      function formItemMisc(props) {
        const NForm = vue.inject(formInjectionKey, null);
        const mergedLabelPlacementRef = vue.computed(() => {
          const { labelPlacement } = props;
          if (labelPlacement !== void 0)
            return labelPlacement;
          if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelPlacement)
            return NForm.props.labelPlacement;
          return "top";
        });
        const isAutoLabelWidthRef = vue.computed(() => {
          return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) === "auto");
        });
        const mergedLabelWidthRef = vue.computed(() => {
          if (mergedLabelPlacementRef.value === "top")
            return;
          const { labelWidth } = props;
          if (labelWidth !== void 0 && labelWidth !== "auto") {
            return formatLength(labelWidth);
          }
          if (isAutoLabelWidthRef.value) {
            const autoComputedWidth = NForm === null || NForm === void 0 ? void 0 : NForm.maxChildLabelWidthRef.value;
            if (autoComputedWidth !== void 0) {
              return formatLength(autoComputedWidth);
            } else {
              return void 0;
            }
          }
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) !== void 0) {
            return formatLength(NForm.props.labelWidth);
          }
          return void 0;
        });
        const mergedLabelAlignRef = vue.computed(() => {
          const { labelAlign } = props;
          if (labelAlign)
            return labelAlign;
          if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelAlign)
            return NForm.props.labelAlign;
          return void 0;
        });
        const mergedLabelStyleRef = vue.computed(() => {
          var _a;
          return [
            (_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style,
            props.labelStyle,
            {
              width: mergedLabelWidthRef.value
            }
          ];
        });
        const mergedShowRequireMarkRef = vue.computed(() => {
          const { showRequireMark } = props;
          if (showRequireMark !== void 0)
            return showRequireMark;
          return NForm === null || NForm === void 0 ? void 0 : NForm.props.showRequireMark;
        });
        const mergedRequireMarkPlacementRef = vue.computed(() => {
          const { requireMarkPlacement } = props;
          if (requireMarkPlacement !== void 0)
            return requireMarkPlacement;
          return (NForm === null || NForm === void 0 ? void 0 : NForm.props.requireMarkPlacement) || "right";
        });
        const validationErroredRef = vue.ref(false);
        const mergedValidationStatusRef = vue.computed(() => {
          const { validationStatus } = props;
          if (validationStatus !== void 0)
            return validationStatus;
          if (validationErroredRef.value)
            return "error";
          return void 0;
        });
        const mergedShowFeedbackRef = vue.computed(() => {
          const { showFeedback } = props;
          if (showFeedback !== void 0)
            return showFeedback;
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showFeedback) !== void 0)
            return NForm.props.showFeedback;
          return true;
        });
        const mergedShowLabelRef = vue.computed(() => {
          const { showLabel } = props;
          if (showLabel !== void 0)
            return showLabel;
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showLabel) !== void 0)
            return NForm.props.showLabel;
          return true;
        });
        return {
          validationErrored: validationErroredRef,
          mergedLabelStyle: mergedLabelStyleRef,
          mergedLabelPlacement: mergedLabelPlacementRef,
          mergedLabelAlign: mergedLabelAlignRef,
          mergedShowRequireMark: mergedShowRequireMarkRef,
          mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
          mergedValidationStatus: mergedValidationStatusRef,
          mergedShowFeedback: mergedShowFeedbackRef,
          mergedShowLabel: mergedShowLabelRef,
          isAutoLabelWidth: isAutoLabelWidthRef
        };
      }
      function formItemRule(props) {
        const NForm = vue.inject(formInjectionKey, null);
        const compatibleRulePathRef = vue.computed(() => {
          const { rulePath } = props;
          if (rulePath !== void 0)
            return rulePath;
          const { path } = props;
          if (path !== void 0)
            return path;
          return void 0;
        });
        const mergedRulesRef = vue.computed(() => {
          const rules2 = [];
          const { rule } = props;
          if (rule !== void 0) {
            if (Array.isArray(rule))
              rules2.push(...rule);
            else
              rules2.push(rule);
          }
          if (NForm) {
            const { rules: formRules } = NForm.props;
            const { value: rulePath } = compatibleRulePathRef;
            if (formRules !== void 0 && rulePath !== void 0) {
              const formRule = get(formRules, rulePath);
              if (formRule !== void 0) {
                if (Array.isArray(formRule)) {
                  rules2.push(...formRule);
                } else {
                  rules2.push(formRule);
                }
              }
            }
          }
          return rules2;
        });
        const hasRequiredRuleRef = vue.computed(() => {
          return mergedRulesRef.value.some((rule) => rule.required);
        });
        const mergedRequiredRef = vue.computed(() => {
          return hasRequiredRuleRef.value || props.required;
        });
        return {
          mergedRules: mergedRulesRef,
          mergedRequired: mergedRequiredRef
        };
      }
      const {
        cubicBezierEaseInOut
      } = commonVariables$m;
      function fadeDownTransition({
        name = "fade-down",
        fromOffset = "-4px",
        enterDuration = ".3s",
        leaveDuration = ".3s",
        enterCubicBezier = cubicBezierEaseInOut,
        leaveCubicBezier = cubicBezierEaseInOut
      } = {}) {
        return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
          opacity: 0,
          transform: `translateY(${fromOffset})`
        }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
          opacity: 1,
          transform: "translateY(0)"
        }), c$1(`&.${name}-transition-leave-active`, {
          transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
        }), c$1(`&.${name}-transition-enter-active`, {
          transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
        })];
      }
      const style$I = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE("text", `
 grid-area: text; 
 `), cE("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c$1("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
        transition: "color .3s var(--n-bezier)",
        color: "var(--n-feedback-text-color)"
      }, [cM("warning", {
        color: "var(--n-feedback-text-color-warning)"
      }), cM("error", {
        color: "var(--n-feedback-text-color-error)"
      }), fadeDownTransition({
        fromOffset: "-3px",
        enterDuration: ".3s",
        leaveDuration: ".2s"
      })])])]);
      var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const formItemProps = Object.assign(Object.assign({}, useTheme.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: {
        type: Boolean,
        default: void 0
      }, requireMarkPlacement: String, showFeedback: {
        type: Boolean,
        default: void 0
      }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, showLabel: {
        type: Boolean,
        default: void 0
      }, labelProps: Object });
      const formItemPropKeys = keysOf(formItemProps);
      function wrapValidator(validator2, async) {
        return (...args) => {
          try {
            const validateResult = validator2(...args);
            if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || // Error[]
            (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
              return validateResult;
            } else if (validateResult === void 0) {
              return true;
            } else {
              warn$2("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ` + (async ? "`Promise`" : "`boolean`, `Error` or `Promise`") + " typed value instead.");
              return true;
            }
          } catch (err) {
            warn$2("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
            console.error(err);
            return void 0;
          }
        };
      }
      const NFormItem = vue.defineComponent({
        name: "FormItem",
        props: formItemProps,
        setup(props) {
          useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", vue.toRef(props, "path"));
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const NForm = vue.inject(formInjectionKey, null);
          const formItemSizeRefs = formItemSize(props);
          const formItemMiscRefs = formItemMisc(props);
          const { validationErrored: validationErroredRef } = formItemMiscRefs;
          const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = formItemRule(props);
          const { mergedSize: mergedSizeRef } = formItemSizeRefs;
          const { mergedLabelPlacement: labelPlacementRef, mergedLabelAlign: labelTextAlignRef, mergedRequireMarkPlacement: mergedRequireMarkPlacementRef } = formItemMiscRefs;
          const renderExplainsRef = vue.ref([]);
          const feedbackIdRef = vue.ref(createId());
          const mergedDisabledRef = NForm ? vue.toRef(NForm.props, "disabled") : vue.ref(false);
          const themeRef = useTheme("Form", "-form-item", style$I, formLight$1, props, mergedClsPrefixRef);
          vue.watch(vue.toRef(props, "path"), () => {
            if (props.ignorePathChange)
              return;
            restoreValidation();
          });
          function restoreValidation() {
            renderExplainsRef.value = [];
            validationErroredRef.value = false;
            if (props.feedback) {
              feedbackIdRef.value = createId();
            }
          }
          function handleContentBlur() {
            void internalValidate("blur");
          }
          function handleContentChange() {
            void internalValidate("change");
          }
          function handleContentFocus() {
            void internalValidate("focus");
          }
          function handleContentInput() {
            void internalValidate("input");
          }
          function validate(options, callback) {
            return __awaiter$5(this, void 0, void 0, function* () {
              let trigger2;
              let validateCallback;
              let shouldRuleBeApplied;
              let asyncValidatorOptions;
              if (typeof options === "string") {
                trigger2 = options;
                validateCallback = callback;
              } else if (options !== null && typeof options === "object") {
                trigger2 = options.trigger;
                validateCallback = options.callback;
                shouldRuleBeApplied = options.shouldRuleBeApplied;
                asyncValidatorOptions = options.options;
              }
              yield new Promise((resolve, reject) => {
                void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({ valid, errors }) => {
                  if (valid) {
                    if (validateCallback) {
                      validateCallback();
                    }
                    resolve();
                  } else {
                    if (validateCallback) {
                      validateCallback(errors);
                    }
                    reject(errors);
                  }
                });
              });
            });
          }
          const internalValidate = (trigger2 = null, shouldRuleBeApplied = () => true, options = {
            suppressWarning: true
          }) => __awaiter$5(this, void 0, void 0, function* () {
            const { path } = props;
            if (!options) {
              options = {};
            } else {
              if (!options.first)
                options.first = props.first;
            }
            const { value: rules2 } = mergedRulesRef;
            const value = NForm ? get(NForm.props.model, path || "") : void 0;
            const messageRenderers = {};
            const originalMessageRendersMessage = {};
            const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger2);
              } else {
                return rule.trigger === trigger2;
              }
            })).filter(shouldRuleBeApplied).map((rule, i) => {
              const shallowClonedRule = Object.assign({}, rule);
              if (shallowClonedRule.validator) {
                shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
              }
              if (shallowClonedRule.asyncValidator) {
                shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
              }
              if (shallowClonedRule.renderMessage) {
                const rendererKey = `__renderMessage__${i}`;
                originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
                shallowClonedRule.message = rendererKey;
                messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
              }
              return shallowClonedRule;
            });
            if (!activeRules.length) {
              return {
                valid: true
              };
            }
            const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
            const validator2 = new Schema({ [mergedPath]: activeRules });
            const { validateMessages } = (NForm === null || NForm === void 0 ? void 0 : NForm.props) || {};
            if (validateMessages) {
              validator2.messages(validateMessages);
            }
            return yield new Promise((resolve) => {
              void validator2.validate({ [mergedPath]: value }, options, (errors) => {
                if (errors === null || errors === void 0 ? void 0 : errors.length) {
                  renderExplainsRef.value = errors.map((error) => {
                    const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
                    return {
                      key: transformedMessage,
                      render: () => {
                        if (transformedMessage.startsWith("__renderMessage__")) {
                          return messageRenderers[transformedMessage]();
                        }
                        return transformedMessage;
                      }
                    };
                  });
                  errors.forEach((error) => {
                    var _a;
                    if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith("__renderMessage__")) {
                      error.message = originalMessageRendersMessage[error.message];
                    }
                  });
                  validationErroredRef.value = true;
                  resolve({
                    valid: false,
                    errors
                  });
                } else {
                  restoreValidation();
                  resolve({
                    valid: true
                  });
                }
              });
            });
          });
          vue.provide(formItemInjectionKey, {
            path: vue.toRef(props, "path"),
            disabled: mergedDisabledRef,
            mergedSize: formItemSizeRefs.mergedSize,
            mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
            restoreValidation,
            handleContentBlur,
            handleContentChange,
            handleContentFocus,
            handleContentInput
          });
          const exposedRef = {
            validate,
            restoreValidation,
            internalValidate
          };
          const labelElementRef = vue.ref(null);
          vue.onMounted(() => {
            if (!formItemMiscRefs.isAutoLabelWidth.value)
              return;
            const labelElement = labelElementRef.value;
            if (labelElement !== null) {
              const memoizedWhitespace = labelElement.style.whiteSpace;
              labelElement.style.whiteSpace = "nowrap";
              labelElement.style.width = "";
              NForm === null || NForm === void 0 ? void 0 : NForm.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
              labelElement.style.whiteSpace = memoizedWhitespace;
            }
          });
          const cssVarsRef = vue.computed(() => {
            var _a;
            const { value: size2 } = mergedSizeRef;
            const { value: labelPlacement } = labelPlacementRef;
            const direction = labelPlacement === "top" ? "vertical" : "horizontal";
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { labelTextColor, asteriskColor, lineHeight: lineHeight2, feedbackTextColor, feedbackTextColorWarning, feedbackTextColorError, feedbackPadding, labelFontWeight, [createKey("labelHeight", size2)]: labelHeight, [createKey("blankHeight", size2)]: blankHeight, [createKey("feedbackFontSize", size2)]: feedbackFontSize, [createKey("feedbackHeight", size2)]: feedbackHeight, [createKey("labelPadding", direction)]: labelPadding, [createKey("labelTextAlign", direction)]: labelTextAlign, [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize } } = themeRef.value;
            let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
            if (labelPlacement === "top") {
              mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
            }
            const cssVars = {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-line-height": lineHeight2,
              "--n-blank-height": blankHeight,
              "--n-label-font-size": labelFontSize,
              "--n-label-text-align": mergedLabelTextAlign,
              "--n-label-height": labelHeight,
              "--n-label-padding": labelPadding,
              "--n-label-font-weight": labelFontWeight,
              "--n-asterisk-color": asteriskColor,
              "--n-label-text-color": labelTextColor,
              "--n-feedback-padding": feedbackPadding,
              "--n-feedback-font-size": feedbackFontSize,
              "--n-feedback-height": feedbackHeight,
              "--n-feedback-text-color": feedbackTextColor,
              "--n-feedback-text-color-warning": feedbackTextColorWarning,
              "--n-feedback-text-color-error": feedbackTextColorError
            };
            return cssVars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", vue.computed(() => {
            var _a;
            return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ""}`;
          }), cssVarsRef, props) : void 0;
          const reverseColSpaceRef = vue.computed(() => {
            return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
          });
          return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef, mergedClsPrefix: mergedClsPrefixRef, mergedRequired: mergedRequiredRef, feedbackId: feedbackIdRef, renderExplains: renderExplainsRef, reverseColSpace: reverseColSpaceRef }, formItemMiscRefs), formItemSizeRefs), exposedRef), { cssVars: inlineThemeDisabled ? void 0 : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
        },
        render() {
          const { $slots, mergedClsPrefix, mergedShowLabel, mergedShowRequireMark, mergedRequireMarkPlacement, onRender } = this;
          const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderLabel = () => {
            const labelText = this.$slots.label ? this.$slots.label() : this.label;
            if (!labelText)
              return null;
            const textNode = vue.h("span", { class: `${mergedClsPrefix}-form-item-label__text` }, labelText);
            const markNode = renderedShowRequireMark ? vue.h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk` }, mergedRequireMarkPlacement !== "left" ? "*" : "*") : mergedRequireMarkPlacement === "right-hanging" && vue.h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder` }, "*");
            const { labelProps } = this;
            return vue.h("label", Object.assign({}, labelProps, { class: [
              labelProps === null || labelProps === void 0 ? void 0 : labelProps.class,
              `${mergedClsPrefix}-form-item-label`,
              `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`,
              this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`
            ], style: this.mergedLabelStyle, ref: "labelElementRef" }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
          };
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-form-item`,
              this.themeClass,
              `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
              `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
              this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`,
              !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`
            ], style: this.cssVars },
            mergedShowLabel && renderLabel(),
            vue.h("div", { class: [
              `${mergedClsPrefix}-form-item-blank`,
              this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
            ] }, $slots),
            this.mergedShowFeedback ? vue.h(
              "div",
              { key: this.feedbackId, class: `${mergedClsPrefix}-form-item-feedback-wrapper` },
              vue.h(vue.Transition, { name: "fade-down-transition", mode: "out-in" }, {
                default: () => {
                  const { mergedValidationStatus } = this;
                  return resolveWrappedSlot($slots.feedback, (children) => {
                    var _a;
                    const { feedback } = this;
                    const feedbackNodes = children || feedback ? vue.h("div", { key: "__feedback__", class: `${mergedClsPrefix}-form-item-feedback__line` }, children || feedback) : this.renderExplains.length ? (_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({ key, render: render2 }) => vue.h("div", { key, class: `${mergedClsPrefix}-form-item-feedback__line` }, render2())) : null;
                    return feedbackNodes ? mergedValidationStatus === "warning" ? vue.h("div", { key: "controlled-warning", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning` }, feedbackNodes) : mergedValidationStatus === "error" ? vue.h("div", { key: "controlled-error", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error` }, feedbackNodes) : mergedValidationStatus === "success" ? vue.h("div", { key: "controlled-success", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success` }, feedbackNodes) : vue.h("div", { key: "controlled-default", class: `${mergedClsPrefix}-form-item-feedback` }, feedbackNodes) : null;
                  });
                }
              })
            ) : null
          );
        }
      });
      const defaultSpan$1 = 1;
      const gridInjectionKey = createInjectionKey("n-grid");
      const defaultSpan = 1;
      const gridItemProps = {
        span: {
          type: [Number, String],
          default: defaultSpan
        },
        offset: {
          type: [Number, String],
          default: 0
        },
        suffix: Boolean,
        // private props
        privateOffset: Number,
        privateSpan: Number,
        privateColStart: Number,
        privateShow: {
          type: Boolean,
          default: true
        }
      };
      const gridItemPropKeys = keysOf(gridItemProps);
      const NGi = vue.defineComponent({
        __GRID_ITEM__: true,
        name: "GridItem",
        alias: ["Gi"],
        props: gridItemProps,
        setup() {
          const {
            isSsrRef,
            xGapRef,
            itemStyleRef,
            overflowRef,
            layoutShiftDisabledRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(gridInjectionKey);
          const self2 = vue.getCurrentInstance();
          return {
            overflow: overflowRef,
            itemStyle: itemStyleRef,
            layoutShiftDisabled: layoutShiftDisabledRef,
            mergedXGap: vue.computed(() => {
              return pxfy(xGapRef.value || 0);
            }),
            deriveStyle: () => {
              void isSsrRef.value;
              const {
                privateSpan = defaultSpan,
                privateShow = true,
                privateColStart = void 0,
                privateOffset = 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              } = self2.vnode.props;
              const { value: xGap } = xGapRef;
              const mergedXGap = pxfy(xGap || 0);
              return {
                display: !privateShow ? "none" : "",
                gridColumn: `${privateColStart !== null && privateColStart !== void 0 ? privateColStart : `span ${privateSpan}`} / span ${privateSpan}`,
                marginLeft: privateOffset ? `calc((100% - (${privateSpan} - 1) * ${mergedXGap}) / ${privateSpan} * ${privateOffset} + ${mergedXGap} * ${privateOffset})` : ""
              };
            }
          };
        },
        render() {
          var _a, _b;
          if (this.layoutShiftDisabled) {
            const { span, offset, mergedXGap } = this;
            return vue.h("div", { style: {
              gridColumn: `span ${span} / span ${span}`,
              marginLeft: offset ? `calc((100% - (${span} - 1) * ${mergedXGap}) / ${span} * ${offset} + ${mergedXGap} * ${offset})` : ""
            } }, this.$slots);
          }
          return vue.h("div", { style: [this.itemStyle, this.deriveStyle()] }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, { overflow: this.overflow }));
        }
      });
      const formItemGiProps = Object.assign(Object.assign({}, gridItemProps), formItemProps);
      const FormItemGridItem = vue.defineComponent({
        __GRID_ITEM__: true,
        name: "FormItemGridItem",
        alias: ["FormItemGi"],
        props: formItemGiProps,
        setup() {
          const formItemInstRef = vue.ref(null);
          const validate = (...args) => {
            const { value } = formItemInstRef;
            if (value) {
              return value.validate(...args);
            }
          };
          const restoreValidation = () => {
            const { value } = formItemInstRef;
            if (value) {
              value.restoreValidation();
            }
          };
          return {
            formItemInstRef,
            validate,
            restoreValidation
          };
        },
        render() {
          return vue.h(NGi, keep(this.$.vnode.props || {}, gridItemPropKeys), {
            default: () => {
              const itemProps = keep(this.$props, formItemPropKeys);
              return vue.h(NFormItem, Object.assign({ ref: "formItemInstRef" }, itemProps), this.$slots);
            }
          });
        }
      });
      const positionStyles = Array.apply(null, {
        length: 24
      }).map((_, index) => {
        const prefixIndex = index + 1;
        const percent2 = `calc(100% / 24 * ${prefixIndex})`;
        return [cM(`${prefixIndex}-span`, {
          width: percent2
        }), cM(`${prefixIndex}-offset`, {
          marginLeft: percent2
        }), cM(`${prefixIndex}-push`, {
          left: percent2
        }), cM(`${prefixIndex}-pull`, {
          right: percent2
        })];
      });
      const style$H = c$1([cB("row", {
        width: "100%",
        display: "flex",
        flexWrap: "wrap"
      }), cB("col", {
        verticalAlign: "top",
        boxSizing: "border-box",
        display: "inline-block",
        position: "relative",
        zIndex: "auto"
      }, [cE("box", {
        position: "relative",
        zIndex: "auto",
        width: "100%",
        height: "100%"
      }), positionStyles])]);
      const rowInjectionKey = createInjectionKey("n-row");
      const rowProps = {
        gutter: {
          type: [Array, Number, String],
          default: 0
        },
        alignItems: String,
        justifyContent: String
      };
      const rowPropKeys = keysOf(rowProps);
      const NRow = vue.defineComponent({
        name: "Row",
        props: rowProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          useStyle("-legacy-grid", style$H, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Row", mergedRtlRef, mergedClsPrefixRef);
          const verticalGutterRef = useMemo(() => {
            const { gutter } = props;
            if (Array.isArray(gutter)) {
              return gutter[1] || 0;
            }
            return 0;
          });
          const horizontalGutterRef = useMemo(() => {
            const { gutter } = props;
            if (Array.isArray(gutter)) {
              return gutter[0];
            }
            return Number(gutter);
          });
          vue.provide(rowInjectionKey, {
            mergedClsPrefixRef,
            gutterRef: vue.toRef(props, "gutter"),
            verticalGutterRef,
            horizontalGutterRef
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            styleMargin: useMemo(() => `-${formatLength(verticalGutterRef.value, {
            c: 0.5
          })} -${formatLength(horizontalGutterRef.value, { c: 0.5 })}`),
            styleWidth: useMemo(() => `calc(100% + ${formatLength(horizontalGutterRef.value)})`)
          };
        },
        render() {
          return vue.h("div", { class: [
            `${this.mergedClsPrefix}-row`,
            this.rtlEnabled && `${this.mergedClsPrefix}-row--rtl`
          ], style: {
            margin: this.styleMargin,
            width: this.styleWidth,
            alignItems: this.alignItems,
            justifyContent: this.justifyContent
          } }, this.$slots);
        }
      });
      const colProps = {
        span: {
          type: [String, Number],
          default: 1
        },
        push: {
          type: [String, Number],
          default: 0
        },
        pull: {
          type: [String, Number],
          default: 0
        },
        offset: {
          type: [String, Number],
          default: 0
        }
      };
      const colPropKeys = keysOf(colProps);
      const NCol = vue.defineComponent({
        name: "Col",
        props: colProps,
        setup(props) {
          const NRow2 = vue.inject(rowInjectionKey, null);
          if (!NRow2)
            throwError("col", "`n-col` must be placed inside `n-row`.");
          return {
            mergedClsPrefix: NRow2.mergedClsPrefixRef,
            gutter: NRow2.gutterRef,
            stylePadding: vue.computed(() => `${formatLength(NRow2.verticalGutterRef.value, {
            c: 0.5
          })} ${formatLength(NRow2.horizontalGutterRef.value, { c: 0.5 })}`),
            mergedPush: vue.computed(() => Number(props.push) - Number(props.pull))
          };
        },
        render() {
          const { $slots, span, mergedPush, offset, stylePadding, gutter, mergedClsPrefix } = this;
          return vue.h("div", { class: [
            `${mergedClsPrefix}-col`,
            {
              [`${mergedClsPrefix}-col--${span}-span`]: true,
              [`${mergedClsPrefix}-col--${mergedPush}-push`]: mergedPush > 0,
              [`${mergedClsPrefix}-col--${-mergedPush}-pull`]: mergedPush < 0,
              [`${mergedClsPrefix}-col--${offset}-offset`]: offset
            }
          ], style: {
            padding: stylePadding
          } }, gutter ? vue.h("div", null, $slots) : $slots);
        }
      });
      const formItemColProps = Object.assign(Object.assign({}, colProps), formItemProps);
      const formItemColPropKeys = keysOf(formItemColProps);
      const NFormItemCol = vue.defineComponent({
        name: "FormItemCol",
        props: formItemColProps,
        setup() {
          const formItemInstRef = vue.ref(null);
          const validate = (...args) => {
            const { value } = formItemInstRef;
            if (value) {
              return value.validate(...args);
            }
          };
          const restoreValidation = () => {
            const { value } = formItemInstRef;
            if (value) {
              value.restoreValidation();
            }
          };
          return {
            formItemInstRef,
            validate,
            restoreValidation
          };
        },
        render() {
          return vue.h(NCol, keep(this.$props, colPropKeys), {
            default: () => {
              const itemProps = keep(this.$props, formItemPropKeys);
              return vue.h(NFormItem, Object.assign({ ref: "formItemInstRef" }, itemProps), this.$slots);
            }
          });
        }
      });
      const formItemRowProps = Object.assign(Object.assign({}, rowProps), formItemColProps);
      const FormItemRow = vue.defineComponent({
        name: "FormItemRow",
        props: formItemRowProps,
        setup() {
          const formItemColInstRef = vue.ref(null);
          const validate = (...args) => {
            const { value } = formItemColInstRef;
            if (value) {
              return value.validate(...args);
            }
          };
          const restoreValidation = () => {
            const { value } = formItemColInstRef;
            if (value) {
              value.restoreValidation();
            }
          };
          return {
            formItemColInstRef,
            validate,
            restoreValidation
          };
        },
        render() {
          return vue.h(NRow, keep(this.$props, rowPropKeys), {
            default: () => {
              const colProps2 = keep(this.$props, formItemColPropKeys);
              return vue.h(NFormItemCol, Object.assign(Object.assign({ ref: "formItemColInstRef" }, colProps2), { span: 24 }), this.$slots);
            }
          });
        }
      });
      const GlobalStyle = vue.defineComponent({
        name: "GlobalStyle",
        setup() {
          if (typeof document === "undefined")
            return;
          const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
          const { body } = document;
          const { style: style2 } = body;
          let styleApplied = false;
          let firstApply = true;
          vue.onBeforeMount(() => {
            vue.watchEffect(() => {
              var _a, _b;
              const { textColor2, fontSize: fontSize2, fontFamily: fontFamily2, bodyColor, cubicBezierEaseInOut: cubicBezierEaseInOut2, lineHeight: lineHeight2 } = NConfigProvider2 ? merge$3({}, ((_a = NConfigProvider2.mergedThemeRef.value) === null || _a === void 0 ? void 0 : _a.common) || commonLight, (_b = NConfigProvider2.mergedThemeOverridesRef.value) === null || _b === void 0 ? void 0 : _b.common) : commonLight;
              if (styleApplied || !body.hasAttribute("n-styled")) {
                style2.setProperty("-webkit-text-size-adjust", "100%");
                style2.setProperty("-webkit-tap-highlight-color", "transparent");
                style2.padding = "0";
                style2.margin = "0";
                style2.backgroundColor = bodyColor;
                style2.color = textColor2;
                style2.fontSize = fontSize2;
                style2.fontFamily = fontFamily2;
                style2.lineHeight = lineHeight2;
                const transition = `color .3s ${cubicBezierEaseInOut2}, background-color .3s ${cubicBezierEaseInOut2}`;
                if (firstApply) {
                  setTimeout(() => {
                    style2.transition = transition;
                  }, 0);
                } else {
                  style2.transition = transition;
                }
                body.setAttribute("n-styled", "");
                styleApplied = true;
                firstApply = false;
              }
            });
          });
          vue.onUnmounted(() => {
            if (styleApplied) {
              body.removeAttribute("n-styled");
            }
          });
        },
        render() {
          return null;
        }
      });
      const gradientTextDark = {
        name: "GradientText",
        common: commonDark,
        self(vars) {
          const { primaryColor, successColor, warningColor, errorColor, infoColor, primaryColorSuppl, successColorSuppl, warningColorSuppl, errorColorSuppl, infoColorSuppl, fontWeightStrong } = vars;
          return {
            fontWeight: fontWeightStrong,
            rotate: "252deg",
            colorStartPrimary: primaryColor,
            colorEndPrimary: primaryColorSuppl,
            colorStartInfo: infoColor,
            colorEndInfo: infoColorSuppl,
            colorStartWarning: warningColor,
            colorEndWarning: warningColorSuppl,
            colorStartError: errorColor,
            colorEndError: errorColorSuppl,
            colorStartSuccess: successColor,
            colorEndSuccess: successColorSuppl
          };
        }
      };
      const gradientTextDark$1 = gradientTextDark;
      const self$y = (vars) => {
        const { primaryColor, successColor, warningColor, errorColor, infoColor, fontWeightStrong } = vars;
        return {
          fontWeight: fontWeightStrong,
          rotate: "252deg",
          colorStartPrimary: changeColor(primaryColor, { alpha: 0.6 }),
          colorEndPrimary: primaryColor,
          colorStartInfo: changeColor(infoColor, { alpha: 0.6 }),
          colorEndInfo: infoColor,
          colorStartWarning: changeColor(warningColor, { alpha: 0.6 }),
          colorEndWarning: warningColor,
          colorStartError: changeColor(errorColor, { alpha: 0.6 }),
          colorEndError: errorColor,
          colorStartSuccess: changeColor(successColor, { alpha: 0.6 }),
          colorEndSuccess: successColor
        };
      };
      const gradientTextLight = {
        name: "GradientText",
        common: commonLight,
        self: self$y
      };
      const gradientTextLight$1 = gradientTextLight;
      const style$G = cB("gradient-text", `
 display: inline-block;
 font-weight: var(--n-font-weight);
 -webkit-background-clip: text;
 background-clip: text;
 color: #0000;
 white-space: nowrap;
 background-image: linear-gradient(var(--n-rotate), var(--n-color-start) 0%, var(--n-color-end) 100%);
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier);
`);
      const gradientTextProps = Object.assign(Object.assign({}, useTheme.props), { size: [String, Number], fontSize: [String, Number], type: {
        type: String,
        default: "primary"
      }, color: [Object, String], gradient: [Object, String] });
      const GradientText = vue.defineComponent({
        name: "GradientText",
        props: gradientTextProps,
        setup(props) {
          useHoudini();
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const compatibleTypeRef = vue.computed(() => {
            const { type: type2 } = props;
            if (type2 === "danger")
              return "error";
            return type2;
          });
          const styleFontSizeRef = vue.computed(() => {
            let fontSize2 = props.size || props.fontSize;
            if (fontSize2)
              fontSize2 = formatLength(fontSize2);
            return fontSize2 || void 0;
          });
          const styleBgImageRef = vue.computed(() => {
            const gradient = props.color || props.gradient;
            if (typeof gradient === "string") {
              return gradient;
            } else if (gradient) {
              const deg = gradient.deg || 0;
              const from = gradient.from;
              const to = gradient.to;
              return `linear-gradient(${deg}deg, ${from} 0%, ${to} 100%)`;
            }
            return void 0;
          });
          const themeRef = useTheme("GradientText", "-gradient-text", style$G, gradientTextLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { value: type2 } = compatibleTypeRef;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { rotate, [createKey("colorStart", type2)]: colorStart, [createKey("colorEnd", type2)]: colorEnd, fontWeight } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-rotate": rotate,
              "--n-color-start": colorStart,
              "--n-color-end": colorEnd,
              "--n-font-weight": fontWeight
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("gradient-text", vue.computed(() => compatibleTypeRef.value[0]), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            compatibleType: compatibleTypeRef,
            styleFontSize: styleFontSizeRef,
            styleBgImage: styleBgImageRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("span", { class: [
            `${mergedClsPrefix}-gradient-text`,
            `${mergedClsPrefix}-gradient-text--${this.compatibleType}-type`,
            this.themeClass
          ], style: [
            {
              fontSize: this.styleFontSize,
              backgroundImage: this.styleBgImage
            },
            this.cssVars
          ] }, this.$slots);
        }
      });
      const defaultBreakpoints = {
        xs: 0,
        s: 640,
        m: 1024,
        l: 1280,
        xl: 1536,
        xxl: 1920
        // normal desktop display
      };
      const defaultCols = 24;
      const SSR_ATTR_NAME = "__ssr__";
      const gridProps = {
        layoutShiftDisabled: Boolean,
        responsive: {
          type: [String, Boolean],
          default: "self"
        },
        cols: {
          type: [Number, String],
          default: defaultCols
        },
        itemResponsive: Boolean,
        collapsed: Boolean,
        // may create grid rows < collapsedRows since a item may take all the row
        collapsedRows: {
          type: Number,
          default: 1
        },
        itemStyle: [Object, String],
        xGap: {
          type: [Number, String],
          default: 0
        },
        yGap: {
          type: [Number, String],
          default: 0
        }
      };
      const NGrid = vue.defineComponent({
        name: "Grid",
        inheritAttrs: false,
        props: gridProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedBreakpointsRef } = useConfig(props);
          const numRegex = /^\d+$/;
          const widthRef = vue.ref(void 0);
          const breakpointsRef = useBreakpoints((mergedBreakpointsRef === null || mergedBreakpointsRef === void 0 ? void 0 : mergedBreakpointsRef.value) || defaultBreakpoints);
          const isResponsiveRef = useMemo(() => {
            if (props.itemResponsive)
              return true;
            if (!numRegex.test(props.cols.toString()))
              return true;
            if (!numRegex.test(props.xGap.toString()))
              return true;
            if (!numRegex.test(props.yGap.toString()))
              return true;
            return false;
          });
          const responsiveQueryRef = vue.computed(() => {
            if (!isResponsiveRef.value)
              return void 0;
            return props.responsive === "self" ? widthRef.value : breakpointsRef.value;
          });
          const responsiveColsRef = useMemo(() => {
            var _a;
            return (_a = Number(parseResponsivePropValue(props.cols.toString(), responsiveQueryRef.value))) !== null && _a !== void 0 ? _a : defaultCols;
          });
          const responsiveXGapRef = useMemo(() => parseResponsivePropValue(props.xGap.toString(), responsiveQueryRef.value));
          const responsiveYGapRef = useMemo(() => parseResponsivePropValue(props.yGap.toString(), responsiveQueryRef.value));
          const handleResize = (entry) => {
            widthRef.value = entry.contentRect.width;
          };
          const handleResizeRaf = (entry) => {
            beforeNextFrameOnce(handleResize, entry);
          };
          const overflowRef = vue.ref(false);
          const handleResizeRef = vue.computed(() => {
            if (props.responsive === "self") {
              return handleResizeRaf;
            }
            return void 0;
          });
          const isSsrRef = vue.ref(false);
          const contentElRef = vue.ref();
          vue.onMounted(() => {
            const { value: contentEl } = contentElRef;
            if (contentEl) {
              if (contentEl.hasAttribute(SSR_ATTR_NAME)) {
                contentEl.removeAttribute(SSR_ATTR_NAME);
                isSsrRef.value = true;
              }
            }
          });
          vue.provide(gridInjectionKey, {
            layoutShiftDisabledRef: vue.toRef(props, "layoutShiftDisabled"),
            isSsrRef,
            itemStyleRef: vue.toRef(props, "itemStyle"),
            xGapRef: responsiveXGapRef,
            overflowRef
          });
          return {
            isSsr: !isBrowser$2,
            contentEl: contentElRef,
            mergedClsPrefix: mergedClsPrefixRef,
            style: vue.computed(() => {
              if (props.layoutShiftDisabled) {
                return {
                  width: "100%",
                  display: "grid",
                  gridTemplateColumns: `repeat(${props.cols}, minmax(0, 1fr))`,
                  columnGap: pxfy(props.xGap),
                  rowGap: pxfy(props.yGap)
                };
              }
              return {
                width: "100%",
                display: "grid",
                gridTemplateColumns: `repeat(${responsiveColsRef.value}, minmax(0, 1fr))`,
                columnGap: pxfy(responsiveXGapRef.value),
                rowGap: pxfy(responsiveYGapRef.value)
              };
            }),
            isResponsive: isResponsiveRef,
            responsiveQuery: responsiveQueryRef,
            responsiveCols: responsiveColsRef,
            handleResize: handleResizeRef,
            overflow: overflowRef
          };
        },
        render() {
          if (this.layoutShiftDisabled) {
            return vue.h("div", vue.mergeProps({
              ref: "contentEl",
              class: `${this.mergedClsPrefix}-grid`,
              style: this.style
            }, this.$attrs), this.$slots);
          }
          const renderContent = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            this.overflow = false;
            const rawChildren = flatten$3(getSlot$1(this));
            const childrenAndRawSpan = [];
            const { collapsed, collapsedRows, responsiveCols, responsiveQuery } = this;
            rawChildren.forEach((child) => {
              var _a2, _b2, _c2, _d2;
              if (((_a2 = child === null || child === void 0 ? void 0 : child.type) === null || _a2 === void 0 ? void 0 : _a2.__GRID_ITEM__) !== true)
                return;
              if (isNodeVShowFalse(child)) {
                const clonedNode = vue.cloneVNode(child);
                if (clonedNode.props) {
                  clonedNode.props.privateShow = false;
                } else {
                  clonedNode.props = { privateShow: false };
                }
                childrenAndRawSpan.push({
                  child: clonedNode,
                  rawChildSpan: 0
                });
                return;
              }
              child.dirs = ((_b2 = child.dirs) === null || _b2 === void 0 ? void 0 : _b2.filter(({ dir }) => dir !== vue.vShow)) || null;
              const clonedChild = vue.cloneVNode(child);
              const rawChildSpan = Number((_d2 = parseResponsivePropValue((_c2 = clonedChild.props) === null || _c2 === void 0 ? void 0 : _c2.span, responsiveQuery)) !== null && _d2 !== void 0 ? _d2 : defaultSpan$1);
              if (rawChildSpan === 0)
                return;
              childrenAndRawSpan.push({
                child: clonedChild,
                rawChildSpan
              });
            });
            let suffixSpan = 0;
            const maybeSuffixNode = (_a = childrenAndRawSpan[childrenAndRawSpan.length - 1]) === null || _a === void 0 ? void 0 : _a.child;
            if (maybeSuffixNode === null || maybeSuffixNode === void 0 ? void 0 : maybeSuffixNode.props) {
              const suffixPropValue = (_b = maybeSuffixNode.props) === null || _b === void 0 ? void 0 : _b.suffix;
              if (suffixPropValue !== void 0 && suffixPropValue !== false) {
                suffixSpan = (_d = (_c = maybeSuffixNode.props) === null || _c === void 0 ? void 0 : _c.span) !== null && _d !== void 0 ? _d : defaultSpan$1;
                maybeSuffixNode.props.privateSpan = suffixSpan;
                maybeSuffixNode.props.privateColStart = responsiveCols + 1 - suffixSpan;
                maybeSuffixNode.props.privateShow = (_e = maybeSuffixNode.props.privateShow) !== null && _e !== void 0 ? _e : true;
              }
            }
            let spanCounter = 0;
            let done = false;
            for (const { child, rawChildSpan } of childrenAndRawSpan) {
              if (done) {
                this.overflow = true;
              }
              if (!done) {
                const childOffset = Number((_g = parseResponsivePropValue((_f = child.props) === null || _f === void 0 ? void 0 : _f.offset, responsiveQuery)) !== null && _g !== void 0 ? _g : 0);
                const childSpan = Math.min(rawChildSpan + childOffset, responsiveCols);
                if (!child.props) {
                  child.props = {
                    privateSpan: childSpan,
                    privateOffset: childOffset
                  };
                } else {
                  child.props.privateSpan = childSpan;
                  child.props.privateOffset = childOffset;
                }
                if (collapsed) {
                  const remainder = spanCounter % responsiveCols;
                  if (childSpan + remainder > responsiveCols) {
                    spanCounter += responsiveCols - remainder;
                  }
                  if (childSpan + spanCounter + suffixSpan > collapsedRows * responsiveCols) {
                    done = true;
                  } else {
                    spanCounter += childSpan;
                  }
                }
              }
              if (done) {
                if (child.props) {
                  if (child.props.privateShow !== true) {
                    child.props.privateShow = false;
                  }
                } else {
                  child.props = {
                    privateShow: false
                  };
                }
              }
            }
            return vue.h("div", vue.mergeProps({
              ref: "contentEl",
              class: `${this.mergedClsPrefix}-grid`,
              style: this.style,
              [SSR_ATTR_NAME]: this.isSsr || void 0
            }, this.$attrs), childrenAndRawSpan.map(({ child }) => child));
          };
          return this.isResponsive && this.responsive === "self" ? vue.h(VResizeObserver, { onResize: this.handleResize }, {
            default: renderContent
          }) : renderContent();
        }
      });
      const self$x = (vars) => {
        const { primaryColor, baseColor } = vars;
        return {
          color: primaryColor,
          iconColor: baseColor
        };
      };
      const iconWrapperLight = {
        name: "IconWrapper",
        common: commonLight,
        self: self$x
      };
      const iconWrapperLight$1 = iconWrapperLight;
      const iconDark = {
        name: "IconWrapper",
        common: commonDark,
        self: self$x
      };
      const iconWrapperDark = iconDark;
      const style$F = cB("icon-wrapper", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-icon-color);
`);
      const iconWrapperProps = Object.assign(Object.assign({}, useTheme.props), { size: {
        type: Number,
        default: 24
      }, borderRadius: {
        type: Number,
        default: 6
      }, color: String, iconColor: String });
      const NIconWrapper = vue.defineComponent({
        name: "IconWrapper",
        props: iconWrapperProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("IconWrapper", "-icon-wrapper", style$F, iconWrapperLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { color, iconColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": color,
              "--n-icon-color": iconColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon-wrapper", void 0, cssVarsRef, props) : void 0;
          return () => {
            const size2 = formatLength(props.size);
            themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
            return vue.h("div", { class: [
              `${mergedClsPrefixRef.value}-icon-wrapper`,
              themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value
            ], style: [
              cssVarsRef === null || cssVarsRef === void 0 ? void 0 : cssVarsRef.value,
              {
                height: size2,
                width: size2,
                borderRadius: formatLength(props.borderRadius),
                backgroundColor: props.color,
                color: props.iconColor
              }
            ] }, slots);
          };
        }
      });
      const imagePreviewSharedProps = Object.assign(Object.assign({}, useTheme.props), { showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean });
      const imageContextKey = createInjectionKey("n-image");
      function self$w() {
        return {
          toolbarIconColor: "rgba(255, 255, 255, .9)",
          toolbarColor: "rgba(0, 0, 0, .35)",
          toolbarBoxShadow: "none",
          toolbarBorderRadius: "24px"
        };
      }
      const imageLight = createTheme({
        name: "Image",
        common: commonLight,
        peers: {
          Tooltip: tooltipLight$1
        },
        self: self$w
      });
      const commonVars$3 = {
        closeMargin: "16px 12px",
        closeSize: "20px",
        closeIconSize: "16px",
        width: "365px",
        padding: "16px",
        titleFontSize: "16px",
        metaFontSize: "12px",
        descriptionFontSize: "12px"
      };
      const self$v = (vars) => {
        const { textColor2, successColor, infoColor, warningColor, errorColor, popoverColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, textColor1, textColor3, borderRadius, fontWeightStrong, boxShadow2, lineHeight: lineHeight2, fontSize: fontSize2 } = vars;
        return Object.assign(Object.assign({}, commonVars$3), {
          borderRadius,
          lineHeight: lineHeight2,
          fontSize: fontSize2,
          headerFontWeight: fontWeightStrong,
          iconColor: textColor2,
          iconColorSuccess: successColor,
          iconColorInfo: infoColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          color: popoverColor,
          textColor: textColor2,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          headerTextColor: textColor1,
          descriptionTextColor: textColor3,
          actionTextColor: textColor2,
          boxShadow: boxShadow2
        });
      };
      const notificationLight = createTheme({
        name: "Notification",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1
        },
        self: self$v
      });
      const notificationLight$1 = notificationLight;
      const notificationDark = {
        name: "Notification",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1
        },
        self: self$v
      };
      const notificationDark$1 = notificationDark;
      const commonVariables$4 = {
        margin: "0 0 8px 0",
        padding: "10px 20px",
        maxWidth: "720px",
        minWidth: "420px",
        iconMargin: "0 10px 0 0",
        closeMargin: "0 0 0 10px",
        closeSize: "20px",
        closeIconSize: "16px",
        iconSize: "20px",
        fontSize: "14px"
      };
      const self$u = (vars) => {
        const { textColor2, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, errorColor, warningColor, popoverColor, boxShadow2, primaryColor, lineHeight: lineHeight2, borderRadius, closeColorHover, closeColorPressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$4), {
          closeBorderRadius: borderRadius,
          textColor: textColor2,
          textColorInfo: textColor2,
          textColorSuccess: textColor2,
          textColorError: textColor2,
          textColorWarning: textColor2,
          textColorLoading: textColor2,
          color: popoverColor,
          colorInfo: popoverColor,
          colorSuccess: popoverColor,
          colorError: popoverColor,
          colorWarning: popoverColor,
          colorLoading: popoverColor,
          boxShadow: boxShadow2,
          boxShadowInfo: boxShadow2,
          boxShadowSuccess: boxShadow2,
          boxShadowError: boxShadow2,
          boxShadowWarning: boxShadow2,
          boxShadowLoading: boxShadow2,
          iconColor: textColor2,
          iconColorInfo: infoColor,
          iconColorSuccess: successColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          iconColorLoading: primaryColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          closeColorHoverLoading: closeColorHover,
          closeColorPressedLoading: closeColorPressed,
          closeIconColorLoading: closeIconColor,
          closeIconColorHoverLoading: closeIconColorHover,
          closeIconColorPressedLoading: closeIconColorPressed,
          loadingColor: primaryColor,
          lineHeight: lineHeight2,
          borderRadius
        });
      };
      const messageLight = {
        name: "Message",
        common: commonLight,
        self: self$u
      };
      const messageLight$1 = messageLight;
      const messageDark = {
        name: "Message",
        common: commonDark,
        self: self$u
      };
      const messageDark$1 = messageDark;
      const buttonGroupDark = {
        name: "ButtonGroup",
        common: commonDark
      };
      const buttonGroupDark$1 = buttonGroupDark;
      const buttonGroupLight = {
        name: "ButtonGroup",
        common: commonLight
      };
      const buttonGroupLight$1 = buttonGroupLight;
      const inputNumberDark = {
        name: "InputNumber",
        common: commonDark,
        peers: {
          Button: buttonDark$1,
          Input: inputDark$1
        },
        self(vars) {
          const { textColorDisabled } = vars;
          return {
            iconColorDisabled: textColorDisabled
          };
        }
      };
      const inputNumberDark$1 = inputNumberDark;
      const self$t = (vars) => {
        const { textColorDisabled } = vars;
        return {
          iconColorDisabled: textColorDisabled
        };
      };
      const inputNumberLight = createTheme({
        name: "InputNumber",
        common: commonLight,
        peers: {
          Button: buttonLight$1,
          Input: inputLight$1
        },
        self: self$t
      });
      const inputNumberLight$1 = inputNumberLight;
      const layoutDark = {
        name: "Layout",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1
        },
        self(vars) {
          const { textColor2, bodyColor, popoverColor, cardColor, dividerColor, scrollbarColor, scrollbarColorHover } = vars;
          return {
            textColor: textColor2,
            textColorInverted: textColor2,
            color: bodyColor,
            colorEmbedded: bodyColor,
            headerColor: cardColor,
            headerColorInverted: cardColor,
            footerColor: cardColor,
            footerColorInverted: cardColor,
            headerBorderColor: dividerColor,
            headerBorderColorInverted: dividerColor,
            footerBorderColor: dividerColor,
            footerBorderColorInverted: dividerColor,
            siderBorderColor: dividerColor,
            siderBorderColorInverted: dividerColor,
            siderColor: cardColor,
            siderColorInverted: cardColor,
            siderToggleButtonBorder: "1px solid transparent",
            siderToggleButtonColor: popoverColor,
            siderToggleButtonIconColor: textColor2,
            siderToggleButtonIconColorInverted: textColor2,
            siderToggleBarColor: composite(bodyColor, scrollbarColor),
            siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
            __invertScrollbar: "false"
          };
        }
      };
      const layoutDark$1 = layoutDark;
      const self$s = (vars) => {
        const { baseColor, textColor2, bodyColor, cardColor, dividerColor, actionColor, scrollbarColor, scrollbarColorHover, invertedColor } = vars;
        return {
          textColor: textColor2,
          textColorInverted: "#FFF",
          color: bodyColor,
          colorEmbedded: actionColor,
          headerColor: cardColor,
          headerColorInverted: invertedColor,
          footerColor: actionColor,
          footerColorInverted: invertedColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: invertedColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: invertedColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: invertedColor,
          siderColor: cardColor,
          siderColorInverted: invertedColor,
          siderToggleButtonBorder: `1px solid ${dividerColor}`,
          siderToggleButtonColor: baseColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          // hack for inverted background
          __invertScrollbar: "true"
        };
      };
      const layoutLight = createTheme({
        name: "Layout",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1
        },
        self: self$s
      });
      const layoutLight$1 = layoutLight;
      const self$r = (vars) => {
        const { textColor2, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontSize: fontSize2, hoverColor } = vars;
        return {
          textColor: textColor2,
          color: cardColor,
          colorHover: hoverColor,
          colorModal: modalColor,
          colorHoverModal: composite(modalColor, hoverColor),
          colorPopover: popoverColor,
          colorHoverPopover: composite(popoverColor, hoverColor),
          borderColor: dividerColor,
          borderColorModal: composite(modalColor, dividerColor),
          borderColorPopover: composite(popoverColor, dividerColor),
          borderRadius,
          fontSize: fontSize2
        };
      };
      const listLight = {
        name: "List",
        common: commonLight,
        self: self$r
      };
      const listLight$1 = listLight;
      const listDark$1 = {
        name: "List",
        common: commonDark,
        self: self$r
      };
      const listDark$2 = listDark$1;
      const loadingBarDark = {
        name: "LoadingBar",
        common: commonDark,
        self(vars) {
          const { primaryColor } = vars;
          return {
            colorError: "red",
            colorLoading: primaryColor,
            height: "2px"
          };
        }
      };
      const loadingBarDark$1 = loadingBarDark;
      const self$q = (vars) => {
        const { primaryColor, errorColor } = vars;
        return {
          colorError: errorColor,
          colorLoading: primaryColor,
          height: "2px"
        };
      };
      const loadingBarLight = {
        name: "LoadingBar",
        common: commonLight,
        self: self$q
      };
      const loadingBarLight$1 = loadingBarLight;
      const logDark = {
        name: "Log",
        common: commonDark,
        peers: {
          Scrollbar: scrollbarDark$1,
          Code: codeDark$1
        },
        self(vars) {
          const { textColor2, inputColor, fontSize: fontSize2, primaryColor } = vars;
          return {
            loaderFontSize: fontSize2,
            loaderTextColor: textColor2,
            loaderColor: inputColor,
            loaderBorder: "1px solid #0000",
            loadingColor: primaryColor
          };
        }
      };
      const logDark$1 = logDark;
      const self$p = (vars) => {
        const { textColor2, modalColor, borderColor, fontSize: fontSize2, primaryColor } = vars;
        return {
          loaderFontSize: fontSize2,
          loaderTextColor: textColor2,
          loaderColor: modalColor,
          loaderBorder: `1px solid ${borderColor}`,
          loadingColor: primaryColor
        };
      };
      const logLight = createTheme({
        name: "Log",
        common: commonLight,
        peers: {
          Scrollbar: scrollbarLight$1,
          Code: codeLight$1
        },
        self: self$p
      });
      const logLight$1 = logLight;
      const listDark = {
        name: "Mention",
        common: commonDark,
        peers: {
          InternalSelectMenu: internalSelectMenuDark$1,
          Input: inputDark$1
        },
        self(vars) {
          const { boxShadow2 } = vars;
          return {
            menuBoxShadow: boxShadow2
          };
        }
      };
      const mentionDark = listDark;
      const self$o = (vars) => {
        const { boxShadow2 } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      };
      const mentionLight = createTheme({
        name: "Mention",
        common: commonLight,
        peers: {
          InternalSelectMenu: internalSelectMenuLight$1,
          Input: inputLight$1
        },
        self: self$o
      });
      const mentionLight$1 = mentionLight;
      function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
        return {
          itemColorHoverInverted: "#0000",
          itemColorActiveInverted: activeItemColor,
          itemColorActiveHoverInverted: activeItemColor,
          itemColorActiveCollapsedInverted: activeItemColor,
          itemTextColorInverted: color,
          itemTextColorHoverInverted: activeTextColor,
          itemTextColorChildActiveInverted: activeTextColor,
          itemTextColorChildActiveHoverInverted: activeTextColor,
          itemTextColorActiveInverted: activeTextColor,
          itemTextColorActiveHoverInverted: activeTextColor,
          itemTextColorHorizontalInverted: color,
          itemTextColorHoverHorizontalInverted: activeTextColor,
          itemTextColorChildActiveHorizontalInverted: activeTextColor,
          itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
          itemTextColorActiveHorizontalInverted: activeTextColor,
          itemTextColorActiveHoverHorizontalInverted: activeTextColor,
          itemIconColorInverted: color,
          itemIconColorHoverInverted: activeTextColor,
          itemIconColorActiveInverted: activeTextColor,
          itemIconColorActiveHoverInverted: activeTextColor,
          itemIconColorChildActiveInverted: activeTextColor,
          itemIconColorChildActiveHoverInverted: activeTextColor,
          itemIconColorCollapsedInverted: color,
          itemIconColorHorizontalInverted: color,
          itemIconColorHoverHorizontalInverted: activeTextColor,
          itemIconColorActiveHorizontalInverted: activeTextColor,
          itemIconColorActiveHoverHorizontalInverted: activeTextColor,
          itemIconColorChildActiveHorizontalInverted: activeTextColor,
          itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
          arrowColorInverted: color,
          arrowColorHoverInverted: activeTextColor,
          arrowColorActiveInverted: activeTextColor,
          arrowColorActiveHoverInverted: activeTextColor,
          arrowColorChildActiveInverted: activeTextColor,
          arrowColorChildActiveHoverInverted: activeTextColor,
          groupTextColorInverted: groupTextColor
        };
      }
      const self$n = (vars) => {
        const { borderRadius, textColor3, primaryColor, textColor2, textColor1, fontSize: fontSize2, dividerColor, hoverColor, primaryColorHover } = vars;
        return Object.assign({
          borderRadius,
          color: "#0000",
          groupTextColor: textColor3,
          itemColorHover: hoverColor,
          itemColorActive: changeColor(primaryColor, { alpha: 0.1 }),
          itemColorActiveHover: changeColor(primaryColor, { alpha: 0.1 }),
          itemColorActiveCollapsed: changeColor(primaryColor, { alpha: 0.1 }),
          itemTextColor: textColor2,
          itemTextColorHover: textColor2,
          itemTextColorActive: primaryColor,
          itemTextColorActiveHover: primaryColor,
          itemTextColorChildActive: primaryColor,
          itemTextColorChildActiveHover: primaryColor,
          itemTextColorHorizontal: textColor2,
          itemTextColorHoverHorizontal: primaryColorHover,
          itemTextColorActiveHorizontal: primaryColor,
          itemTextColorActiveHoverHorizontal: primaryColor,
          itemTextColorChildActiveHorizontal: primaryColor,
          itemTextColorChildActiveHoverHorizontal: primaryColor,
          itemIconColor: textColor1,
          itemIconColorHover: textColor1,
          itemIconColorActive: primaryColor,
          itemIconColorActiveHover: primaryColor,
          itemIconColorChildActive: primaryColor,
          itemIconColorChildActiveHover: primaryColor,
          itemIconColorCollapsed: textColor1,
          itemIconColorHorizontal: textColor1,
          itemIconColorHoverHorizontal: primaryColorHover,
          itemIconColorActiveHorizontal: primaryColor,
          itemIconColorActiveHoverHorizontal: primaryColor,
          itemIconColorChildActiveHorizontal: primaryColor,
          itemIconColorChildActiveHoverHorizontal: primaryColor,
          itemHeight: "42px",
          arrowColor: textColor2,
          arrowColorHover: textColor2,
          arrowColorActive: primaryColor,
          arrowColorActiveHover: primaryColor,
          arrowColorChildActive: primaryColor,
          arrowColorChildActiveHover: primaryColor,
          colorInverted: "#0000",
          borderColorHorizontal: "#0000",
          fontSize: fontSize2,
          dividerColor
        }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
      };
      const menuLight = createTheme({
        name: "Menu",
        common: commonLight,
        peers: {
          Tooltip: tooltipLight$1,
          Dropdown: dropdownLight$1
        },
        self: self$n
      });
      const menuLight$1 = menuLight;
      const menuDark = {
        name: "Menu",
        common: commonDark,
        peers: {
          Tooltip: tooltipDark$1,
          Dropdown: dropdownDark$1
        },
        self(vars) {
          const { primaryColor, primaryColorSuppl } = vars;
          const commonSelf = self$n(vars);
          commonSelf.itemColorActive = changeColor(primaryColor, { alpha: 0.15 });
          commonSelf.itemColorActiveHover = changeColor(primaryColor, { alpha: 0.15 });
          commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
            alpha: 0.15
          });
          commonSelf.itemColorActiveInverted = primaryColorSuppl;
          commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
          commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
          return commonSelf;
        }
      };
      const menuDark$1 = menuDark;
      const common = {
        titleFontSize: "18px",
        backSize: "22px"
      };
      function self$m(vars) {
        const { textColor1, textColor2, textColor3, fontSize: fontSize2, fontWeightStrong, primaryColorHover, primaryColorPressed } = vars;
        return Object.assign(Object.assign({}, common), { titleFontWeight: fontWeightStrong, fontSize: fontSize2, titleTextColor: textColor1, backColor: textColor2, backColorHover: primaryColorHover, backColorPressed: primaryColorPressed, subtitleTextColor: textColor3 });
      }
      const pageHeaderLight = createTheme({
        name: "PageHeader",
        common: commonLight,
        self: self$m
      });
      const pageHeaderDark = {
        name: "PageHeader",
        common: commonDark,
        self: self$m
      };
      const commonVars$2 = {
        iconSize: "22px"
      };
      const self$l = (vars) => {
        const { fontSize: fontSize2, warningColor } = vars;
        return Object.assign(Object.assign({}, commonVars$2), { fontSize: fontSize2, iconColor: warningColor });
      };
      const popconfirmLight = createTheme({
        name: "Popconfirm",
        common: commonLight,
        peers: {
          Button: buttonLight$1,
          Popover: popoverLight$1
        },
        self: self$l
      });
      const popconfirmLight$1 = popconfirmLight;
      const popconfirmDark = {
        name: "Popconfirm",
        common: commonDark,
        peers: {
          Button: buttonDark$1,
          Popover: popoverDark$1
        },
        self: self$l
      };
      const popconfirmDark$1 = popconfirmDark;
      const self$k = (vars) => {
        const { infoColor, successColor, warningColor, errorColor, textColor2, progressRailColor, fontSize: fontSize2, fontWeight } = vars;
        return {
          fontSize: fontSize2,
          fontSizeCircle: "28px",
          fontWeightCircle: fontWeight,
          railColor: progressRailColor,
          railHeight: "8px",
          iconSizeCircle: "36px",
          iconSizeLine: "18px",
          iconColor: infoColor,
          iconColorInfo: infoColor,
          iconColorSuccess: successColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          textColorCircle: textColor2,
          textColorLineInner: "rgb(255, 255, 255)",
          textColorLineOuter: textColor2,
          fillColor: infoColor,
          fillColorInfo: infoColor,
          fillColorSuccess: successColor,
          fillColorWarning: warningColor,
          fillColorError: errorColor,
          lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
        };
      };
      const progressLight = {
        name: "Progress",
        common: commonLight,
        self: self$k
      };
      const progressLight$1 = progressLight;
      const progressDark = {
        name: "Progress",
        common: commonDark,
        self(vars) {
          const commonSelf = self$k(vars);
          commonSelf.textColorLineInner = "rgb(0, 0, 0)";
          commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
          return commonSelf;
        }
      };
      const progressDark$1 = progressDark;
      const rateDark = {
        name: "Rate",
        common: commonDark,
        self(vars) {
          const { railColor } = vars;
          return {
            itemColor: railColor,
            itemColorActive: "#CCAA33",
            itemSize: "20px",
            sizeSmall: "16px",
            sizeMedium: "20px",
            sizeLarge: "24px"
          };
        }
      };
      const rateDark$1 = rateDark;
      const self$j = (vars) => {
        const { railColor } = vars;
        return {
          itemColor: railColor,
          itemColorActive: "#FFCC33",
          sizeSmall: "16px",
          sizeMedium: "20px",
          sizeLarge: "24px"
        };
      };
      const themeLight = {
        name: "Rate",
        common: commonLight,
        self: self$j
      };
      const rateLight = themeLight;
      const commonVariables$3 = {
        titleFontSizeSmall: "26px",
        titleFontSizeMedium: "32px",
        titleFontSizeLarge: "40px",
        titleFontSizeHuge: "48px",
        fontSizeSmall: "14px",
        fontSizeMedium: "14px",
        fontSizeLarge: "15px",
        fontSizeHuge: "16px",
        iconSizeSmall: "64px",
        iconSizeMedium: "80px",
        iconSizeLarge: "100px",
        iconSizeHuge: "125px",
        iconColor418: void 0,
        iconColor404: void 0,
        iconColor403: void 0,
        iconColor500: void 0
      };
      const self$i = (vars) => {
        const { textColor2, textColor1, errorColor, successColor, infoColor, warningColor, lineHeight: lineHeight2, fontWeightStrong } = vars;
        return Object.assign(Object.assign({}, commonVariables$3), { lineHeight: lineHeight2, titleFontWeight: fontWeightStrong, titleTextColor: textColor1, textColor: textColor2, iconColorError: errorColor, iconColorSuccess: successColor, iconColorInfo: infoColor, iconColorWarning: warningColor });
      };
      const resultLight = {
        name: "Result",
        common: commonLight,
        self: self$i
      };
      const resultLight$1 = resultLight;
      const resultDark = {
        name: "Result",
        common: commonDark,
        self: self$i
      };
      const resultDark$1 = resultDark;
      const sizeVariables$3 = {
        railHeight: "4px",
        railWidthVertical: "4px",
        handleSize: "18px",
        dotHeight: "8px",
        dotWidth: "8px",
        dotBorderRadius: "4px"
      };
      const sliderDark = {
        name: "Slider",
        common: commonDark,
        self(vars) {
          const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
          const { railColor, modalColor, primaryColorSuppl, popoverColor, textColor2, cardColor, borderRadius, fontSize: fontSize2, opacityDisabled } = vars;
          return Object.assign(Object.assign({}, sizeVariables$3), { fontSize: fontSize2, markFontSize: fontSize2, railColor, railColorHover: railColor, fillColor: primaryColorSuppl, fillColorHover: primaryColorSuppl, opacityDisabled, handleColor: "#FFF", dotColor: cardColor, dotColorModal: modalColor, dotColorPopover: popoverColor, handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", indicatorColor: popoverColor, indicatorBoxShadow: boxShadow, indicatorTextColor: textColor2, indicatorBorderRadius: borderRadius, dotBorder: `2px solid ${railColor}`, dotBorderActive: `2px solid ${primaryColorSuppl}`, dotBoxShadow: "" });
        }
      };
      const sliderDark$1 = sliderDark;
      const self$h = (vars) => {
        const indicatorColor = "rgba(0, 0, 0, .85)";
        const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
        const { railColor, primaryColor, baseColor, cardColor, modalColor, popoverColor, borderRadius, fontSize: fontSize2, opacityDisabled } = vars;
        return Object.assign(Object.assign({}, sizeVariables$3), { fontSize: fontSize2, markFontSize: fontSize2, railColor, railColorHover: railColor, fillColor: primaryColor, fillColorHover: primaryColor, opacityDisabled, handleColor: "#FFF", dotColor: cardColor, dotColorModal: modalColor, dotColorPopover: popoverColor, handleBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", handleBoxShadowHover: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", handleBoxShadowActive: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", handleBoxShadowFocus: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", indicatorColor, indicatorBoxShadow: boxShadow, indicatorTextColor: baseColor, indicatorBorderRadius: borderRadius, dotBorder: `2px solid ${railColor}`, dotBorderActive: `2px solid ${primaryColor}`, dotBoxShadow: "" });
      };
      const sliderLight = {
        name: "Slider",
        common: commonLight,
        self: self$h
      };
      const sliderLight$1 = sliderLight;
      const self$g = (vars) => {
        const { opacityDisabled, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, primaryColor, fontSize: fontSize2 } = vars;
        return {
          fontSize: fontSize2,
          textColor: primaryColor,
          sizeTiny: heightTiny,
          sizeSmall: heightSmall,
          sizeMedium: heightMedium,
          sizeLarge: heightLarge,
          sizeHuge: heightHuge,
          color: primaryColor,
          opacitySpinning: opacityDisabled
        };
      };
      const spinLight = {
        name: "Spin",
        common: commonLight,
        self: self$g
      };
      const spinLight$1 = spinLight;
      const spinDark = {
        name: "Spin",
        common: commonDark,
        self: self$g
      };
      const spinDark$1 = spinDark;
      const self$f = (vars) => {
        const { textColor2, textColor3, fontSize: fontSize2, fontWeight } = vars;
        return {
          labelFontSize: fontSize2,
          labelFontWeight: fontWeight,
          valueFontWeight: fontWeight,
          valueFontSize: "24px",
          labelTextColor: textColor3,
          valuePrefixTextColor: textColor2,
          valueSuffixTextColor: textColor2,
          valueTextColor: textColor2
        };
      };
      const statisticLight = {
        name: "Statistic",
        common: commonLight,
        self: self$f
      };
      const statisticLight$1 = statisticLight;
      const statisticDark = {
        name: "Statistic",
        common: commonDark,
        self: self$f
      };
      const statisticDark$1 = statisticDark;
      const commonVariables$2 = {
        stepHeaderFontSizeSmall: "14px",
        stepHeaderFontSizeMedium: "16px",
        indicatorIndexFontSizeSmall: "14px",
        indicatorIndexFontSizeMedium: "16px",
        indicatorSizeSmall: "22px",
        indicatorSizeMedium: "28px",
        indicatorIconSizeSmall: "14px",
        indicatorIconSizeMedium: "18px"
      };
      const self$e = (vars) => {
        const { fontWeightStrong, baseColor, textColorDisabled, primaryColor, errorColor, textColor1, textColor2 } = vars;
        return Object.assign(Object.assign({}, commonVariables$2), { stepHeaderFontWeight: fontWeightStrong, indicatorTextColorProcess: baseColor, indicatorTextColorWait: textColorDisabled, indicatorTextColorFinish: primaryColor, indicatorTextColorError: errorColor, indicatorBorderColorProcess: primaryColor, indicatorBorderColorWait: textColorDisabled, indicatorBorderColorFinish: primaryColor, indicatorBorderColorError: errorColor, indicatorColorProcess: primaryColor, indicatorColorWait: "#0000", indicatorColorFinish: "#0000", indicatorColorError: "#0000", splitorColorProcess: textColorDisabled, splitorColorWait: textColorDisabled, splitorColorFinish: primaryColor, splitorColorError: textColorDisabled, headerTextColorProcess: textColor1, headerTextColorWait: textColorDisabled, headerTextColorFinish: textColorDisabled, headerTextColorError: errorColor, descriptionTextColorProcess: textColor2, descriptionTextColorWait: textColorDisabled, descriptionTextColorFinish: textColorDisabled, descriptionTextColorError: errorColor });
      };
      const stepsLight = {
        name: "Steps",
        common: commonLight,
        self: self$e
      };
      const stepsLight$1 = stepsLight;
      const stepsDark = {
        name: "Steps",
        common: commonDark,
        self: self$e
      };
      const stepsDark$1 = stepsDark;
      const commonVars$1 = {
        buttonHeightSmall: "14px",
        buttonHeightMedium: "18px",
        buttonHeightLarge: "22px",
        buttonWidthSmall: "14px",
        buttonWidthMedium: "18px",
        buttonWidthLarge: "22px",
        buttonWidthPressedSmall: "20px",
        buttonWidthPressedMedium: "24px",
        buttonWidthPressedLarge: "28px",
        railHeightSmall: "18px",
        railHeightMedium: "22px",
        railHeightLarge: "26px",
        railWidthSmall: "32px",
        railWidthMedium: "40px",
        railWidthLarge: "48px"
      };
      const switchDark = {
        name: "Switch",
        common: commonDark,
        self(vars) {
          const { primaryColorSuppl, opacityDisabled, borderRadius, primaryColor, textColor2, baseColor } = vars;
          const railOverlayColor = "rgba(255, 255, 255, .20)";
          return Object.assign(Object.assign({}, commonVars$1), { iconColor: baseColor, textColor: textColor2, loadingColor: primaryColorSuppl, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColorSuppl, buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", buttonColor: "#FFF", railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, { alpha: 0.3 })}` });
        }
      };
      const switchDark$1 = switchDark;
      const self$d = (vars) => {
        const { primaryColor, opacityDisabled, borderRadius, textColor3 } = vars;
        const railOverlayColor = "rgba(0, 0, 0, .14)";
        return Object.assign(Object.assign({}, commonVars$1), { iconColor: textColor3, textColor: "white", loadingColor: primaryColor, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColor, buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", buttonColor: "#FFF", railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}` });
      };
      const switchLight = {
        name: "Switch",
        common: commonLight,
        self: self$d
      };
      const switchLight$1 = switchLight;
      const sizeVariables$2 = {
        thPaddingSmall: "6px",
        thPaddingMedium: "12px",
        thPaddingLarge: "12px",
        tdPaddingSmall: "6px",
        tdPaddingMedium: "12px",
        tdPaddingLarge: "12px"
      };
      const self$c = (vars) => {
        const { dividerColor, cardColor, modalColor, popoverColor, tableHeaderColor, tableColorStriped, textColor1, textColor2, borderRadius, fontWeightStrong, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
        return Object.assign(Object.assign({}, sizeVariables$2), {
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          borderRadius,
          borderColor: composite(cardColor, dividerColor),
          borderColorModal: composite(modalColor, dividerColor),
          borderColorPopover: composite(popoverColor, dividerColor),
          tdColor: cardColor,
          tdColorModal: modalColor,
          tdColorPopover: popoverColor,
          tdColorStriped: composite(cardColor, tableColorStriped),
          tdColorStripedModal: composite(modalColor, tableColorStriped),
          tdColorStripedPopover: composite(popoverColor, tableColorStriped),
          thColor: composite(cardColor, tableHeaderColor),
          thColorModal: composite(modalColor, tableHeaderColor),
          thColorPopover: composite(popoverColor, tableHeaderColor),
          thTextColor: textColor1,
          tdTextColor: textColor2,
          thFontWeight: fontWeightStrong
        });
      };
      const tableLight = {
        name: "Table",
        common: commonLight,
        self: self$c
      };
      const tableLight$1 = tableLight;
      const tableDark = {
        name: "Table",
        common: commonDark,
        self: self$c
      };
      const tableDark$1 = tableDark;
      const sizeVariables$1 = {
        tabFontSizeSmall: "14px",
        tabFontSizeMedium: "14px",
        tabFontSizeLarge: "16px",
        tabGapSmallLine: "36px",
        tabGapMediumLine: "36px",
        tabGapLargeLine: "36px",
        tabGapSmallLineVertical: "8px",
        tabGapMediumLineVertical: "8px",
        tabGapLargeLineVertical: "8px",
        tabPaddingSmallLine: "6px 0",
        tabPaddingMediumLine: "10px 0",
        tabPaddingLargeLine: "14px 0",
        tabPaddingVerticalSmallLine: "6px 12px",
        tabPaddingVerticalMediumLine: "8px 16px",
        tabPaddingVerticalLargeLine: "10px 20px",
        tabGapSmallBar: "36px",
        tabGapMediumBar: "36px",
        tabGapLargeBar: "36px",
        tabGapSmallBarVertical: "8px",
        tabGapMediumBarVertical: "8px",
        tabGapLargeBarVertical: "8px",
        tabPaddingSmallBar: "4px 0",
        tabPaddingMediumBar: "6px 0",
        tabPaddingLargeBar: "10px 0",
        tabPaddingVerticalSmallBar: "6px 12px",
        tabPaddingVerticalMediumBar: "8px 16px",
        tabPaddingVerticalLargeBar: "10px 20px",
        tabGapSmallCard: "4px",
        tabGapMediumCard: "4px",
        tabGapLargeCard: "4px",
        tabGapSmallCardVertical: "4px",
        tabGapMediumCardVertical: "4px",
        tabGapLargeCardVertical: "4px",
        tabPaddingSmallCard: "8px 16px",
        tabPaddingMediumCard: "10px 20px",
        tabPaddingLargeCard: "12px 24px",
        tabPaddingSmallSegment: "4px 0",
        tabPaddingMediumSegment: "6px 0",
        tabPaddingLargeSegment: "8px 0",
        tabPaddingVerticalLargeSegment: "0 8px",
        tabPaddingVerticalSmallCard: "8px 12px",
        tabPaddingVerticalMediumCard: "10px 16px",
        tabPaddingVerticalLargeCard: "12px 20px",
        tabPaddingVerticalSmallSegment: "0 4px",
        tabPaddingVerticalMediumSegment: "0 6px",
        tabGapSmallSegment: "0",
        tabGapMediumSegment: "0",
        tabGapLargeSegment: "0",
        tabGapSmallSegmentVertical: "0",
        tabGapMediumSegmentVertical: "0",
        tabGapLargeSegmentVertical: "0",
        panePaddingSmall: "8px 0 0 0",
        panePaddingMedium: "12px 0 0 0",
        panePaddingLarge: "16px 0 0 0",
        closeSize: "18px",
        closeIconSize: "14px"
      };
      const self$b = (vars) => {
        const { textColor2, primaryColor, textColorDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, tabColor, baseColor, dividerColor, fontWeight, textColor1, borderRadius, fontSize: fontSize2, fontWeightStrong } = vars;
        return Object.assign(Object.assign({}, sizeVariables$1), {
          colorSegment: tabColor,
          tabFontSizeCard: fontSize2,
          tabTextColorLine: textColor1,
          tabTextColorActiveLine: primaryColor,
          tabTextColorHoverLine: primaryColor,
          tabTextColorDisabledLine: textColorDisabled,
          tabTextColorSegment: textColor1,
          tabTextColorActiveSegment: textColor2,
          tabTextColorHoverSegment: textColor2,
          tabTextColorDisabledSegment: textColorDisabled,
          tabTextColorBar: textColor1,
          tabTextColorActiveBar: primaryColor,
          tabTextColorHoverBar: primaryColor,
          tabTextColorDisabledBar: textColorDisabled,
          tabTextColorCard: textColor1,
          tabTextColorHoverCard: textColor1,
          tabTextColorActiveCard: primaryColor,
          tabTextColorDisabledCard: textColorDisabled,
          barColor: primaryColor,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          closeBorderRadius: borderRadius,
          tabColor,
          tabColorSegment: baseColor,
          tabBorderColor: dividerColor,
          tabFontWeightActive: fontWeight,
          tabFontWeight: fontWeight,
          tabBorderRadius: borderRadius,
          paneTextColor: textColor2,
          fontWeightStrong
        });
      };
      const tabsLight = {
        name: "Tabs",
        common: commonLight,
        self: self$b
      };
      const tabsLight$1 = tabsLight;
      const tabsDark = {
        name: "Tabs",
        common: commonDark,
        self(vars) {
          const commonSelf = self$b(vars);
          const { inputColor } = vars;
          commonSelf.colorSegment = inputColor;
          commonSelf.tabColorSegment = inputColor;
          return commonSelf;
        }
      };
      const tabsDark$1 = tabsDark;
      const self$a = (vars) => {
        const { textColor1, textColor2, fontWeightStrong, fontSize: fontSize2 } = vars;
        return {
          fontSize: fontSize2,
          titleTextColor: textColor1,
          textColor: textColor2,
          titleFontWeight: fontWeightStrong
        };
      };
      const thingLight = {
        name: "Thing",
        common: commonLight,
        self: self$a
      };
      const thingLight$1 = thingLight;
      const thingDark = {
        name: "Thing",
        common: commonDark,
        self: self$a
      };
      const thingDark$1 = thingDark;
      const sizeVariables = {
        titleMarginMedium: "0 0 6px 0",
        titleMarginLarge: "-2px 0 6px 0",
        titleFontSizeMedium: "14px",
        titleFontSizeLarge: "16px",
        iconSizeMedium: "14px",
        iconSizeLarge: "14px"
      };
      const timelineDark = {
        name: "Timeline",
        common: commonDark,
        self(vars) {
          const { textColor3, infoColorSuppl, errorColorSuppl, successColorSuppl, warningColorSuppl, textColor1, textColor2, railColor, fontWeightStrong, fontSize: fontSize2 } = vars;
          return Object.assign(Object.assign({}, sizeVariables), { contentFontSize: fontSize2, titleFontWeight: fontWeightStrong, circleBorder: `2px solid ${textColor3}`, circleBorderInfo: `2px solid ${infoColorSuppl}`, circleBorderError: `2px solid ${errorColorSuppl}`, circleBorderSuccess: `2px solid ${successColorSuppl}`, circleBorderWarning: `2px solid ${warningColorSuppl}`, iconColor: textColor3, iconColorInfo: infoColorSuppl, iconColorError: errorColorSuppl, iconColorSuccess: successColorSuppl, iconColorWarning: warningColorSuppl, titleTextColor: textColor1, contentTextColor: textColor2, metaTextColor: textColor3, lineColor: railColor });
        }
      };
      const timelineDark$1 = timelineDark;
      const self$9 = (vars) => {
        const { textColor3, infoColor, errorColor, successColor, warningColor, textColor1, textColor2, railColor, fontWeightStrong, fontSize: fontSize2 } = vars;
        return Object.assign(Object.assign({}, sizeVariables), { contentFontSize: fontSize2, titleFontWeight: fontWeightStrong, circleBorder: `2px solid ${textColor3}`, circleBorderInfo: `2px solid ${infoColor}`, circleBorderError: `2px solid ${errorColor}`, circleBorderSuccess: `2px solid ${successColor}`, circleBorderWarning: `2px solid ${warningColor}`, iconColor: textColor3, iconColorInfo: infoColor, iconColorError: errorColor, iconColorSuccess: successColor, iconColorWarning: warningColor, titleTextColor: textColor1, contentTextColor: textColor2, metaTextColor: textColor3, lineColor: railColor });
      };
      const timelineLight = {
        name: "Timeline",
        common: commonLight,
        self: self$9
      };
      const timelineLight$1 = timelineLight;
      const commonVariables$1 = {
        extraFontSizeSmall: "12px",
        extraFontSizeMedium: "12px",
        extraFontSizeLarge: "14px",
        titleFontSizeSmall: "14px",
        titleFontSizeMedium: "16px",
        titleFontSizeLarge: "16px",
        closeSize: "20px",
        closeIconSize: "16px",
        headerHeightSmall: "44px",
        headerHeightMedium: "44px",
        headerHeightLarge: "50px"
      };
      const transferDark$1 = {
        name: "Transfer",
        common: commonDark,
        peers: {
          Checkbox: checkboxDark$1,
          Scrollbar: scrollbarDark$1,
          Input: inputDark$1,
          Empty: emptyDark$1,
          Button: buttonDark$1
        },
        self(vars) {
          const { fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, borderRadius, inputColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, textColor3, hoverColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, dividerColor } = vars;
          return Object.assign(Object.assign({}, commonVariables$1), {
            itemHeightSmall: heightMedium,
            itemHeightMedium: heightMedium,
            itemHeightLarge: heightLarge,
            fontSizeSmall,
            fontSizeMedium,
            fontSizeLarge,
            borderRadius,
            dividerColor,
            borderColor: "#0000",
            listColor: inputColor,
            headerColor: tableHeaderColor,
            titleTextColor: textColor1,
            titleTextColorDisabled: textColorDisabled,
            extraTextColor: textColor3,
            extraTextColorDisabled: textColorDisabled,
            itemTextColor: textColor2,
            itemTextColorDisabled: textColorDisabled,
            itemColorPending: hoverColor,
            titleFontWeight: fontWeight,
            closeColorHover,
            closeColorPressed,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed
          });
        }
      };
      const transferDark$2 = transferDark$1;
      const self$8 = (vars) => {
        const { fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, borderRadius, cardColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, textColor3, borderColor, hoverColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$1), {
          itemHeightSmall: heightMedium,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          dividerColor: borderColor,
          borderColor,
          listColor: cardColor,
          headerColor: composite(cardColor, tableHeaderColor),
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor3,
          extraTextColorDisabled: textColorDisabled,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed
        });
      };
      const transferLight$1 = createTheme({
        name: "Transfer",
        common: commonLight,
        peers: {
          Checkbox: checkboxLight$1,
          Scrollbar: scrollbarLight$1,
          Input: inputLight$1,
          Empty: emptyLight$1,
          Button: buttonLight$1
        },
        self: self$8
      });
      const transferLight$2 = transferLight$1;
      const self$7 = (vars) => {
        const { borderRadiusSmall, hoverColor, pressedColor, primaryColor, textColor3, textColor2, textColorDisabled, fontSize: fontSize2 } = vars;
        return {
          fontSize: fontSize2,
          nodeBorderRadius: borderRadiusSmall,
          nodeColorHover: hoverColor,
          nodeColorPressed: pressedColor,
          nodeColorActive: changeColor(primaryColor, { alpha: 0.1 }),
          arrowColor: textColor3,
          nodeTextColor: textColor2,
          nodeTextColorDisabled: textColorDisabled,
          loadingColor: primaryColor,
          dropMarkColor: primaryColor
        };
      };
      const treeLight = createTheme({
        name: "Tree",
        common: commonLight,
        peers: {
          Checkbox: checkboxLight$1,
          Scrollbar: scrollbarLight$1,
          Empty: emptyLight$1
        },
        self: self$7
      });
      const treeLight$1 = treeLight;
      const treeDark = {
        name: "Tree",
        common: commonDark,
        peers: {
          Checkbox: checkboxDark$1,
          Scrollbar: scrollbarDark$1,
          Empty: emptyDark$1
        },
        self(vars) {
          const { primaryColor } = vars;
          const commonSelf = self$7(vars);
          commonSelf.nodeColorActive = changeColor(primaryColor, { alpha: 0.15 });
          return commonSelf;
        }
      };
      const treeDark$1 = treeDark;
      const treeSelectDark = {
        name: "TreeSelect",
        common: commonDark,
        peers: {
          Tree: treeDark$1,
          Empty: emptyDark$1,
          InternalSelection: internalSelectionDark$1
        }
      };
      const treeSelectDark$1 = treeSelectDark;
      const self$6 = (vars) => {
        const { popoverColor, boxShadow2, borderRadius, heightMedium, dividerColor, textColor2 } = vars;
        return {
          menuPadding: "4px",
          menuColor: popoverColor,
          menuBoxShadow: boxShadow2,
          menuBorderRadius: borderRadius,
          menuHeight: `calc(${heightMedium} * 7.6)`,
          actionDividerColor: dividerColor,
          actionTextColor: textColor2,
          actionPadding: "8px 12px"
        };
      };
      const treeSelectLight = createTheme({
        name: "TreeSelect",
        common: commonLight,
        peers: {
          Tree: treeLight$1,
          Empty: emptyLight$1,
          InternalSelection: internalSelectionLight$1
        },
        self: self$6
      });
      const treeSelectLight$1 = treeSelectLight;
      const commonVars = {
        headerFontSize1: "30px",
        headerFontSize2: "22px",
        headerFontSize3: "18px",
        headerFontSize4: "16px",
        headerFontSize5: "16px",
        headerFontSize6: "16px",
        headerMargin1: "28px 0 20px 0",
        headerMargin2: "28px 0 20px 0",
        headerMargin3: "28px 0 20px 0",
        headerMargin4: "28px 0 18px 0",
        headerMargin5: "28px 0 18px 0",
        headerMargin6: "28px 0 18px 0",
        headerPrefixWidth1: "16px",
        headerPrefixWidth2: "16px",
        headerPrefixWidth3: "12px",
        headerPrefixWidth4: "12px",
        headerPrefixWidth5: "12px",
        headerPrefixWidth6: "12px",
        headerBarWidth1: "4px",
        headerBarWidth2: "4px",
        headerBarWidth3: "3px",
        headerBarWidth4: "3px",
        headerBarWidth5: "3px",
        headerBarWidth6: "3px",
        pMargin: "16px 0 16px 0",
        liMargin: ".25em 0 0 0",
        olPadding: "0 0 0 2em",
        ulPadding: "0 0 0 2em"
      };
      const self$5 = (vars) => {
        const { primaryColor, textColor2, borderColor, lineHeight: lineHeight2, fontSize: fontSize2, borderRadiusSmall, dividerColor, fontWeightStrong, textColor1, textColor3, infoColor, warningColor, errorColor, successColor, codeColor } = vars;
        return Object.assign(Object.assign({}, commonVars), { aTextColor: primaryColor, blockquoteTextColor: textColor2, blockquotePrefixColor: borderColor, blockquoteLineHeight: lineHeight2, blockquoteFontSize: fontSize2, codeBorderRadius: borderRadiusSmall, liTextColor: textColor2, liLineHeight: lineHeight2, liFontSize: fontSize2, hrColor: dividerColor, headerFontWeight: fontWeightStrong, headerTextColor: textColor1, pTextColor: textColor2, pTextColor1Depth: textColor1, pTextColor2Depth: textColor2, pTextColor3Depth: textColor3, pLineHeight: lineHeight2, pFontSize: fontSize2, headerBarColor: primaryColor, headerBarColorPrimary: primaryColor, headerBarColorInfo: infoColor, headerBarColorError: errorColor, headerBarColorWarning: warningColor, headerBarColorSuccess: successColor, textColor: textColor2, textColor1Depth: textColor1, textColor2Depth: textColor2, textColor3Depth: textColor3, textColorPrimary: primaryColor, textColorInfo: infoColor, textColorSuccess: successColor, textColorWarning: warningColor, textColorError: errorColor, codeTextColor: textColor2, codeColor, codeBorder: "1px solid #0000" });
      };
      const typographyLight = {
        name: "Typography",
        common: commonLight,
        self: self$5
      };
      const typographyLight$1 = typographyLight;
      const typographyDark = {
        name: "Typography",
        common: commonDark,
        self: self$5
      };
      const typographyDark$1 = typographyDark;
      const self$4 = (vars) => {
        const { iconColor, primaryColor, errorColor, textColor2, successColor, opacityDisabled, actionColor, borderColor, hoverColor, lineHeight: lineHeight2, borderRadius, fontSize: fontSize2 } = vars;
        return {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          borderRadius,
          draggerColor: actionColor,
          draggerBorder: `1px dashed ${borderColor}`,
          draggerBorderHover: `1px dashed ${primaryColor}`,
          itemColorHover: hoverColor,
          itemColorHoverError: changeColor(errorColor, {
            alpha: 0.06
          }),
          itemTextColor: textColor2,
          itemTextColorError: errorColor,
          itemTextColorSuccess: successColor,
          itemIconColor: iconColor,
          itemDisabledOpacity: opacityDisabled,
          itemBorderImageCardError: `1px solid ${errorColor}`,
          itemBorderImageCard: `1px solid ${borderColor}`
        };
      };
      const uploadLight = createTheme({
        name: "Upload",
        common: commonLight,
        peers: {
          Button: buttonLight$1,
          Progress: progressLight$1
        },
        self: self$4
      });
      const uploadLight$1 = uploadLight;
      const uploadDark = {
        name: "Upload",
        common: commonDark,
        peers: {
          Button: buttonDark$1,
          Progress: progressDark$1
        },
        self(vars) {
          const { errorColor } = vars;
          const commonSelf = self$4(vars);
          commonSelf.itemColorHoverError = changeColor(errorColor, {
            alpha: 0.09
          });
          return commonSelf;
        }
      };
      const uploadDark$1 = uploadDark;
      const watermarkDark = {
        name: "Watermark",
        common: commonDark,
        self(vars) {
          const { fontFamily: fontFamily2 } = vars;
          return {
            fontFamily: fontFamily2
          };
        }
      };
      const watermarkDark$1 = watermarkDark;
      const watermarkLight = createTheme({
        name: "Watermark",
        common: commonLight,
        self(vars) {
          const { fontFamily: fontFamily2 } = vars;
          return {
            fontFamily: fontFamily2
          };
        }
      });
      const watermarkLight$1 = watermarkLight;
      const rowLight = {
        name: "Row",
        common: commonLight
      };
      const rowLight$1 = rowLight;
      const rowDark = {
        name: "Row",
        common: commonDark
      };
      const rowDark$1 = rowDark;
      const imageDark = {
        name: "Image",
        common: commonDark,
        peers: {
          Tooltip: tooltipDark$1
        },
        self: (vars) => {
          const { textColor2 } = vars;
          return {
            toolbarIconColor: textColor2,
            toolbarColor: "rgba(0, 0, 0, .35)",
            toolbarBoxShadow: "none",
            toolbarBorderRadius: "24px"
          };
        }
      };
      const prevIcon = vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" })
      );
      const nextIcon = vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" })
      );
      const closeIcon = vue.h(
        "svg",
        { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        vue.h("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" })
      );
      const style$E = c$1([c$1("body >", [cB("image-container", "position: fixed;")]), cB("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), cB("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [fadeInTransition()]), cB("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), fadeInTransition()]), cB("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [fadeInScaleUpTransition()]), cB("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), cB("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [cNotM("preview-disabled", `
 cursor: pointer;
 `), c$1("img", `
 border-radius: inherit;
 `)])]);
      const BLEEDING = 32;
      const NImagePreview = vue.defineComponent({
        name: "ImagePreview",
        props: Object.assign(Object.assign({}, imagePreviewSharedProps), { onNext: Function, onPrev: Function, clsPrefix: {
          type: String,
          required: true
        } }),
        setup(props) {
          const themeRef = useTheme("Image", "-image", style$E, imageLight, props, vue.toRef(props, "clsPrefix"));
          let thumbnailEl = null;
          const previewRef = vue.ref(null);
          const previewWrapperRef = vue.ref(null);
          const previewSrcRef = vue.ref(void 0);
          const showRef = vue.ref(false);
          const displayedRef = vue.ref(false);
          const { localeRef } = useLocale("Image");
          function syncTransformOrigin() {
            const { value: previewWrapper } = previewWrapperRef;
            if (!thumbnailEl || !previewWrapper)
              return;
            const { style: style2 } = previewWrapper;
            const tbox = thumbnailEl.getBoundingClientRect();
            const tx = tbox.left + tbox.width / 2;
            const ty = tbox.top + tbox.height / 2;
            style2.transformOrigin = `${tx}px ${ty}px`;
          }
          function handleKeydown(e) {
            var _a, _b;
            switch (e.key) {
              case " ":
                e.preventDefault();
                break;
              case "ArrowLeft":
                (_a = props.onPrev) === null || _a === void 0 ? void 0 : _a.call(props);
                break;
              case "ArrowRight":
                (_b = props.onNext) === null || _b === void 0 ? void 0 : _b.call(props);
                break;
              case "Escape":
                toggleShow();
                break;
            }
          }
          vue.watch(showRef, (value) => {
            if (value) {
              on("keydown", document, handleKeydown);
            } else
              off("keydown", document, handleKeydown);
          });
          vue.onBeforeUnmount(() => {
            off("keydown", document, handleKeydown);
          });
          let startX = 0;
          let startY = 0;
          let offsetX = 0;
          let offsetY = 0;
          let startOffsetX = 0;
          let startOffsetY = 0;
          let mouseDownClientX = 0;
          let mouseDownClientY = 0;
          let dragging = false;
          function handleMouseMove(e) {
            const { clientX, clientY } = e;
            offsetX = clientX - startX;
            offsetY = clientY - startY;
            beforeNextFrameOnce(derivePreviewStyle);
          }
          function getMoveStrategy(opts) {
            const { mouseUpClientX, mouseUpClientY, mouseDownClientX: mouseDownClientX2, mouseDownClientY: mouseDownClientY2 } = opts;
            const deltaHorizontal = mouseDownClientX2 - mouseUpClientX;
            const deltaVertical = mouseDownClientY2 - mouseUpClientY;
            const moveVerticalDirection = `vertical${deltaVertical > 0 ? "Top" : "Bottom"}`;
            const moveHorizontalDirection = `horizontal${deltaHorizontal > 0 ? "Left" : "Right"}`;
            return {
              moveVerticalDirection,
              moveHorizontalDirection,
              deltaHorizontal,
              deltaVertical
            };
          }
          function getDerivedOffset(moveStrategy) {
            const { value: preview } = previewRef;
            if (!preview)
              return { offsetX: 0, offsetY: 0 };
            const pbox = preview.getBoundingClientRect();
            const { moveVerticalDirection, moveHorizontalDirection, deltaHorizontal, deltaVertical } = moveStrategy || {};
            let nextOffsetX = 0;
            let nextOffsetY = 0;
            if (pbox.width <= window.innerWidth) {
              nextOffsetX = 0;
            } else if (pbox.left > 0) {
              nextOffsetX = (pbox.width - window.innerWidth) / 2;
            } else if (pbox.right < window.innerWidth) {
              nextOffsetX = -(pbox.width - window.innerWidth) / 2;
            } else if (moveHorizontalDirection === "horizontalRight") {
              nextOffsetX = Math.min((pbox.width - window.innerWidth) / 2, startOffsetX - (deltaHorizontal !== null && deltaHorizontal !== void 0 ? deltaHorizontal : 0));
            } else {
              nextOffsetX = Math.max(-((pbox.width - window.innerWidth) / 2), startOffsetX - (deltaHorizontal !== null && deltaHorizontal !== void 0 ? deltaHorizontal : 0));
            }
            if (pbox.height <= window.innerHeight) {
              nextOffsetY = 0;
            } else if (pbox.top > 0) {
              nextOffsetY = (pbox.height - window.innerHeight) / 2;
            } else if (pbox.bottom < window.innerHeight) {
              nextOffsetY = -(pbox.height - window.innerHeight) / 2;
            } else if (moveVerticalDirection === "verticalBottom") {
              nextOffsetY = Math.min((pbox.height - window.innerHeight) / 2, startOffsetY - (deltaVertical !== null && deltaVertical !== void 0 ? deltaVertical : 0));
            } else {
              nextOffsetY = Math.max(-((pbox.height - window.innerHeight) / 2), startOffsetY - (deltaVertical !== null && deltaVertical !== void 0 ? deltaVertical : 0));
            }
            return {
              offsetX: nextOffsetX,
              offsetY: nextOffsetY
            };
          }
          function handleMouseUp(e) {
            off("mousemove", document, handleMouseMove);
            off("mouseup", document, handleMouseUp);
            const { clientX: mouseUpClientX, clientY: mouseUpClientY } = e;
            dragging = false;
            const moveStrategy = getMoveStrategy({
              mouseUpClientX,
              mouseUpClientY,
              mouseDownClientX,
              mouseDownClientY
            });
            const offset = getDerivedOffset(moveStrategy);
            offsetX = offset.offsetX;
            offsetY = offset.offsetY;
            derivePreviewStyle();
          }
          const imageContext = vue.inject(imageContextKey, null);
          function handlePreviewMousedown(e) {
            var _a, _b;
            (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onMousedown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            if (e.button !== 0)
              return;
            const { clientX, clientY } = e;
            dragging = true;
            startX = clientX - offsetX;
            startY = clientY - offsetY;
            startOffsetX = offsetX;
            startOffsetY = offsetY;
            mouseDownClientX = clientX;
            mouseDownClientY = clientY;
            derivePreviewStyle();
            on("mousemove", document, handleMouseMove);
            on("mouseup", document, handleMouseUp);
          }
          function handlePreviewDblclick(e) {
            var _a, _b;
            (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onDblclick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            const originalImageSizeScale = getOrignalImageSizeScale();
            scale = scale === originalImageSizeScale ? 1 : originalImageSizeScale;
            derivePreviewStyle();
          }
          const scaleRadix = 1.5;
          let scaleExp = 0;
          let scale = 1;
          let rotate = 0;
          function resetScale() {
            scale = 1;
            scaleExp = 0;
          }
          function handleSwitchPrev() {
            var _a;
            resetScale();
            rotate = 0;
            (_a = props.onPrev) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          function handleSwitchNext() {
            var _a;
            resetScale();
            rotate = 0;
            (_a = props.onNext) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          function rotateCounterclockwise() {
            rotate -= 90;
            derivePreviewStyle();
          }
          function rotateClockwise() {
            rotate += 90;
            derivePreviewStyle();
          }
          function getMaxScale() {
            const { value: preview } = previewRef;
            if (!preview)
              return 1;
            const { innerWidth, innerHeight } = window;
            const heightMaxScale = Math.max(1, preview.naturalHeight / (innerHeight - BLEEDING));
            const widthMaxScale = Math.max(1, preview.naturalWidth / (innerWidth - BLEEDING));
            return Math.max(3, heightMaxScale * 2, widthMaxScale * 2);
          }
          function getOrignalImageSizeScale() {
            const { value: preview } = previewRef;
            if (!preview)
              return 1;
            const { innerWidth, innerHeight } = window;
            const heightScale = preview.naturalHeight / (innerHeight - BLEEDING);
            const widthScale = preview.naturalWidth / (innerWidth - BLEEDING);
            if (heightScale < 1 && widthScale < 1) {
              return 1;
            }
            return Math.max(heightScale, widthScale);
          }
          function zoomIn() {
            const maxScale = getMaxScale();
            if (scale < maxScale) {
              scaleExp += 1;
              scale = Math.min(maxScale, Math.pow(scaleRadix, scaleExp));
              derivePreviewStyle();
            }
          }
          function zoomOut() {
            if (scale > 0.5) {
              const originalScale = scale;
              scaleExp -= 1;
              scale = Math.max(0.5, Math.pow(scaleRadix, scaleExp));
              const diff = originalScale - scale;
              derivePreviewStyle(false);
              const offset = getDerivedOffset();
              scale += diff;
              derivePreviewStyle(false);
              scale -= diff;
              offsetX = offset.offsetX;
              offsetY = offset.offsetY;
              derivePreviewStyle();
            }
          }
          function derivePreviewStyle(transition = true) {
            var _a;
            const { value: preview } = previewRef;
            if (!preview)
              return;
            const { style: style2 } = preview;
            const controlledStyle = vue.normalizeStyle((_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.style);
            let controlledStyleString = "";
            if (typeof controlledStyle === "string") {
              controlledStyleString = controlledStyle + ";";
            } else {
              for (const key in controlledStyle) {
                controlledStyleString += `${kebabCase$1(key)}: ${controlledStyle[key]};`;
              }
            }
            const transformStyle = `transform-origin: center; transform: translateX(${offsetX}px) translateY(${offsetY}px) rotate(${rotate}deg) scale(${scale});`;
            if (dragging) {
              style2.cssText = controlledStyleString + "cursor: grabbing; transition: none;" + transformStyle;
            } else {
              style2.cssText = controlledStyleString + "cursor: grab;" + transformStyle + (transition ? "" : "transition: none;");
            }
            if (!transition) {
              void preview.offsetHeight;
            }
          }
          function toggleShow() {
            showRef.value = !showRef.value;
            displayedRef.value = true;
          }
          function resizeToOrignalImageSize() {
            scale = getOrignalImageSizeScale();
            scaleExp = Math.ceil(Math.log(scale) / Math.log(scaleRadix));
            offsetX = 0;
            offsetY = 0;
            derivePreviewStyle();
          }
          const exposedMethods = {
            setPreviewSrc: (src) => {
              previewSrcRef.value = src;
            },
            setThumbnailEl: (el) => {
              thumbnailEl = el;
            },
            toggleShow
          };
          function withTooltip(node, tooltipKey) {
            if (props.showToolbarTooltip) {
              const { value: theme } = themeRef;
              return vue.h(NTooltip, { to: false, theme: theme.peers.Tooltip, themeOverrides: theme.peerOverrides.Tooltip, keepAliveOnHover: false }, {
                default: () => {
                  return localeRef.value[tooltipKey];
                },
                trigger: () => node
              });
            } else {
              return node;
            }
          }
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { toolbarIconColor, toolbarBorderRadius, toolbarBoxShadow, toolbarColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-toolbar-icon-color": toolbarIconColor,
              "--n-toolbar-color": toolbarColor,
              "--n-toolbar-border-radius": toolbarBorderRadius,
              "--n-toolbar-box-shadow": toolbarBoxShadow
            };
          });
          const { inlineThemeDisabled } = useConfig();
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("image-preview", void 0, cssVarsRef, props) : void 0;
          return Object.assign({
            previewRef,
            previewWrapperRef,
            previewSrc: previewSrcRef,
            show: showRef,
            appear: isMounted(),
            displayed: displayedRef,
            previewedImgProps: imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef,
            handleWheel(e) {
              e.preventDefault();
            },
            handlePreviewMousedown,
            handlePreviewDblclick,
            syncTransformOrigin,
            handleAfterLeave: () => {
              resetScale();
              rotate = 0;
              displayedRef.value = false;
            },
            handleDragStart: (e) => {
              var _a, _b;
              (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onDragstart) === null || _b === void 0 ? void 0 : _b.call(_a, e);
              e.preventDefault();
            },
            zoomIn,
            zoomOut,
            rotateCounterclockwise,
            rotateClockwise,
            handleSwitchPrev,
            handleSwitchNext,
            withTooltip,
            resizeToOrignalImageSize,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedMethods);
        },
        render() {
          var _a, _b;
          const { clsPrefix } = this;
          return vue.h(
            vue.Fragment,
            null,
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a),
            vue.h(LazyTeleport, { show: this.show }, {
              default: () => {
                var _a2;
                if (!(this.show || this.displayed)) {
                  return null;
                }
                (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
                return vue.withDirectives(vue.h(
                  "div",
                  { class: [
                    `${clsPrefix}-image-preview-container`,
                    this.themeClass
                  ], style: this.cssVars, onWheel: this.handleWheel },
                  vue.h(vue.Transition, { name: "fade-in-transition", appear: this.appear }, {
                    default: () => this.show ? vue.h("div", { class: `${clsPrefix}-image-preview-overlay`, onClick: this.toggleShow }) : null
                  }),
                  this.showToolbar ? vue.h(vue.Transition, { name: "fade-in-transition", appear: this.appear }, {
                    default: () => {
                      if (!this.show)
                        return null;
                      const { withTooltip } = this;
                      return vue.h(
                        "div",
                        { class: `${clsPrefix}-image-preview-toolbar` },
                        this.onPrev ? vue.h(
                          vue.Fragment,
                          null,
                          withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.handleSwitchPrev }, { default: () => prevIcon }), "tipPrevious"),
                          withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.handleSwitchNext }, { default: () => nextIcon }), "tipNext")
                        ) : null,
                        withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.rotateCounterclockwise }, {
                          default: () => vue.h(RotateCounterclockwiseIcon, null)
                        }), "tipCounterclockwise"),
                        withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.rotateClockwise }, {
                          default: () => vue.h(RotateClockwiseIcon, null)
                        }), "tipClockwise"),
                        withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.resizeToOrignalImageSize }, {
                          default: () => {
                            return vue.h(ResizeSmallIcon, null);
                          }
                        }), "tipOriginalSize"),
                        withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.zoomOut }, { default: () => vue.h(ZoomOutIcon, null) }), "tipZoomOut"),
                        withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.zoomIn }, { default: () => vue.h(ZoomInIcon, null) }), "tipZoomIn"),
                        withTooltip(vue.h(NBaseIcon, { clsPrefix, onClick: this.toggleShow }, { default: () => closeIcon }), "tipClose")
                      );
                    }
                  }) : null,
                  vue.h(vue.Transition, {
                    name: "fade-in-scale-up-transition",
                    onAfterLeave: this.handleAfterLeave,
                    appear: this.appear,
                    // BUG:
                    // onEnter will be called twice, I don't know why
                    // Maybe it is a bug of vue
                    onEnter: this.syncTransformOrigin,
                    onBeforeLeave: this.syncTransformOrigin
                  }, {
                    default: () => {
                      const { previewedImgProps = {} } = this;
                      return vue.withDirectives(vue.h(
                        "div",
                        { class: `${clsPrefix}-image-preview-wrapper`, ref: "previewWrapperRef" },
                        vue.h("img", Object.assign({}, previewedImgProps, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [
                          `${clsPrefix}-image-preview`,
                          previewedImgProps.class
                        ], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))
                      ), [[vue.vShow, this.show]]);
                    }
                  })
                ), [[zindexable$1, { enabled: this.show }]]);
              }
            })
          );
        }
      });
      const imageGroupInjectionKey = createInjectionKey("n-image-group");
      const imageGroupProps = imagePreviewSharedProps;
      const NImageGroup = vue.defineComponent({
        name: "ImageGroup",
        props: imageGroupProps,
        setup(props) {
          let currentSrc;
          const { mergedClsPrefixRef } = useConfig(props);
          const groupId = `c${createId()}`;
          const vm = vue.getCurrentInstance();
          const setPreviewSrc = (src) => {
            var _a;
            currentSrc = src;
            (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.setPreviewSrc(src);
          };
          function go(step) {
            if (!(vm === null || vm === void 0 ? void 0 : vm.proxy))
              return;
            const container = vm.proxy.$el.parentElement;
            const imgs = container.querySelectorAll(`[data-group-id=${groupId}]:not([data-error=true])`);
            if (!imgs.length)
              return;
            const index = Array.from(imgs).findIndex((img) => img.dataset.previewSrc === currentSrc);
            if (~index) {
              setPreviewSrc(imgs[(index + step + imgs.length) % imgs.length].dataset.previewSrc);
            } else {
              setPreviewSrc(imgs[0].dataset.previewSrc);
            }
          }
          vue.provide(imageGroupInjectionKey, {
            mergedClsPrefixRef,
            setPreviewSrc,
            setThumbnailEl: (el) => {
              var _a;
              (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.setThumbnailEl(el);
            },
            toggleShow: () => {
              var _a;
              (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.toggleShow();
            },
            groupId
          });
          const previewInstRef = vue.ref(null);
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            previewInstRef,
            next: () => {
              go(1);
            },
            prev: () => {
              go(-1);
            }
          };
        },
        render() {
          return vue.h(NImagePreview, { theme: this.theme, themeOverrides: this.themeOverrides, clsPrefix: this.mergedClsPrefix, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip }, this.$slots);
        }
      });
      const imageProps = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: {
        type: String,
        default: "fill"
      }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, imagePreviewSharedProps);
      const NImage = vue.defineComponent({
        name: "Image",
        props: imageProps,
        inheritAttrs: false,
        setup(props) {
          const imageRef = vue.ref(null);
          const showErrorRef = vue.ref(false);
          const previewInstRef = vue.ref(null);
          const imageGroupHandle = vue.inject(imageGroupInjectionKey, null);
          const { mergedClsPrefixRef } = imageGroupHandle || useConfig(props);
          const exposedMethods = {
            click: () => {
              if (props.previewDisabled || showErrorRef.value)
                return;
              const mergedPreviewSrc = props.previewSrc || props.src;
              if (imageGroupHandle) {
                imageGroupHandle.setPreviewSrc(mergedPreviewSrc);
                imageGroupHandle.setThumbnailEl(imageRef.value);
                imageGroupHandle.toggleShow();
                return;
              }
              const { value: previewInst } = previewInstRef;
              if (!previewInst)
                return;
              previewInst.setPreviewSrc(mergedPreviewSrc);
              previewInst.setThumbnailEl(imageRef.value);
              previewInst.toggleShow();
            }
          };
          const shouldStartLoadingRef = vue.ref(!props.lazy);
          vue.onMounted(() => {
            var _a;
            (_a = imageRef.value) === null || _a === void 0 ? void 0 : _a.setAttribute("data-group-id", (imageGroupHandle === null || imageGroupHandle === void 0 ? void 0 : imageGroupHandle.groupId) || "");
          });
          vue.onMounted(() => {
            if (props.lazy && props.intersectionObserverOptions) {
              let unobserve;
              const stopWatchHandle = vue.watchEffect(() => {
                unobserve === null || unobserve === void 0 ? void 0 : unobserve();
                unobserve = void 0;
                unobserve = observeIntersection(imageRef.value, props.intersectionObserverOptions, shouldStartLoadingRef);
              });
              vue.onBeforeUnmount(() => {
                stopWatchHandle();
                unobserve === null || unobserve === void 0 ? void 0 : unobserve();
              });
            }
          });
          vue.watchEffect(() => {
            var _a;
            void props.src;
            void ((_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.src);
            showErrorRef.value = false;
          });
          const loadedRef = vue.ref(false);
          vue.provide(imageContextKey, {
            previewedImgPropsRef: vue.toRef(props, "previewedImgProps")
          });
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            groupId: imageGroupHandle === null || imageGroupHandle === void 0 ? void 0 : imageGroupHandle.groupId,
            previewInstRef,
            imageRef,
            showError: showErrorRef,
            shouldStartLoading: shouldStartLoadingRef,
            loaded: loadedRef,
            mergedOnClick: (e) => {
              var _a, _b;
              exposedMethods.click();
              (_b = (_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            },
            mergedOnError: (e) => {
              if (!shouldStartLoadingRef.value)
                return;
              showErrorRef.value = true;
              const { onError, imgProps: { onError: imgPropsOnError } = {} } = props;
              onError === null || onError === void 0 ? void 0 : onError(e);
              imgPropsOnError === null || imgPropsOnError === void 0 ? void 0 : imgPropsOnError(e);
            },
            mergedOnLoad: (e) => {
              const { onLoad, imgProps: { onLoad: imgPropsOnLoad } = {} } = props;
              onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);
              imgPropsOnLoad === null || imgPropsOnLoad === void 0 ? void 0 : imgPropsOnLoad(e);
              loadedRef.value = true;
            }
          }, exposedMethods);
        },
        render() {
          var _a, _b;
          const { mergedClsPrefix, imgProps = {}, loaded, $attrs, lazy } = this;
          const placeholderNode = (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a);
          const loadSrc = this.src || imgProps.src;
          const imgNode = vue.h("img", Object.assign(Object.assign({}, imgProps), {
            ref: "imageRef",
            width: this.width || imgProps.width,
            height: this.height || imgProps.height,
            src: this.showError ? this.fallbackSrc : lazy && this.intersectionObserverOptions ? this.shouldStartLoading ? loadSrc : void 0 : loadSrc,
            alt: this.alt || imgProps.alt,
            "aria-label": this.alt || imgProps.alt,
            onClick: this.mergedOnClick,
            onError: this.mergedOnError,
            onLoad: this.mergedOnLoad,
            // If interseciton observer options is set, do not use native lazy
            loading: isImageSupportNativeLazy && lazy && !this.intersectionObserverOptions ? "lazy" : "eager",
            style: [
              imgProps.style || "",
              placeholderNode && !loaded ? { height: "0", width: "0", visibility: "hidden" } : "",
              { objectFit: this.objectFit }
            ],
            "data-error": this.showError,
            "data-preview-src": this.previewSrc || this.src
          }));
          return vue.h(
            "div",
            Object.assign({}, $attrs, { role: "none", class: [
              $attrs.class,
              `${mergedClsPrefix}-image`,
              (this.previewDisabled || this.showError) && `${mergedClsPrefix}-image--preview-disabled`
            ] }),
            this.groupId ? imgNode : vue.h(NImagePreview, { theme: this.theme, themeOverrides: this.themeOverrides, clsPrefix: mergedClsPrefix, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip }, {
              default: () => imgNode
            }),
            !loaded && placeholderNode
          );
        }
      });
      function parse(value) {
        if (value === void 0 || value === null || typeof value === "string" && value.trim() === "") {
          return null;
        }
        return Number(value);
      }
      function isWipValue(value) {
        return value.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(value) || /^\.\d+$/.test(value));
      }
      function validator$1(value) {
        if (value === void 0 || value === null)
          return true;
        if (Number.isNaN(value))
          return false;
        return true;
      }
      function format(value, precision) {
        if (value === void 0 || value === null)
          return "";
        return precision === void 0 ? String(value) : value.toFixed(precision);
      }
      function parseNumber(number2) {
        if (number2 === null)
          return null;
        if (typeof number2 === "number") {
          return number2;
        } else {
          const parsedNumber = Number(number2);
          if (Number.isNaN(parsedNumber))
            return null;
          else {
            return parsedNumber;
          }
        }
      }
      const style$D = c$1([cB("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), cB("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
      const HOLDING_CHANGE_THRESHOLD = 800;
      const HOLDING_CHANGE_INTERVAL = 100;
      const inputNumberProps = Object.assign(Object.assign({}, useTheme.props), {
        autofocus: Boolean,
        loading: {
          type: Boolean,
          default: void 0
        },
        placeholder: String,
        defaultValue: {
          type: Number,
          default: null
        },
        value: Number,
        step: {
          type: [Number, String],
          default: 1
        },
        min: [Number, String],
        max: [Number, String],
        size: String,
        disabled: {
          type: Boolean,
          default: void 0
        },
        validator: Function,
        bordered: {
          type: Boolean,
          default: void 0
        },
        showButton: {
          type: Boolean,
          default: true
        },
        buttonPlacement: {
          type: String,
          default: "right"
        },
        readonly: Boolean,
        clearable: Boolean,
        keyboard: {
          type: Object,
          default: {}
        },
        updateValueOnInput: {
          type: Boolean,
          default: true
        },
        parse: Function,
        format: Function,
        precision: Number,
        status: String,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onFocus: [Function, Array],
        onBlur: [Function, Array],
        onClear: [Function, Array],
        // deprecated
        onChange: [Function, Array]
      });
      const InputNumber = vue.defineComponent({
        name: "InputNumber",
        props: inputNumberProps,
        setup(props) {
          const { mergedBorderedRef, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("InputNumber", "-input-number", style$D, inputNumberLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale("InputNumber");
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const inputInstRef = vue.ref(null);
          const minusButtonInstRef = vue.ref(null);
          const addButtonInstRef = vue.ref(null);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const displayedValueRef = vue.ref("");
          const getPrecision = (value) => {
            const fraction = String(value).split(".")[1];
            return fraction ? fraction.length : 0;
          };
          const getMaxPrecision = (currentValue) => {
            const precisions = [props.min, props.max, props.step, currentValue].map((value) => {
              if (value === void 0)
                return 0;
              return getPrecision(value);
            });
            return Math.max(...precisions);
          };
          const mergedPlaceholderRef = useMemo(() => {
            const { placeholder } = props;
            if (placeholder !== void 0)
              return placeholder;
            return localeRef.value.placeholder;
          });
          const mergedStepRef = useMemo(() => {
            const parsedNumber = parseNumber(props.step);
            if (parsedNumber !== null) {
              return parsedNumber === 0 ? 1 : Math.abs(parsedNumber);
            }
            return 1;
          });
          const mergedMinRef = useMemo(() => {
            const parsedNumber = parseNumber(props.min);
            if (parsedNumber !== null)
              return parsedNumber;
            else
              return null;
          });
          const mergedMaxRef = useMemo(() => {
            const parsedNumber = parseNumber(props.max);
            if (parsedNumber !== null)
              return parsedNumber;
            else
              return null;
          });
          const doUpdateValue = (value) => {
            const { value: mergedValue } = mergedValueRef;
            if (value === mergedValue) {
              deriveDisplayedValueFromValue();
              return;
            }
            const { "onUpdate:value": _onUpdateValue, onUpdateValue, onChange } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onChange)
              call(onChange, value);
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          };
          const deriveValueFromDisplayedValue = ({ offset, doUpdateIfValid, fixPrecision, isInputing }) => {
            const { value: displayedValue } = displayedValueRef;
            if (isInputing && isWipValue(displayedValue)) {
              return false;
            }
            const parsedValue = (props.parse || parse)(displayedValue);
            if (parsedValue === null) {
              if (doUpdateIfValid)
                doUpdateValue(null);
              return null;
            }
            if (validator$1(parsedValue)) {
              const currentPrecision = getPrecision(parsedValue);
              const { precision } = props;
              if (precision !== void 0 && precision < currentPrecision && !fixPrecision) {
                return false;
              }
              let nextValue = parseFloat((parsedValue + offset).toFixed(precision !== null && precision !== void 0 ? precision : getMaxPrecision(parsedValue)));
              if (validator$1(nextValue)) {
                const { value: mergedMax } = mergedMaxRef;
                const { value: mergedMin } = mergedMinRef;
                if (mergedMax !== null && nextValue > mergedMax) {
                  if (!doUpdateIfValid || isInputing)
                    return false;
                  nextValue = mergedMax;
                }
                if (mergedMin !== null && nextValue < mergedMin) {
                  if (!doUpdateIfValid || isInputing)
                    return false;
                  nextValue = mergedMin;
                }
                if (props.validator && !props.validator(nextValue))
                  return false;
                if (doUpdateIfValid)
                  doUpdateValue(nextValue);
                return nextValue;
              }
            }
            return false;
          };
          const deriveDisplayedValueFromValue = () => {
            const { value: mergedValue } = mergedValueRef;
            if (validator$1(mergedValue)) {
              const { format: formatProp, precision } = props;
              if (formatProp) {
                displayedValueRef.value = formatProp(mergedValue);
              } else {
                if (mergedValue === null || precision === void 0 || // precision overflow
                getPrecision(mergedValue) > precision) {
                  displayedValueRef.value = format(mergedValue, void 0);
                } else {
                  displayedValueRef.value = format(mergedValue, precision);
                }
              }
            } else {
              displayedValueRef.value = String(mergedValue);
            }
          };
          deriveDisplayedValueFromValue();
          const displayedValueInvalidRef = useMemo(() => {
            const derivedValue = deriveValueFromDisplayedValue({
              offset: 0,
              doUpdateIfValid: false,
              isInputing: false,
              fixPrecision: false
            });
            return derivedValue === false;
          });
          const minusableRef = useMemo(() => {
            const { value: mergedValue } = mergedValueRef;
            if (props.validator && mergedValue === null) {
              return false;
            }
            const { value: mergedStep } = mergedStepRef;
            const derivedNextValue = deriveValueFromDisplayedValue({
              offset: -mergedStep,
              doUpdateIfValid: false,
              isInputing: false,
              fixPrecision: false
            });
            return derivedNextValue !== false;
          });
          const addableRef = useMemo(() => {
            const { value: mergedValue } = mergedValueRef;
            if (props.validator && mergedValue === null) {
              return false;
            }
            const { value: mergedStep } = mergedStepRef;
            const derivedNextValue = deriveValueFromDisplayedValue({
              offset: +mergedStep,
              doUpdateIfValid: false,
              isInputing: false,
              fixPrecision: false
            });
            return derivedNextValue !== false;
          });
          function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
              call(onFocus, e);
            nTriggerFormFocus();
          }
          function doBlur(e) {
            var _a, _b;
            if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
              return;
            }
            const value = deriveValueFromDisplayedValue({
              offset: 0,
              doUpdateIfValid: true,
              isInputing: false,
              fixPrecision: true
            });
            if (value !== false) {
              const inputElRef = (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.inputElRef;
              if (inputElRef) {
                inputElRef.value = String(value || "");
              }
              if (mergedValueRef.value === value) {
                deriveDisplayedValueFromValue();
              }
            } else {
              deriveDisplayedValueFromValue();
            }
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
              call(onBlur, e);
            nTriggerFormBlur();
            void vue.nextTick(() => {
              deriveDisplayedValueFromValue();
            });
          }
          function doClear(e) {
            const { onClear } = props;
            if (onClear)
              call(onClear, e);
          }
          function doAdd() {
            const { value: addable } = addableRef;
            if (!addable) {
              clearAddHoldTimeout();
              return;
            }
            const { value: mergedValue } = mergedValueRef;
            if (mergedValue === null) {
              if (!props.validator) {
                doUpdateValue(createValidValue());
              }
            } else {
              const { value: mergedStep } = mergedStepRef;
              deriveValueFromDisplayedValue({
                offset: mergedStep,
                doUpdateIfValid: true,
                isInputing: false,
                fixPrecision: true
              });
            }
          }
          function doMinus() {
            const { value: minusable } = minusableRef;
            if (!minusable) {
              clearMinusHoldTimeout();
              return;
            }
            const { value: mergedValue } = mergedValueRef;
            if (mergedValue === null) {
              if (!props.validator) {
                doUpdateValue(createValidValue());
              }
            } else {
              const { value: mergedStep } = mergedStepRef;
              deriveValueFromDisplayedValue({
                offset: -mergedStep,
                doUpdateIfValid: true,
                isInputing: false,
                fixPrecision: true
              });
            }
          }
          const handleFocus = doFocus;
          const handleBlur = doBlur;
          function createValidValue() {
            if (props.validator)
              return null;
            const { value: mergedMin } = mergedMinRef;
            const { value: mergedMax } = mergedMaxRef;
            if (mergedMin !== null) {
              return Math.max(0, mergedMin);
            } else if (mergedMax !== null) {
              return Math.min(0, mergedMax);
            } else {
              return 0;
            }
          }
          function handleClear(e) {
            doClear(e);
            doUpdateValue(null);
          }
          function handleMouseDown(e) {
            var _a, _b, _c;
            if ((_a = addButtonInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.target)) {
              e.preventDefault();
            }
            if ((_b = minusButtonInstRef.value) === null || _b === void 0 ? void 0 : _b.$el.contains(e.target)) {
              e.preventDefault();
            }
            (_c = inputInstRef.value) === null || _c === void 0 ? void 0 : _c.activate();
          }
          let minusHoldStateIntervalId = null;
          let addHoldStateIntervalId = null;
          let firstMinusMousedownId = null;
          function clearMinusHoldTimeout() {
            if (firstMinusMousedownId) {
              window.clearTimeout(firstMinusMousedownId);
              firstMinusMousedownId = null;
            }
            if (minusHoldStateIntervalId) {
              window.clearInterval(minusHoldStateIntervalId);
              minusHoldStateIntervalId = null;
            }
          }
          function clearAddHoldTimeout() {
            if (firstAddMousedownId) {
              window.clearTimeout(firstAddMousedownId);
              firstAddMousedownId = null;
            }
            if (addHoldStateIntervalId) {
              window.clearInterval(addHoldStateIntervalId);
              addHoldStateIntervalId = null;
            }
          }
          function handleMinusMousedown() {
            clearMinusHoldTimeout();
            firstMinusMousedownId = window.setTimeout(() => {
              minusHoldStateIntervalId = window.setInterval(() => {
                doMinus();
              }, HOLDING_CHANGE_INTERVAL);
            }, HOLDING_CHANGE_THRESHOLD);
            on("mouseup", document, clearMinusHoldTimeout, {
              once: true
            });
          }
          let firstAddMousedownId = null;
          function handleAddMousedown() {
            clearAddHoldTimeout();
            firstAddMousedownId = window.setTimeout(() => {
              addHoldStateIntervalId = window.setInterval(() => {
                doAdd();
              }, HOLDING_CHANGE_INTERVAL);
            }, HOLDING_CHANGE_THRESHOLD);
            on("mouseup", document, clearAddHoldTimeout, {
              once: true
            });
          }
          const handleAddClick = () => {
            if (addHoldStateIntervalId)
              return;
            doAdd();
          };
          const handleMinusClick = () => {
            if (minusHoldStateIntervalId)
              return;
            doMinus();
          };
          function handleKeyDown(e) {
            var _a, _b;
            if (e.key === "Enter") {
              if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
                return;
              }
              const value = deriveValueFromDisplayedValue({
                offset: 0,
                doUpdateIfValid: true,
                isInputing: false,
                fixPrecision: true
              });
              if (value !== false) {
                (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.deactivate();
              }
            } else if (e.key === "ArrowUp") {
              if (!addableRef.value)
                return;
              if (props.keyboard.ArrowUp === false)
                return;
              e.preventDefault();
              const value = deriveValueFromDisplayedValue({
                offset: 0,
                doUpdateIfValid: true,
                isInputing: false,
                fixPrecision: true
              });
              if (value !== false) {
                doAdd();
              }
            } else if (e.key === "ArrowDown") {
              if (!minusableRef.value)
                return;
              if (props.keyboard.ArrowDown === false)
                return;
              e.preventDefault();
              const value = deriveValueFromDisplayedValue({
                offset: 0,
                doUpdateIfValid: true,
                isInputing: false,
                fixPrecision: true
              });
              if (value !== false) {
                doMinus();
              }
            }
          }
          function handleUpdateDisplayedValue(value) {
            displayedValueRef.value = value;
            if (props.updateValueOnInput && !props.format && !props.parse && props.precision === void 0) {
              deriveValueFromDisplayedValue({
                offset: 0,
                doUpdateIfValid: true,
                isInputing: true,
                fixPrecision: false
              });
            }
          }
          vue.watch(mergedValueRef, () => {
            deriveDisplayedValueFromValue();
          });
          const exposedMethods = {
            focus: () => {
              var _a;
              return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          const rtlEnabledRef = useRtl("InputNumber", mergedRtlRef, mergedClsPrefixRef);
          return Object.assign(Object.assign({}, exposedMethods), {
            rtlEnabled: rtlEnabledRef,
            inputInstRef,
            minusButtonInstRef,
            addButtonInstRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            mergedPlaceholder: mergedPlaceholderRef,
            displayedValueInvalid: displayedValueInvalidRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            displayedValue: displayedValueRef,
            addable: addableRef,
            minusable: minusableRef,
            mergedStatus: mergedStatusRef,
            handleFocus,
            handleBlur,
            handleClear,
            handleMouseDown,
            handleAddClick,
            handleMinusClick,
            handleAddMousedown,
            handleMinusMousedown,
            handleKeyDown,
            handleUpdateDisplayedValue,
            // theme
            mergedTheme: themeRef,
            inputThemeOverrides: {
              paddingSmall: "0 8px 0 10px",
              paddingMedium: "0 8px 0 12px",
              paddingLarge: "0 8px 0 14px"
            },
            buttonThemeOverrides: vue.computed(() => {
              const { self: { iconColorDisabled } } = themeRef.value;
              const [r, g, b, a2] = rgba(iconColorDisabled);
              return {
                textColorTextDisabled: `rgb(${r}, ${g}, ${b})`,
                opacityDisabled: `${a2}`
              };
            })
          });
        },
        render() {
          const { mergedClsPrefix, $slots } = this;
          const renderMinusButton = () => {
            return vue.h(XButton, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, {
              icon: () => resolveSlot($slots["minus-icon"], () => [
                vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                  default: () => vue.h(RemoveIcon, null)
                })
              ])
            });
          };
          const renderAddButton = () => {
            return vue.h(XButton, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, {
              icon: () => resolveSlot($slots["add-icon"], () => [
                vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                  default: () => vue.h(AddIcon, null)
                })
              ])
            });
          };
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-input-number`,
              this.rtlEnabled && `${mergedClsPrefix}-input-number--rtl`
            ] },
            vue.h(NInput, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, internalLoadingBeforeSuffix: true }, {
              prefix: () => {
                var _a;
                return this.showButton && this.buttonPlacement === "both" ? [
                  renderMinusButton(),
                  resolveWrappedSlot($slots.prefix, (children) => {
                    if (children) {
                      return vue.h("span", { class: `${mergedClsPrefix}-input-number-prefix` }, children);
                    }
                    return null;
                  })
                ] : (_a = $slots.prefix) === null || _a === void 0 ? void 0 : _a.call($slots);
              },
              suffix: () => {
                var _a;
                return this.showButton ? [
                  resolveWrappedSlot($slots.suffix, (children) => {
                    if (children) {
                      return vue.h("span", { class: `${mergedClsPrefix}-input-number-suffix` }, children);
                    }
                    return null;
                  }),
                  this.buttonPlacement === "right" ? renderMinusButton() : null,
                  renderAddButton()
                ] : (_a = $slots.suffix) === null || _a === void 0 ? void 0 : _a.call($slots);
              }
            })
          );
        }
      });
      const layoutSiderInjectionKey = createInjectionKey("n-layout-sider");
      const positionProp = {
        type: String,
        default: "static"
      };
      const style$C = cB("layout", `
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 flex: auto;
 overflow: hidden;
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
`, [cB("layout-scroll-container", `
 overflow-x: hidden;
 box-sizing: border-box;
 height: 100%;
 `), cM("absolute-positioned", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]);
      const layoutProps = {
        embedded: Boolean,
        position: positionProp,
        nativeScrollbar: {
          type: Boolean,
          default: true
        },
        scrollbarProps: Object,
        onScroll: Function,
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        hasSider: Boolean,
        siderPlacement: {
          type: String,
          default: "left"
        }
      };
      const layoutInjectionKey = createInjectionKey("n-layout");
      function createLayoutComponent(isContent) {
        return vue.defineComponent({
          name: isContent ? "LayoutContent" : "Layout",
          props: Object.assign(Object.assign({}, useTheme.props), layoutProps),
          setup(props) {
            const scrollableElRef = vue.ref(null);
            const scrollbarInstRef = vue.ref(null);
            const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
            const themeRef = useTheme("Layout", "-layout", style$C, layoutLight$1, props, mergedClsPrefixRef);
            function scrollTo(options, y) {
              if (props.nativeScrollbar) {
                const { value: scrollableEl } = scrollableElRef;
                if (scrollableEl) {
                  if (y === void 0) {
                    scrollableEl.scrollTo(options);
                  } else {
                    scrollableEl.scrollTo(options, y);
                  }
                }
              } else {
                const { value: scrollbarInst } = scrollbarInstRef;
                if (scrollbarInst) {
                  scrollbarInst.scrollTo(options, y);
                }
              }
            }
            vue.provide(layoutInjectionKey, props);
            let scrollX = 0;
            let scrollY = 0;
            const handleNativeElScroll = (e) => {
              var _a;
              const target = e.target;
              scrollX = target.scrollLeft;
              scrollY = target.scrollTop;
              (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
            };
            useReactivated(() => {
              if (props.nativeScrollbar) {
                const el = scrollableElRef.value;
                if (el) {
                  el.scrollTop = scrollY;
                  el.scrollLeft = scrollX;
                }
              }
            });
            const hasSiderStyle = {
              display: "flex",
              flexWrap: "nowrap",
              width: "100%",
              flexDirection: "row"
            };
            const exposedMethods = {
              scrollTo
            };
            const cssVarsRef = vue.computed(() => {
              const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
              return {
                "--n-bezier": cubicBezierEaseInOut2,
                "--n-color": props.embedded ? self2.colorEmbedded : self2.color,
                "--n-text-color": self2.textColor
              };
            });
            const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout", vue.computed(() => {
              return props.embedded ? "e" : "";
            }), cssVarsRef, props) : void 0;
            return Object.assign({
              mergedClsPrefix: mergedClsPrefixRef,
              scrollableElRef,
              scrollbarInstRef,
              hasSiderStyle,
              mergedTheme: themeRef,
              handleNativeElScroll,
              cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
            }, exposedMethods);
          },
          render() {
            var _a;
            const { mergedClsPrefix, hasSider } = this;
            (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
            const hasSiderStyle = hasSider ? this.hasSiderStyle : void 0;
            const layoutClass = [
              this.themeClass,
              isContent && `${mergedClsPrefix}-layout-content`,
              `${mergedClsPrefix}-layout`,
              `${mergedClsPrefix}-layout--${this.position}-positioned`
            ];
            return vue.h("div", { class: layoutClass, style: this.cssVars }, this.nativeScrollbar ? vue.h("div", { ref: "scrollableElRef", class: `${mergedClsPrefix}-layout-scroll-container`, style: [this.contentStyle, hasSiderStyle], onScroll: this.handleNativeElScroll }, this.$slots) : vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, { onScroll: this.onScroll, ref: "scrollbarInstRef", theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, contentStyle: [this.contentStyle, hasSiderStyle] }), this.$slots));
          }
        });
      }
      const Layout = createLayoutComponent(false);
      const LayoutContent = createLayoutComponent(true);
      const style$B = cB("layout-header", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 box-sizing: border-box;
 width: 100%;
 background-color: var(--n-color);
 color: var(--n-text-color);
`, [cM("absolute-positioned", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 `), cM("bordered", `
 border-bottom: solid 1px var(--n-border-color);
 `)]);
      const headerProps$1 = {
        position: positionProp,
        inverted: Boolean,
        bordered: {
          type: Boolean,
          default: false
        }
      };
      const LayoutHeader = vue.defineComponent({
        name: "LayoutHeader",
        props: Object.assign(Object.assign({}, useTheme.props), headerProps$1),
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Layout", "-layout-header", style$B, layoutLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const vars = {
              "--n-bezier": cubicBezierEaseInOut2
            };
            if (props.inverted) {
              vars["--n-color"] = self2.headerColorInverted;
              vars["--n-text-color"] = self2.textColorInverted;
              vars["--n-border-color"] = self2.headerBorderColorInverted;
            } else {
              vars["--n-color"] = self2.headerColor;
              vars["--n-text-color"] = self2.textColor;
              vars["--n-border-color"] = self2.headerBorderColor;
            }
            return vars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout-header", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", { class: [
            `${mergedClsPrefix}-layout-header`,
            this.themeClass,
            this.position && `${mergedClsPrefix}-layout-header--${this.position}-positioned`,
            this.bordered && `${mergedClsPrefix}-layout-header--bordered`
          ], style: this.cssVars }, this.$slots);
        }
      });
      const style$A = cB("layout-footer", `
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-sizing: border-box;
`, [cM("absolute-positioned", `
 position: absolute;
 left: 0;
 right: 0;
 bottom: 0;
 `), cM("bordered", `
 border-top: solid 1px var(--n-border-color);
 `)]);
      const layoutFooterProps = Object.assign(Object.assign({}, useTheme.props), { inverted: Boolean, position: positionProp, bordered: Boolean });
      const LayoutFooter = vue.defineComponent({
        name: "LayoutFooter",
        props: layoutFooterProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Layout", "-layout-footer", style$A, layoutLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const vars = {
              "--n-bezier": cubicBezierEaseInOut2
            };
            if (props.inverted) {
              vars["--n-color"] = self2.footerColorInverted;
              vars["--n-text-color"] = self2.textColorInverted;
              vars["--n-border-color"] = self2.footerBorderColorInverted;
            } else {
              vars["--n-color"] = self2.footerColor;
              vars["--n-text-color"] = self2.textColor;
              vars["--n-border-color"] = self2.footerBorderColor;
            }
            return vars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout-footer", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", { class: [
            `${mergedClsPrefix}-layout-footer`,
            this.themeClass,
            this.position && `${mergedClsPrefix}-layout-footer--${this.position}-positioned`,
            this.bordered && `${mergedClsPrefix}-layout-footer--bordered`
          ], style: this.cssVars }, this.$slots);
        }
      });
      const style$z = cB("layout-sider", `
 flex-shrink: 0;
 box-sizing: border-box;
 position: relative;
 z-index: 1;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 min-width .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 display: flex;
 justify-content: flex-end;
`, [cM("bordered", [cE("border", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 width: 1px;
 background-color: var(--n-border-color);
 transition: background-color .3s var(--n-bezier);
 `)]), cE("left-placement", [cM("bordered", [cE("border", `
 right: 0;
 `)])]), cM("right-placement", `
 justify-content: flex-start;
 `, [cM("bordered", [cE("border", `
 left: 0;
 `)]), cM("collapsed", [cB("layout-toggle-button", [cB("base-icon", `
 transform: rotate(180deg);
 `)]), cB("layout-toggle-bar", [c$1("&:hover", [cE("top", {
        transform: "rotate(-12deg) scale(1.15) translateY(-2px)"
      }), cE("bottom", {
        transform: "rotate(12deg) scale(1.15) translateY(2px)"
      })])])]), cB("layout-toggle-button", `
 left: 0;
 transform: translateX(-50%) translateY(-50%);
 `, [cB("base-icon", `
 transform: rotate(0);
 `)]), cB("layout-toggle-bar", `
 left: -28px;
 transform: rotate(180deg);
 `, [c$1("&:hover", [cE("top", {
        transform: "rotate(12deg) scale(1.15) translateY(-2px)"
      }), cE("bottom", {
        transform: "rotate(-12deg) scale(1.15) translateY(2px)"
      })])])]), cM("collapsed", [cB("layout-toggle-bar", [c$1("&:hover", [cE("top", {
        transform: "rotate(-12deg) scale(1.15) translateY(-2px)"
      }), cE("bottom", {
        transform: "rotate(12deg) scale(1.15) translateY(2px)"
      })])]), cB("layout-toggle-button", [cB("base-icon", `
 transform: rotate(0);
 `)])]), cB("layout-toggle-button", `
 transition:
 color .3s var(--n-bezier),
 right .3s var(--n-bezier),
 left .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 cursor: pointer;
 width: 24px;
 height: 24px;
 position: absolute;
 top: 50%;
 right: 0;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 18px;
 color: var(--n-toggle-button-icon-color);
 border: var(--n-toggle-button-border);
 background-color: var(--n-toggle-button-color);
 box-shadow: 0 2px 4px 0px rgba(0, 0, 0, .06);
 transform: translateX(50%) translateY(-50%);
 z-index: 1;
 `, [cB("base-icon", `
 transition: transform .3s var(--n-bezier);
 transform: rotate(180deg);
 `)]), cB("layout-toggle-bar", `
 cursor: pointer;
 height: 72px;
 width: 32px;
 position: absolute;
 top: calc(50% - 36px);
 right: -28px;
 `, [cE("top, bottom", `
 position: absolute;
 width: 4px;
 border-radius: 2px;
 height: 38px;
 left: 14px;
 transition: 
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cE("bottom", `
 position: absolute;
 top: 34px;
 `), c$1("&:hover", [cE("top", {
        transform: "rotate(12deg) scale(1.15) translateY(-2px)"
      }), cE("bottom", {
        transform: "rotate(-12deg) scale(1.15) translateY(2px)"
      })]), cE("top, bottom", {
        backgroundColor: "var(--n-toggle-bar-color)"
      }), c$1("&:hover", [cE("top, bottom", {
        backgroundColor: "var(--n-toggle-bar-color-hover)"
      })])]), cE("border", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 width: 1px;
 transition: background-color .3s var(--n-bezier);
 `), cB("layout-sider-scroll-container", `
 flex-grow: 1;
 flex-shrink: 0;
 box-sizing: border-box;
 height: 100%;
 opacity: 0;
 transition: opacity .3s var(--n-bezier);
 max-width: 100%;
 `), cM("show-content", [cB("layout-sider-scroll-container", {
        opacity: 1
      })]), cM("absolute-positioned", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 `)]);
      const ToggleButton = vue.defineComponent({
        name: "LayoutToggleButton",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          onClick: Function
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-layout-toggle-button`, onClick: this.onClick },
            vue.h(NBaseIcon, { clsPrefix }, {
              default: () => vue.h(ChevronRightIcon, null)
            })
          );
        }
      });
      const ToggleBar = vue.defineComponent({
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          onClick: Function
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { onClick: this.onClick, class: `${clsPrefix}-layout-toggle-bar` },
            vue.h("div", { class: `${clsPrefix}-layout-toggle-bar__top` }),
            vue.h("div", { class: `${clsPrefix}-layout-toggle-bar__bottom` })
          );
        }
      });
      const layoutSiderProps = {
        position: positionProp,
        bordered: Boolean,
        collapsedWidth: {
          type: Number,
          default: 48
        },
        width: {
          type: [Number, String],
          default: 272
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        collapseMode: {
          type: String,
          default: "transform"
        },
        collapsed: {
          type: Boolean,
          default: void 0
        },
        defaultCollapsed: Boolean,
        showCollapsedContent: {
          type: Boolean,
          default: true
        },
        showTrigger: {
          type: [Boolean, String],
          default: false
        },
        nativeScrollbar: {
          type: Boolean,
          default: true
        },
        inverted: Boolean,
        scrollbarProps: Object,
        triggerStyle: [String, Object],
        collapsedTriggerStyle: [String, Object],
        "onUpdate:collapsed": [Function, Array],
        onUpdateCollapsed: [Function, Array],
        onAfterEnter: Function,
        onAfterLeave: Function,
        // deprecated
        onExpand: [Function, Array],
        onCollapse: [Function, Array],
        onScroll: Function
      };
      const LayoutSider = vue.defineComponent({
        name: "LayoutSider",
        props: Object.assign(Object.assign({}, useTheme.props), layoutSiderProps),
        setup(props) {
          const layoutProps2 = vue.inject(layoutInjectionKey);
          const scrollableElRef = vue.ref(null);
          const scrollbarInstRef = vue.ref(null);
          const styleMaxWidthRef = vue.computed(() => {
            return formatLength(mergedCollapsedRef.value ? props.collapsedWidth : props.width);
          });
          const scrollContainerStyleRef = vue.computed(() => {
            if (props.collapseMode !== "transform")
              return {};
            return {
              minWidth: formatLength(props.width)
            };
          });
          const siderPlacementRef = vue.computed(() => {
            return layoutProps2 ? layoutProps2.siderPlacement : "left";
          });
          const uncontrolledCollapsedRef = vue.ref(props.defaultCollapsed);
          const mergedCollapsedRef = useMergedState(vue.toRef(props, "collapsed"), uncontrolledCollapsedRef);
          function scrollTo(options, y) {
            if (props.nativeScrollbar) {
              const { value: scrollableEl } = scrollableElRef;
              if (scrollableEl) {
                if (y === void 0) {
                  scrollableEl.scrollTo(options);
                } else {
                  scrollableEl.scrollTo(options, y);
                }
              }
            } else {
              const { value: scrollbarInst } = scrollbarInstRef;
              if (scrollbarInst) {
                scrollbarInst.scrollTo(options, y);
              }
            }
          }
          function handleTriggerClick() {
            const {
              "onUpdate:collapsed": _onUpdateCollapsed,
              onUpdateCollapsed,
              // deprecated
              onExpand,
              onCollapse
            } = props;
            const { value: collapsed } = mergedCollapsedRef;
            if (onUpdateCollapsed) {
              call(onUpdateCollapsed, !collapsed);
            }
            if (_onUpdateCollapsed) {
              call(_onUpdateCollapsed, !collapsed);
            }
            uncontrolledCollapsedRef.value = !collapsed;
            if (collapsed) {
              if (onExpand)
                call(onExpand);
            } else {
              if (onCollapse)
                call(onCollapse);
            }
          }
          let scrollX = 0;
          let scrollY = 0;
          const handleNativeElScroll = (e) => {
            var _a;
            const target = e.target;
            scrollX = target.scrollLeft;
            scrollY = target.scrollTop;
            (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          };
          useReactivated(() => {
            if (props.nativeScrollbar) {
              const el = scrollableElRef.value;
              if (el) {
                el.scrollTop = scrollY;
                el.scrollLeft = scrollX;
              }
            }
          });
          vue.provide(layoutSiderInjectionKey, {
            collapsedRef: mergedCollapsedRef,
            collapseModeRef: vue.toRef(props, "collapseMode")
          });
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Layout", "-layout-sider", style$z, layoutLight$1, props, mergedClsPrefixRef);
          function handleTransitionend(e) {
            var _a, _b;
            if (e.propertyName === "max-width") {
              if (mergedCollapsedRef.value) {
                (_a = props.onAfterLeave) === null || _a === void 0 ? void 0 : _a.call(props);
              } else {
                (_b = props.onAfterEnter) === null || _b === void 0 ? void 0 : _b.call(props);
              }
            }
          }
          const exposedMethods = {
            scrollTo
          };
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const { siderToggleButtonColor, siderToggleButtonBorder, siderToggleBarColor, siderToggleBarColorHover } = self2;
            const vars = {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-toggle-button-color": siderToggleButtonColor,
              "--n-toggle-button-border": siderToggleButtonBorder,
              "--n-toggle-bar-color": siderToggleBarColor,
              "--n-toggle-bar-color-hover": siderToggleBarColorHover
            };
            if (props.inverted) {
              vars["--n-color"] = self2.siderColorInverted;
              vars["--n-text-color"] = self2.textColorInverted;
              vars["--n-border-color"] = self2.siderBorderColorInverted;
              vars["--n-toggle-button-icon-color"] = self2.siderToggleButtonIconColorInverted;
              vars.__invertScrollbar = self2.__invertScrollbar;
            } else {
              vars["--n-color"] = self2.siderColor;
              vars["--n-text-color"] = self2.textColor;
              vars["--n-border-color"] = self2.siderBorderColor;
              vars["--n-toggle-button-icon-color"] = self2.siderToggleButtonIconColor;
            }
            return vars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout-sider", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
          return Object.assign({
            scrollableElRef,
            scrollbarInstRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
            styleMaxWidth: styleMaxWidthRef,
            mergedCollapsed: mergedCollapsedRef,
            scrollContainerStyle: scrollContainerStyleRef,
            siderPlacement: siderPlacementRef,
            handleNativeElScroll,
            handleTransitionend,
            handleTriggerClick,
            inlineThemeDisabled,
            cssVars: cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedMethods);
        },
        render() {
          var _a;
          const { mergedClsPrefix, mergedCollapsed, showTrigger } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "aside",
            { class: [
              `${mergedClsPrefix}-layout-sider`,
              this.themeClass,
              `${mergedClsPrefix}-layout-sider--${this.position}-positioned`,
              `${mergedClsPrefix}-layout-sider--${this.siderPlacement}-placement`,
              this.bordered && `${mergedClsPrefix}-layout-sider--bordered`,
              mergedCollapsed && `${mergedClsPrefix}-layout-sider--collapsed`,
              (!mergedCollapsed || this.showCollapsedContent) && `${mergedClsPrefix}-layout-sider--show-content`
            ], onTransitionend: this.handleTransitionend, style: [
              this.inlineThemeDisabled ? void 0 : this.cssVars,
              {
                maxWidth: this.styleMaxWidth,
                width: formatLength(this.width)
              }
            ] },
            !this.nativeScrollbar ? vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, {
              onScroll: this.onScroll,
              ref: "scrollbarInstRef",
              style: this.scrollContainerStyle,
              contentStyle: this.contentStyle,
              theme: this.mergedTheme.peers.Scrollbar,
              themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
              // here is a hack, since in light theme the scrollbar color is dark,
              // we need to invert it in light color...
              builtinThemeOverrides: this.inverted && this.cssVars.__invertScrollbar === "true" ? {
                colorHover: "rgba(255, 255, 255, .4)",
                color: "rgba(255, 255, 255, .3)"
              } : void 0
            }), this.$slots) : vue.h("div", { class: `${mergedClsPrefix}-layout-sider-scroll-container`, onScroll: this.handleNativeElScroll, style: [
              this.scrollContainerStyle,
              {
                overflow: "auto"
              },
              this.contentStyle
            ], ref: "scrollableElRef" }, this.$slots),
            showTrigger ? showTrigger === "bar" ? vue.h(ToggleBar, { clsPrefix: mergedClsPrefix, style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle, onClick: this.handleTriggerClick }) : vue.h(ToggleButton, { clsPrefix: mergedClsPrefix, style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle, onClick: this.handleTriggerClick }) : null,
            this.bordered ? vue.h("div", { class: `${mergedClsPrefix}-layout-sider__border` }) : null
          );
        }
      });
      const commonVariables = {
        extraFontSize: "12px",
        width: "440px"
      };
      const transferDark = {
        name: "Transfer",
        common: commonDark,
        peers: {
          Checkbox: checkboxDark$1,
          Scrollbar: scrollbarDark$1,
          Input: inputDark$1,
          Empty: emptyDark$1,
          Button: buttonDark$1
        },
        self(vars) {
          const { iconColorDisabled, iconColor, fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, heightSmall, borderRadius, inputColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, hoverColor } = vars;
          return Object.assign(Object.assign({}, commonVariables), {
            itemHeightSmall: heightSmall,
            itemHeightMedium: heightMedium,
            itemHeightLarge: heightLarge,
            fontSizeSmall,
            fontSizeMedium,
            fontSizeLarge,
            borderRadius,
            borderColor: "#0000",
            listColor: inputColor,
            headerColor: tableHeaderColor,
            titleTextColor: textColor1,
            titleTextColorDisabled: textColorDisabled,
            extraTextColor: textColor2,
            filterDividerColor: "#0000",
            itemTextColor: textColor2,
            itemTextColorDisabled: textColorDisabled,
            itemColorPending: hoverColor,
            titleFontWeight: fontWeight,
            iconColor,
            iconColorDisabled
          });
        }
      };
      const legacyTransferDark = transferDark;
      const self$3 = (vars) => {
        const { fontWeight, iconColorDisabled, iconColor, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, heightSmall, borderRadius, cardColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, borderColor, hoverColor } = vars;
        return Object.assign(Object.assign({}, commonVariables), {
          itemHeightSmall: heightSmall,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor,
          listColor: cardColor,
          headerColor: composite(cardColor, tableHeaderColor),
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor2,
          filterDividerColor: borderColor,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          iconColor,
          iconColorDisabled
        });
      };
      const transferLight = createTheme({
        name: "Transfer",
        common: commonLight,
        peers: {
          Checkbox: checkboxLight$1,
          Scrollbar: scrollbarLight$1,
          Input: inputLight$1,
          Empty: emptyLight$1,
          Button: buttonLight$1
        },
        self: self$3
      });
      const legacyTransferLight = transferLight;
      const transferInjectionKey$1 = createInjectionKey("n-transfer");
      const NTransferHeader$1 = vue.defineComponent({
        name: "TransferHeader",
        props: {
          source: {
            type: Boolean,
            default: false
          },
          onChange: {
            type: Function,
            required: true
          },
          title: String
        },
        setup(props) {
          const {
            srcOptsRef,
            tgtOptsRef,
            srcCheckedStatusRef,
            tgtCheckedStatusRef,
            srcCheckedValuesRef,
            tgtCheckedValuesRef,
            mergedThemeRef,
            disabledRef,
            mergedClsPrefixRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(transferInjectionKey$1);
          const checkboxPropsRef = vue.computed(() => {
            const { source } = props;
            if (source) {
              return srcCheckedStatusRef.value;
            } else {
              return tgtCheckedStatusRef.value;
            }
          });
          return () => {
            const { source } = props;
            const { value: checkboxProps2 } = checkboxPropsRef;
            const { value: mergedTheme } = mergedThemeRef;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            return vue.h(
              "div",
              { class: `${mergedClsPrefix}-legacy-transfer-list-header` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-legacy-transfer-list-header__checkbox` },
                vue.h(NCheckbox, { theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, checked: checkboxProps2.checked, indeterminate: checkboxProps2.indeterminate, disabled: checkboxProps2.disabled || disabledRef.value, onUpdateChecked: props.onChange })
              ),
              vue.h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-header__header` }, props.title),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-legacy-transfer-list-header__extra` },
                source ? srcCheckedValuesRef.value.length : tgtCheckedValuesRef.value.length,
                "/",
                source ? srcOptsRef.value.length : tgtOptsRef.value.length
              )
            );
          };
        }
      });
      const NTransferListItem$1 = vue.defineComponent({
        name: "NTransferListItem",
        props: {
          source: {
            type: Boolean,
            default: false
          },
          label: {
            type: String,
            required: true
          },
          value: {
            type: [String, Number],
            required: true
          },
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props) {
          const { source } = props;
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            srcCheckedValuesRef,
            tgtCheckedValuesRef,
            handleSrcCheckboxClick,
            handleTgtCheckboxClick
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(transferInjectionKey$1);
          const checkedRef = source ? useMemo(() => srcCheckedValuesRef.value.includes(props.value)) : useMemo(() => tgtCheckedValuesRef.value.includes(props.value));
          const handleClick2 = source ? () => {
            if (!props.disabled) {
              handleSrcCheckboxClick(!checkedRef.value, props.value);
            }
          } : () => {
            if (!props.disabled) {
              handleTgtCheckboxClick(!checkedRef.value, props.value);
            }
          };
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            checked: checkedRef,
            handleClick: handleClick2
          };
        },
        render() {
          const { disabled, mergedTheme, mergedClsPrefix, label, checked, source } = this;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-legacy-transfer-list-item`,
              disabled && `${mergedClsPrefix}-legacy-transfer-list-item--disabled`,
              source ? `${mergedClsPrefix}-legacy-transfer-list-item--source` : `${mergedClsPrefix}-legacy-transfer-list-item--target`
            ], onClick: this.handleClick },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-legacy-transfer-list-item__checkbox` },
              vue.h(NCheckbox, { theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, disabled, checked })
            ),
            vue.h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-item__label`, title: getTitleAttribute(label) }, label)
          );
        }
      });
      const NTransferList$1 = vue.defineComponent({
        name: "TransferList",
        props: {
          virtualScroll: {
            type: Boolean,
            required: true
          },
          itemSize: {
            type: Number,
            required: true
          },
          options: {
            type: Array,
            required: true
          },
          disabled: {
            type: Boolean,
            required: true
          },
          isMounted: {
            type: Boolean,
            required: true
          },
          isInputing: {
            type: Boolean,
            required: true
          },
          source: {
            type: Boolean,
            default: false
          }
        },
        setup() {
          const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey$1);
          const scrollerInstRef = vue.ref(null);
          const vlInstRef = vue.ref(null);
          function syncVLScroller() {
            var _a;
            (_a = scrollerInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function scrollContainer() {
            const { value } = vlInstRef;
            if (!value)
              return null;
            const { listElRef } = value;
            return listElRef;
          }
          function scrollContent() {
            const { value } = vlInstRef;
            if (!value)
              return null;
            const { itemsElRef } = value;
            return itemsElRef;
          }
          return {
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            scrollerInstRef,
            vlInstRef,
            syncVLScroller,
            scrollContainer,
            scrollContent
          };
        },
        render() {
          const { mergedTheme, mergedClsPrefix, virtualScroll, syncVLScroller } = this;
          return vue.h(
            vue.Fragment,
            null,
            vue.h(NScrollbar, { ref: "scrollerInstRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: virtualScroll ? this.scrollContainer : void 0, content: virtualScroll ? this.scrollContent : void 0 }, {
              default: () => virtualScroll ? vue.h(VVirtualList, { ref: "vlInstRef", style: { height: "100%" }, class: `${mergedClsPrefix}-legacy-transfer-list-content`, items: this.options, itemSize: this.itemSize, showScrollbar: false, onResize: syncVLScroller, onScroll: syncVLScroller, keyField: "value" }, {
                default: ({ item }) => {
                  const { source, disabled } = this;
                  return vue.h(NTransferListItem$1, { source, key: item.value, value: item.value, disabled: item.disabled || disabled, label: item.label });
                }
              }) : vue.h(
                "div",
                { class: `${mergedClsPrefix}-legacy-transfer-list-content` },
                vue.h(vue.TransitionGroup, { name: "item", appear: this.isMounted, css: !this.isInputing }, {
                  default: () => {
                    const { source, disabled } = this;
                    return this.options.map((option) => vue.h(NTransferListItem$1, { source, key: option.value, value: option.value, disabled: option.disabled || disabled, label: option.label }));
                  }
                })
              )
            }),
            vue.h(vue.Transition, { name: "fade-in-transition", appear: this.isMounted, css: !this.isInputing }, {
              default: () => this.options.length ? null : vue.h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
            })
          );
        }
      });
      const NTransferFilter$1 = vue.defineComponent({
        name: "TransferFilter",
        props: {
          value: String,
          placeholder: String,
          disabled: Boolean,
          onFocus: {
            type: Function,
            required: true
          },
          onBlur: {
            type: Function,
            required: true
          },
          onUpdateValue: {
            type: Function,
            required: true
          }
        },
        setup() {
          const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey$1);
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef
          };
        },
        render() {
          const { mergedTheme, mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-legacy-transfer-filter` },
            vue.h(NInput, { value: this.value, onUpdateValue: this.onUpdateValue, disabled: this.disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, clearable: true, size: "small", placeholder: this.placeholder, onFocus: this.onFocus, onBlur: this.onBlur }, {
              "clear-icon-placeholder": () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-legacy-transfer-icon` }, { default: () => vue.h(SearchIcon, null) })
            })
          );
        }
      });
      function useTransferData$1(props, mergedDisabledRef) {
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const optMapRef = vue.computed(() => {
          const map2 = /* @__PURE__ */ new Map();
          (props.options || []).forEach((opt) => map2.set(opt.value, opt));
          return map2;
        });
        const tgtValueSetRef = vue.computed(() => new Set(mergedValueRef.value || []));
        const srcOptsRef = vue.computed(() => props.options.filter((option) => !tgtValueSetRef.value.has(option.value)));
        const tgtOptsRef = vue.computed(() => {
          const optMap = optMapRef.value;
          return (mergedValueRef.value || []).map((v) => optMap.get(v));
        });
        const srcPatternRef = vue.ref("");
        const tgtPatternRef = vue.ref("");
        const filteredSrcOptsRef = vue.computed(() => {
          if (!props.filterable)
            return srcOptsRef.value;
          const { filter } = props;
          return srcOptsRef.value.filter((opt) => filter(srcPatternRef.value, opt, "source"));
        });
        const filteredTgtOptsRef = vue.computed(() => {
          if (!props.filterable)
            return tgtOptsRef.value;
          const { filter } = props;
          return tgtOptsRef.value.filter((opt) => filter(tgtPatternRef.value, opt, "target"));
        });
        const avlSrcValueSetRef = vue.computed(() => new Set(filteredSrcOptsRef.value.filter((opt) => !opt.disabled).map((opt) => opt.value)));
        const avlTgtValueSetRef = vue.computed(() => new Set(filteredTgtOptsRef.value.filter((opt) => !opt.disabled).map((opt) => opt.value)));
        const srcCheckedValuesRef = vue.ref([]);
        const tgtCheckedValuesRef = vue.ref([]);
        const srcCheckedStatusRef = vue.computed(() => {
          const srcCheckedLength = srcCheckedValuesRef.value.filter((v) => avlSrcValueSetRef.value.has(v)).length;
          const avlValueCount = avlSrcValueSetRef.value.size;
          if (avlValueCount === 0) {
            return {
              checked: false,
              indeterminate: false,
              disabled: true
            };
          } else if (srcCheckedLength === 0) {
            return {
              checked: false,
              indeterminate: false
            };
          } else if (srcCheckedLength === avlValueCount) {
            return {
              checked: true,
              indeterminate: false
            };
          } else {
            return {
              checked: false,
              indeterminate: true
            };
          }
        });
        const tgtCheckedStatusRef = vue.computed(() => {
          const tgtCheckedLength = tgtCheckedValuesRef.value.filter((v) => avlTgtValueSetRef.value.has(v)).length;
          const avlValueCount = avlTgtValueSetRef.value.size;
          if (avlValueCount === 0) {
            return {
              checked: false,
              indeterminate: false,
              disabled: true
            };
          } else if (tgtCheckedLength === 0) {
            return {
              checked: false,
              indeterminate: false
            };
          } else if (tgtCheckedLength === avlValueCount) {
            return {
              checked: true,
              indeterminate: false
            };
          } else {
            return {
              checked: false,
              indeterminate: true
            };
          }
        });
        const fromButtonDisabledRef = useMemo(() => {
          if (mergedDisabledRef.value)
            return true;
          return tgtCheckedValuesRef.value.length === 0;
        });
        const toButtonDisabledRef = useMemo(() => {
          if (mergedDisabledRef.value)
            return true;
          return srcCheckedValuesRef.value.length === 0;
        });
        const isInputingRef = vue.ref(false);
        function handleInputFocus() {
          isInputingRef.value = true;
        }
        function handleInputBlur() {
          isInputingRef.value = false;
        }
        function handleSrcFilterUpdateValue(value) {
          srcPatternRef.value = value !== null && value !== void 0 ? value : "";
        }
        function handleTgtFilterUpdateValue(value) {
          tgtPatternRef.value = value !== null && value !== void 0 ? value : "";
        }
        return {
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          avlSrcValueSet: avlSrcValueSetRef,
          avlTgtValueSet: avlTgtValueSetRef,
          tgtOpts: tgtOptsRef,
          srcOpts: srcOptsRef,
          filteredSrcOpts: filteredSrcOptsRef,
          filteredTgtOpts: filteredTgtOptsRef,
          srcCheckedValues: srcCheckedValuesRef,
          tgtCheckedValues: tgtCheckedValuesRef,
          srcCheckedStatus: srcCheckedStatusRef,
          tgtCheckedStatus: tgtCheckedStatusRef,
          srcPattern: srcPatternRef,
          tgtPattern: tgtPatternRef,
          isInputing: isInputingRef,
          fromButtonDisabled: fromButtonDisabledRef,
          toButtonDisabled: toButtonDisabledRef,
          handleInputFocus,
          handleInputBlur,
          handleTgtFilterUpdateValue,
          handleSrcFilterUpdateValue
        };
      }
      const animation = c$1([c$1("@keyframes legacy-transfer-slide-in-from-left", `
 0% {
 transform: translateX(-150%);
 }
 100% {
 transform: translateX(0);
 }
 `), c$1("@keyframes legacy-transfer-slide-out-to-right", `
 0% {
 transform: translateX(0);
 }
 100% {
 transform: translateX(150%);
 }
 `), c$1("@keyframes legacy-transfer-slide-in-from-right", `
 0% {
 transform: translateX(150%);
 }
 100% {
 transform: translateX(0);
 }
 `), c$1("@keyframes legacy-transfer-slide-out-to-left", `
 0% {
 transform: translateX(0);
 }
 100% {
 transform: translateX(-150%);
 }
 `), c$1("@keyframes legacy-transfer-height-collapse", `
 0% {
 max-height: var(--n-item-height);
 }
 100% {
 max-height: 0;
 }
 `), c$1("@keyframes legacy-transfer-height-expand", `
 0% {
 max-height: 0;
 }
 100% {
 max-height: var(--n-item-height);
 }
 `)]);
      const style$y = c$1([cB("legacy-transfer", `
 display: flex;
 width: var(--n-width);
 font-size: var(--n-font-size);
 height: 240px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB("legacy-transfer-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), cM("disabled", [cB("legacy-transfer-icon", {
        color: "var(--n-icon-color-disabled)"
      })]), cB("legacy-transfer-list", `
 height: inherit;
 display: flex;
 flex-direction: column;
 background-clip: padding-box;
 width: calc(50% - 36px);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 background-color: var(--n-list-color);
 `, [cE("border", `
 border: 1px solid var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), cB("legacy-transfer-list-header", `
 height: calc(var(--n-item-height) + 4px);
 box-sizing: border-box;
 display: flex;
 align-items: center;
 background-clip: padding-box;
 border-radius: inherit;
 border-bottom-left-radius: 0;
 border-bottom-right-radius: 0;
 background-color: var(--n-header-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cE("checkbox", `
 display: flex;
 align-items: center;
 position: relative;
 padding: 0 9px 0 14px;
 `), cE("header", `
 flex: 1;
 line-height: 1;
 font-weight: var(--n-header-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-header-text-color);
 `, [cM("disabled", {
        color: "var(--n-header-text-color-disabled)"
      })]), cE("extra", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-extra-font-size);
 justify-self: flex-end;
 margin-right: 14px;
 white-space: nowrap;
 color: var(--n-header-extra-text-color);
 `)]), cB("legacy-transfer-list-body", `
 flex-basis: 0;
 flex-grow: 1;
 box-sizing: border-box;
 position: relative;
 display: flex;
 flex-direction: column;
 border-radius: inherit;
 border-top-left-radius: 0;
 border-top-right-radius: 0;
 `, [cB("legacy-transfer-filter", `
 padding: 0 8px 8px 8px;
 box-sizing: border-box;
 background-color: var(--n-header-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-filter-divider-color);
 `), cB("legacy-transfer-list-flex-container", `
 flex: 1;
 position: relative;
 `, [cB("scrollbar", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 height: unset;
 `, [cB("scrollbar-content", {
        width: "100%"
      })]), cB("empty", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 `, [fadeInTransition()]), cB("legacy-transfer-list-content", `
 padding: 0;
 margin: 0;
 position: relative;
 `, [cM("transition-disabled", [cB("legacy-transfer-list-item", {
        animation: "none !important"
      })]), cB("legacy-transfer-list-item", `
 height: var(--n-item-height);
 max-height: var(--n-item-height);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 cursor: pointer;
 display: flex;
 align-items: center;
 color: var(--n-item-text-color);
 `, [cNotM("disabled", [c$1("&:hover", {
        backgroundColor: "var(--n-item-color-pending)"
      })]), cE("extra", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 padding-right: 4px;
 `), cE("checkbox", `
 display: flex;
 align-items: center;
 position: relative;
 padding: 0 9px 0 14px;
 `), cM("disabled", `
 cursor: not-allowed
 background-color: #0000;
 color: var(--n-item-text-color-disabled);
 `), cM("source", {
        animationFillMode: "forwards"
      }, [c$1("&.item-enter-active", `
 transform: translateX(150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
 animation-delay: 0s, .25s;
 animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-right;
 `), c$1("&.item-leave-active", `
 transform: translateX(-150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
 animation-delay: .25s, 0s;
 animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-right;
 `)]), cM("target", {
        animationFillMode: "forwards"
      }, [c$1("&.item-enter-active", `
 transform: translateX(-150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
 animation-delay: 0s, .25s;
 animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-left;
 `), c$1("&.item-leave-active", `
 transform: translateX(150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
 animation-delay: .25s, 0s;
 animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-left;
 `)])])])])])]), cB("legacy-transfer-gap", {
        width: "72px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexDirection: "column"
      }), cB("button", [c$1("&:first-child", {
        marginBottom: "12px"
      })])]), animation]);
      const transferProps$1 = Object.assign(Object.assign({}, useTheme.props), { value: Array, defaultValue: {
        type: Array,
        default: null
      }, options: {
        type: Array,
        default: () => []
      }, disabled: {
        type: Boolean,
        default: void 0
      }, virtualScroll: Boolean, sourceTitle: String, targetTitle: String, filterable: Boolean, sourceFilterPlaceholder: String, targetFilterPlaceholder: String, filter: {
        type: Function,
        default: (pattern2, option) => {
          if (!pattern2)
            return true;
          return ~("" + option.label).toLowerCase().indexOf(("" + pattern2).toLowerCase());
        }
      }, size: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] });
      const Transfer$1 = vue.defineComponent({
        name: "LegacyTransfer",
        props: transferProps$1,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("LegacyTransfer", "-legacy-transfer", style$y, legacyTransferLight, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const itemSizeRef = vue.computed(() => {
            const { value: size2 } = mergedSizeRef;
            const { self: { [createKey("itemHeight", size2)]: itemSize } } = themeRef.value;
            return depx(itemSize);
          });
          const { uncontrolledValue: uncontrolledValueRef, mergedValue: mergedValueRef, avlSrcValueSet: avlSrcValueSetRef, avlTgtValueSet: avlTgtValueSetRef, tgtOpts: tgtOptsRef, srcOpts: srcOptsRef, filteredSrcOpts: filteredSrcOptsRef, filteredTgtOpts: filteredTgtOptsRef, srcCheckedValues: srcCheckedValuesRef, tgtCheckedValues: tgtCheckedValuesRef, srcCheckedStatus: srcCheckedStatusRef, tgtCheckedStatus: tgtCheckedStatusRef, srcPattern: srcPatternRef, tgtPattern: tgtPatternRef, isInputing: isInputingRef, fromButtonDisabled: fromButtonDisabledRef, toButtonDisabled: toButtonDisabledRef, handleInputFocus, handleInputBlur, handleTgtFilterUpdateValue, handleSrcFilterUpdateValue } = useTransferData$1(props, mergedDisabledRef);
          function doUpdateValue(value) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue, onChange } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            if (onChange)
              call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function handleSrcHeaderCheck(value) {
            const { value: { checked, indeterminate } } = srcCheckedStatusRef;
            if (indeterminate || checked) {
              srcCheckedValuesRef.value = [];
            } else {
              srcCheckedValuesRef.value = Array.from(avlSrcValueSetRef.value);
            }
          }
          function handleTgtHeaderCheck() {
            const { value: { checked, indeterminate } } = tgtCheckedStatusRef;
            if (indeterminate || checked) {
              tgtCheckedValuesRef.value = [];
            } else {
              tgtCheckedValuesRef.value = Array.from(avlTgtValueSetRef.value);
            }
          }
          function handleTgtCheckboxClick(checked, optionValue) {
            if (checked) {
              tgtCheckedValuesRef.value.push(optionValue);
            } else {
              const index = tgtCheckedValuesRef.value.findIndex((v) => v === optionValue);
              if (~index) {
                tgtCheckedValuesRef.value.splice(index, 1);
              }
            }
          }
          function handleSrcCheckboxClick(checked, optionValue) {
            if (checked) {
              srcCheckedValuesRef.value.push(optionValue);
            } else {
              const index = srcCheckedValuesRef.value.findIndex((v) => v === optionValue);
              if (~index) {
                srcCheckedValuesRef.value.splice(index, 1);
              }
            }
          }
          function handleToTgtClick() {
            doUpdateValue(srcCheckedValuesRef.value.concat(mergedValueRef.value || []));
            srcCheckedValuesRef.value = [];
          }
          function handleToSrcClick() {
            const tgtCheckedValueSet = new Set(tgtCheckedValuesRef.value);
            doUpdateValue((mergedValueRef.value || []).filter((v) => !tgtCheckedValueSet.has(v)));
            tgtCheckedValuesRef.value = [];
          }
          vue.provide(transferInjectionKey$1, {
            mergedClsPrefixRef,
            mergedSizeRef,
            disabledRef: mergedDisabledRef,
            mergedThemeRef: themeRef,
            srcCheckedValuesRef,
            tgtCheckedValuesRef,
            srcOptsRef,
            tgtOptsRef,
            srcCheckedStatusRef,
            tgtCheckedStatusRef,
            handleSrcCheckboxClick,
            handleTgtCheckboxClick
          });
          const { localeRef } = useLocale("LegacyTransfer");
          return {
            locale: localeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedDisabled: mergedDisabledRef,
            itemSize: itemSizeRef,
            isMounted: isMounted(),
            isInputing: isInputingRef,
            mergedTheme: themeRef,
            filteredSrcOpts: filteredSrcOptsRef,
            filteredTgtOpts: filteredTgtOptsRef,
            srcPattern: srcPatternRef,
            tgtPattern: tgtPatternRef,
            toButtonDisabled: toButtonDisabledRef,
            fromButtonDisabled: fromButtonDisabledRef,
            handleSrcHeaderCheck,
            handleTgtHeaderCheck,
            handleToSrcClick,
            handleToTgtClick,
            handleInputFocus,
            handleInputBlur,
            handleTgtFilterUpdateValue,
            handleSrcFilterUpdateValue,
            cssVars: vue.computed(() => {
              const { value: size2 } = mergedSizeRef;
              const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseIn: cubicBezierEaseIn2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { width, borderRadius, borderColor, listColor, headerColor, titleTextColor, titleTextColorDisabled, extraTextColor, filterDividerColor, itemTextColor, itemColorPending, itemTextColorDisabled, extraFontSize, titleFontWeight, iconColor, iconColorDisabled, [createKey("fontSize", size2)]: fontSize2, [createKey("itemHeight", size2)]: itemHeight } } = themeRef.value;
              return {
                "--n-bezier": cubicBezierEaseInOut2,
                "--n-bezier-ease-in": cubicBezierEaseIn2,
                "--n-bezier-ease-out": cubicBezierEaseOut2,
                "--n-border-color": borderColor,
                "--n-border-radius": borderRadius,
                "--n-extra-font-size": extraFontSize,
                "--n-filter-divider-color": filterDividerColor,
                "--n-font-size": fontSize2,
                "--n-header-color": headerColor,
                "--n-header-extra-text-color": extraTextColor,
                "--n-header-font-weight": titleFontWeight,
                "--n-header-text-color": titleTextColor,
                "--n-header-text-color-disabled": titleTextColorDisabled,
                "--n-item-color-pending": itemColorPending,
                "--n-item-height": itemHeight,
                "--n-item-text-color": itemTextColor,
                "--n-item-text-color-disabled": itemTextColorDisabled,
                "--n-list-color": listColor,
                "--n-width": width,
                "--n-icon-color": iconColor,
                "--n-icon-color-disabled": iconColorDisabled
              };
            })
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-legacy-transfer`,
              this.mergedDisabled && `${mergedClsPrefix}-legacy-transfer--disabled`,
              this.filterable && `${mergedClsPrefix}-legacy-transfer--filterable`
            ], style: this.cssVars },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-legacy-transfer-list` },
              vue.h(NTransferHeader$1, { source: true, onChange: this.handleSrcHeaderCheck, title: this.sourceTitle || this.locale.sourceTitle }),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-legacy-transfer-list-body` },
                this.filterable ? vue.h(NTransferFilter$1, { onUpdateValue: this.handleSrcFilterUpdateValue, value: this.srcPattern, disabled: this.mergedDisabled, placeholder: this.sourceFilterPlaceholder, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur }) : null,
                vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-legacy-transfer-list-flex-container` },
                  vue.h(NTransferList$1, { source: true, options: this.filteredSrcOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, isMounted: this.isMounted, isInputing: this.isInputing, itemSize: this.itemSize })
                )
              ),
              vue.h("div", { class: `${mergedClsPrefix}-legacy-transfer-list__border` })
            ),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-legacy-transfer-gap` },
              vue.h(NButton, { disabled: this.toButtonDisabled || this.mergedDisabled, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, onClick: this.handleToTgtClick }, {
                icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(ChevronRightIcon, null) })
              }),
              vue.h(NButton, { disabled: this.fromButtonDisabled || this.mergedDisabled, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, onClick: this.handleToSrcClick }, {
                icon: () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(ChevronLeftIcon, null) })
              })
            ),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-legacy-transfer-list` },
              vue.h(NTransferHeader$1, { onChange: this.handleTgtHeaderCheck, title: this.targetTitle || this.locale.targetTitle }),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-legacy-transfer-list-body` },
                this.filterable ? vue.h(NTransferFilter$1, { onUpdateValue: this.handleTgtFilterUpdateValue, value: this.tgtPattern, disabled: this.mergedDisabled, placeholder: this.targetFilterPlaceholder, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur }) : null,
                vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-legacy-transfer-list-flex-container` },
                  vue.h(NTransferList$1, { options: this.filteredTgtOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, isMounted: this.isMounted, isInputing: this.isInputing, itemSize: this.itemSize })
                )
              ),
              vue.h("div", { class: `${mergedClsPrefix}-legacy-transfer-list__border` })
            )
          );
        }
      });
      const style$x = c$1([cB("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [cM("show-divider", [cB("list-item", [c$1("&:not(:last-child)", [cE("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), cM("clickable", [cB("list-item", `
 cursor: pointer;
 `)]), cM("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), cM("hoverable", [cB("list-item", `
 border-radius: var(--n-border-radius);
 `, [c$1("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [cE("divider", `
 background-color: transparent;
 `)])])]), cM("bordered, hoverable", [cB("list-item", `
 padding: 12px 20px;
 `), cE("header, footer", `
 padding: 12px 20px;
 `)]), cE("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [c$1("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), cB("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE("prefix", `
 margin-right: 20px;
 flex: 0;
 `), cE("suffix", `
 margin-left: 20px;
 flex: 0;
 `), cE("main", `
 flex: 1;
 `), cE("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), insideModal(cB("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);
      const listProps = Object.assign(Object.assign({}, useTheme.props), { size: {
        type: String,
        default: "medium"
      }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: {
        type: Boolean,
        default: true
      } });
      const listInjectionKey = createInjectionKey("n-list");
      const List = vue.defineComponent({
        name: "List",
        props: listProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl("List", mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme("List", "-list", style$x, listLight$1, props, mergedClsPrefixRef);
          vue.provide(listInjectionKey, {
            showDividerRef: vue.toRef(props, "showDivider"),
            mergedClsPrefixRef
          });
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { fontSize: fontSize2, textColor, color, colorModal, colorPopover, borderColor, borderColorModal, borderColorPopover, borderRadius, colorHover, colorHoverModal, colorHoverPopover } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-color": color,
              "--n-border-radius": borderRadius,
              "--n-border-color": borderColor,
              "--n-border-color-modal": borderColorModal,
              "--n-border-color-popover": borderColorPopover,
              "--n-color-modal": colorModal,
              "--n-color-popover": colorPopover,
              "--n-color-hover": colorHover,
              "--n-color-hover-modal": colorHoverModal,
              "--n-color-hover-popover": colorHoverPopover
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("list", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "ul",
            { class: [
              `${mergedClsPrefix}-list`,
              this.rtlEnabled && `${mergedClsPrefix}-list--rtl`,
              this.bordered && `${mergedClsPrefix}-list--bordered`,
              this.showDivider && `${mergedClsPrefix}-list--show-divider`,
              this.hoverable && `${mergedClsPrefix}-list--hoverable`,
              this.clickable && `${mergedClsPrefix}-list--clickable`,
              this.themeClass
            ], style: this.cssVars },
            $slots.header ? vue.h("div", { class: `${mergedClsPrefix}-list__header` }, $slots.header()) : null,
            (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots),
            $slots.footer ? vue.h("div", { class: `${mergedClsPrefix}-list__footer` }, $slots.footer()) : null
          );
        }
      });
      const ListItem = vue.defineComponent({
        name: "ListItem",
        setup() {
          const listInjection = vue.inject(listInjectionKey, null);
          if (!listInjection) {
            throwError("list-item", "`n-list-item` must be placed in `n-list`.");
          }
          return {
            showDivider: listInjection.showDividerRef,
            mergedClsPrefix: listInjection.mergedClsPrefixRef
          };
        },
        render() {
          const { $slots, mergedClsPrefix } = this;
          return vue.h(
            "li",
            { class: `${mergedClsPrefix}-list-item` },
            $slots.prefix ? vue.h("div", { class: `${mergedClsPrefix}-list-item__prefix` }, $slots.prefix()) : null,
            $slots.default ? vue.h("div", { class: `${mergedClsPrefix}-list-item__main` }, $slots) : null,
            $slots.suffix ? vue.h("div", { class: `${mergedClsPrefix}-list-item__suffix` }, $slots.suffix()) : null,
            this.showDivider && vue.h("div", { class: `${mergedClsPrefix}-list-item__divider` })
          );
        }
      });
      const loadingBarProviderInjectionKey = createInjectionKey("n-loading-bar");
      const loadingBarApiInjectionKey = createInjectionKey("n-loading-bar-api");
      const style$w = cB("loading-bar-container", `
 z-index: 5999;
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 height: 2px;
`, [fadeInTransition({
        enterDuration: "0.3s",
        leaveDuration: "0.8s"
      }), cB("loading-bar", `
 width: 100%;
 transition:
 max-width 4s linear,
 background .2s linear;
 height: var(--n-height);
 `, [cM("starting", `
 background: var(--n-color-loading);
 `), cM("finishing", `
 background: var(--n-color-loading);
 transition:
 max-width .2s linear,
 background .2s linear;
 `), cM("error", `
 background: var(--n-color-error);
 transition:
 max-width .2s linear,
 background .2s linear;
 `)])]);
      var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      function createClassName(status, clsPrefix) {
        return `${clsPrefix}-loading-bar ${clsPrefix}-loading-bar--${status}`;
      }
      const NLoadingBar = vue.defineComponent({
        name: "LoadingBar",
        props: {
          containerStyle: [String, Object]
        },
        setup() {
          const { inlineThemeDisabled } = useConfig();
          const {
            props: providerProps,
            mergedClsPrefixRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(loadingBarProviderInjectionKey);
          const loadingBarRef = vue.ref(null);
          const enteringRef = vue.ref(false);
          const startedRef = vue.ref(false);
          const loadingRef = vue.ref(false);
          const transitionDisabledRef = vue.ref(false);
          let finishing = false;
          const erroringRef = vue.ref(false);
          const mergedLoadingBarStyle = vue.computed(() => {
            const { loadingBarStyle } = providerProps;
            if (!loadingBarStyle)
              return "";
            return loadingBarStyle[erroringRef.value ? "error" : "loading"];
          });
          function init2() {
            return __awaiter$4(this, void 0, void 0, function* () {
              enteringRef.value = false;
              loadingRef.value = false;
              finishing = false;
              erroringRef.value = false;
              transitionDisabledRef.value = true;
              yield vue.nextTick();
              transitionDisabledRef.value = false;
            });
          }
          function start(fromProgress = 0, toProgress = 80, status = "starting") {
            return __awaiter$4(this, void 0, void 0, function* () {
              yield init2();
              loadingRef.value = true;
              startedRef.value = true;
              yield vue.nextTick();
              const el = loadingBarRef.value;
              if (!el)
                return;
              el.style.maxWidth = `${fromProgress}%`;
              el.style.transition = "none";
              void el.offsetWidth;
              el.className = createClassName(status, mergedClsPrefixRef.value);
              el.style.transition = "";
              el.style.maxWidth = `${toProgress}%`;
            });
          }
          function finish() {
            if (finishing || erroringRef.value || !loadingRef.value)
              return;
            finishing = true;
            const el = loadingBarRef.value;
            if (!el)
              return;
            el.className = createClassName("finishing", mergedClsPrefixRef.value);
            el.style.maxWidth = "100%";
            void el.offsetWidth;
            loadingRef.value = false;
          }
          function error() {
            if (finishing || erroringRef.value)
              return;
            if (!loadingRef.value) {
              void start(100, 100, "error").then(() => {
                erroringRef.value = true;
                const el = loadingBarRef.value;
                if (!el)
                  return;
                el.className = createClassName("error", mergedClsPrefixRef.value);
                void el.offsetWidth;
                loadingRef.value = false;
              });
            } else {
              erroringRef.value = true;
              const el = loadingBarRef.value;
              if (!el)
                return;
              el.className = createClassName("error", mergedClsPrefixRef.value);
              el.style.maxWidth = "100%";
              void el.offsetWidth;
              loadingRef.value = false;
            }
          }
          function handleEnter() {
            enteringRef.value = true;
          }
          function handleAfterEnter() {
            enteringRef.value = false;
          }
          function handleAfterLeave() {
            return __awaiter$4(this, void 0, void 0, function* () {
              yield init2();
            });
          }
          const themeRef = useTheme("LoadingBar", "-loading-bar", style$w, loadingBarLight$1, providerProps, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { self: { height, colorError, colorLoading } } = themeRef.value;
            return {
              "--n-height": height,
              "--n-color-loading": colorLoading,
              "--n-color-error": colorError
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("loading-bar", void 0, cssVarsRef, providerProps) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            loadingBarRef,
            started: startedRef,
            loading: loadingRef,
            entering: enteringRef,
            transitionDisabled: transitionDisabledRef,
            start,
            error,
            finish,
            handleEnter,
            handleAfterEnter,
            handleAfterLeave,
            mergedLoadingBarStyle,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          if (!this.started)
            return null;
          const { mergedClsPrefix } = this;
          return vue.h(vue.Transition, {
            name: "fade-in-transition",
            appear: true,
            onEnter: this.handleEnter,
            onAfterEnter: this.handleAfterEnter,
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            onAfterLeave: this.handleAfterLeave,
            css: !this.transitionDisabled
          }, {
            default: () => {
              var _a;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return vue.withDirectives(vue.h(
                "div",
                { class: [
                  `${mergedClsPrefix}-loading-bar-container`,
                  this.themeClass
                ], style: this.containerStyle },
                vue.h("div", { ref: "loadingBarRef", class: [`${mergedClsPrefix}-loading-bar`], style: [
                  this.cssVars,
                  this.mergedLoadingBarStyle
                ] })
              ), [[vue.vShow, this.loading || !this.loading && this.entering]]);
            }
          });
        }
      });
      const loadingBarProviderProps = Object.assign(Object.assign({}, useTheme.props), { to: {
        type: [String, Object, Boolean],
        default: void 0
      }, containerStyle: [String, Object], loadingBarStyle: {
        type: Object
      } });
      const NLoadingBarProvider = vue.defineComponent({
        name: "LoadingBarProvider",
        props: loadingBarProviderProps,
        setup(props) {
          const isMountedRef = isMounted();
          const loadingBarRef = vue.ref(null);
          const methods = {
            start() {
              var _a;
              if (isMountedRef.value) {
                (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.start();
              } else {
                void vue.nextTick(() => {
                  var _a2;
                  (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.start();
                });
              }
            },
            error() {
              var _a;
              if (isMountedRef.value) {
                (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.error();
              } else {
                void vue.nextTick(() => {
                  var _a2;
                  (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.error();
                });
              }
            },
            finish() {
              var _a;
              if (isMountedRef.value) {
                (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.finish();
              } else {
                void vue.nextTick(() => {
                  var _a2;
                  (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.finish();
                });
              }
            }
          };
          const { mergedClsPrefixRef } = useConfig(props);
          vue.provide(loadingBarApiInjectionKey, methods);
          vue.provide(loadingBarProviderInjectionKey, {
            props,
            mergedClsPrefixRef
          });
          return Object.assign(methods, {
            loadingBarRef
          });
        },
        render() {
          var _a, _b;
          return vue.h(
            vue.Fragment,
            null,
            vue.h(
              vue.Teleport,
              { disabled: this.to === false, to: this.to || "body" },
              vue.h(NLoadingBar, { ref: "loadingBarRef", containerStyle: this.containerStyle })
            ),
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)
          );
        }
      });
      function useLoadingBar() {
        const loadingBar = vue.inject(loadingBarApiInjectionKey, null);
        if (loadingBar === null) {
          throwError("use-loading-bar", "No outer <n-loading-bar-provider /> founded.");
        }
        return loadingBar;
      }
      const NLogLoader = vue.defineComponent({
        name: "LogLoader",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup() {
          return {
            locale: useLocale("Log").localeRef
          };
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(
            "div",
            { class: `${clsPrefix}-log-loader` },
            vue.h(NBaseLoading, { clsPrefix, strokeWidth: 24, scale: 0.85 }),
            vue.h("span", { class: `${clsPrefix}-log-loader__content` }, this.locale.loading)
          );
        }
      });
      const logInjectionKey = createInjectionKey("n-log");
      const NLogLine = vue.defineComponent({
        props: {
          line: {
            type: String,
            default: ""
          }
        },
        setup(props) {
          const { trimRef, highlightRef, languageRef, mergedHljsRef } = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            vue.inject(logInjectionKey)
          );
          const selfRef = vue.ref(null);
          const maybeTrimmedLinesRef = vue.computed(() => {
            return trimRef.value ? props.line.trim() : props.line;
          });
          function setInnerHTML() {
            if (selfRef.value) {
              selfRef.value.innerHTML = generateCodeHTML(languageRef.value, maybeTrimmedLinesRef.value);
            }
          }
          function generateCodeHTML(language, code) {
            const { value: hljs } = mergedHljsRef;
            if (hljs) {
              if (language && hljs.getLanguage(language)) {
                return hljs.highlight(code, { language }).value;
              }
            }
            return code;
          }
          vue.onMounted(() => {
            if (highlightRef.value) {
              setInnerHTML();
            }
          });
          vue.watch(vue.toRef(props, "line"), () => {
            if (highlightRef.value) {
              setInnerHTML();
            }
          });
          return {
            highlight: highlightRef,
            selfRef,
            maybeTrimmedLines: maybeTrimmedLinesRef
          };
        },
        render() {
          const { highlight, maybeTrimmedLines } = this;
          return vue.h("pre", { ref: "selfRef" }, highlight ? null : maybeTrimmedLines);
        }
      });
      const style$v = cB("log", `
 position: relative;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
`, [c$1("pre", `
 white-space: pre-wrap;
 word-break: break-word;
 margin: 0;
 `), cB("log-loader", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 box-sizing: border-box;
 position: absolute;
 right: 16px;
 top: 8px;
 height: 34px;
 border-radius: 17px;
 line-height: 34px;
 white-space: nowrap;
 overflow: hidden;
 border: var(--n-loader-border);
 color: var(--n-loader-text-color);
 background-color: var(--n-loader-color);
 font-size: var(--n-loader-font-size);
 `, [fadeInScaleUpTransition(), cE("content", `
 display: inline-block;
 vertical-align: bottom;
 line-height: 34px;
 padding-left: 40px;
 padding-right: 20px;
 white-space: nowrap;
 `), cB("base-loading", `
 color: var(--n-loading-color);
 position: absolute;
 left: 12px;
 top: calc(50% - 10px);
 font-size: 20px;
 width: 20px;
 height: 20px;
 display: inline-block;
 `)])]);
      const logProps = Object.assign(Object.assign({}, useTheme.props), { loading: Boolean, trim: Boolean, log: String, fontSize: {
        type: Number,
        default: 14
      }, lines: {
        type: Array,
        default: () => []
      }, lineHeight: {
        type: Number,
        default: 1.25
      }, language: String, rows: {
        type: Number,
        default: 15
      }, offsetTop: {
        type: Number,
        default: 0
      }, offsetBottom: {
        type: Number,
        default: 0
      }, hljs: Object, onReachTop: Function, onReachBottom: Function, onRequireMore: Function });
      const Log = vue.defineComponent({
        name: "Log",
        props: logProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const slientRef = vue.ref(false);
          const highlightRef = vue.computed(() => {
            return props.language !== void 0;
          });
          const styleHeightRef = vue.computed(() => {
            return `calc(${Math.round(props.rows * props.lineHeight * props.fontSize)}px)`;
          });
          const mergedLinesRef = vue.computed(() => {
            const { log } = props;
            if (log) {
              return log.split("\n");
            }
            return props.lines;
          });
          const scrollbarRef = vue.ref(null);
          const themeRef = useTheme("Log", "-log", style$v, logLight$1, props, mergedClsPrefixRef);
          function handleScroll(e) {
            const container = e.target;
            const content = container.firstElementChild;
            if (slientRef.value) {
              void vue.nextTick(() => {
                slientRef.value = false;
              });
              return;
            }
            const containerHeight = container.offsetHeight;
            const containerScrollTop = container.scrollTop;
            const contentHeight = content.offsetHeight;
            const scrollTop = containerScrollTop;
            const scrollBottom = contentHeight - containerScrollTop - containerHeight;
            if (scrollTop <= props.offsetTop) {
              const { onReachTop, onRequireMore } = props;
              if (onRequireMore)
                onRequireMore("top");
              if (onReachTop)
                onReachTop();
            }
            if (scrollBottom <= props.offsetBottom) {
              const { onReachBottom, onRequireMore } = props;
              if (onRequireMore)
                onRequireMore("bottom");
              if (onReachBottom)
                onReachBottom();
            }
          }
          const handleWheel = throttle(_handleWheel, 300);
          function _handleWheel(e) {
            if (slientRef.value) {
              void vue.nextTick(() => {
                slientRef.value = false;
              });
              return;
            }
            if (scrollbarRef.value) {
              const { containerRef, contentRef } = scrollbarRef.value;
              if (containerRef && contentRef) {
                const containerHeight = containerRef.offsetHeight;
                const containerScrollTop = containerRef.scrollTop;
                const contentHeight = contentRef.offsetHeight;
                const scrollTop = containerScrollTop;
                const scrollBottom = contentHeight - containerScrollTop - containerHeight;
                const deltaY = e.deltaY;
                if (scrollTop === 0 && deltaY < 0) {
                  const { onRequireMore } = props;
                  if (onRequireMore)
                    onRequireMore("top");
                }
                if (scrollBottom <= 0 && deltaY > 0) {
                  const { onRequireMore } = props;
                  if (onRequireMore)
                    onRequireMore("bottom");
                }
              }
            }
          }
          function scrollTo(options) {
            const { value: scrollbarInst } = scrollbarRef;
            if (!scrollbarInst)
              return;
            const { slient, top, position } = options;
            if (slient) {
              slientRef.value = true;
            }
            if (top !== void 0) {
              scrollbarInst.scrollTo({ left: 0, top });
            } else if (position === "bottom" || position === "top") {
              scrollbarInst.scrollTo({ position });
            }
          }
          function scrollToTop(slient = false) {
            warn$2("log", "`scrollToTop` is deprecated, please use `scrollTo({ position: 'top'})` instead.");
            scrollTo({
              position: "top",
              slient
            });
          }
          function scrollToBottom(slient = false) {
            warn$2("log", "`scrollToTop` is deprecated, please use `scrollTo({ position: 'bottom'})` instead.");
            scrollTo({
              position: "bottom",
              slient
            });
          }
          vue.provide(logInjectionKey, {
            languageRef: vue.toRef(props, "language"),
            mergedHljsRef: useHljs(props),
            trimRef: vue.toRef(props, "trim"),
            highlightRef
          });
          const exportedMethods = {
            scrollTo
          };
          const cssVarsRef = vue.computed(() => {
            const { self: { loaderFontSize, loaderTextColor, loaderColor, loaderBorder, loadingColor }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-loader-font-size": loaderFontSize,
              "--n-loader-border": loaderBorder,
              "--n-loader-color": loaderColor,
              "--n-loader-text-color": loaderTextColor,
              "--n-loading-color": loadingColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("log", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exportedMethods), {
            mergedClsPrefix: mergedClsPrefixRef,
            scrollbarRef,
            mergedTheme: themeRef,
            styleHeight: styleHeightRef,
            mergedLines: mergedLinesRef,
            scrollToTop,
            scrollToBottom,
            handleWheel,
            handleScroll,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const { mergedClsPrefix, mergedTheme, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", {
            class: [`${mergedClsPrefix}-log`, this.themeClass],
            style: [
              {
                lineHeight: this.lineHeight,
                height: this.styleHeight
              },
              this.cssVars
            ],
            onWheelPassive: this.handleWheel
          }, [
            vue.h(NScrollbar, { ref: "scrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, onScroll: this.handleScroll }, {
              default: () => vue.h(NCode, { internalNoHighlight: true, internalFontSize: this.fontSize, theme: mergedTheme.peers.Code, themeOverrides: mergedTheme.peerOverrides.Code }, {
                default: () => this.mergedLines.map((line, index) => {
                  return vue.h(NLogLine, { key: index, line });
                })
              })
            }),
            vue.h(vue.Transition, { name: "fade-in-scale-up-transition" }, {
              default: () => this.loading ? vue.h(NLogLoader, { clsPrefix: mergedClsPrefix }) : null
            })
          ]);
        }
      });
      const menuInjectionKey = createInjectionKey("n-menu");
      const submenuInjectionKey = createInjectionKey("n-submenu");
      const menuItemGroupInjectionKey = createInjectionKey("n-menu-item-group");
      const ICON_MARGIN_RIGHT = 8;
      function useMenuChild(props) {
        const NMenu = vue.inject(menuInjectionKey);
        const { props: menuProps2, mergedCollapsedRef } = NMenu;
        const NSubmenu2 = vue.inject(submenuInjectionKey, null);
        const NMenuOptionGroup2 = vue.inject(menuItemGroupInjectionKey, null);
        const horizontalRef = vue.computed(() => {
          return menuProps2.mode === "horizontal";
        });
        const dropdownPlacementRef = vue.computed(() => {
          if (horizontalRef.value) {
            return menuProps2.dropdownPlacement;
          }
          if ("tmNodes" in props)
            return "right-start";
          return "right";
        });
        const maxIconSizeRef = vue.computed(() => {
          var _a;
          return Math.max((_a = menuProps2.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps2.iconSize, menuProps2.iconSize);
        });
        const activeIconSizeRef = vue.computed(() => {
          var _a;
          if (!horizontalRef.value && props.root && mergedCollapsedRef.value) {
            return (_a = menuProps2.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps2.iconSize;
          } else {
            return menuProps2.iconSize;
          }
        });
        const paddingLeftRef = vue.computed(() => {
          if (horizontalRef.value)
            return void 0;
          const { collapsedWidth, indent, rootIndent } = menuProps2;
          const { root: root2, isGroup: isGroup2 } = props;
          const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
          if (root2) {
            if (mergedCollapsedRef.value) {
              return collapsedWidth / 2 - maxIconSizeRef.value / 2;
            }
            return mergedRootIndent;
          }
          if (NMenuOptionGroup2) {
            return indent / 2 + NMenuOptionGroup2.paddingLeftRef.value;
          }
          if (NSubmenu2) {
            return (isGroup2 ? indent / 2 : indent) + NSubmenu2.paddingLeftRef.value;
          }
          return void 0;
        });
        const iconMarginRightRef = vue.computed(() => {
          const { collapsedWidth, indent, rootIndent } = menuProps2;
          const { value: maxIconSize } = maxIconSizeRef;
          const { root: root2 } = props;
          if (horizontalRef.value)
            return ICON_MARGIN_RIGHT;
          if (!root2)
            return ICON_MARGIN_RIGHT;
          if (!mergedCollapsedRef.value)
            return ICON_MARGIN_RIGHT;
          const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
          return mergedRootIndent + maxIconSize + ICON_MARGIN_RIGHT - (collapsedWidth + maxIconSize) / 2;
        });
        return {
          dropdownPlacement: dropdownPlacementRef,
          activeIconSize: activeIconSizeRef,
          maxIconSize: maxIconSizeRef,
          paddingLeft: paddingLeftRef,
          iconMarginRight: iconMarginRightRef,
          NMenu,
          NSubmenu: NSubmenu2
        };
      }
      const useMenuChildProps = {
        internalKey: {
          type: [String, Number],
          required: true
        },
        root: Boolean,
        isGroup: Boolean,
        level: {
          type: Number,
          required: true
        },
        title: [String, Function],
        extra: [String, Function]
      };
      const menuItemGroupProps = Object.assign(Object.assign({}, useMenuChildProps), { tmNode: {
        type: Object,
        required: true
      }, tmNodes: {
        type: Array,
        required: true
      } });
      const NMenuOptionGroup = vue.defineComponent({
        name: "MenuOptionGroup",
        props: menuItemGroupProps,
        setup(props) {
          vue.provide(submenuInjectionKey, null);
          const MenuChild = useMenuChild(props);
          vue.provide(menuItemGroupInjectionKey, {
            paddingLeftRef: MenuChild.paddingLeft
          });
          const { mergedClsPrefixRef, props: menuProps2 } = vue.inject(menuInjectionKey);
          return function() {
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            const paddingLeft = MenuChild.paddingLeft.value;
            const { nodeProps } = menuProps2;
            const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(props.tmNode.rawNode);
            return vue.h(
              "div",
              { class: `${mergedClsPrefix}-menu-item-group`, role: "group" },
              vue.h(
                "div",
                Object.assign({}, attrs, { class: [`${mergedClsPrefix}-menu-item-group-title`, attrs === null || attrs === void 0 ? void 0 : attrs.class], style: [
                  (attrs === null || attrs === void 0 ? void 0 : attrs.style) || "",
                  paddingLeft !== void 0 ? `padding-left: ${paddingLeft}px;` : ""
                ] }),
                render$1(props.title),
                props.extra ? vue.h(
                  vue.Fragment,
                  null,
                  " ",
                  render$1(props.extra)
                ) : null
              ),
              vue.h("div", null, props.tmNodes.map((tmNode) => itemRenderer(tmNode, menuProps2)))
            );
          };
        }
      });
      const NMenuOptionContent = vue.defineComponent({
        name: "MenuOptionContent",
        props: {
          collapsed: Boolean,
          disabled: Boolean,
          title: [String, Function],
          icon: Function,
          extra: [String, Function],
          showArrow: Boolean,
          childActive: Boolean,
          hover: Boolean,
          paddingLeft: Number,
          selected: Boolean,
          maxIconSize: {
            type: Number,
            required: true
          },
          activeIconSize: {
            type: Number,
            required: true
          },
          iconMarginRight: {
            type: Number,
            required: true
          },
          clsPrefix: {
            type: String,
            required: true
          },
          onClick: Function,
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const { props: menuProps2 } = vue.inject(menuInjectionKey);
          return {
            menuProps: menuProps2,
            style: vue.computed(() => {
              const { paddingLeft } = props;
              return { paddingLeft: paddingLeft && `${paddingLeft}px` };
            }),
            iconStyle: vue.computed(() => {
              const { maxIconSize, activeIconSize, iconMarginRight } = props;
              return {
                width: `${maxIconSize}px`,
                height: `${maxIconSize}px`,
                fontSize: `${activeIconSize}px`,
                marginRight: `${iconMarginRight}px`
              };
            })
          };
        },
        render() {
          const { clsPrefix, tmNode, menuProps: { renderIcon, renderLabel, renderExtra, expandIcon } } = this;
          const icon = renderIcon ? renderIcon(tmNode.rawNode) : render$1(this.icon);
          return vue.h(
            "div",
            { onClick: (e) => {
              var _a;
              (_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, e);
            }, role: "none", class: [
              `${clsPrefix}-menu-item-content`,
              {
                [`${clsPrefix}-menu-item-content--selected`]: this.selected,
                [`${clsPrefix}-menu-item-content--collapsed`]: this.collapsed,
                [`${clsPrefix}-menu-item-content--child-active`]: this.childActive,
                [`${clsPrefix}-menu-item-content--disabled`]: this.disabled,
                [`${clsPrefix}-menu-item-content--hover`]: this.hover
              }
            ], style: this.style },
            icon && vue.h("div", { class: `${clsPrefix}-menu-item-content__icon`, style: this.iconStyle, role: "none" }, [icon]),
            vue.h(
              "div",
              { class: `${clsPrefix}-menu-item-content-header`, role: "none" },
              renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title),
              this.extra || renderExtra ? vue.h(
                "span",
                { class: `${clsPrefix}-menu-item-content-header__extra` },
                " ",
                renderExtra ? renderExtra(tmNode.rawNode) : render$1(this.extra)
              ) : null
            ),
            this.showArrow ? vue.h(NBaseIcon, { ariaHidden: true, class: `${clsPrefix}-menu-item-content__arrow`, clsPrefix }, {
              default: () => expandIcon ? expandIcon(tmNode.rawNode) : vue.h(ChevronDownFilledIcon, null)
            }) : null
          );
        }
      });
      const submenuProps = Object.assign(Object.assign({}, useMenuChildProps), { rawNodes: {
        type: Array,
        default: () => []
      }, tmNodes: {
        type: Array,
        default: () => []
      }, tmNode: {
        type: Object,
        required: true
      }, disabled: {
        type: Boolean,
        default: false
      }, icon: Function, onClick: Function });
      const NSubmenu = vue.defineComponent({
        name: "Submenu",
        props: submenuProps,
        setup(props) {
          const MenuChild = useMenuChild(props);
          const { NMenu, NSubmenu: NSubmenu2 } = MenuChild;
          const { props: menuProps2, mergedCollapsedRef, mergedThemeRef } = NMenu;
          const mergedDisabledRef = vue.computed(() => {
            const { disabled } = props;
            if (NSubmenu2 === null || NSubmenu2 === void 0 ? void 0 : NSubmenu2.mergedDisabledRef.value)
              return true;
            if (menuProps2.disabled)
              return true;
            return disabled;
          });
          const dropdownShowRef = vue.ref(false);
          vue.provide(submenuInjectionKey, {
            paddingLeftRef: MenuChild.paddingLeft,
            mergedDisabledRef
          });
          vue.provide(menuItemGroupInjectionKey, null);
          function doClick() {
            const { onClick } = props;
            if (onClick)
              onClick();
          }
          function handleClick2() {
            if (!mergedDisabledRef.value) {
              if (!mergedCollapsedRef.value) {
                NMenu.toggleExpand(props.internalKey);
              }
              doClick();
            }
          }
          function handlePopoverShowChange(value) {
            dropdownShowRef.value = value;
          }
          return {
            menuProps: menuProps2,
            mergedTheme: mergedThemeRef,
            doSelect: NMenu.doSelect,
            inverted: NMenu.invertedRef,
            isHorizontal: NMenu.isHorizontalRef,
            mergedClsPrefix: NMenu.mergedClsPrefixRef,
            maxIconSize: MenuChild.maxIconSize,
            activeIconSize: MenuChild.activeIconSize,
            iconMarginRight: MenuChild.iconMarginRight,
            dropdownPlacement: MenuChild.dropdownPlacement,
            dropdownShow: dropdownShowRef,
            paddingLeft: MenuChild.paddingLeft,
            mergedDisabled: mergedDisabledRef,
            mergedValue: NMenu.mergedValueRef,
            childActive: useMemo(() => {
              return NMenu.activePathRef.value.includes(props.internalKey);
            }),
            collapsed: vue.computed(() => {
              if (menuProps2.mode === "horizontal")
                return false;
              if (mergedCollapsedRef.value) {
                return true;
              }
              return !NMenu.mergedExpandedKeysRef.value.includes(props.internalKey);
            }),
            dropdownEnabled: vue.computed(() => {
              return !mergedDisabledRef.value && (menuProps2.mode === "horizontal" || mergedCollapsedRef.value);
            }),
            handlePopoverShowChange,
            handleClick: handleClick2
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix, menuProps: { renderIcon, renderLabel } } = this;
          const createSubmenuItem = () => {
            const { isHorizontal, paddingLeft, collapsed, mergedDisabled, maxIconSize, activeIconSize, title, childActive, icon, handleClick: handleClick2, menuProps: { nodeProps }, dropdownShow, iconMarginRight, tmNode, mergedClsPrefix: mergedClsPrefix2 } = this;
            const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
            return vue.h(
              "div",
              Object.assign({}, attrs, { class: [`${mergedClsPrefix2}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class], role: "menuitem" }),
              vue.h(NMenuOptionContent, { tmNode, paddingLeft, collapsed, disabled: mergedDisabled, iconMarginRight, maxIconSize, activeIconSize, title, extra: this.extra, showArrow: !isHorizontal, childActive, clsPrefix: mergedClsPrefix2, icon, hover: dropdownShow, onClick: handleClick2 })
            );
          };
          const createSubmenuChildren = () => {
            return vue.h(NFadeInExpandTransition, null, {
              default: () => {
                const { tmNodes, collapsed } = this;
                return !collapsed ? vue.h("div", { class: `${mergedClsPrefix}-submenu-children`, role: "menu" }, tmNodes.map((item) => itemRenderer(item, this.menuProps))) : null;
              }
            });
          };
          return this.root ? vue.h(NDropdown, Object.assign({ size: "large", trigger: "hover" }, (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.dropdownProps, { themeOverrides: this.mergedTheme.peerOverrides.Dropdown, theme: this.mergedTheme.peers.Dropdown, builtinThemeOverrides: {
            fontSizeLarge: "14px",
            optionIconSizeLarge: "18px"
          }, value: this.mergedValue, disabled: !this.dropdownEnabled, placement: this.dropdownPlacement, keyField: this.menuProps.keyField, labelField: this.menuProps.labelField, childrenField: this.menuProps.childrenField, onUpdateShow: this.handlePopoverShowChange, options: this.rawNodes, onSelect: this.doSelect, inverted: this.inverted, renderIcon, renderLabel }), {
            default: () => vue.h(
              "div",
              { class: `${mergedClsPrefix}-submenu`, role: "menuitem", "aria-expanded": !this.collapsed },
              createSubmenuItem(),
              this.isHorizontal ? null : createSubmenuChildren()
            )
          }) : vue.h(
            "div",
            { class: `${mergedClsPrefix}-submenu`, role: "menuitem", "aria-expanded": !this.collapsed },
            createSubmenuItem(),
            createSubmenuChildren()
          );
        }
      });
      const menuItemProps = Object.assign(Object.assign({}, useMenuChildProps), { tmNode: {
        type: Object,
        required: true
      }, disabled: Boolean, icon: Function, onClick: Function });
      const NMenuOption = vue.defineComponent({
        name: "MenuOption",
        props: menuItemProps,
        setup(props) {
          const MenuChild = useMenuChild(props);
          const { NSubmenu: NSubmenu2, NMenu } = MenuChild;
          const { props: menuProps2, mergedClsPrefixRef, mergedCollapsedRef } = NMenu;
          const submenuDisabledRef = NSubmenu2 ? NSubmenu2.mergedDisabledRef : { value: false };
          const mergedDisabledRef = vue.computed(() => {
            return submenuDisabledRef.value || props.disabled;
          });
          function doClick(e) {
            const { onClick } = props;
            if (onClick)
              onClick(e);
          }
          function handleClick2(e) {
            if (!mergedDisabledRef.value) {
              NMenu.doSelect(props.internalKey, props.tmNode.rawNode);
              doClick(e);
            }
          }
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            dropdownPlacement: MenuChild.dropdownPlacement,
            paddingLeft: MenuChild.paddingLeft,
            iconMarginRight: MenuChild.iconMarginRight,
            maxIconSize: MenuChild.maxIconSize,
            activeIconSize: MenuChild.activeIconSize,
            mergedTheme: NMenu.mergedThemeRef,
            menuProps: menuProps2,
            dropdownEnabled: useMemo(() => {
              return props.root && mergedCollapsedRef.value && menuProps2.mode !== "horizontal" && !mergedDisabledRef.value;
            }),
            selected: useMemo(() => {
              if (NMenu.mergedValueRef.value === props.internalKey)
                return true;
              return false;
            }),
            mergedDisabled: mergedDisabledRef,
            handleClick: handleClick2
          };
        },
        render() {
          const { mergedClsPrefix, mergedTheme, tmNode, menuProps: { renderLabel, nodeProps } } = this;
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
          return vue.h(
            "div",
            Object.assign({}, attrs, { role: "menuitem", class: [`${mergedClsPrefix}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class] }),
            vue.h(NTooltip, { theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip, trigger: "hover", placement: this.dropdownPlacement, disabled: !this.dropdownEnabled || this.title === void 0, internalExtraClass: ["menu-tooltip"] }, {
              default: () => renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title),
              trigger: () => vue.h(NMenuOptionContent, { tmNode, clsPrefix: mergedClsPrefix, paddingLeft: this.paddingLeft, iconMarginRight: this.iconMarginRight, maxIconSize: this.maxIconSize, activeIconSize: this.activeIconSize, selected: this.selected, title: this.title, extra: this.extra, disabled: this.mergedDisabled, icon: this.icon, onClick: this.handleClick })
            })
          );
        }
      });
      const NMenuDivider = vue.defineComponent({
        name: "MenuDivider",
        setup() {
          const NMenu = vue.inject(menuInjectionKey);
          const { mergedClsPrefixRef, isHorizontalRef } = NMenu;
          return () => isHorizontalRef.value ? null : vue.h("div", { class: `${mergedClsPrefixRef.value}-menu-divider` });
        }
      });
      const groupPropKeys = keysOf(menuItemGroupProps);
      const itemPropKeys = keysOf(menuItemProps);
      const submenuPropKeys = keysOf(submenuProps);
      function isIgnoredNode(rawNode) {
        return rawNode.type === "divider" || rawNode.type === "render";
      }
      function isDividerNode(rawNode) {
        return rawNode.type === "divider";
      }
      function itemRenderer(tmNode, menuProps2) {
        const { rawNode } = tmNode;
        const { show } = rawNode;
        if (show === false) {
          return null;
        }
        if (isIgnoredNode(rawNode)) {
          if (isDividerNode(rawNode)) {
            return vue.h(NMenuDivider, Object.assign({ key: tmNode.key }, rawNode.props));
          }
          return null;
        }
        const { labelField } = menuProps2;
        const { key, level, isGroup: isGroup2 } = tmNode;
        const props = Object.assign(Object.assign({}, rawNode), {
          title: rawNode.title || rawNode[labelField],
          extra: rawNode.titleExtra || rawNode.extra,
          key,
          internalKey: key,
          // since key can't be used as a prop
          level,
          root: level === 0,
          isGroup: isGroup2
        });
        if (tmNode.children) {
          if (tmNode.isGroup) {
            return vue.h(NMenuOptionGroup, keep(props, groupPropKeys, { tmNode, tmNodes: tmNode.children, key }));
          }
          return vue.h(NSubmenu, keep(props, submenuPropKeys, {
            key,
            rawNodes: rawNode[menuProps2.childrenField],
            tmNodes: tmNode.children,
            tmNode
          }));
        } else {
          return vue.h(NMenuOption, keep(props, itemPropKeys, {
            key,
            tmNode
          }));
        }
      }
      const hoverStyleChildren = [c$1("&::before", "background-color: var(--n-item-color-hover);"), cE("arrow", `
 color: var(--n-arrow-color-hover);
 `), cE("icon", `
 color: var(--n-item-icon-color-hover);
 `), cB("menu-item-content-header", `
 color: var(--n-item-text-color-hover);
 `, [c$1("a", `
 color: var(--n-item-text-color-hover);
 `), cE("extra", `
 color: var(--n-item-text-color-hover);
 `)])];
      const horizontalHoverStyleChildren = [cE("icon", `
 color: var(--n-item-icon-color-hover-horizontal);
 `), cB("menu-item-content-header", `
 color: var(--n-item-text-color-hover-horizontal);
 `, [c$1("a", `
 color: var(--n-item-text-color-hover-horizontal);
 `), cE("extra", `
 color: var(--n-item-text-color-hover-horizontal);
 `)])];
      const style$u = c$1([cB("menu", `
 background-color: var(--n-color);
 color: var(--n-item-text-color);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 box-sizing: border-box;
 font-size: var(--n-font-size);
 padding-bottom: 6px;
 `, [cM("horizontal", `
 display: inline-flex;
 padding-bottom: 0;
 `, [cB("submenu", "margin: 0;"), cB("menu-item", "margin: 0;"), cB("menu-item-content", `
 padding: 0 20px;
 border-bottom: 2px solid #0000;
 `, [c$1("&::before", "display: none;"), cM("selected", "border-bottom: 2px solid var(--n-border-color-horizontal)")]), cB("menu-item-content", [cM("selected", [cE("icon", "color: var(--n-item-icon-color-active-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-active-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-horizontal);")])]), cM("child-active", `
 border-bottom: 2px solid var(--n-border-color-horizontal);
 `, [cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-horizontal);
 `, [c$1("a", `
 color: var(--n-item-text-color-child-active-horizontal);
 `), cE("extra", `
 color: var(--n-item-text-color-child-active-horizontal);
 `)]), cE("icon", `
 color: var(--n-item-icon-color-child-active-horizontal);
 `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", horizontalHoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-active-hover-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-hover-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-hover-horizontal);")])])]), cM("child-active", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-child-active-hover-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-hover-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-child-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-child-active-hover-horizontal);")])])]), hoverStyle("border-bottom: 2px solid var(--n-border-color-horizontal);", horizontalHoverStyleChildren)]), cB("menu-item-content-header", [c$1("a", "color: var(--n-item-text-color-horizontal);")])])]), cM("collapsed", [cB("menu-item-content", [cM("selected", [c$1("&::before", `
 background-color: var(--n-item-color-active-collapsed) !important;
 `)]), cB("menu-item-content-header", "opacity: 0;"), cE("arrow", "opacity: 0;"), cE("icon", "color: var(--n-item-icon-color-collapsed);")])]), cB("menu-item", `
 height: var(--n-item-height);
 margin-top: 6px;
 position: relative;
 `), cB("menu-item-content", `
 box-sizing: border-box;
 line-height: 1.75;
 height: 100%;
 display: grid;
 grid-template-areas: "icon content arrow";
 grid-template-columns: auto 1fr auto;
 align-items: center;
 cursor: pointer;
 position: relative;
 padding-right: 18px;
 transition:
 background-color .3s var(--n-bezier),
 padding-left .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1("> *", "z-index: 1;"), c$1("&::before", `
 z-index: auto;
 content: "";
 background-color: #0000;
 position: absolute;
 left: 8px;
 right: 8px;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cM("disabled", `
 opacity: .45;
 cursor: not-allowed;
 `), cM("collapsed", [cE("arrow", "transform: rotate(0);")]), cM("selected", [c$1("&::before", "background-color: var(--n-item-color-active);"), cE("arrow", "color: var(--n-arrow-color-active);"), cE("icon", "color: var(--n-item-icon-color-active);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active);
 `, [c$1("a", "color: var(--n-item-text-color-active);"), cE("extra", "color: var(--n-item-text-color-active);")])]), cM("child-active", [cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active);
 `, [c$1("a", `
 color: var(--n-item-text-color-child-active);
 `), cE("extra", `
 color: var(--n-item-text-color-child-active);
 `)]), cE("arrow", `
 color: var(--n-arrow-color-child-active);
 `), cE("icon", `
 color: var(--n-item-icon-color-child-active);
 `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", hoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-active-hover);"), cE("icon", "color: var(--n-item-icon-color-active-hover);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-hover);
 `, [c$1("a", "color: var(--n-item-text-color-active-hover);"), cE("extra", "color: var(--n-item-text-color-active-hover);")])])]), cM("child-active", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-child-active-hover);"), cE("icon", "color: var(--n-item-icon-color-child-active-hover);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-hover);
 `, [c$1("a", "color: var(--n-item-text-color-child-active-hover);"), cE("extra", "color: var(--n-item-text-color-child-active-hover);")])])]), cM("selected", [hoverStyle(null, [c$1("&::before", "background-color: var(--n-item-color-active-hover);")])]), hoverStyle(null, hoverStyleChildren)]), cE("icon", `
 grid-area: icon;
 color: var(--n-item-icon-color);
 transition:
 color .3s var(--n-bezier),
 font-size .3s var(--n-bezier),
 margin-right .3s var(--n-bezier);
 box-sizing: content-box;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 `), cE("arrow", `
 grid-area: arrow;
 font-size: 16px;
 color: var(--n-arrow-color);
 transform: rotate(180deg);
 opacity: 1;
 transition:
 color .3s var(--n-bezier),
 transform 0.2s var(--n-bezier),
 opacity 0.2s var(--n-bezier);
 `), cB("menu-item-content-header", `
 grid-area: content;
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 opacity: 1;
 white-space: nowrap;
 overflow: hidden;
 text-overflow: ellipsis;
 color: var(--n-item-text-color);
 `, [c$1("a", `
 outline: none;
 text-decoration: none;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cE("extra", `
 font-size: .93em;
 color: var(--n-group-text-color);
 transition: color .3s var(--n-bezier);
 `)])]), cB("submenu", `
 cursor: pointer;
 position: relative;
 margin-top: 6px;
 `, [cB("menu-item-content", `
 height: var(--n-item-height);
 `), cB("submenu-children", `
 overflow: hidden;
 padding: 0;
 `, [fadeInHeightExpandTransition({
        duration: ".2s"
      })])]), cB("menu-item-group", [cB("menu-item-group-title", `
 margin-top: 6px;
 color: var(--n-group-text-color);
 cursor: default;
 font-size: .93em;
 height: 36px;
 display: flex;
 align-items: center;
 transition:
 padding-left .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)])]), cB("menu-tooltip", [c$1("a", `
 color: inherit;
 text-decoration: none;
 `)]), cB("menu-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 6px 18px;
 `)]);
      function hoverStyle(props, children) {
        return [cM("hover", props, children), c$1("&:hover", props, children)];
      }
      const menuProps = Object.assign(Object.assign({}, useTheme.props), {
        options: {
          type: Array,
          default: () => []
        },
        collapsed: {
          type: Boolean,
          default: void 0
        },
        collapsedWidth: {
          type: Number,
          default: 48
        },
        iconSize: {
          type: Number,
          default: 20
        },
        collapsedIconSize: {
          type: Number,
          default: 24
        },
        rootIndent: Number,
        indent: {
          type: Number,
          default: 32
        },
        labelField: {
          type: String,
          default: "label"
        },
        keyField: {
          type: String,
          default: "key"
        },
        childrenField: {
          type: String,
          default: "children"
        },
        disabledField: {
          type: String,
          default: "disabled"
        },
        defaultExpandAll: Boolean,
        defaultExpandedKeys: Array,
        expandedKeys: Array,
        value: [String, Number],
        defaultValue: {
          type: [String, Number],
          default: null
        },
        mode: {
          type: String,
          default: "vertical"
        },
        watchProps: {
          type: Array,
          default: void 0
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          default: true
        },
        inverted: Boolean,
        "onUpdate:expandedKeys": [Function, Array],
        onUpdateExpandedKeys: [Function, Array],
        onUpdateValue: [Function, Array],
        "onUpdate:value": [Function, Array],
        expandIcon: Function,
        renderIcon: Function,
        renderLabel: Function,
        renderExtra: Function,
        dropdownProps: Object,
        accordion: Boolean,
        nodeProps: Function,
        // deprecated
        items: Array,
        onOpenNamesChange: [Function, Array],
        onSelect: [Function, Array],
        onExpandedNamesChange: [Function, Array],
        expandedNames: Array,
        defaultExpandedNames: Array,
        dropdownPlacement: {
          type: String,
          default: "bottom"
        }
      });
      const Menu = vue.defineComponent({
        name: "Menu",
        props: menuProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Menu", "-menu", style$u, menuLight$1, props, mergedClsPrefixRef);
          const layoutSider = vue.inject(layoutSiderInjectionKey, null);
          const mergedCollapsedRef = vue.computed(() => {
            var _a;
            const { collapsed } = props;
            if (collapsed !== void 0)
              return collapsed;
            if (layoutSider) {
              const { collapseModeRef, collapsedRef } = layoutSider;
              if (collapseModeRef.value === "width") {
                return (_a = collapsedRef.value) !== null && _a !== void 0 ? _a : false;
              }
            }
            return false;
          });
          const treeMateRef = vue.computed(() => {
            const { keyField, childrenField, disabledField } = props;
            return createTreeMate(props.items || props.options, {
              getIgnored(node) {
                return isIgnoredNode(node);
              },
              getChildren(node) {
                return node[childrenField];
              },
              getDisabled(node) {
                return node[disabledField];
              },
              getKey(node) {
                var _a;
                return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
              }
            });
          });
          const treeKeysLevelOneRef = vue.computed(() => new Set(treeMateRef.value.treeNodes.map((e) => e.key)));
          const { watchProps } = props;
          const uncontrolledValueRef = vue.ref(null);
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultValue")) {
            vue.watchEffect(() => {
              uncontrolledValueRef.value = props.defaultValue;
            });
          } else {
            uncontrolledValueRef.value = props.defaultValue;
          }
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const uncontrolledExpandedKeysRef = vue.ref([]);
          const initUncontrolledExpandedKeys = () => {
            uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? treeMateRef.value.getNonLeafKeys() : props.defaultExpandedNames || props.defaultExpandedKeys || treeMateRef.value.getPath(mergedValueRef.value, {
              includeSelf: false
            }).keyPath;
          };
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultExpandedKeys")) {
            vue.watchEffect(initUncontrolledExpandedKeys);
          } else {
            initUncontrolledExpandedKeys();
          }
          const controlledExpandedKeysRef = useCompitable(props, [
            "expandedNames",
            "expandedKeys"
          ]);
          const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
          const tmNodesRef = vue.computed(() => treeMateRef.value.treeNodes);
          const activePathRef = vue.computed(() => {
            return treeMateRef.value.getPath(mergedValueRef.value).keyPath;
          });
          vue.provide(menuInjectionKey, {
            props,
            mergedCollapsedRef,
            mergedThemeRef: themeRef,
            mergedValueRef,
            mergedExpandedKeysRef,
            activePathRef,
            mergedClsPrefixRef,
            isHorizontalRef: vue.computed(() => props.mode === "horizontal"),
            invertedRef: vue.toRef(props, "inverted"),
            doSelect,
            toggleExpand
          });
          function doSelect(value, item) {
            const { "onUpdate:value": _onUpdateValue, onUpdateValue, onSelect } = props;
            if (onUpdateValue) {
              call(onUpdateValue, value, item);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value, item);
            }
            if (onSelect) {
              call(onSelect, value, item);
            }
            uncontrolledValueRef.value = value;
          }
          function doUpdateExpandedKeys(value) {
            const { "onUpdate:expandedKeys": _onUpdateExpandedKeys, onUpdateExpandedKeys, onExpandedNamesChange, onOpenNamesChange } = props;
            if (_onUpdateExpandedKeys) {
              call(_onUpdateExpandedKeys, value);
            }
            if (onUpdateExpandedKeys) {
              call(onUpdateExpandedKeys, value);
            }
            if (onExpandedNamesChange) {
              call(onExpandedNamesChange, value);
            }
            if (onOpenNamesChange) {
              call(onOpenNamesChange, value);
            }
            uncontrolledExpandedKeysRef.value = value;
          }
          function toggleExpand(key) {
            const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
            const index = currentExpandedKeys.findIndex((expanededKey) => expanededKey === key);
            if (~index) {
              currentExpandedKeys.splice(index, 1);
            } else {
              if (props.accordion) {
                if (treeKeysLevelOneRef.value.has(key)) {
                  const closeKeyIndex = currentExpandedKeys.findIndex((e) => treeKeysLevelOneRef.value.has(e));
                  if (closeKeyIndex > -1) {
                    currentExpandedKeys.splice(closeKeyIndex, 1);
                  }
                }
              }
              currentExpandedKeys.push(key);
            }
            doUpdateExpandedKeys(currentExpandedKeys);
          }
          const showOption = (key) => {
            const selectedKeyPath = treeMateRef.value.getPath(key !== null && key !== void 0 ? key : mergedValueRef.value, {
              includeSelf: false
            }).keyPath;
            if (!selectedKeyPath.length)
              return;
            const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
            const nextExpandedKeys = /* @__PURE__ */ new Set([
              ...currentExpandedKeys,
              ...selectedKeyPath
            ]);
            if (props.accordion) {
              treeKeysLevelOneRef.value.forEach((firstLevelKey) => {
                if (nextExpandedKeys.has(firstLevelKey) && !selectedKeyPath.includes(firstLevelKey)) {
                  nextExpandedKeys.delete(firstLevelKey);
                }
              });
            }
            doUpdateExpandedKeys(Array.from(nextExpandedKeys));
          };
          const cssVarsRef = vue.computed(() => {
            const { inverted } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const { borderRadius, borderColorHorizontal, fontSize: fontSize2, itemHeight, dividerColor } = self2;
            const vars = {
              "--n-divider-color": dividerColor,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-border-color-horizontal": borderColorHorizontal,
              "--n-border-radius": borderRadius,
              "--n-item-height": itemHeight
            };
            if (inverted) {
              vars["--n-group-text-color"] = self2.groupTextColorInverted;
              vars["--n-color"] = self2.colorInverted;
              vars["--n-item-text-color"] = self2.itemTextColorInverted;
              vars["--n-item-text-color-hover"] = self2.itemTextColorHoverInverted;
              vars["--n-item-text-color-active"] = self2.itemTextColorActiveInverted;
              vars["--n-item-text-color-child-active"] = self2.itemTextColorChildActiveInverted;
              vars["--n-item-text-color-child-active-hover"] = self2.itemTextColorChildActiveInverted;
              vars["--n-item-text-color-active-hover"] = self2.itemTextColorActiveHoverInverted;
              vars["--n-item-icon-color"] = self2.itemIconColorInverted;
              vars["--n-item-icon-color-hover"] = self2.itemIconColorHoverInverted;
              vars["--n-item-icon-color-active"] = self2.itemIconColorActiveInverted;
              vars["--n-item-icon-color-active-hover"] = self2.itemIconColorActiveHoverInverted;
              vars["--n-item-icon-color-child-active"] = self2.itemIconColorChildActiveInverted;
              vars["--n-item-icon-color-child-active-hover"] = self2.itemIconColorChildActiveHoverInverted;
              vars["--n-item-icon-color-collapsed"] = self2.itemIconColorCollapsedInverted;
              vars["--n-item-text-color-horizontal"] = self2.itemTextColorHorizontalInverted;
              vars["--n-item-text-color-hover-horizontal"] = self2.itemTextColorHoverHorizontalInverted;
              vars["--n-item-text-color-active-horizontal"] = self2.itemTextColorActiveHorizontalInverted;
              vars["--n-item-text-color-child-active-horizontal"] = self2.itemTextColorChildActiveHorizontalInverted;
              vars["--n-item-text-color-child-active-hover-horizontal"] = self2.itemTextColorChildActiveHoverHorizontalInverted;
              vars["--n-item-text-color-active-hover-horizontal"] = self2.itemTextColorActiveHoverHorizontalInverted;
              vars["--n-item-icon-color-horizontal"] = self2.itemIconColorHorizontalInverted;
              vars["--n-item-icon-color-hover-horizontal"] = self2.itemIconColorHoverHorizontalInverted;
              vars["--n-item-icon-color-active-horizontal"] = self2.itemIconColorActiveHorizontalInverted;
              vars["--n-item-icon-color-active-hover-horizontal"] = self2.itemIconColorActiveHoverHorizontalInverted;
              vars["--n-item-icon-color-child-active-horizontal"] = self2.itemIconColorChildActiveHorizontalInverted;
              vars["--n-item-icon-color-child-active-hover-horizontal"] = self2.itemIconColorChildActiveHoverHorizontalInverted;
              vars["--n-arrow-color"] = self2.arrowColorInverted;
              vars["--n-arrow-color-hover"] = self2.arrowColorHoverInverted;
              vars["--n-arrow-color-active"] = self2.arrowColorActiveInverted;
              vars["--n-arrow-color-active-hover"] = self2.arrowColorActiveHoverInverted;
              vars["--n-arrow-color-child-active"] = self2.arrowColorChildActiveInverted;
              vars["--n-arrow-color-child-active-hover"] = self2.arrowColorChildActiveHoverInverted;
              vars["--n-item-color-hover"] = self2.itemColorHoverInverted;
              vars["--n-item-color-active"] = self2.itemColorActiveInverted;
              vars["--n-item-color-active-hover"] = self2.itemColorActiveHoverInverted;
              vars["--n-item-color-active-collapsed"] = self2.itemColorActiveCollapsedInverted;
            } else {
              vars["--n-group-text-color"] = self2.groupTextColor;
              vars["--n-color"] = self2.color;
              vars["--n-item-text-color"] = self2.itemTextColor;
              vars["--n-item-text-color-hover"] = self2.itemTextColorHover;
              vars["--n-item-text-color-active"] = self2.itemTextColorActive;
              vars["--n-item-text-color-child-active"] = self2.itemTextColorChildActive;
              vars["--n-item-text-color-child-active-hover"] = self2.itemTextColorChildActiveHover;
              vars["--n-item-text-color-active-hover"] = self2.itemTextColorActiveHover;
              vars["--n-item-icon-color"] = self2.itemIconColor;
              vars["--n-item-icon-color-hover"] = self2.itemIconColorHover;
              vars["--n-item-icon-color-active"] = self2.itemIconColorActive;
              vars["--n-item-icon-color-active-hover"] = self2.itemIconColorActiveHover;
              vars["--n-item-icon-color-child-active"] = self2.itemIconColorChildActive;
              vars["--n-item-icon-color-child-active-hover"] = self2.itemIconColorChildActiveHover;
              vars["--n-item-icon-color-collapsed"] = self2.itemIconColorCollapsed;
              vars["--n-item-text-color-horizontal"] = self2.itemTextColorHorizontal;
              vars["--n-item-text-color-hover-horizontal"] = self2.itemTextColorHoverHorizontal;
              vars["--n-item-text-color-active-horizontal"] = self2.itemTextColorActiveHorizontal;
              vars["--n-item-text-color-child-active-horizontal"] = self2.itemTextColorChildActiveHorizontal;
              vars["--n-item-text-color-child-active-hover-horizontal"] = self2.itemTextColorChildActiveHoverHorizontal;
              vars["--n-item-text-color-active-hover-horizontal"] = self2.itemTextColorActiveHoverHorizontal;
              vars["--n-item-icon-color-horizontal"] = self2.itemIconColorHorizontal;
              vars["--n-item-icon-color-hover-horizontal"] = self2.itemIconColorHoverHorizontal;
              vars["--n-item-icon-color-active-horizontal"] = self2.itemIconColorActiveHorizontal;
              vars["--n-item-icon-color-active-hover-horizontal"] = self2.itemIconColorActiveHoverHorizontal;
              vars["--n-item-icon-color-child-active-horizontal"] = self2.itemIconColorChildActiveHorizontal;
              vars["--n-item-icon-color-child-active-hover-horizontal"] = self2.itemIconColorChildActiveHoverHorizontal;
              vars["--n-arrow-color"] = self2.arrowColor;
              vars["--n-arrow-color-hover"] = self2.arrowColorHover;
              vars["--n-arrow-color-active"] = self2.arrowColorActive;
              vars["--n-arrow-color-active-hover"] = self2.arrowColorActiveHover;
              vars["--n-arrow-color-child-active"] = self2.arrowColorChildActive;
              vars["--n-arrow-color-child-active-hover"] = self2.arrowColorChildActiveHover;
              vars["--n-item-color-hover"] = self2.itemColorHover;
              vars["--n-item-color-active"] = self2.itemColorActive;
              vars["--n-item-color-active-hover"] = self2.itemColorActiveHover;
              vars["--n-item-color-active-collapsed"] = self2.itemColorActiveCollapsed;
            }
            return vars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("menu", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            controlledExpandedKeys: controlledExpandedKeysRef,
            uncontrolledExpanededKeys: uncontrolledExpandedKeysRef,
            mergedExpandedKeys: mergedExpandedKeysRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            activePath: activePathRef,
            tmNodes: tmNodesRef,
            mergedTheme: themeRef,
            mergedCollapsed: mergedCollapsedRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            showOption
          };
        },
        render() {
          const { mergedClsPrefix, mode, themeClass, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", { role: mode === "horizontal" ? "menubar" : "menu", class: [
            `${mergedClsPrefix}-menu`,
            themeClass,
            `${mergedClsPrefix}-menu--${mode}`,
            this.mergedCollapsed && `${mergedClsPrefix}-menu--collapsed`
          ], style: this.cssVars }, this.tmNodes.map((tmNode) => itemRenderer(tmNode, this.$props)));
        }
      });
      function getRelativePosition(element, options = {
        debug: false,
        useSelectionEnd: false,
        checkWidthOverflow: true
      }) {
        const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;
        const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;
        const position = options.useSelectionEnd ? selectionEnd : selectionStart;
        const properties = [
          "direction",
          "boxSizing",
          "width",
          "height",
          "overflowX",
          "overflowY",
          "borderTopWidth",
          "borderRightWidth",
          "borderBottomWidth",
          "borderLeftWidth",
          "borderStyle",
          "paddingTop",
          "paddingRight",
          "paddingBottom",
          "paddingLeft",
          // https://developer.mozilla.org/en-US/docs/Web/CSS/font
          "fontStyle",
          "fontVariant",
          "fontWeight",
          "fontStretch",
          "fontSize",
          "fontSizeAdjust",
          "lineHeight",
          "fontFamily",
          "textAlign",
          "textTransform",
          "textIndent",
          "textDecoration",
          "letterSpacing",
          "wordSpacing",
          "tabSize",
          "MozTabSize"
        ];
        const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
        if (!isBrowser$2) {
          throw new Error("textarea-caret-position#getCaretPosition should only be called in a browser");
        }
        const debug = options === null || options === void 0 ? void 0 : options.debug;
        if (debug) {
          const el = document.querySelector("#input-textarea-caret-position-mirror-div");
          if (el === null || el === void 0 ? void 0 : el.parentNode)
            el.parentNode.removeChild(el);
        }
        const div = document.createElement("div");
        div.id = "input-textarea-caret-position-mirror-div";
        document.body.appendChild(div);
        const style2 = div.style;
        const computed2 = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;
        const isInput = element.nodeName === "INPUT";
        style2.whiteSpace = isInput ? "nowrap" : "pre-wrap";
        if (!isInput)
          style2.wordWrap = "break-word";
        style2.position = "absolute";
        if (!debug)
          style2.visibility = "hidden";
        properties.forEach((prop) => {
          if (isInput && prop === "lineHeight") {
            if (computed2.boxSizing === "border-box") {
              const height = parseInt(computed2.height);
              const outerHeight = parseInt(computed2.paddingTop) + parseInt(computed2.paddingBottom) + parseInt(computed2.borderTopWidth) + parseInt(computed2.borderBottomWidth);
              const targetHeight = outerHeight + parseInt(computed2.lineHeight);
              if (height > targetHeight) {
                style2.lineHeight = `${height - outerHeight}px`;
              } else if (height === targetHeight) {
                style2.lineHeight = computed2.lineHeight;
              } else {
                style2.lineHeight = "0";
              }
            } else {
              style2.lineHeight = computed2.height;
            }
          } else {
            style2[prop] = computed2[prop];
          }
        });
        if (isFirefox) {
          if (element.scrollHeight > parseInt(computed2.height)) {
            style2.overflowY = "scroll";
          }
        } else {
          style2.overflow = "hidden";
        }
        div.textContent = element.value.substring(0, position);
        if (isInput && div.textContent) {
          div.textContent = div.textContent.replace(/\s/g, "");
        }
        const span = document.createElement("span");
        span.textContent = element.value.substring(position) || ".";
        span.style.position = "relative";
        span.style.left = `${-element.scrollLeft}px`;
        span.style.top = `${-element.scrollTop}px`;
        div.appendChild(span);
        const relativePosition = {
          top: span.offsetTop + parseInt(computed2.borderTopWidth),
          left: span.offsetLeft + parseInt(computed2.borderLeftWidth),
          absolute: false,
          // We don't use line-height since it may be too large for position. Eg. 34px
          // for input
          height: parseInt(computed2.fontSize) * 1.5
        };
        if (debug) {
          span.style.backgroundColor = "#aaa";
        } else {
          document.body.removeChild(div);
        }
        if (relativePosition.left >= element.clientWidth && options.checkWidthOverflow) {
          relativePosition.left = element.clientWidth;
        }
        return relativePosition;
      }
      const style$t = c$1([cB("mention", "width: 100%; z-index: auto; position: relative;"), cB("mention-menu", `
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
        originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
      })])]);
      const mentionProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        autosize: [Boolean, Object],
        options: {
          type: Array,
          default: []
        },
        type: {
          type: String,
          default: "text"
        },
        separator: {
          type: String,
          validator: (separator) => {
            if (separator.length !== 1) {
              warn$2("mention", "`separator`'s length must be 1.");
              return false;
            }
            return true;
          },
          default: " "
        },
        bordered: {
          type: Boolean,
          default: void 0
        },
        disabled: Boolean,
        value: String,
        defaultValue: {
          type: String,
          default: ""
        },
        loading: Boolean,
        prefix: {
          type: [String, Array],
          default: "@"
        },
        placeholder: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "bottom-start"
        },
        size: String,
        renderLabel: Function,
        status: String,
        "onUpdate:show": [Array, Function],
        onUpdateShow: [Array, Function],
        "onUpdate:value": [Array, Function],
        onUpdateValue: [Array, Function],
        onSearch: Function,
        onSelect: Function,
        onFocus: Function,
        onBlur: Function,
        // private
        internalDebug: Boolean
      });
      const Mention = vue.defineComponent({
        name: "Mention",
        props: mentionProps,
        setup(props) {
          const { namespaceRef, mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Mention", "-mention", style$t, mentionLight$1, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const inputInstRef = vue.ref(null);
          const cursorRef = vue.ref(null);
          const followerRef = vue.ref(null);
          const partialPatternRef = vue.ref("");
          let cachedPrefix = null;
          let cachedPartialPatternStart = null;
          let cachedPartialPatternEnd = null;
          const filteredOptionsRef = vue.computed(() => {
            const { value: pattern2 } = partialPatternRef;
            return props.options.filter((option) => {
              if (!pattern2)
                return true;
              if (typeof option.label === "string") {
                return option.label.startsWith(pattern2);
              }
              if (typeof option.value === "string") {
                return option.value.startsWith(pattern2);
              }
              return false;
            });
          });
          const treeMateRef = vue.computed(() => {
            return createTreeMate(filteredOptionsRef.value, {
              getKey: (v) => {
                return v.value;
              }
            });
          });
          const selectMenuInstRef = vue.ref(null);
          const showMenuRef = vue.ref(false);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const cssVarsRef = vue.computed(() => {
            const { self: { menuBoxShadow } } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("mention", void 0, cssVarsRef, props) : void 0;
          function doUpdateShowMenu(show) {
            if (props.disabled)
              return;
            const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow)
              call(onUpdateShow, show);
            if (_onUpdateShow)
              call(_onUpdateShow, show);
            if (!show) {
              cachedPrefix = null;
              cachedPartialPatternStart = null;
              cachedPartialPatternEnd = null;
            }
            showMenuRef.value = show;
          }
          function doUpdateValue(value) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            if (_onUpdateValue) {
              call(_onUpdateValue, value);
            }
            if (onUpdateValue) {
              call(onUpdateValue, value);
            }
            nTriggerFormInput();
            nTriggerFormChange();
            uncontrolledValueRef.value = value;
          }
          function getInputEl() {
            return props.type === "text" ? inputInstRef.value.inputElRef : inputInstRef.value.textareaElRef;
          }
          function deriveShowMenu() {
            var _a;
            const inputEl = getInputEl();
            if (document.activeElement !== inputEl) {
              doUpdateShowMenu(false);
              return;
            }
            const { selectionEnd } = inputEl;
            if (selectionEnd === null) {
              doUpdateShowMenu(false);
              return;
            }
            const inputValue = inputEl.value;
            const { separator } = props;
            const { prefix: prefix2 } = props;
            const prefixArray = typeof prefix2 === "string" ? [prefix2] : prefix2;
            for (let i = selectionEnd - 1; i >= 0; --i) {
              const char = inputValue[i];
              if (char === separator || char === "\n" || char === "\r") {
                doUpdateShowMenu(false);
                return;
              }
              if (prefixArray.includes(char)) {
                const partialPattern = inputValue.slice(i + 1, selectionEnd);
                doUpdateShowMenu(true);
                (_a = props.onSearch) === null || _a === void 0 ? void 0 : _a.call(props, partialPattern, char);
                partialPatternRef.value = partialPattern;
                cachedPrefix = char;
                cachedPartialPatternStart = i + 1;
                cachedPartialPatternEnd = selectionEnd;
                return;
              }
            }
            doUpdateShowMenu(false);
          }
          function syncCursor() {
            const { value: cursorAnchor } = cursorRef;
            if (!cursorAnchor)
              return;
            const inputEl = getInputEl();
            const cursorPos = getRelativePosition(inputEl);
            cursorPos.left += inputEl.parentElement.offsetLeft;
            cursorAnchor.style.left = `${cursorPos.left}px`;
            cursorAnchor.style.top = `${cursorPos.top + cursorPos.height}px`;
          }
          function syncPosition() {
            var _a;
            if (!showMenuRef.value)
              return;
            (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleInputUpdateValue(value) {
            doUpdateValue(value);
            syncAfterCursorMove();
          }
          function syncAfterCursorMove() {
            setTimeout(() => {
              syncCursor();
              deriveShowMenu();
              void vue.nextTick().then(syncPosition);
            }, 0);
          }
          function handleInputKeyDown(e) {
            var _a, _b;
            if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
              if ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.isCompositing)
                return;
              syncAfterCursorMove();
            } else if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "Enter") {
              if ((_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.isCompositing)
                return;
              const { value: selectMenuInst } = selectMenuInstRef;
              if (showMenuRef.value) {
                if (selectMenuInst) {
                  e.preventDefault();
                  if (e.key === "ArrowUp") {
                    selectMenuInst.prev();
                  } else if (e.key === "ArrowDown") {
                    selectMenuInst.next();
                  } else {
                    const pendingOptionTmNode = selectMenuInst.getPendingTmNode();
                    if (pendingOptionTmNode) {
                      handleSelect(pendingOptionTmNode);
                    } else {
                      doUpdateShowMenu(false);
                    }
                  }
                }
              } else {
                syncAfterCursorMove();
              }
            }
          }
          function handleInputFocus(e) {
            const { onFocus } = props;
            onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
            const { nTriggerFormFocus } = formItem;
            nTriggerFormFocus();
            syncAfterCursorMove();
          }
          function focus() {
            var _a;
            (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function blur() {
            var _a;
            (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
          }
          function handleInputBlur(e) {
            const { onBlur } = props;
            onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
            const { nTriggerFormBlur } = formItem;
            nTriggerFormBlur();
            doUpdateShowMenu(false);
          }
          function handleSelect(tmNode) {
            var _a;
            if (cachedPrefix === null || cachedPartialPatternStart === null || cachedPartialPatternEnd === null) {
              return;
            }
            const { rawNode: { value = "" } } = tmNode;
            const inputEl = getInputEl();
            const inputValue = inputEl.value;
            const { separator } = props;
            const nextEndPart = inputValue.slice(cachedPartialPatternEnd);
            const alreadySeparated = nextEndPart.startsWith(separator);
            const nextMiddlePart = `${value}${alreadySeparated ? "" : separator}`;
            doUpdateValue(inputValue.slice(0, cachedPartialPatternStart) + nextMiddlePart + nextEndPart);
            (_a = props.onSelect) === null || _a === void 0 ? void 0 : _a.call(props, tmNode.rawNode, cachedPrefix);
            const nextSelectionEnd = cachedPartialPatternStart + nextMiddlePart.length + (alreadySeparated ? 1 : 0);
            void vue.nextTick().then(() => {
              inputEl.selectionStart = nextSelectionEnd;
              inputEl.selectionEnd = nextSelectionEnd;
              deriveShowMenu();
            });
          }
          function handleInputMouseDown() {
            if (!props.disabled) {
              syncAfterCursorMove();
            }
          }
          return {
            namespace: namespaceRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            mergedSize: formItem.mergedSizeRef,
            mergedStatus: formItem.mergedStatusRef,
            mergedTheme: themeRef,
            treeMate: treeMateRef,
            selectMenuInstRef,
            inputInstRef,
            cursorRef,
            followerRef,
            showMenu: showMenuRef,
            adjustedTo: useAdjustedTo(props),
            isMounted: isMounted(),
            mergedValue: mergedValueRef,
            handleInputFocus,
            handleInputBlur,
            handleInputUpdateValue,
            handleInputKeyDown,
            handleSelect,
            handleInputMouseDown,
            focus,
            blur,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedTheme, mergedClsPrefix, $slots } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-mention` },
            vue.h(NInput, { status: this.mergedStatus, themeOverrides: mergedTheme.peerOverrides.Input, theme: mergedTheme.peers.Input, size: this.mergedSize, autosize: this.autosize, type: this.type, ref: "inputInstRef", placeholder: this.placeholder, onMousedown: this.handleInputMouseDown, onUpdateValue: this.handleInputUpdateValue, onKeydown: this.handleInputKeyDown, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur, bordered: this.mergedBordered, disabled: this.disabled, value: this.mergedValue }),
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => {
                    const style2 = {
                      position: "absolute",
                      width: 0,
                      height: 0
                    };
                    return vue.h("div", { style: style2, ref: "cursorRef" });
                  }
                }),
                vue.h(VFollower, { ref: "followerRef", placement: this.placement, show: this.showMenu, containerClass: this.namespace, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                    default: () => {
                      const { mergedTheme: mergedTheme2, onRender } = this;
                      onRender === null || onRender === void 0 ? void 0 : onRender();
                      return this.showMenu ? vue.h(NInternalSelectMenu, { clsPrefix: mergedClsPrefix, theme: mergedTheme2.peers.InternalSelectMenu, themeOverrides: mergedTheme2.peerOverrides.InternalSelectMenu, autoPending: true, ref: "selectMenuInstRef", class: [
                        `${mergedClsPrefix}-mention-menu`,
                        this.themeClass
                      ], loading: this.loading, treeMate: this.treeMate, virtualScroll: false, style: this.cssVars, onToggle: this.handleSelect, renderLabel: this.renderLabel }, $slots) : null;
                    }
                  })
                })
              ]
            })
          );
        }
      });
      const messageProps = {
        icon: Function,
        type: {
          type: String,
          default: "info"
        },
        content: [String, Number, Function],
        showIcon: {
          type: Boolean,
          default: true
        },
        closable: Boolean,
        keepAliveOnHover: Boolean,
        onClose: Function,
        onMouseenter: Function,
        onMouseleave: Function
      };
      const messageApiInjectionKey = createInjectionKey("n-message-api");
      const messageProviderInjectionKey = createInjectionKey("n-message-provider");
      const style$s = c$1([cB("message-wrapper", `
 margin: var(--n-margin);
 z-index: 0;
 transform-origin: top center;
 display: flex;
 `, [fadeInHeightExpandTransition({
        overflow: "visible",
        originalTransition: "transform .3s var(--n-bezier)",
        enterToProps: {
          transform: "scale(1)"
        },
        leaveToProps: {
          transform: "scale(0.85)"
        }
      })]), cB("message", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 margin-bottom .3s var(--n-bezier);
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 flex-wrap: nowrap;
 overflow: hidden;
 max-width: var(--n-max-width);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-shadow: var(--n-box-shadow);
 `, [cE("content", `
 display: inline-block;
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 `), cE("icon", `
 position: relative;
 margin: var(--n-icon-margin);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 flex-shrink: 0;
 `, [["default", "info", "success", "warning", "error", "loading"].map((type2) => cM(`${type2}-type`, [c$1("> *", `
 color: var(--n-icon-color-${type2});
 transition: color .3s var(--n-bezier);
 `)])), c$1("> *", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 flex-shrink: 0;
 `, [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `)])]), cB("message-container", `
 z-index: 6000;
 position: fixed;
 height: 0;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: center;
 `, [cM("top", `
 top: 12px;
 left: 0;
 right: 0;
 `), cM("top-left", `
 top: 12px;
 left: 12px;
 right: 0;
 align-items: flex-start;
 `), cM("top-right", `
 top: 12px;
 left: 0;
 right: 12px;
 align-items: flex-end;
 `), cM("bottom", `
 bottom: 4px;
 left: 0;
 right: 0;
 justify-content: flex-end;
 `), cM("bottom-left", `
 bottom: 4px;
 left: 12px;
 right: 0;
 justify-content: flex-end;
 align-items: flex-start;
 `), cM("bottom-right", `
 bottom: 4px;
 left: 0;
 right: 12px;
 justify-content: flex-end;
 align-items: flex-end;
 `)])]);
      const iconRenderMap$1 = {
        info: () => vue.h(InfoIcon, null),
        success: () => vue.h(SuccessIcon, null),
        warning: () => vue.h(WarningIcon, null),
        error: () => vue.h(ErrorIcon, null),
        default: () => null
      };
      const NMessage = vue.defineComponent({
        name: "Message",
        props: Object.assign(Object.assign({}, messageProps), { render: Function }),
        setup(props) {
          const { inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const {
            props: messageProviderProps2,
            mergedClsPrefixRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(messageProviderInjectionKey);
          const rtlEnabledRef = useRtl("Message", mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme("Message", "-message", style$s, messageLight$1, messageProviderProps2, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { type: type2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { padding, margin, maxWidth, iconMargin, closeMargin, closeSize, iconSize, fontSize: fontSize2, lineHeight: lineHeight2, borderRadius, iconColorInfo, iconColorSuccess, iconColorWarning, iconColorError, iconColorLoading, closeIconSize, closeBorderRadius, [createKey("textColor", type2)]: textColor, [createKey("boxShadow", type2)]: boxShadow, [createKey("color", type2)]: color, [createKey("closeColorHover", type2)]: closeColorHover, [createKey("closeColorPressed", type2)]: closeColorPressed, [createKey("closeIconColor", type2)]: closeIconColor, [createKey("closeIconColorPressed", type2)]: closeIconColorPressed, [createKey("closeIconColorHover", type2)]: closeIconColorHover } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-margin": margin,
              "--n-padding": padding,
              "--n-max-width": maxWidth,
              "--n-font-size": fontSize2,
              "--n-icon-margin": iconMargin,
              "--n-icon-size": iconSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-size": closeSize,
              "--n-close-margin": closeMargin,
              "--n-text-color": textColor,
              "--n-color": color,
              "--n-box-shadow": boxShadow,
              "--n-icon-color-info": iconColorInfo,
              "--n-icon-color-success": iconColorSuccess,
              "--n-icon-color-warning": iconColorWarning,
              "--n-icon-color-error": iconColorError,
              "--n-icon-color-loading": iconColorLoading,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-line-height": lineHeight2,
              "--n-border-radius": borderRadius
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("message", vue.computed(() => props.type[0]), cssVarsRef, {}) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            messageProviderProps: messageProviderProps2,
            handleClose() {
              var _a;
              (_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props);
            },
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            placement: messageProviderProps2.placement
          };
        },
        render() {
          const { render: renderMessage, type: type2, closable, content, mergedClsPrefix, cssVars, themeClass, onRender, icon, handleClose, showIcon } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          let iconNode;
          return vue.h("div", { class: [`${mergedClsPrefix}-message-wrapper`, themeClass], onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave, style: [
            {
              alignItems: this.placement.startsWith("top") ? "flex-start" : "flex-end"
            },
            cssVars
          ] }, renderMessage ? renderMessage(this.$props) : vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-message ${mergedClsPrefix}-message--${type2}-type`,
              this.rtlEnabled && `${mergedClsPrefix}-message--rtl`
            ] },
            (iconNode = createIconVNode(icon, type2, mergedClsPrefix)) && showIcon ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-message__icon ${mergedClsPrefix}-message__icon--${type2}-type` },
              vue.h(NIconSwitchTransition, null, {
                default: () => iconNode
              })
            ) : null,
            vue.h("div", { class: `${mergedClsPrefix}-message__content` }, render$1(content)),
            closable ? vue.h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-message__close`, onClick: handleClose, absolute: true }) : null
          ));
        }
      });
      function createIconVNode(icon, type2, clsPrefix) {
        if (typeof icon === "function") {
          return icon();
        } else {
          const innerIcon = type2 === "loading" ? vue.h(NBaseLoading, { clsPrefix, strokeWidth: 24, scale: 0.85 }) : iconRenderMap$1[type2]();
          if (!innerIcon)
            return null;
          return vue.h(NBaseIcon, { clsPrefix, key: type2 }, {
            default: () => innerIcon
          });
        }
      }
      const MessageEnvironment = vue.defineComponent({
        name: "MessageEnvironment",
        props: Object.assign(Object.assign({}, messageProps), {
          duration: {
            type: Number,
            default: 3e3
          },
          onAfterLeave: Function,
          onLeave: Function,
          internalKey: {
            type: String,
            required: true
          },
          // private
          onInternalAfterLeave: Function,
          // deprecated
          onHide: Function,
          onAfterHide: Function
        }),
        setup(props) {
          let timerId = null;
          const showRef = vue.ref(true);
          vue.onMounted(() => {
            setHideTimeout();
          });
          function setHideTimeout() {
            const { duration } = props;
            if (duration) {
              timerId = window.setTimeout(hide, duration);
            }
          }
          function handleMouseenter(e) {
            if (e.currentTarget !== e.target)
              return;
            if (timerId !== null) {
              window.clearTimeout(timerId);
              timerId = null;
            }
          }
          function handleMouseleave(e) {
            if (e.currentTarget !== e.target)
              return;
            setHideTimeout();
          }
          function hide() {
            const { onHide } = props;
            showRef.value = false;
            if (timerId) {
              window.clearTimeout(timerId);
              timerId = null;
            }
            if (onHide)
              onHide();
          }
          function handleClose() {
            const { onClose } = props;
            if (onClose)
              onClose();
            hide();
          }
          function handleAfterLeave() {
            const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
            if (onAfterLeave)
              onAfterLeave();
            if (onInternalAfterLeave)
              onInternalAfterLeave(internalKey);
            if (onAfterHide)
              onAfterHide();
          }
          function deactivate() {
            hide();
          }
          return {
            show: showRef,
            hide,
            handleClose,
            handleAfterLeave,
            handleMouseleave,
            handleMouseenter,
            deactivate
          };
        },
        render() {
          return vue.h(NFadeInExpandTransition, { appear: true, onAfterLeave: this.handleAfterLeave, onLeave: this.onLeave }, {
            default: () => [
              this.show ? vue.h(NMessage, { content: this.content, type: this.type, icon: this.icon, showIcon: this.showIcon, closable: this.closable, onClose: this.handleClose, onMouseenter: this.keepAliveOnHover ? this.handleMouseenter : void 0, onMouseleave: this.keepAliveOnHover ? this.handleMouseleave : void 0 }) : null
            ]
          });
        }
      });
      const messageProviderProps = Object.assign(Object.assign({}, useTheme.props), { to: [String, Object], duration: {
        type: Number,
        default: 3e3
      }, keepAliveOnHover: Boolean, max: Number, placement: {
        type: String,
        default: "top"
      }, closable: Boolean, containerStyle: [String, Object] });
      const NMessageProvider = vue.defineComponent({
        name: "MessageProvider",
        props: messageProviderProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const messageListRef = vue.ref([]);
          const messageRefs = vue.ref({});
          const api = {
            create(content, options) {
              return create2(content, Object.assign({ type: "default" }, options));
            },
            info(content, options) {
              return create2(content, Object.assign(Object.assign({}, options), { type: "info" }));
            },
            success(content, options) {
              return create2(content, Object.assign(Object.assign({}, options), { type: "success" }));
            },
            warning(content, options) {
              return create2(content, Object.assign(Object.assign({}, options), { type: "warning" }));
            },
            error(content, options) {
              return create2(content, Object.assign(Object.assign({}, options), { type: "error" }));
            },
            loading(content, options) {
              return create2(content, Object.assign(Object.assign({}, options), { type: "loading" }));
            },
            destroyAll
          };
          vue.provide(messageProviderInjectionKey, {
            props,
            mergedClsPrefixRef
          });
          vue.provide(messageApiInjectionKey, api);
          function create2(content, options) {
            const key = createId();
            const messageReactive = vue.reactive(Object.assign(Object.assign({}, options), {
              content,
              key,
              destroy: () => {
                var _a;
                (_a = messageRefs.value[key]) === null || _a === void 0 ? void 0 : _a.hide();
              }
            }));
            const { max } = props;
            if (max && messageListRef.value.length >= max) {
              messageListRef.value.shift();
            }
            messageListRef.value.push(messageReactive);
            return messageReactive;
          }
          function handleAfterLeave(key) {
            messageListRef.value.splice(messageListRef.value.findIndex((message2) => message2.key === key), 1);
            delete messageRefs.value[key];
          }
          function destroyAll() {
            Object.values(messageRefs.value).forEach((messageInstRef) => {
              messageInstRef.hide();
            });
          }
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            messageRefs,
            messageList: messageListRef,
            handleAfterLeave
          }, api);
        },
        render() {
          var _a, _b, _c;
          return vue.h(
            vue.Fragment,
            null,
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a),
            this.messageList.length ? vue.h(
              vue.Teleport,
              { to: (_c = this.to) !== null && _c !== void 0 ? _c : "body" },
              vue.h("div", { class: [
                `${this.mergedClsPrefix}-message-container`,
                `${this.mergedClsPrefix}-message-container--${this.placement}`
              ], key: "message-container", style: this.containerStyle }, this.messageList.map((message2) => {
                return vue.h(MessageEnvironment, Object.assign({ ref: (inst) => {
                  if (inst) {
                    this.messageRefs[message2.key] = inst;
                  }
                }, internalKey: message2.key, onInternalAfterLeave: this.handleAfterLeave }, omit(message2, ["destroy"], void 0), { duration: message2.duration === void 0 ? this.duration : message2.duration, keepAliveOnHover: message2.keepAliveOnHover === void 0 ? this.keepAliveOnHover : message2.keepAliveOnHover, closable: message2.closable === void 0 ? this.closable : message2.closable }));
              }))
            ) : null
          );
        }
      });
      function useMessage() {
        const api = vue.inject(messageApiInjectionKey, null);
        if (api === null) {
          throwError("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.");
        }
        return api;
      }
      const notificationProviderInjectionKey = createInjectionKey("n-notification-provider");
      const NotificationContainer = vue.defineComponent({
        name: "NotificationContainer",
        props: {
          scrollable: {
            type: Boolean,
            required: true
          },
          placement: {
            type: String,
            required: true
          }
        },
        setup() {
          const { mergedThemeRef, mergedClsPrefixRef, wipTransitionCountRef } = vue.inject(notificationProviderInjectionKey);
          const selfRef = vue.ref(null);
          vue.watchEffect(() => {
            var _a, _b;
            if (wipTransitionCountRef.value > 0) {
              (_a = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _a === void 0 ? void 0 : _a.classList.add("transitioning");
            } else {
              (_b = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _b === void 0 ? void 0 : _b.classList.remove("transitioning");
            }
          });
          return {
            selfRef,
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            transitioning: wipTransitionCountRef
          };
        },
        render() {
          const { $slots, scrollable, mergedClsPrefix, mergedTheme, placement } = this;
          return vue.h("div", { ref: "selfRef", class: [
            `${mergedClsPrefix}-notification-container`,
            scrollable && `${mergedClsPrefix}-notification-container--scrollable`,
            `${mergedClsPrefix}-notification-container--${placement}`
          ] }, scrollable ? vue.h(NScrollbar, { theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, contentStyle: { overflow: "hidden" } }, $slots) : $slots);
        }
      });
      const iconRenderMap = {
        info: () => vue.h(InfoIcon, null),
        success: () => vue.h(SuccessIcon, null),
        warning: () => vue.h(WarningIcon, null),
        error: () => vue.h(ErrorIcon, null),
        default: () => null
      };
      const notificationProps = {
        closable: {
          type: Boolean,
          default: true
        },
        type: {
          type: String,
          default: "default"
        },
        avatar: Function,
        title: [String, Function],
        description: [String, Function],
        content: [String, Function],
        meta: [String, Function],
        action: [String, Function],
        onClose: {
          type: Function,
          required: true
        },
        keepAliveOnHover: Boolean,
        onMouseenter: Function,
        onMouseleave: Function
      };
      const notificationPropKeys = keysOf(notificationProps);
      const Notification = vue.defineComponent({
        name: "Notification",
        props: notificationProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            props: providerProps
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(notificationProviderInjectionKey);
          const { inlineThemeDisabled, mergedRtlRef } = useConfig();
          const rtlEnabledRef = useRtl("Notification", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { type: type2 } = props;
            const { self: { color, textColor, closeIconColor, closeIconColorHover, closeIconColorPressed, headerTextColor, descriptionTextColor, actionTextColor, borderRadius, headerFontWeight, boxShadow, lineHeight: lineHeight2, fontSize: fontSize2, closeMargin, closeSize, width, padding, closeIconSize, closeBorderRadius, closeColorHover, closeColorPressed, titleFontSize, metaFontSize, descriptionFontSize, [createKey("iconColor", type2)]: iconColor }, common: { cubicBezierEaseOut: cubicBezierEaseOut2, cubicBezierEaseIn: cubicBezierEaseIn2, cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = mergedThemeRef.value;
            const { left, right, top, bottom } = getMargin(padding);
            return {
              "--n-color": color,
              "--n-font-size": fontSize2,
              "--n-text-color": textColor,
              "--n-description-text-color": descriptionTextColor,
              "--n-action-text-color": actionTextColor,
              "--n-title-text-color": headerTextColor,
              "--n-title-font-weight": headerFontWeight,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-bezier-ease-in": cubicBezierEaseIn2,
              "--n-border-radius": borderRadius,
              "--n-box-shadow": boxShadow,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-line-height": lineHeight2,
              "--n-icon-color": iconColor,
              "--n-close-margin": closeMargin,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-width": width,
              "--n-padding-left": left,
              "--n-padding-right": right,
              "--n-padding-top": top,
              "--n-padding-bottom": bottom,
              "--n-title-font-size": titleFontSize,
              "--n-meta-font-size": metaFontSize,
              "--n-description-font-size": descriptionFontSize
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("notification", vue.computed(() => props.type[0]), cssVarsRef, providerProps) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            showAvatar: vue.computed(() => {
              return props.avatar || props.type !== "default";
            }),
            handleCloseClick() {
              props.onClose();
            },
            rtlEnabled: rtlEnabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-notification-wrapper`, this.themeClass], onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave, style: this.cssVars },
            vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-notification`,
                this.rtlEnabled && `${mergedClsPrefix}-notification--rtl`,
                this.themeClass,
                {
                  [`${mergedClsPrefix}-notification--closable`]: this.closable,
                  [`${mergedClsPrefix}-notification--show-avatar`]: this.showAvatar
                }
              ], style: this.cssVars },
              this.showAvatar ? vue.h("div", { class: `${mergedClsPrefix}-notification__avatar` }, this.avatar ? render$1(this.avatar) : this.type !== "default" ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => iconRenderMap[this.type]() }) : null) : null,
              this.closable ? vue.h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-notification__close`, onClick: this.handleCloseClick }) : null,
              vue.h(
                "div",
                { ref: "bodyRef", class: `${mergedClsPrefix}-notification-main` },
                this.title ? vue.h("div", { class: `${mergedClsPrefix}-notification-main__header` }, render$1(this.title)) : null,
                this.description ? vue.h("div", { class: `${mergedClsPrefix}-notification-main__description` }, render$1(this.description)) : null,
                this.content ? vue.h("pre", { class: `${mergedClsPrefix}-notification-main__content` }, render$1(this.content)) : null,
                this.meta || this.action ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-notification-main-footer` },
                  this.meta ? vue.h("div", { class: `${mergedClsPrefix}-notification-main-footer__meta` }, render$1(this.meta)) : null,
                  this.action ? vue.h("div", { class: `${mergedClsPrefix}-notification-main-footer__action` }, render$1(this.action)) : null
                ) : null
              )
            )
          );
        }
      });
      const notificationEnvOptions = Object.assign(Object.assign({}, notificationProps), {
        duration: Number,
        onClose: Function,
        onLeave: Function,
        onAfterEnter: Function,
        onAfterLeave: Function,
        /** @deprecated */
        onHide: Function,
        /** @deprecated */
        onAfterShow: Function,
        /** @deprecated */
        onAfterHide: Function
      });
      const NotificationEnvironment = vue.defineComponent({
        name: "NotificationEnvironment",
        props: Object.assign(Object.assign({}, notificationEnvOptions), {
          // private
          internalKey: {
            type: String,
            required: true
          },
          onInternalAfterLeave: {
            type: Function,
            required: true
          }
        }),
        setup(props) {
          const {
            wipTransitionCountRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(notificationProviderInjectionKey);
          const showRef = vue.ref(true);
          let timerId = null;
          function hide() {
            showRef.value = false;
            if (timerId) {
              window.clearTimeout(timerId);
            }
          }
          function handleBeforeEnter(el) {
            wipTransitionCountRef.value++;
            void vue.nextTick(() => {
              el.style.height = `${el.offsetHeight}px`;
              el.style.maxHeight = "0";
              el.style.transition = "none";
              void el.offsetHeight;
              el.style.transition = "";
              el.style.maxHeight = el.style.height;
            });
          }
          function handleAfterEnter(el) {
            wipTransitionCountRef.value--;
            el.style.height = "";
            el.style.maxHeight = "";
            const { onAfterEnter, onAfterShow } = props;
            if (onAfterEnter)
              onAfterEnter();
            if (onAfterShow)
              onAfterShow();
          }
          function handleBeforeLeave(el) {
            wipTransitionCountRef.value++;
            el.style.maxHeight = `${el.offsetHeight}px`;
            el.style.height = `${el.offsetHeight}px`;
            void el.offsetHeight;
          }
          function handleLeave(el) {
            const { onHide } = props;
            if (onHide)
              onHide();
            el.style.maxHeight = "0";
            void el.offsetHeight;
          }
          function handleAfterLeave() {
            wipTransitionCountRef.value--;
            const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
            if (onAfterLeave)
              onAfterLeave();
            onInternalAfterLeave(internalKey);
            if (onAfterHide)
              onAfterHide();
          }
          function setHideTimeout() {
            const { duration } = props;
            if (duration) {
              timerId = window.setTimeout(hide, duration);
            }
          }
          function handleMouseenter(e) {
            if (e.currentTarget !== e.target)
              return;
            if (timerId !== null) {
              window.clearTimeout(timerId);
              timerId = null;
            }
          }
          function handleMouseleave(e) {
            if (e.currentTarget !== e.target)
              return;
            setHideTimeout();
          }
          function handleClose() {
            const { onClose } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((feedback) => {
                if (feedback === false)
                  return;
                hide();
              });
            } else {
              hide();
            }
          }
          vue.onMounted(() => {
            if (props.duration) {
              timerId = window.setTimeout(hide, props.duration);
            }
          });
          return {
            show: showRef,
            hide,
            handleClose,
            handleAfterLeave,
            handleLeave,
            handleBeforeLeave,
            handleAfterEnter,
            handleBeforeEnter,
            handleMouseenter,
            handleMouseleave
          };
        },
        render() {
          return vue.h(vue.Transition, {
            name: "notification-transition",
            appear: true,
            // convert to any since Element is not compitable with HTMLElement
            onBeforeEnter: this.handleBeforeEnter,
            onAfterEnter: this.handleAfterEnter,
            onBeforeLeave: this.handleBeforeLeave,
            onLeave: this.handleLeave,
            onAfterLeave: this.handleAfterLeave
          }, {
            default: () => {
              return this.show ? vue.h(Notification, Object.assign({}, keep(this.$props, notificationPropKeys), { onClose: this.handleClose, onMouseenter: this.duration && this.keepAliveOnHover ? this.handleMouseenter : void 0, onMouseleave: this.duration && this.keepAliveOnHover ? this.handleMouseleave : void 0 })) : null;
            }
          });
        }
      });
      const style$r = c$1([cB("notification-container", `
 z-index: 4000;
 position: fixed;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: flex-end;
 `, [c$1(">", [cB("scrollbar", `
 width: initial;
 overflow: visible;
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [c$1(">", [cB("scrollbar-container", `
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [cB("scrollbar-content", `
 padding-top: 12px;
 padding-bottom: 33px;
 `)])])])]), cM("top, top-right, top-left", `
 top: 12px;
 `, [c$1("&.transitioning >", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", `
 min-height: 100vh !important;
 `)])])])]), cM("bottom, bottom-right, bottom-left", `
 bottom: 12px;
 `, [c$1(">", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", [cB("scrollbar-content", `
 padding-bottom: 12px;
 `)])])])]), cB("notification-wrapper", `
 display: flex;
 align-items: flex-end;
 margin-bottom: 0;
 margin-top: 12px;
 `)]), cM("top, bottom", `
 left: 50%;
 transform: translateX(-50%);
 `, [cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 transform: scale(0.85);
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 transform: scale(1);
 `)])]), cM("top", [cB("notification-wrapper", `
 transform-origin: top center;
 `)]), cM("bottom", [cB("notification-wrapper", `
 transform-origin: bottom center;
 `)]), cM("top-right, bottom-right", [cB("notification", `
 margin-left: 28px;
 margin-right: 16px;
 `)]), cM("top-left, bottom-left", [cB("notification", `
 margin-left: 16px;
 margin-right: 28px;
 `)]), cM("top-right", `
 right: 0;
 `, [placementTransformStyle("top-right")]), cM("top-left", `
 left: 0;
 `, [placementTransformStyle("top-left")]), cM("bottom-right", `
 right: 0;
 `, [placementTransformStyle("bottom-right")]), cM("bottom-left", `
 left: 0;
 `, [placementTransformStyle("bottom-left")]), cM("scrollable", [cM("top-right", `
 top: 0;
 `), cM("top-left", `
 top: 0;
 `), cM("bottom-right", `
 bottom: 0;
 `), cM("bottom-left", `
 bottom: 0;
 `)]), cB("notification-wrapper", `
 margin-bottom: 12px;
 `, [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 opacity: 0;
 margin-top: 0 !important;
 margin-bottom: 0 !important;
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 opacity: 1;
 `), c$1("&.notification-transition-leave-active", `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-in),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `), c$1("&.notification-transition-enter-active", `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-out),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `)]), cB("notification", `
 background-color: var(--n-color);
 color: var(--n-text-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 font-family: inherit;
 font-size: var(--n-font-size);
 font-weight: 400;
 position: relative;
 display: flex;
 overflow: hidden;
 flex-shrink: 0;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 width: var(--n-width);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 box-sizing: border-box;
 opacity: 1;
 `, [cE("avatar", [cB("icon", {
        color: "var(--n-icon-color)"
      }), cB("base-icon", {
        color: "var(--n-icon-color)"
      })]), cM("show-avatar", [cB("notification-main", `
 margin-left: 40px;
 width: calc(100% - 40px); 
 `)]), cM("closable", [cB("notification-main", [c$1("> *:first-child", {
        paddingRight: "20px"
      })]), cE("close", `
 position: absolute;
 top: 0;
 right: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("avatar", `
 position: absolute;
 top: var(--n-padding-top);
 left: var(--n-padding-left);
 width: 28px;
 height: 28px;
 font-size: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("icon", "transition: color .3s var(--n-bezier);")]), cB("notification-main", `
 padding-top: var(--n-padding-top);
 padding-bottom: var(--n-padding-bottom);
 box-sizing: border-box;
 display: flex;
 flex-direction: column;
 margin-left: 8px;
 width: calc(100% - 8px);
 `, [cB("notification-main-footer", `
 display: flex;
 align-items: center;
 justify-content: space-between;
 margin-top: 12px;
 `, [cE("meta", `
 font-size: var(--n-meta-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE("action", `
 cursor: pointer;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-action-text-color);
 `)]), cE("header", `
 font-weight: var(--n-title-font-weight);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-title-text-color);
 `), cE("description", `
 margin-top: 8px;
 font-size: var(--n-description-font-size);
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE("content", `
 line-height: var(--n-line-height);
 margin: 12px 0 0 0;
 font-family: inherit;
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-text-color);
 `, [c$1("&:first-child", {
        margin: 0
      })])])])])]);
      function placementTransformStyle(placement) {
        const direction = placement.split("-")[1];
        const transformXEnter = direction === "left" ? "calc(-100%)" : "calc(100%)";
        const transformXLeave = "0";
        return cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 transform: translate(${transformXEnter}, 0);
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 transform: translate(${transformXLeave}, 0);
 `)]);
      }
      const notificationApiInjectionKey = createInjectionKey("n-notification-api");
      const notificationProviderProps = Object.assign(Object.assign({}, useTheme.props), { containerStyle: [String, Object], to: [String, Object], scrollable: {
        type: Boolean,
        default: true
      }, max: Number, placement: {
        type: String,
        default: "top-right"
      }, keepAliveOnHover: Boolean });
      const NNotificationProvider = vue.defineComponent({
        name: "NotificationProvider",
        props: notificationProviderProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const notificationListRef = vue.ref([]);
          const notificationRefs = {};
          const leavingKeySet = /* @__PURE__ */ new Set();
          function create2(options) {
            const key = createId();
            const destroy = () => {
              leavingKeySet.add(key);
              if (notificationRefs[key]) {
                notificationRefs[key].hide();
              }
            };
            const notificationReactive = vue.reactive(Object.assign(Object.assign({}, options), {
              key,
              destroy,
              hide: destroy,
              deactivate: destroy
            }));
            const { max } = props;
            if (max && notificationListRef.value.length - leavingKeySet.size >= max) {
              let someoneMountedRemoved = false;
              let index = 0;
              for (const notification of notificationListRef.value) {
                if (!leavingKeySet.has(notification.key)) {
                  if (notificationRefs[notification.key]) {
                    notification.destroy();
                    someoneMountedRemoved = true;
                  }
                  break;
                }
                index++;
              }
              if (!someoneMountedRemoved) {
                notificationListRef.value.splice(index, 1);
              }
            }
            notificationListRef.value.push(notificationReactive);
            return notificationReactive;
          }
          const apis = ["info", "success", "warning", "error"].map((type2) => {
            return (options) => create2(Object.assign(Object.assign({}, options), { type: type2 }));
          });
          function handleAfterLeave(key) {
            leavingKeySet.delete(key);
            notificationListRef.value.splice(notificationListRef.value.findIndex((notification) => notification.key === key), 1);
          }
          const themeRef = useTheme("Notification", "-notification", style$r, notificationLight$1, props, mergedClsPrefixRef);
          const api = {
            create: create2,
            info: apis[0],
            success: apis[1],
            warning: apis[2],
            error: apis[3],
            open,
            destroyAll
          };
          const wipTransitionCountRef = vue.ref(0);
          vue.provide(notificationApiInjectionKey, api);
          vue.provide(notificationProviderInjectionKey, {
            props,
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            wipTransitionCountRef
          });
          function open(options) {
            return create2(options);
          }
          function destroyAll() {
            Object.values(notificationListRef.value).forEach((notification) => {
              notification.hide();
            });
          }
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            notificationList: notificationListRef,
            notificationRefs,
            handleAfterLeave
          }, api);
        },
        render() {
          var _a, _b, _c;
          const { placement } = this;
          return vue.h(
            vue.Fragment,
            null,
            (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a),
            this.notificationList.length ? vue.h(
              vue.Teleport,
              { to: (_c = this.to) !== null && _c !== void 0 ? _c : "body" },
              vue.h(NotificationContainer, { style: this.containerStyle, scrollable: this.scrollable && placement !== "top" && placement !== "bottom", placement }, {
                default: () => {
                  return this.notificationList.map((notification) => {
                    return vue.h(NotificationEnvironment, Object.assign({ ref: (inst) => {
                      const refKey = notification.key;
                      if (inst === null) {
                        delete this.notificationRefs[refKey];
                      } else
                        this.notificationRefs[refKey] = inst;
                    } }, omit(notification, [
                      "destroy",
                      "hide",
                      "deactivate"
                    ]), { internalKey: notification.key, onInternalAfterLeave: this.handleAfterLeave, keepAliveOnHover: notification.keepAliveOnHover === void 0 ? this.keepAliveOnHover : notification.keepAliveOnHover }));
                  });
                }
              })
            ) : null
          );
        }
      });
      function useNotification() {
        const api = vue.inject(notificationApiInjectionKey, null);
        if (api === null) {
          throwError("use-notification", "No outer `n-notification-provider` found.");
        }
        return api;
      }
      const style$q = c$1([cB("page-header-header", `
 margin-bottom: 20px;
 `), cB("page-header", `
 display: flex;
 align-items: center;
 justify-content: space-between;
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cE("main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 `), cE("back", `
 display: flex;
 margin-right: 16px;
 font-size: var(--n-back-size);
 cursor: pointer;
 color: var(--n-back-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&:hover", "color: var(--n-back-color-hover);"), c$1("&:active", "color: var(--n-back-color-pressed);")]), cE("avatar", `
 display: flex;
 margin-right: 12px
 `), cE("title", `
 margin-right: 16px;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE("subtitle", `
 font-size: 14px;
 transition: color .3s var(--n-bezier);
 color: var(--n-subtitle-text-color);
 `)]), cB("page-header-content", `
 font-size: var(--n-font-size);
 `, [c$1("&:not(:first-child)", "margin-top: 20px;")]), cB("page-header-footer", `
 font-size: var(--n-font-size);
 `, [c$1("&:not(:first-child)", "margin-top: 20px;")])]);
      const pageHeaderProps = Object.assign(Object.assign({}, useTheme.props), { title: String, subtitle: String, extra: String, onBack: Function });
      const PageHeader = vue.defineComponent({
        name: "PageHeader",
        props: pageHeaderProps,
        setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("PageHeader", "-page-header", style$q, pageHeaderLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("PageHeader", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { self: { titleTextColor, subtitleTextColor, backColor, fontSize: fontSize2, titleFontSize, backSize, titleFontWeight, backColorHover, backColorPressed }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-title-text-color": titleTextColor,
              "--n-title-font-size": titleFontSize,
              "--n-title-font-weight": titleFontWeight,
              "--n-font-size": fontSize2,
              "--n-back-size": backSize,
              "--n-subtitle-text-color": subtitleTextColor,
              "--n-back-color": backColor,
              "--n-back-color-hover": backColorHover,
              "--n-back-color-pressed": backColorPressed,
              "--n-bezier": cubicBezierEaseInOut2
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("page-header", void 0, cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { onBack, title, subtitle, extra, mergedClsPrefix, cssVars, $slots } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const { title: titleSlot, subtitle: subtitleSlot, extra: extraSlot, default: defaultSlot, header: headerSlot, avatar: avatarSlot, footer: footerSlot, back: backSlot } = $slots;
          const showBack = onBack;
          const showTitle = title || titleSlot;
          const showSubtitle = subtitle || subtitleSlot;
          const showExtra = extra || extraSlot;
          return vue.h(
            "div",
            { style: cssVars, class: [
              `${mergedClsPrefix}-page-header-wrapper`,
              this.themeClass,
              this.rtlEnabled && `${mergedClsPrefix}-page-header-wrapper--rtl`
            ] },
            headerSlot ? vue.h("div", { class: `${mergedClsPrefix}-page-header-header`, key: "breadcrumb" }, headerSlot()) : null,
            (showBack || avatarSlot || showTitle || showSubtitle || showExtra) && vue.h(
              "div",
              { class: `${mergedClsPrefix}-page-header`, key: "header" },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-page-header__main`, key: "back" },
                showBack ? vue.h("div", { class: `${mergedClsPrefix}-page-header__back`, onClick: onBack }, backSlot ? backSlot() : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                  default: () => vue.h(ArrowBackIcon, null)
                })) : null,
                avatarSlot ? vue.h("div", { class: `${mergedClsPrefix}-page-header__avatar` }, avatarSlot()) : null,
                showTitle ? vue.h("div", { class: `${mergedClsPrefix}-page-header__title`, key: "title" }, title || titleSlot()) : null,
                showSubtitle ? vue.h("div", { class: `${mergedClsPrefix}-page-header__subtitle`, key: "subtitle" }, subtitle || subtitleSlot()) : null
              ),
              showExtra ? vue.h("div", { class: `${mergedClsPrefix}-page-header__extra` }, extra || extraSlot()) : null
            ),
            defaultSlot ? vue.h("div", { class: `${mergedClsPrefix}-page-header-content`, key: "content" }, defaultSlot()) : null,
            footerSlot ? vue.h("div", { class: `${mergedClsPrefix}-page-header-footer`, key: "footer" }, footerSlot()) : null
          );
        }
      });
      const popconfirmInjectionKey = createInjectionKey("n-popconfirm");
      const panelProps = {
        positiveText: String,
        negativeText: String,
        showIcon: {
          type: Boolean,
          default: true
        },
        onPositiveClick: {
          type: Function,
          required: true
        },
        onNegativeClick: {
          type: Function,
          required: true
        }
      };
      const panelPropKeys = keysOf(panelProps);
      const PopconfirmPanel = vue.defineComponent({
        name: "NPopconfirmPanel",
        props: panelProps,
        setup(props) {
          const { localeRef } = useLocale("Popconfirm");
          const { inlineThemeDisabled } = useConfig();
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            props: popconfirmProps2
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(popconfirmInjectionKey);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { fontSize: fontSize2, iconSize, iconColor } } = mergedThemeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-icon-size": iconSize,
              "--n-icon-color": iconColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("popconfirm-panel", void 0, cssVarsRef, popconfirmProps2) : void 0;
          return Object.assign(Object.assign({}, useLocale("Popconfirm")), {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            localizedPositiveText: vue.computed(() => {
              return props.positiveText || localeRef.value.positiveText;
            }),
            localizedNegativeText: vue.computed(() => {
              return props.negativeText || localeRef.value.negativeText;
            }),
            positiveButtonProps: vue.toRef(popconfirmProps2, "positiveButtonProps"),
            negativeButtonProps: vue.toRef(popconfirmProps2, "negativeButtonProps"),
            handlePositiveClick(e) {
              props.onPositiveClick(e);
            },
            handleNegativeClick(e) {
              props.onNegativeClick(e);
            },
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const { mergedClsPrefix, showIcon, $slots } = this;
          const actionContentNode = resolveSlot($slots.action, () => this.negativeText === null && this.positiveText === null ? [] : [
            this.negativeText !== null && vue.h(NButton, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }),
            this.positiveText !== null && vue.h(NButton, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })
          ]);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-popconfirm__panel`, this.themeClass], style: this.cssVars },
            resolveWrappedSlot($slots.default, (children) => showIcon || children ? vue.h(
              "div",
              { class: `${mergedClsPrefix}-popconfirm__body` },
              showIcon ? vue.h("div", { class: `${mergedClsPrefix}-popconfirm__icon` }, resolveSlot($slots.icon, () => [
                vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(WarningIcon, null) })
              ])) : null,
              children
            ) : null),
            actionContentNode ? vue.h("div", { class: [`${mergedClsPrefix}-popconfirm__action`] }, actionContentNode) : null
          );
        }
      });
      const style$p = cB("popconfirm", [cE("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [cE("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("&:not(:first-child)", "margin-top: 8px"), cB("button", [c$1("&:not(:last-child)", "margin-right: 8px;")])])]);
      const popconfirmProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), { positiveText: String, negativeText: String, showIcon: {
        type: Boolean,
        default: true
      }, trigger: {
        type: String,
        default: "click"
      }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function });
      const Popconfirm = vue.defineComponent({
        name: "Popconfirm",
        props: popconfirmProps,
        __popover__: true,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig();
          const themeRef = useTheme("Popconfirm", "-popconfirm", style$p, popconfirmLight$1, props, mergedClsPrefixRef);
          const popoverInstRef = vue.ref(null);
          function handlePositiveClick(e) {
            const { onPositiveClick, "onUpdate:show": onUpdateShow } = props;
            void Promise.resolve(onPositiveClick ? onPositiveClick(e) : true).then((value) => {
              var _a;
              if (value === false)
                return;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
              if (onUpdateShow)
                call(onUpdateShow, false);
            });
          }
          function handleNegativeClick(e) {
            const { onNegativeClick, "onUpdate:show": onUpdateShow } = props;
            void Promise.resolve(onNegativeClick ? onNegativeClick(e) : true).then((value) => {
              var _a;
              if (value === false)
                return;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
              if (onUpdateShow)
                call(onUpdateShow, false);
            });
          }
          vue.provide(popconfirmInjectionKey, {
            mergedThemeRef: themeRef,
            mergedClsPrefixRef,
            props
          });
          const exposedMethods = {
            setShow(value) {
              var _a;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
            },
            syncPosition() {
              var _a;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
            }
          };
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedTheme: themeRef,
            popoverInstRef,
            handlePositiveClick,
            handleNegativeClick
          });
        },
        render() {
          const { $slots: slots, $props: props, mergedTheme } = this;
          return vue.h(NPopover, omit(props, panelPropKeys, {
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            internalExtraClass: ["popconfirm"],
            ref: "popoverInstRef"
          }), {
            trigger: slots.activator || slots.trigger,
            default: () => {
              const panelProps2 = keep(props, panelPropKeys);
              return vue.h(PopconfirmPanel, Object.assign(Object.assign({}, panelProps2), { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), slots);
            }
          });
        }
      });
      const style$o = c$1([cB("progress", {
        display: "inline-block"
      }, [cB("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), cM("line", `
 width: 100%;
 display: block;
 `, [cB("progress-content", `
 display: flex;
 align-items: center;
 `, [cB("progress-graph", {
        flex: 1
      })]), cB("progress-custom-content", {
        marginLeft: "14px"
      }), cB("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [cM("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), cM("circle, dashboard", {
        width: "120px"
      }, [cB("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cB("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), cB("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), cM("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [cB("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), cB("progress-content", {
        position: "relative"
      }), cB("progress-graph", {
        position: "relative"
      }, [cB("progress-graph-circle", [c$1("svg", {
        verticalAlign: "bottom"
      }), cB("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [cM("empty", {
        opacity: 0
      })]), cB("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), cB("progress-graph-line", [cM("indicator-inside", [cB("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [cB("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), cB("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), cM("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [cB("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), cB("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), cB("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [cB("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [cM("processing", [c$1("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), c$1("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]);
      const iconMap$2 = {
        success: vue.h(SuccessIcon, null),
        error: vue.h(ErrorIcon, null),
        warning: vue.h(WarningIcon, null),
        info: vue.h(InfoIcon, null)
      };
      const Line = vue.defineComponent({
        name: "ProgressLine",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          percentage: {
            type: Number,
            default: 0
          },
          railColor: String,
          railStyle: [String, Object],
          fillColor: String,
          status: {
            type: String,
            required: true
          },
          indicatorPlacement: {
            type: String,
            required: true
          },
          indicatorTextColor: String,
          unit: {
            type: String,
            default: "%"
          },
          processing: {
            type: Boolean,
            required: true
          },
          showIndicator: {
            type: Boolean,
            required: true
          },
          height: [String, Number],
          railBorderRadius: [String, Number],
          fillBorderRadius: [String, Number]
        },
        setup(props, { slots }) {
          const styleHeightRef = vue.computed(() => {
            return formatLength(props.height);
          });
          const styleRailBorderRadiusRef = vue.computed(() => {
            if (props.railBorderRadius !== void 0) {
              return formatLength(props.railBorderRadius);
            }
            if (props.height !== void 0) {
              return formatLength(props.height, { c: 0.5 });
            }
            return "";
          });
          const styleFillBorderRadiusRef = vue.computed(() => {
            if (props.fillBorderRadius !== void 0) {
              return formatLength(props.fillBorderRadius);
            }
            if (props.railBorderRadius !== void 0) {
              return formatLength(props.railBorderRadius);
            }
            if (props.height !== void 0) {
              return formatLength(props.height, { c: 0.5 });
            }
            return "";
          });
          return () => {
            const { indicatorPlacement, railColor, railStyle, percentage, unit, indicatorTextColor, status, showIndicator, fillColor, processing, clsPrefix } = props;
            return vue.h(
              "div",
              { class: `${clsPrefix}-progress-content`, role: "none" },
              vue.h(
                "div",
                { class: `${clsPrefix}-progress-graph`, "aria-hidden": true },
                vue.h(
                  "div",
                  { class: [
                    `${clsPrefix}-progress-graph-line`,
                    {
                      [`${clsPrefix}-progress-graph-line--indicator-${indicatorPlacement}`]: true
                    }
                  ] },
                  vue.h(
                    "div",
                    { class: `${clsPrefix}-progress-graph-line-rail`, style: [
                      {
                        backgroundColor: railColor,
                        height: styleHeightRef.value,
                        borderRadius: styleRailBorderRadiusRef.value
                      },
                      railStyle
                    ] },
                    vue.h("div", { class: [
                      `${clsPrefix}-progress-graph-line-fill`,
                      processing && `${clsPrefix}-progress-graph-line-fill--processing`
                    ], style: {
                      maxWidth: `${props.percentage}%`,
                      backgroundColor: fillColor,
                      height: styleHeightRef.value,
                      lineHeight: styleHeightRef.value,
                      borderRadius: styleFillBorderRadiusRef.value
                    } }, indicatorPlacement === "inside" ? vue.h(
                      "div",
                      { class: `${clsPrefix}-progress-graph-line-indicator`, style: {
                        color: indicatorTextColor
                      } },
                      percentage,
                      unit
                    ) : null)
                  )
                )
              ),
              showIndicator && indicatorPlacement === "outside" ? vue.h("div", null, slots.default ? vue.h("div", { class: `${clsPrefix}-progress-custom-content`, style: {
                color: indicatorTextColor
              }, role: "none" }, slots.default()) : status === "default" ? vue.h(
                "div",
                { role: "none", class: `${clsPrefix}-progress-icon ${clsPrefix}-progress-icon--as-text`, style: {
                  color: indicatorTextColor
                } },
                percentage,
                unit
              ) : vue.h(
                "div",
                { class: `${clsPrefix}-progress-icon`, "aria-hidden": true },
                vue.h(NBaseIcon, { clsPrefix }, { default: () => iconMap$2[status] })
              )) : null
            );
          };
        }
      });
      const iconMap$1 = {
        success: vue.h(SuccessIcon, null),
        error: vue.h(ErrorIcon, null),
        warning: vue.h(WarningIcon, null),
        info: vue.h(InfoIcon, null)
      };
      const Circle = vue.defineComponent({
        name: "ProgressCircle",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          status: {
            type: String,
            required: true
          },
          strokeWidth: {
            type: Number,
            required: true
          },
          fillColor: String,
          railColor: String,
          railStyle: [String, Object],
          percentage: {
            type: Number,
            default: 0
          },
          offsetDegree: {
            type: Number,
            default: 0
          },
          showIndicator: {
            type: Boolean,
            required: true
          },
          indicatorTextColor: String,
          unit: String,
          viewBoxWidth: {
            type: Number,
            required: true
          },
          gapDegree: {
            type: Number,
            required: true
          },
          gapOffsetDegree: {
            type: Number,
            default: 0
          }
        },
        setup(props, { slots }) {
          function getPathStyles(percent2, offsetDegree, strokeColor) {
            const { gapDegree, viewBoxWidth, strokeWidth } = props;
            const radius = 50;
            const beginPositionX = 0;
            const beginPositionY = radius;
            const endPositionX = 0;
            const endPositionY = 2 * radius;
            const centerX = 50 + strokeWidth / 2;
            const pathString = `M ${centerX},${centerX} m ${beginPositionX},${beginPositionY}
      a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
      a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
            const len2 = Math.PI * 2 * radius;
            const pathStyle = {
              stroke: strokeColor,
              strokeDasharray: `${percent2 / 100 * (len2 - gapDegree)}px ${viewBoxWidth * 8}px`,
              strokeDashoffset: `-${gapDegree / 2}px`,
              transformOrigin: offsetDegree ? "center" : void 0,
              transform: offsetDegree ? `rotate(${offsetDegree}deg)` : void 0
            };
            return {
              pathString,
              pathStyle
            };
          }
          return () => {
            const { fillColor, railColor, strokeWidth, offsetDegree, status, percentage, showIndicator, indicatorTextColor, unit, gapOffsetDegree, clsPrefix } = props;
            const { pathString: railPathString, pathStyle: railPathStyle } = getPathStyles(100, 0, railColor);
            const { pathString: fillPathString, pathStyle: fillPathStyle } = getPathStyles(percentage, offsetDegree, fillColor);
            const viewBoxSize = 100 + strokeWidth;
            return vue.h(
              "div",
              { class: `${clsPrefix}-progress-content`, role: "none" },
              vue.h(
                "div",
                { class: `${clsPrefix}-progress-graph`, "aria-hidden": true },
                vue.h(
                  "div",
                  { class: `${clsPrefix}-progress-graph-circle`, style: {
                    transform: gapOffsetDegree ? `rotate(${gapOffsetDegree}deg)` : void 0
                  } },
                  vue.h(
                    "svg",
                    { viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}` },
                    vue.h(
                      "g",
                      null,
                      vue.h("path", { class: `${clsPrefix}-progress-graph-circle-rail`, d: railPathString, "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: railPathStyle })
                    ),
                    vue.h(
                      "g",
                      null,
                      vue.h("path", { class: [
                        `${clsPrefix}-progress-graph-circle-fill`,
                        percentage === 0 && `${clsPrefix}-progress-graph-circle-fill--empty`
                      ], d: fillPathString, "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: fillPathStyle })
                    )
                  )
                )
              ),
              showIndicator ? vue.h("div", null, slots.default ? vue.h("div", { class: `${clsPrefix}-progress-custom-content`, role: "none" }, slots.default()) : status !== "default" ? vue.h(
                "div",
                { class: `${clsPrefix}-progress-icon`, "aria-hidden": true },
                vue.h(NBaseIcon, { clsPrefix }, {
                  default: () => iconMap$1[status]
                })
              ) : vue.h(
                "div",
                { class: `${clsPrefix}-progress-text`, style: {
                  color: indicatorTextColor
                }, role: "none" },
                vue.h("span", { class: `${clsPrefix}-progress-text__percentage` }, percentage),
                vue.h("span", { class: `${clsPrefix}-progress-text__unit` }, unit)
              )) : null
            );
          };
        }
      });
      function circlePath(r, sw, vw = 100) {
        return `m ${vw / 2} ${vw / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
      }
      const MultipleCircle = vue.defineComponent({
        name: "ProgressMultipleCircle",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          viewBoxWidth: {
            type: Number,
            required: true
          },
          percentage: {
            type: Array,
            default: [0]
          },
          strokeWidth: {
            type: Number,
            required: true
          },
          circleGap: {
            type: Number,
            required: true
          },
          showIndicator: {
            type: Boolean,
            required: true
          },
          fillColor: {
            type: Array,
            default: () => []
          },
          railColor: {
            type: Array,
            default: () => []
          },
          railStyle: {
            type: Array,
            default: () => []
          }
        },
        setup(props, { slots }) {
          const strokeDasharrayRef = vue.computed(() => {
            const strokeDasharrays = props.percentage.map((v, i) => `${Math.PI * v / 100 * (props.viewBoxWidth / 2 - props.strokeWidth / 2 * (1 + 2 * i) - props.circleGap * i) * 2}, ${props.viewBoxWidth * 8}`);
            return strokeDasharrays;
          });
          return () => {
            const { viewBoxWidth, strokeWidth, circleGap, showIndicator, fillColor, railColor, railStyle, percentage, clsPrefix } = props;
            return vue.h(
              "div",
              { class: `${clsPrefix}-progress-content`, role: "none" },
              vue.h(
                "div",
                { class: `${clsPrefix}-progress-graph`, "aria-hidden": true },
                vue.h(
                  "div",
                  { class: `${clsPrefix}-progress-graph-circle` },
                  vue.h("svg", { viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}` }, percentage.map((p2, index) => {
                    return vue.h(
                      "g",
                      { key: index },
                      vue.h("path", { class: `${clsPrefix}-progress-graph-circle-rail`, d: circlePath(viewBoxWidth / 2 - strokeWidth / 2 * (1 + 2 * index) - circleGap * index, strokeWidth, viewBoxWidth), "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: [
                        {
                          strokeDashoffset: 0,
                          stroke: railColor[index]
                        },
                        railStyle[index]
                      ] }),
                      vue.h("path", { class: [
                        `${clsPrefix}-progress-graph-circle-fill`,
                        p2 === 0 && `${clsPrefix}-progress-graph-circle-fill--empty`
                      ], d: circlePath(viewBoxWidth / 2 - strokeWidth / 2 * (1 + 2 * index) - circleGap * index, strokeWidth, viewBoxWidth), "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: {
                        strokeDasharray: strokeDasharrayRef.value[index],
                        strokeDashoffset: 0,
                        stroke: fillColor[index]
                      } })
                    );
                  }))
                )
              ),
              showIndicator && slots.default ? vue.h(
                "div",
                null,
                vue.h("div", { class: `${clsPrefix}-progress-text` }, slots.default())
              ) : null
            );
          };
        }
      });
      const progressProps = Object.assign(Object.assign({}, useTheme.props), { processing: Boolean, type: {
        type: String,
        default: "line"
      }, gapDegree: Number, gapOffsetDegree: Number, status: {
        type: String,
        default: "default"
      }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array], viewBoxWidth: {
        type: Number,
        default: 100
      }, strokeWidth: {
        type: Number,
        default: 7
      }, percentage: [Number, Array], unit: {
        type: String,
        default: "%"
      }, showIndicator: {
        type: Boolean,
        default: true
      }, indicatorPosition: {
        type: String,
        default: "outside"
      }, indicatorPlacement: {
        type: String,
        default: "outside"
      }, indicatorTextColor: String, circleGap: {
        type: Number,
        default: 1
      }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number });
      const NProgress = vue.defineComponent({
        name: "Progress",
        props: progressProps,
        setup(props) {
          const mergedIndicatorPlacementRef = vue.computed(() => {
            return props.indicatorPlacement || props.indicatorPosition;
          });
          const gapDeg = vue.computed(() => {
            if (props.gapDegree || props.gapDegree === 0) {
              return props.gapDegree;
            }
            if (props.type === "dashboard") {
              return 75;
            }
            return void 0;
          });
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Progress", "-progress", style$o, progressLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { status } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { fontSize: fontSize2, fontSizeCircle, railColor, railHeight, iconSizeCircle, iconSizeLine, textColorCircle, textColorLineInner, textColorLineOuter, lineBgProcessing, fontWeightCircle, [createKey("iconColor", status)]: iconColor, [createKey("fillColor", status)]: fillColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-fill-color": fillColor,
              "--n-font-size": fontSize2,
              "--n-font-size-circle": fontSizeCircle,
              "--n-font-weight-circle": fontWeightCircle,
              "--n-icon-color": iconColor,
              "--n-icon-size-circle": iconSizeCircle,
              "--n-icon-size-line": iconSizeLine,
              "--n-line-bg-processing": lineBgProcessing,
              "--n-rail-color": railColor,
              "--n-rail-height": railHeight,
              "--n-text-color-circle": textColorCircle,
              "--n-text-color-line-inner": textColorLineInner,
              "--n-text-color-line-outer": textColorLineOuter
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("progress", vue.computed(() => props.status[0]), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedIndicatorPlacement: mergedIndicatorPlacementRef,
            gapDeg,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { type: type2, cssVars, indicatorTextColor, showIndicator, status, railColor, railStyle, color, percentage, viewBoxWidth, strokeWidth, mergedIndicatorPlacement, unit, borderRadius, fillBorderRadius, height, processing, circleGap, mergedClsPrefix, gapDeg, gapOffsetDegree, themeClass, $slots, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", { class: [
            themeClass,
            `${mergedClsPrefix}-progress`,
            `${mergedClsPrefix}-progress--${type2}`,
            `${mergedClsPrefix}-progress--${status}`
          ], style: cssVars, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": percentage, role: type2 === "circle" || type2 === "line" || type2 === "dashboard" ? "progressbar" : "none" }, type2 === "circle" || type2 === "dashboard" ? vue.h(Circle, { clsPrefix: mergedClsPrefix, status, showIndicator, indicatorTextColor, railColor, fillColor: color, railStyle, offsetDegree: this.offsetDegree, percentage, viewBoxWidth, strokeWidth, gapDegree: gapDeg === void 0 ? type2 === "dashboard" ? 75 : 0 : gapDeg, gapOffsetDegree, unit }, $slots) : type2 === "line" ? vue.h(Line, { clsPrefix: mergedClsPrefix, status, showIndicator, indicatorTextColor, railColor, fillColor: color, railStyle, percentage, processing, indicatorPlacement: mergedIndicatorPlacement, unit, fillBorderRadius, railBorderRadius: borderRadius, height }, $slots) : type2 === "multiple-circle" ? vue.h(MultipleCircle, { clsPrefix: mergedClsPrefix, strokeWidth, railColor, fillColor: color, railStyle, viewBoxWidth, percentage, showIndicator, circleGap }, $slots) : null);
        }
      });
      const StarIcon = vue.h(
        "svg",
        { viewBox: "0 0 512 512" },
        vue.h("path", { d: "M394 480a16 16 0 01-9.39-3L256 383.76 127.39 477a16 16 0 01-24.55-18.08L153 310.35 23 221.2a16 16 0 019-29.2h160.38l48.4-148.95a16 16 0 0130.44 0l48.4 149H480a16 16 0 019.05 29.2L359 310.35l50.13 148.53A16 16 0 01394 480z" })
      );
      const style$n = cB("rate", {
        display: "inline-flex",
        flexWrap: "nowrap"
      }, [c$1("&:hover", [cE("item", `
 transition:
 transform .1s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("item", `
 position: relative;
 display: flex;
 transition:
 transform .1s var(--n-bezier),
 color .3s var(--n-bezier);
 transform: scale(1);
 font-size: var(--n-item-size);
 color: var(--n-item-color);
 `, [c$1("&:not(:first-child)", `
 margin-left: 6px;
 `), cM("active", `
 color: var(--n-item-color-active);
 `)]), cNotM("readonly", `
 cursor: pointer;
 `, [cE("item", [c$1("&:hover", `
 transform: scale(1.05);
 `), c$1("&:active", `
 transform: scale(0.96);
 `)])]), cE("half", `
 display: flex;
 transition: inherit;
 position: absolute;
 top: 0;
 left: 0;
 bottom: 0;
 width: 50%;
 overflow: hidden;
 color: rgba(255, 255, 255, 0);
 `, [cM("active", `
 color: var(--n-item-color-active);
 `)])]);
      const rateProps = Object.assign(Object.assign({}, useTheme.props), { allowHalf: Boolean, count: {
        type: Number,
        default: 5
      }, value: Number, defaultValue: {
        type: Number,
        default: null
      }, readonly: Boolean, size: {
        type: [String, Number],
        default: "medium"
      }, clearable: Boolean, color: String, onClear: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
      const Rate = vue.defineComponent({
        name: "Rate",
        props: rateProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Rate", "-rate", style$n, rateLight, props, mergedClsPrefixRef);
          const controlledValueRef = vue.toRef(props, "value");
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const hoverIndexRef = vue.ref(null);
          const formItem = useFormItem(props);
          const mergedValue = useMergedState(controlledValueRef, uncontrolledValueRef);
          function doUpdateValue(value) {
            const { "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            if (_onUpdateValue) {
              call(_onUpdateValue, value);
            }
            if (onUpdateValue) {
              call(onUpdateValue, value);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function getDerivedValue(index, e) {
            if (props.allowHalf) {
              if (e.offsetX >= Math.floor(e.currentTarget.offsetWidth / 2)) {
                return index + 1;
              } else {
                return index + 0.5;
              }
            } else {
              return index + 1;
            }
          }
          let cleared = false;
          function handleMouseMove(index, e) {
            if (cleared)
              return;
            hoverIndexRef.value = getDerivedValue(index, e);
          }
          function handleMouseLeave() {
            hoverIndexRef.value = null;
          }
          function handleClick2(index, e) {
            var _a;
            const { clearable } = props;
            const derivedValue = getDerivedValue(index, e);
            if (clearable && derivedValue === mergedValue.value) {
              cleared = true;
              (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props);
              hoverIndexRef.value = null;
              doUpdateValue(null);
            } else {
              doUpdateValue(derivedValue);
            }
          }
          function handleMouseEnterSomeStar() {
            cleared = false;
          }
          const mergedSizeRef = vue.computed(() => {
            const { size: size2 } = props;
            const { self: self2 } = themeRef.value;
            if (typeof size2 === "number") {
              return `${size2}px`;
            } else {
              return self2[createKey("size", size2)];
            }
          });
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const { itemColor, itemColorActive } = self2;
            const { color } = props;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-item-color": itemColor,
              "--n-item-color-active": color || itemColorActive,
              "--n-item-size": mergedSizeRef.value
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("rate", vue.computed(() => {
            const size2 = mergedSizeRef.value;
            const { color } = props;
            let hash = "";
            if (size2) {
              hash += size2[0];
            }
            if (color) {
              hash += color2Class(color);
            }
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue,
            hoverIndex: hoverIndexRef,
            handleMouseMove,
            handleClick: handleClick2,
            handleMouseLeave,
            handleMouseEnterSomeStar,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { readonly: readonly2, hoverIndex, mergedValue, mergedClsPrefix, onRender, $slots: { default: defaultSlot } } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", { class: [
            `${mergedClsPrefix}-rate`,
            {
              [`${mergedClsPrefix}-rate--readonly`]: readonly2
            },
            this.themeClass
          ], style: this.cssVars, onMouseleave: this.handleMouseLeave }, vue.renderList(this.count, (_, index) => {
            const icon = defaultSlot ? defaultSlot({ index }) : vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => StarIcon });
            const entireStarActive = hoverIndex !== null ? index + 1 <= hoverIndex : index + 1 <= (mergedValue || 0);
            return vue.h(
              "div",
              { key: index, class: [
                `${mergedClsPrefix}-rate__item`,
                entireStarActive && `${mergedClsPrefix}-rate__item--active`
              ], onClick: readonly2 ? void 0 : (e) => {
                this.handleClick(index, e);
              }, onMouseenter: this.handleMouseEnterSomeStar, onMousemove: readonly2 ? void 0 : (e) => {
                this.handleMouseMove(index, e);
              } },
              icon,
              this.allowHalf ? vue.h("div", { class: [
                `${mergedClsPrefix}-rate__half`,
                {
                  [`${mergedClsPrefix}-rate__half--active`]: !entireStarActive && hoverIndex !== null ? index + 0.5 <= hoverIndex : index + 0.5 <= (mergedValue || 0)
                }
              ] }, icon) : null
            );
          }));
        }
      });
      const image404 = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
        vue.h("circle", { fill: "#FFCB4C", cx: "18", cy: "17.018", r: "17" }),
        vue.h("path", { fill: "#65471B", d: "M14.524 21.036c-.145-.116-.258-.274-.312-.464-.134-.46.13-.918.59-1.021 4.528-1.021 7.577 1.363 7.706 1.465.384.306.459.845.173 1.205-.286.358-.828.401-1.211.097-.11-.084-2.523-1.923-6.182-1.098-.274.061-.554-.016-.764-.184z" }),
        vue.h("ellipse", { fill: "#65471B", cx: "13.119", cy: "11.174", rx: "2.125", ry: "2.656" }),
        vue.h("ellipse", { fill: "#65471B", cx: "24.375", cy: "12.236", rx: "2.125", ry: "2.656" }),
        vue.h("path", { fill: "#F19020", d: "M17.276 35.149s1.265-.411 1.429-1.352c.173-.972-.624-1.167-.624-1.167s1.041-.208 1.172-1.376c.123-1.101-.861-1.363-.861-1.363s.97-.4 1.016-1.539c.038-.959-.995-1.428-.995-1.428s5.038-1.221 5.556-1.341c.516-.12 1.32-.615 1.069-1.694-.249-1.08-1.204-1.118-1.697-1.003-.494.115-6.744 1.566-8.9 2.068l-1.439.334c-.54.127-.785-.11-.404-.512.508-.536.833-1.129.946-2.113.119-1.035-.232-2.313-.433-2.809-.374-.921-1.005-1.649-1.734-1.899-1.137-.39-1.945.321-1.542 1.561.604 1.854.208 3.375-.833 4.293-2.449 2.157-3.588 3.695-2.83 6.973.828 3.575 4.377 5.876 7.952 5.048l3.152-.681z" }),
        vue.h("path", { fill: "#65471B", d: "M9.296 6.351c-.164-.088-.303-.224-.391-.399-.216-.428-.04-.927.393-1.112 4.266-1.831 7.699-.043 7.843.034.433.231.608.747.391 1.154-.216.405-.74.546-1.173.318-.123-.063-2.832-1.432-6.278.047-.257.109-.547.085-.785-.042zm12.135 3.75c-.156-.098-.286-.243-.362-.424-.187-.442.023-.927.468-1.084 4.381-1.536 7.685.48 7.823.567.415.26.555.787.312 1.178-.242.39-.776.495-1.191.238-.12-.072-2.727-1.621-6.267-.379-.266.091-.553.046-.783-.096z" })
      );
      const image500 = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
        vue.h("path", { fill: "#FFCC4D", d: "M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18" }),
        vue.h("ellipse", { fill: "#664500", cx: "18", cy: "27", rx: "5", ry: "6" }),
        vue.h("path", { fill: "#664500", d: "M5.999 11c-.208 0-.419-.065-.599-.2-.442-.331-.531-.958-.2-1.4C8.462 5.05 12.816 5 13 5c.552 0 1 .448 1 1 0 .551-.445.998-.996 1-.155.002-3.568.086-6.204 3.6-.196.262-.497.4-.801.4zm24.002 0c-.305 0-.604-.138-.801-.4-2.64-3.521-6.061-3.598-6.206-3.6-.55-.006-.994-.456-.991-1.005C22.006 5.444 22.45 5 23 5c.184 0 4.537.05 7.8 4.4.332.442.242 1.069-.2 1.4-.18.135-.39.2-.599.2zm-16.087 4.5l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L12.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L13.914 15.5zm11 0l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L23.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L24.914 15.5z" })
      );
      const image418 = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
        vue.h("ellipse", { fill: "#292F33", cx: "18", cy: "26", rx: "18", ry: "10" }),
        vue.h("ellipse", { fill: "#66757F", cx: "18", cy: "24", rx: "18", ry: "10" }),
        vue.h("path", { fill: "#E1E8ED", d: "M18 31C3.042 31 1 16 1 12h34c0 2-1.958 19-17 19z" }),
        vue.h("path", { fill: "#77B255", d: "M35 12.056c0 5.216-7.611 9.444-17 9.444S1 17.271 1 12.056C1 6.84 8.611 3.611 18 3.611s17 3.229 17 8.445z" }),
        vue.h("ellipse", { fill: "#A6D388", cx: "18", cy: "13", rx: "15", ry: "7" }),
        vue.h("path", { d: "M21 17c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.739-1.109.9-2.246.478-3.377-.461-1.236-1.438-1.996-1.731-2.077-.553 0-.958-.443-.958-.996 0-.552.491-.995 1.043-.995.997 0 2.395 1.153 3.183 2.625 1.034 1.933.91 4.039-.351 5.929-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.196-.451.294-.707.294zm-6-2c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.727-1.091.893-2.083.494-2.947-.444-.961-1.431-1.469-1.684-1.499-.552 0-.989-.447-.989-1 0-.552.458-1 1.011-1 .997 0 2.585.974 3.36 2.423.481.899 1.052 2.761-.528 5.131-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.197-.451.295-.707.295z", fill: "#5C913B" })
      );
      const image403 = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
        vue.h("path", { fill: "#EF9645", d: "M15.5 2.965c1.381 0 2.5 1.119 2.5 2.5v.005L20.5.465c1.381 0 2.5 1.119 2.5 2.5V4.25l2.5-1.535c1.381 0 2.5 1.119 2.5 2.5V8.75L29 18H15.458L15.5 2.965z" }),
        vue.h("path", { fill: "#FFDC5D", d: "M4.625 16.219c1.381-.611 3.354.208 4.75 2.188.917 1.3 1.187 3.151 2.391 3.344.46.073 1.234-.313 1.234-1.397V4.5s0-2 2-2 2 2 2 2v11.633c0-.029 1-.064 1-.082V2s0-2 2-2 2 2 2 2v14.053c0 .017 1 .041 1 .069V4.25s0-2 2-2 2 2 2 2v12.638c0 .118 1 .251 1 .398V8.75s0-2 2-2 2 2 2 2V24c0 6.627-5.373 12-12 12-4.775 0-8.06-2.598-9.896-5.292C8.547 28.423 8.096 26.051 8 25.334c0 0-.123-1.479-1.156-2.865-1.469-1.969-2.5-3.156-3.125-3.866-.317-.359-.625-1.707.906-2.384z" })
      );
      const style$m = cB("result", `
 color: var(--n-text-color);
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier);
`, [cB("result-icon", `
 display: flex;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `, [cE("status-image", `
 font-size: var(--n-icon-size);
 width: 1em;
 height: 1em;
 `), cB("base-icon", `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("result-content", {
        marginTop: "24px"
      }), cB("result-footer", `
 margin-top: 24px;
 text-align: center;
 `), cB("result-header", [cE("title", `
 margin-top: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 text-align: center;
 color: var(--n-title-text-color);
 font-size: var(--n-title-font-size);
 `), cE("description", `
 margin-top: 4px;
 text-align: center;
 font-size: var(--n-font-size);
 `)])]);
      const iconMap = {
        403: image403,
        404: image404,
        418: image418,
        500: image500,
        info: vue.h(InfoIcon, null),
        success: vue.h(SuccessIcon, null),
        warning: vue.h(WarningIcon, null),
        error: vue.h(ErrorIcon, null)
      };
      const resultProps = Object.assign(Object.assign({}, useTheme.props), { size: {
        type: String,
        default: "medium"
      }, status: {
        type: String,
        default: "info"
      }, title: String, description: String });
      const Result = vue.defineComponent({
        name: "Result",
        props: resultProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Result", "-result", style$m, resultLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { size: size2, status } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { textColor, lineHeight: lineHeight2, titleTextColor, titleFontWeight, [createKey("iconColor", status)]: iconColor, [createKey("fontSize", size2)]: fontSize2, [createKey("titleFontSize", size2)]: titleFontSize, [createKey("iconSize", size2)]: iconSize } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-icon-size": iconSize,
              "--n-line-height": lineHeight2,
              "--n-text-color": textColor,
              "--n-title-font-size": titleFontSize,
              "--n-title-font-weight": titleFontWeight,
              "--n-title-text-color": titleTextColor,
              "--n-icon-color": iconColor || ""
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("result", vue.computed(() => {
            const { size: size2, status } = props;
            let hash = "";
            if (size2) {
              hash += size2[0];
            }
            if (status) {
              hash += status[0];
            }
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { status, $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [`${mergedClsPrefix}-result`, this.themeClass], style: this.cssVars },
            vue.h("div", { class: `${mergedClsPrefix}-result-icon` }, ((_a = $slots.icon) === null || _a === void 0 ? void 0 : _a.call($slots)) || vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => iconMap[status] })),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-result-header` },
              this.title ? vue.h("div", { class: `${mergedClsPrefix}-result-header__title` }, this.title) : null,
              this.description ? vue.h("div", { class: `${mergedClsPrefix}-result-header__description` }, this.description) : null
            ),
            $slots.default && vue.h("div", { class: `${mergedClsPrefix}-result-content` }, $slots),
            $slots.footer && vue.h("div", { class: `${mergedClsPrefix}-result-footer` }, $slots.footer())
          );
        }
      });
      const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), { trigger: String, xScrollable: Boolean, onScroll: Function, size: Number });
      const Scrollbar = vue.defineComponent({
        name: "Scrollbar",
        props: scrollbarProps,
        setup() {
          const scrollbarInstRef = vue.ref(null);
          const exposedMethods = {
            scrollTo: (...args) => {
              var _a;
              (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(args[0], args[1]);
            },
            scrollBy: (...args) => {
              var _a;
              (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollBy(args[0], args[1]);
            }
          };
          return Object.assign(Object.assign({}, exposedMethods), { scrollbarInstRef });
        },
        render() {
          return vue.h(NScrollbar, Object.assign({ ref: "scrollbarInstRef" }, this.$props), this.$slots);
        }
      });
      const Scrollbar$1 = Scrollbar;
      const skeletonDark = {
        name: "Skeleton",
        common: commonDark,
        self(vars) {
          const { heightSmall, heightMedium, heightLarge, borderRadius } = vars;
          return {
            color: "rgba(255, 255, 255, 0.12)",
            colorEnd: "rgba(255, 255, 255, 0.18)",
            borderRadius,
            heightSmall,
            heightMedium,
            heightLarge
          };
        }
      };
      const self$2 = (vars) => {
        const { heightSmall, heightMedium, heightLarge, borderRadius } = vars;
        return {
          color: "#eee",
          colorEnd: "#ddd",
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
        };
      };
      const skeletonLight = {
        name: "Skeleton",
        common: commonLight,
        self: self$2
      };
      const style$l = c$1([cB("skeleton", `
 height: 1em;
 width: 100%;
 transition: background-color .3s var(--n-bezier);
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
 background-color: var(--n-color-start);
 `), c$1("@keyframes skeleton-loading", `
 0% {
 background: var(--n-color-start);
 }
 40% {
 background: var(--n-color-end);
 }
 80% {
 background: var(--n-color-start);
 }
 100% {
 background: var(--n-color-start);
 }
 `)]);
      const skeletonProps = Object.assign(Object.assign({}, useTheme.props), { text: Boolean, round: Boolean, circle: Boolean, height: [String, Number], width: [String, Number], size: String, repeat: {
        type: Number,
        default: 1
      }, animated: {
        type: Boolean,
        default: true
      }, sharp: {
        type: Boolean,
        default: true
      } });
      const Skeleton = vue.defineComponent({
        name: "Skeleton",
        inheritAttrs: false,
        props: skeletonProps,
        setup(props) {
          useHoudini();
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("Skeleton", "-skeleton", style$l, skeletonLight, props, mergedClsPrefixRef);
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            style: vue.computed(() => {
              var _a, _b;
              const theme = themeRef.value;
              const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = theme;
              const selfThemeVars = theme.self;
              const { color, colorEnd, borderRadius } = selfThemeVars;
              let sizeHeight;
              const { circle, sharp, round: round2, width, height, size: size2, text, animated } = props;
              if (size2 !== void 0) {
                sizeHeight = selfThemeVars[createKey("height", size2)];
              }
              const mergedWidth = circle ? (_a = width !== null && width !== void 0 ? width : height) !== null && _a !== void 0 ? _a : sizeHeight : width;
              const mergedHeight = (_b = circle ? width !== null && width !== void 0 ? width : height : height) !== null && _b !== void 0 ? _b : sizeHeight;
              return {
                display: text ? "inline-block" : "",
                verticalAlign: text ? "-0.125em" : "",
                borderRadius: circle ? "50%" : round2 ? "4096px" : sharp ? "" : borderRadius,
                width: typeof mergedWidth === "number" ? pxfy(mergedWidth) : mergedWidth,
                height: typeof mergedHeight === "number" ? pxfy(mergedHeight) : mergedHeight,
                animation: !animated ? "none" : "",
                "--n-bezier": cubicBezierEaseInOut2,
                "--n-color-start": color,
                "--n-color-end": colorEnd
              };
            })
          };
        },
        render() {
          const { repeat: repeat2, style: style2, mergedClsPrefix, $attrs } = this;
          const child = vue.h("div", vue.mergeProps({
            class: `${mergedClsPrefix}-skeleton`,
            style: style2
          }, $attrs));
          if (repeat2 > 1) {
            return vue.h(vue.Fragment, null, Array.apply(null, { length: repeat2 }).map((_) => [
              child,
              "\n"
            ]));
          }
          return child;
        }
      });
      function isTouchEvent(e) {
        return window.TouchEvent && e instanceof window.TouchEvent;
      }
      function useRefs() {
        const refs = vue.ref(/* @__PURE__ */ new Map());
        const setRefs = (index) => (el) => {
          refs.value.set(index, el);
        };
        vue.onBeforeUpdate(() => {
          refs.value.clear();
        });
        return [refs, setRefs];
      }
      const style$k = c$1([cB("slider", `
 display: block;
 padding: calc((var(--n-handle-size) - var(--n-rail-height)) / 2) 0;
 position: relative;
 z-index: 0;
 width: 100%;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 `, [cM("reverse", [cB("slider-handles", [cB("slider-handle-wrapper", `
 transform: translate(50%, -50%);
 `)]), cB("slider-dots", [cB("slider-dot", `
 transform: translateX(50%, -50%);
 `)]), cM("vertical", [cB("slider-handles", [cB("slider-handle-wrapper", `
 transform: translate(-50%, -50%);
 `)]), cB("slider-marks", [cB("slider-mark", `
 transform: translateY(calc(-50% + var(--n-dot-height) / 2));
 `)]), cB("slider-dots", [cB("slider-dot", `
 transform: translateX(-50%) translateY(0);
 `)])])]), cM("vertical", `
 padding: 0 calc((var(--n-handle-size) - var(--n-rail-height)) / 2);
 width: var(--n-rail-width-vertical);
 height: 100%;
 `, [cB("slider-handles", `
 top: calc(var(--n-handle-size) / 2);
 right: 0;
 bottom: calc(var(--n-handle-size) / 2);
 left: 0;
 `, [cB("slider-handle-wrapper", `
 top: unset;
 left: 50%;
 transform: translate(-50%, 50%);
 `)]), cB("slider-rail", `
 height: 100%;
 `, [cE("fill", `
 top: unset;
 right: 0;
 bottom: unset;
 left: 0;
 `)]), cM("with-mark", `
 width: var(--n-rail-width-vertical);
 margin: 0 32px 0 8px;
 `), cB("slider-marks", `
 top: calc(var(--n-handle-size) / 2);
 right: unset;
 bottom: calc(var(--n-handle-size) / 2);
 left: 22px;
 font-size: var(--n-mark-font-size);
 `, [cB("slider-mark", `
 transform: translateY(50%);
 white-space: nowrap;
 `)]), cB("slider-dots", `
 top: calc(var(--n-handle-size) / 2);
 right: unset;
 bottom: calc(var(--n-handle-size) / 2);
 left: 50%;
 `, [cB("slider-dot", `
 transform: translateX(-50%) translateY(50%);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `, [cB("slider-handle", `
 cursor: not-allowed;
 `)]), cM("with-mark", `
 width: 100%;
 margin: 8px 0 32px 0;
 `), c$1("&:hover", [cB("slider-rail", {
        backgroundColor: "var(--n-rail-color-hover)"
      }, [cE("fill", {
        backgroundColor: "var(--n-fill-color-hover)"
      })]), cB("slider-handle", {
        boxShadow: "var(--n-handle-box-shadow-hover)"
      })]), cM("active", [cB("slider-rail", {
        backgroundColor: "var(--n-rail-color-hover)"
      }, [cE("fill", {
        backgroundColor: "var(--n-fill-color-hover)"
      })]), cB("slider-handle", {
        boxShadow: "var(--n-handle-box-shadow-hover)"
      })]), cB("slider-marks", `
 position: absolute;
 top: 18px;
 left: calc(var(--n-handle-size) / 2);
 right: calc(var(--n-handle-size) / 2);
 `, [cB("slider-mark", `
 position: absolute;
 transform: translateX(-50%);
 white-space: nowrap;
 `)]), cB("slider-rail", `
 width: 100%;
 position: relative;
 height: var(--n-rail-height);
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 border-radius: calc(var(--n-rail-height) / 2);
 `, [cE("fill", `
 position: absolute;
 top: 0;
 bottom: 0;
 border-radius: calc(var(--n-rail-height) / 2);
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-fill-color);
 `)]), cB("slider-handles", `
 position: absolute;
 top: 0;
 right: calc(var(--n-handle-size) / 2);
 bottom: 0;
 left: calc(var(--n-handle-size) / 2);
 `, [cB("slider-handle-wrapper", `
 outline: none;
 position: absolute;
 top: 50%;
 transform: translate(-50%, -50%);
 cursor: pointer;
 display: flex;
 `, [cB("slider-handle", `
 height: var(--n-handle-size);
 width: var(--n-handle-size);
 border-radius: 50%;
 overflow: hidden;
 transition: box-shadow .2s var(--n-bezier), background-color .3s var(--n-bezier);
 background-color: var(--n-handle-color);
 box-shadow: var(--n-handle-box-shadow);
 `, [c$1("&:hover", `
 box-shadow: var(--n-handle-box-shadow-hover);
 `)]), c$1("&:focus", [cB("slider-handle", `
 box-shadow: var(--n-handle-box-shadow-focus);
 `, [c$1("&:hover", `
 box-shadow: var(--n-handle-box-shadow-active);
 `)])])])]), cB("slider-dots", `
 position: absolute;
 top: 50%;
 left: calc(var(--n-handle-size) / 2);
 right: calc(var(--n-handle-size) / 2);
 `, [cM("transition-disabled", [cB("slider-dot", "transition: none;")]), cB("slider-dot", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 transform: translate(-50%, -50%);
 height: var(--n-dot-height);
 width: var(--n-dot-width);
 border-radius: var(--n-dot-border-radius);
 overflow: hidden;
 box-sizing: border-box;
 border: var(--n-dot-border);
 background-color: var(--n-dot-color);
 `, [cM("active", "border: var(--n-dot-border-active);")])])]), cB("slider-handle-indicator", `
 font-size: var(--n-font-size);
 padding: 6px 10px;
 border-radius: var(--n-indicator-border-radius);
 color: var(--n-indicator-text-color);
 background-color: var(--n-indicator-color);
 box-shadow: var(--n-indicator-box-shadow);
 `, [fadeInScaleUpTransition()]), cB("slider-handle-indicator", `
 font-size: var(--n-font-size);
 padding: 6px 10px;
 border-radius: var(--n-indicator-border-radius);
 color: var(--n-indicator-text-color);
 background-color: var(--n-indicator-color);
 box-shadow: var(--n-indicator-box-shadow);
 `, [cM("top", `
 margin-bottom: 12px;
 `), cM("right", `
 margin-left: 12px;
 `), cM("bottom", `
 margin-top: 12px;
 `), cM("left", `
 margin-right: 12px;
 `), fadeInScaleUpTransition()]), insideModal(cB("slider", [cB("slider-dot", "background-color: var(--n-dot-color-modal);")])), insidePopover(cB("slider", [cB("slider-dot", "background-color: var(--n-dot-color-popover);")]))]);
      const eventButtonLeft = 0;
      const sliderProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, defaultValue: {
        type: [Number, Array],
        default: 0
      }, marks: Object, disabled: {
        type: Boolean,
        default: void 0
      }, formatTooltip: Function, keyboard: {
        type: Boolean,
        default: true
      }, min: {
        type: Number,
        default: 0
      }, max: {
        type: Number,
        default: 100
      }, step: {
        type: [Number, String],
        default: 1
      }, range: Boolean, value: [Number, Array], placement: String, showTooltip: {
        type: Boolean,
        default: void 0
      }, tooltip: {
        type: Boolean,
        default: true
      }, vertical: Boolean, reverse: Boolean, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
      const Slider = vue.defineComponent({
        name: "Slider",
        props: sliderProps,
        setup(props) {
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Slider", "-slider", style$k, sliderLight$1, props, mergedClsPrefixRef);
          const handleRailRef = vue.ref(null);
          const [handleRefs, setHandleRefs] = useRefs();
          const [followerRefs, setFollowerRefs] = useRefs();
          const followerEnabledIndexSetRef = vue.ref(/* @__PURE__ */ new Set());
          const formItem = useFormItem(props);
          const { mergedDisabledRef } = formItem;
          const precisionRef = vue.computed(() => {
            const { step } = props;
            if (Number(step) <= 0 || step === "mark")
              return 0;
            const stepString = step.toString();
            let precision = 0;
            if (stepString.includes(".")) {
              precision = stepString.length - stepString.indexOf(".") - 1;
            }
            return precision;
          });
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const arrifiedValueRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            return (props.range ? mergedValue : [mergedValue]).map(clampValue2);
          });
          const handleCountExceeds2Ref = vue.computed(() => arrifiedValueRef.value.length > 2);
          const mergedPlacementRef = vue.computed(() => {
            return props.placement === void 0 ? props.vertical ? "right" : "top" : props.placement;
          });
          const markValuesRef = vue.computed(() => {
            const { marks } = props;
            return marks ? Object.keys(marks).map(parseFloat) : null;
          });
          const activeIndexRef = vue.ref(-1);
          const previousIndexRef = vue.ref(-1);
          const hoverIndexRef = vue.ref(-1);
          const draggingRef = vue.ref(false);
          const dotTransitionDisabledRef = vue.ref(false);
          const styleDirectionRef = vue.computed(() => {
            const { vertical, reverse } = props;
            const left = reverse ? "right" : "left";
            const bottom = reverse ? "top" : "bottom";
            return vertical ? bottom : left;
          });
          const fillStyleRef = vue.computed(() => {
            if (handleCountExceeds2Ref.value)
              return;
            const values = arrifiedValueRef.value;
            const start = valueToPercentage(props.range ? Math.min(...values) : props.min);
            const end = valueToPercentage(props.range ? Math.max(...values) : values[0]);
            const { value: styleDirection } = styleDirectionRef;
            return props.vertical ? {
              [styleDirection]: `${start}%`,
              height: `${end - start}%`
            } : {
              [styleDirection]: `${start}%`,
              width: `${end - start}%`
            };
          });
          const markInfosRef = vue.computed(() => {
            const mergedMarks = [];
            const { marks } = props;
            if (marks) {
              const orderValues = arrifiedValueRef.value.slice();
              orderValues.sort((a2, b) => a2 - b);
              const { value: styleDirection } = styleDirectionRef;
              const { value: handleCountExceeds2 } = handleCountExceeds2Ref;
              const { range: range2 } = props;
              const isActive = handleCountExceeds2 ? () => false : (num) => range2 ? num >= orderValues[0] && num <= orderValues[orderValues.length - 1] : num <= orderValues[0];
              for (const key of Object.keys(marks)) {
                const num = Number(key);
                mergedMarks.push({
                  active: isActive(num),
                  label: marks[key],
                  style: {
                    [styleDirection]: `${valueToPercentage(num)}%`
                  }
                });
              }
            }
            return mergedMarks;
          });
          function getHandleStyle(value, index) {
            const percentage = valueToPercentage(value);
            const { value: styleDirection } = styleDirectionRef;
            return {
              [styleDirection]: `${percentage}%`,
              zIndex: index === activeIndexRef.value ? 1 : 0
            };
          }
          function isShowTooltip(index) {
            return props.showTooltip || hoverIndexRef.value === index || activeIndexRef.value === index && draggingRef.value;
          }
          function shouldKeepTooltipTransition(index) {
            if (!draggingRef.value)
              return true;
            return !(activeIndexRef.value === index && previousIndexRef.value === index);
          }
          function focusActiveHandle(index) {
            var _a;
            if (~index) {
              activeIndexRef.value = index;
              (_a = handleRefs.value.get(index)) === null || _a === void 0 ? void 0 : _a.focus();
            }
          }
          function syncPosition() {
            followerRefs.value.forEach((inst, index) => {
              if (isShowTooltip(index))
                inst.syncPosition();
            });
          }
          function doUpdateValue(value) {
            const { "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function dispatchValueUpdate(value) {
            const { range: range2 } = props;
            if (range2) {
              if (Array.isArray(value)) {
                const { value: oldValues } = arrifiedValueRef;
                if (value.join() !== oldValues.join()) {
                  doUpdateValue(value);
                }
              }
            } else if (!Array.isArray(value)) {
              const oldValue = arrifiedValueRef.value[0];
              if (oldValue !== value) {
                doUpdateValue(value);
              }
            }
          }
          function doDispatchValue(value, index) {
            if (props.range) {
              const values = arrifiedValueRef.value.slice();
              values.splice(index, 1, value);
              dispatchValueUpdate(values);
            } else {
              dispatchValueUpdate(value);
            }
          }
          function sanitizeValue(value, currentValue, stepBuffer) {
            const stepping = stepBuffer !== void 0;
            if (!stepBuffer) {
              stepBuffer = value - currentValue > 0 ? 1 : -1;
            }
            const markValues = markValuesRef.value || [];
            const { step } = props;
            if (step === "mark") {
              const closestMark2 = getClosestMark(value, markValues.concat(currentValue), stepping ? stepBuffer : void 0);
              return closestMark2 ? closestMark2.value : currentValue;
            }
            if (step <= 0)
              return currentValue;
            const { value: precision } = precisionRef;
            let closestMark;
            if (stepping) {
              const currentStep = Number((currentValue / step).toFixed(precision));
              const actualStep = Math.floor(currentStep);
              const leftStep = currentStep > actualStep ? actualStep : actualStep - 1;
              const rightStep = currentStep < actualStep ? actualStep : actualStep + 1;
              closestMark = getClosestMark(currentValue, [
                Number((leftStep * step).toFixed(precision)),
                Number((rightStep * step).toFixed(precision)),
                ...markValues
              ], stepBuffer);
            } else {
              const roundValue = getRoundValue(value);
              closestMark = getClosestMark(value, [...markValues, roundValue]);
            }
            return closestMark ? clampValue2(closestMark.value) : currentValue;
          }
          function clampValue2(value) {
            return Math.min(props.max, Math.max(props.min, value));
          }
          function valueToPercentage(value) {
            const { max, min } = props;
            return (value - min) / (max - min) * 100;
          }
          function percentageToValue(percentage) {
            const { max, min } = props;
            return min + (max - min) * percentage;
          }
          function getRoundValue(value) {
            const { step, min } = props;
            if (Number(step) <= 0 || step === "mark")
              return value;
            const newValue = Math.round((value - min) / step) * step + min;
            return Number(newValue.toFixed(precisionRef.value));
          }
          function getClosestMark(currentValue, markValues = markValuesRef.value, buffer) {
            if (!(markValues === null || markValues === void 0 ? void 0 : markValues.length))
              return null;
            let closestMark = null;
            let index = -1;
            while (++index < markValues.length) {
              const diff = markValues[index] - currentValue;
              const distance = Math.abs(diff);
              if (
                // find marks in the same direction
                (buffer === void 0 || diff * buffer > 0) && (closestMark === null || distance < closestMark.distance)
              ) {
                closestMark = {
                  index,
                  distance,
                  value: markValues[index]
                };
              }
            }
            return closestMark;
          }
          function getPointValue(event) {
            const railEl = handleRailRef.value;
            if (!railEl)
              return;
            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;
            const railRect = railEl.getBoundingClientRect();
            let percentage;
            if (props.vertical) {
              percentage = (railRect.bottom - touchEvent.clientY) / railRect.height;
            } else {
              percentage = (touchEvent.clientX - railRect.left) / railRect.width;
            }
            if (props.reverse) {
              percentage = 1 - percentage;
            }
            return percentageToValue(percentage);
          }
          function handleRailKeyDown(e) {
            if (mergedDisabledRef.value || !props.keyboard)
              return;
            const { vertical, reverse } = props;
            switch (e.key) {
              case "ArrowUp":
                e.preventDefault();
                handleStepValue(vertical && reverse ? -1 : 1);
                break;
              case "ArrowRight":
                e.preventDefault();
                handleStepValue(!vertical && reverse ? -1 : 1);
                break;
              case "ArrowDown":
                e.preventDefault();
                handleStepValue(vertical && reverse ? 1 : -1);
                break;
              case "ArrowLeft":
                e.preventDefault();
                handleStepValue(!vertical && reverse ? 1 : -1);
                break;
            }
          }
          function handleStepValue(ratio) {
            const activeIndex = activeIndexRef.value;
            if (activeIndex === -1)
              return;
            const { step } = props;
            const currentValue = arrifiedValueRef.value[activeIndex];
            const nextValue = Number(step) <= 0 || step === "mark" ? currentValue : currentValue + step * ratio;
            doDispatchValue(
              // Avoid the number of value does not change when `step` is null
              sanitizeValue(nextValue, currentValue, ratio > 0 ? 1 : -1),
              activeIndex
            );
          }
          function handleRailMouseDown(event) {
            var _a, _b;
            if (mergedDisabledRef.value)
              return;
            if (!isTouchEvent(event) && event.button !== eventButtonLeft) {
              return;
            }
            const pointValue = getPointValue(event);
            if (pointValue === void 0)
              return;
            const values = arrifiedValueRef.value.slice();
            const activeIndex = props.range ? (_b = (_a = getClosestMark(pointValue, values)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1 : 0;
            if (activeIndex !== -1) {
              event.preventDefault();
              focusActiveHandle(activeIndex);
              startDragging();
              doDispatchValue(sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]), activeIndex);
            }
          }
          function startDragging() {
            if (!draggingRef.value) {
              draggingRef.value = true;
              on("touchend", document, handleMouseUp);
              on("mouseup", document, handleMouseUp);
              on("touchmove", document, handleMouseMove);
              on("mousemove", document, handleMouseMove);
            }
          }
          function stopDragging() {
            if (draggingRef.value) {
              draggingRef.value = false;
              off("touchend", document, handleMouseUp);
              off("mouseup", document, handleMouseUp);
              off("touchmove", document, handleMouseMove);
              off("mousemove", document, handleMouseMove);
            }
          }
          function handleMouseMove(event) {
            const { value: activeIndex } = activeIndexRef;
            if (!draggingRef.value || activeIndex === -1) {
              stopDragging();
              return;
            }
            const pointValue = getPointValue(event);
            doDispatchValue(sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]), activeIndex);
          }
          function handleMouseUp() {
            stopDragging();
          }
          function handleHandleFocus(index) {
            activeIndexRef.value = index;
            if (!mergedDisabledRef.value) {
              hoverIndexRef.value = index;
            }
          }
          function handleHandleBlur(index) {
            if (activeIndexRef.value === index) {
              activeIndexRef.value = -1;
              stopDragging();
            }
            if (hoverIndexRef.value === index) {
              hoverIndexRef.value = -1;
            }
          }
          function handleHandleMouseEnter(index) {
            hoverIndexRef.value = index;
          }
          function handleHandleMouseLeave(index) {
            if (hoverIndexRef.value === index) {
              hoverIndexRef.value = -1;
            }
          }
          vue.watch(activeIndexRef, (_, previous) => void vue.nextTick(() => previousIndexRef.value = previous));
          vue.watch(mergedValueRef, () => {
            if (props.marks) {
              if (dotTransitionDisabledRef.value)
                return;
              dotTransitionDisabledRef.value = true;
              void vue.nextTick(() => {
                dotTransitionDisabledRef.value = false;
              });
            }
            void vue.nextTick(syncPosition);
          });
          vue.onBeforeUnmount(() => {
            stopDragging();
          });
          const cssVarsRef = vue.computed(() => {
            const { self: { markFontSize, railColor, railColorHover, fillColor, fillColorHover, handleColor, opacityDisabled, dotColor, dotColorModal, handleBoxShadow, handleBoxShadowHover, handleBoxShadowActive, handleBoxShadowFocus, dotBorder, dotBoxShadow, railHeight, railWidthVertical, handleSize, dotHeight, dotWidth, dotBorderRadius, fontSize: fontSize2, dotBorderActive, dotColorPopover }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-dot-border": dotBorder,
              "--n-dot-border-active": dotBorderActive,
              "--n-dot-border-radius": dotBorderRadius,
              "--n-dot-box-shadow": dotBoxShadow,
              "--n-dot-color": dotColor,
              "--n-dot-color-modal": dotColorModal,
              "--n-dot-color-popover": dotColorPopover,
              "--n-dot-height": dotHeight,
              "--n-dot-width": dotWidth,
              "--n-fill-color": fillColor,
              "--n-fill-color-hover": fillColorHover,
              "--n-font-size": fontSize2,
              "--n-handle-box-shadow": handleBoxShadow,
              "--n-handle-box-shadow-active": handleBoxShadowActive,
              "--n-handle-box-shadow-focus": handleBoxShadowFocus,
              "--n-handle-box-shadow-hover": handleBoxShadowHover,
              "--n-handle-color": handleColor,
              "--n-handle-size": handleSize,
              "--n-opacity-disabled": opacityDisabled,
              "--n-rail-color": railColor,
              "--n-rail-color-hover": railColorHover,
              "--n-rail-height": railHeight,
              "--n-rail-width-vertical": railWidthVertical,
              "--n-mark-font-size": markFontSize
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("slider", void 0, cssVarsRef, props) : void 0;
          const indicatorCssVarsRef = vue.computed(() => {
            const { self: { fontSize: fontSize2, indicatorColor, indicatorBoxShadow, indicatorTextColor, indicatorBorderRadius } } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-indicator-border-radius": indicatorBorderRadius,
              "--n-indicator-box-shadow": indicatorBoxShadow,
              "--n-indicator-color": indicatorColor,
              "--n-indicator-text-color": indicatorTextColor
            };
          });
          const indicatorThemeClassHandle = inlineThemeDisabled ? useThemeClass("slider-indicator", void 0, indicatorCssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            mergedDisabled: mergedDisabledRef,
            mergedPlacement: mergedPlacementRef,
            isMounted: isMounted(),
            adjustedTo: useAdjustedTo(props),
            dotTransitionDisabled: dotTransitionDisabledRef,
            markInfos: markInfosRef,
            isShowTooltip,
            shouldKeepTooltipTransition,
            handleRailRef,
            setHandleRefs,
            setFollowerRefs,
            fillStyle: fillStyleRef,
            getHandleStyle,
            activeIndex: activeIndexRef,
            arrifiedValues: arrifiedValueRef,
            followerEnabledIndexSet: followerEnabledIndexSetRef,
            handleRailMouseDown,
            handleHandleFocus,
            handleHandleBlur,
            handleHandleMouseEnter,
            handleHandleMouseLeave,
            handleRailKeyDown,
            indicatorCssVars: inlineThemeDisabled ? void 0 : indicatorCssVarsRef,
            indicatorThemeClass: indicatorThemeClassHandle === null || indicatorThemeClassHandle === void 0 ? void 0 : indicatorThemeClassHandle.themeClass,
            indicatorOnRender: indicatorThemeClassHandle === null || indicatorThemeClassHandle === void 0 ? void 0 : indicatorThemeClassHandle.onRender,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix, themeClass, formatTooltip } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-slider`,
              themeClass,
              {
                [`${mergedClsPrefix}-slider--disabled`]: this.mergedDisabled,
                [`${mergedClsPrefix}-slider--active`]: this.activeIndex !== -1,
                [`${mergedClsPrefix}-slider--with-mark`]: this.marks,
                [`${mergedClsPrefix}-slider--vertical`]: this.vertical,
                [`${mergedClsPrefix}-slider--reverse`]: this.reverse
              }
            ], style: this.cssVars, onKeydown: this.handleRailKeyDown, onMousedown: this.handleRailMouseDown, onTouchstart: this.handleRailMouseDown },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-slider-rail` },
              vue.h("div", { class: `${mergedClsPrefix}-slider-rail__fill`, style: this.fillStyle }),
              this.marks ? vue.h("div", { class: [
                `${mergedClsPrefix}-slider-dots`,
                this.dotTransitionDisabled && `${mergedClsPrefix}-slider-dots--transition-disabled`
              ] }, this.markInfos.map((mark) => vue.h("div", { key: mark.label, class: [
                `${mergedClsPrefix}-slider-dot`,
                {
                  [`${mergedClsPrefix}-slider-dot--active`]: mark.active
                }
              ], style: mark.style }))) : null,
              vue.h("div", { ref: "handleRailRef", class: `${mergedClsPrefix}-slider-handles` }, this.arrifiedValues.map((value, index) => {
                const showTooltip = this.isShowTooltip(index);
                return vue.h(VBinder, null, {
                  default: () => [
                    vue.h(VTarget, null, {
                      default: () => vue.h("div", { ref: this.setHandleRefs(index), class: `${mergedClsPrefix}-slider-handle-wrapper`, tabindex: this.mergedDisabled ? -1 : 0, style: this.getHandleStyle(value, index), onFocus: () => {
                        this.handleHandleFocus(index);
                      }, onBlur: () => {
                        this.handleHandleBlur(index);
                      }, onMouseenter: () => {
                        this.handleHandleMouseEnter(index);
                      }, onMouseleave: () => {
                        this.handleHandleMouseLeave(index);
                      } }, resolveSlot(this.$slots.thumb, () => [
                        vue.h("div", { class: `${mergedClsPrefix}-slider-handle` })
                      ]))
                    }),
                    this.tooltip && vue.h(VFollower, { ref: this.setFollowerRefs(index), show: showTooltip, to: this.adjustedTo, enabled: this.showTooltip && !this.range || this.followerEnabledIndexSet.has(index), teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, placement: this.mergedPlacement, containerClass: this.namespace }, {
                      default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, css: this.shouldKeepTooltipTransition(index), onEnter: () => {
                        this.followerEnabledIndexSet.add(index);
                      }, onAfterLeave: () => {
                        this.followerEnabledIndexSet.delete(index);
                      } }, {
                        default: () => {
                          var _a2;
                          if (showTooltip) {
                            (_a2 = this.indicatorOnRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
                            return vue.h("div", { class: [
                              `${mergedClsPrefix}-slider-handle-indicator`,
                              this.indicatorThemeClass,
                              `${mergedClsPrefix}-slider-handle-indicator--${this.mergedPlacement}`
                            ], style: this.indicatorCssVars }, typeof formatTooltip === "function" ? formatTooltip(value) : value);
                          }
                          return null;
                        }
                      })
                    })
                  ]
                });
              })),
              this.marks ? vue.h("div", { class: `${mergedClsPrefix}-slider-marks` }, this.markInfos.map((mark) => vue.h("div", { key: mark.label, class: `${mergedClsPrefix}-slider-mark`, style: mark.style }, mark.label))) : null
            )
          );
        }
      });
      const style$j = c$1([c$1("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), cB("spin-container", {
        position: "relative"
      }, [cB("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [fadeInTransition()])]), cB("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), cB("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [cM("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), cB("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), cB("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [cM("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]);
      const STROKE_WIDTH = {
        small: 20,
        medium: 18,
        large: 16
      };
      const spinProps = Object.assign(Object.assign({}, useTheme.props), { description: String, stroke: String, size: {
        type: [String, Number],
        default: "medium"
      }, show: {
        type: Boolean,
        default: true
      }, strokeWidth: Number, rotate: {
        type: Boolean,
        default: true
      }, spinning: {
        type: Boolean,
        validator: () => {
          return true;
        },
        default: void 0
      } });
      const Spin = vue.defineComponent({
        name: "Spin",
        props: spinProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Spin", "-spin", style$j, spinLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { size: spinSize } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: self2 } = themeRef.value;
            const { opacitySpinning, color, textColor } = self2;
            const size2 = typeof spinSize === "number" ? pxfy(spinSize) : self2[createKey("size", spinSize)];
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-opacity-spinning": opacitySpinning,
              "--n-size": size2,
              "--n-color": color,
              "--n-text-color": textColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("spin", vue.computed(() => {
            const { size: size2 } = props;
            return typeof size2 === "number" ? String(size2) : size2[0];
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            compitableShow: useCompitable(props, ["spinning", "show"]),
            mergedStrokeWidth: vue.computed(() => {
              const { strokeWidth } = props;
              if (strokeWidth !== void 0)
                return strokeWidth;
              const { size: size2 } = props;
              return STROKE_WIDTH[typeof size2 === "number" ? "medium" : size2];
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a, _b;
          const { $slots, mergedClsPrefix, description } = this;
          const rotate = $slots.icon && this.rotate;
          const descriptionNode = (description || $slots.description) && vue.h("div", { class: `${mergedClsPrefix}-spin-description` }, description || ((_a = $slots.description) === null || _a === void 0 ? void 0 : _a.call($slots)));
          const icon = $slots.icon ? vue.h(
            "div",
            { class: [`${mergedClsPrefix}-spin-body`, this.themeClass] },
            vue.h("div", { class: [
              `${mergedClsPrefix}-spin`,
              rotate && `${mergedClsPrefix}-spin--rotate`
            ], style: $slots.default ? "" : this.cssVars }, $slots.icon()),
            descriptionNode
          ) : vue.h(
            "div",
            { class: [`${mergedClsPrefix}-spin-body`, this.themeClass] },
            vue.h(NBaseLoading, { clsPrefix: mergedClsPrefix, style: $slots.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${mergedClsPrefix}-spin` }),
            descriptionNode
          );
          (_b = this.onRender) === null || _b === void 0 ? void 0 : _b.call(this);
          return $slots.default ? vue.h(
            "div",
            { class: [`${mergedClsPrefix}-spin-container`, this.themeClass], style: this.cssVars },
            vue.h("div", { class: [
              `${mergedClsPrefix}-spin-content`,
              this.compitableShow && `${mergedClsPrefix}-spin-content--spinning`
            ] }, $slots),
            vue.h(vue.Transition, { name: "fade-in-transition" }, {
              default: () => this.compitableShow ? icon : null
            })
          ) : icon;
        }
      });
      const style$i = cB("statistic", [cE("label", `
 font-weight: var(--n-label-font-weight);
 transition: .3s color var(--n-bezier);
 font-size: var(--n-label-font-size);
 color: var(--n-label-text-color);
 `), cB("statistic-value", `
 margin-top: 4px;
 font-weight: var(--n-value-font-weight);
 `, [cE("prefix", `
 margin: 0 4px 0 0;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-prefix-text-color);
 `, [cB("icon", {
        verticalAlign: "-0.125em"
      })]), cE("content", `
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-text-color);
 `), cE("suffix", `
 margin: 0 0 0 4px;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-suffix-text-color);
 `, [cB("icon", {
        verticalAlign: "-0.125em"
      })])])]);
      const statisticProps = Object.assign(Object.assign({}, useTheme.props), { tabularNums: Boolean, label: String, value: [String, Number] });
      const Statistic = vue.defineComponent({
        name: "Statistic",
        props: statisticProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Statistic", "-statistic", style$i, statisticLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Statistic", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { self: { labelFontWeight, valueFontSize, valueFontWeight, valuePrefixTextColor, labelTextColor, valueSuffixTextColor, valueTextColor, labelFontSize }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-label-font-size": labelFontSize,
              "--n-label-font-weight": labelFontWeight,
              "--n-label-text-color": labelTextColor,
              "--n-value-font-weight": valueFontWeight,
              "--n-value-font-size": valueFontSize,
              "--n-value-prefix-text-color": valuePrefixTextColor,
              "--n-value-suffix-text-color": valueSuffixTextColor,
              "--n-value-text-color": valueTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("statistic", void 0, cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix, $slots: { default: defaultSlot, label: labelSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-statistic`,
              this.themeClass,
              this.rtlEnabled && `${mergedClsPrefix}-statistic--rtl`
            ], style: this.cssVars },
            resolveWrappedSlot(labelSlot, (children) => vue.h("div", { class: `${mergedClsPrefix}-statistic__label` }, this.label || children)),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-statistic-value`, style: {
                fontVariantNumeric: this.tabularNums ? "tabular-nums" : ""
              } },
              resolveWrappedSlot(prefixSlot, (children) => children && vue.h("span", { class: `${mergedClsPrefix}-statistic-value__prefix` }, children)),
              this.value !== void 0 ? vue.h("span", { class: `${mergedClsPrefix}-statistic-value__content` }, this.value) : resolveWrappedSlot(defaultSlot, (children) => children && vue.h("span", { class: `${mergedClsPrefix}-statistic-value__content` }, children)),
              resolveWrappedSlot(suffixSlot, (children) => children && vue.h("span", { class: `${mergedClsPrefix}-statistic-value__suffix` }, children))
            )
          );
        }
      });
      const style$h = cB("steps", `
 width: 100%;
 display: flex;
`, [cB("step", `
 position: relative;
 display: flex;
 flex: 1;
 `, [cM("disabled", "cursor: not-allowed"), cM("clickable", `
 cursor: pointer;
 `), c$1("&:last-child", [cB("step-splitor", "display: none;")])]), cB("step-splitor", `
 background-color: var(--n-splitor-color);
 margin-top: calc(var(--n-step-header-font-size) / 2);
 height: 1px;
 flex: 1;
 align-self: flex-start;
 margin-left: 12px;
 margin-right: 12px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("step-content", "flex: 1;", [cB("step-content-header", `
 color: var(--n-header-text-color);
 margin-top: calc(var(--n-indicator-size) / 2 - var(--n-step-header-font-size) / 2);
 line-height: var(--n-step-header-font-size);
 font-size: var(--n-step-header-font-size);
 position: relative;
 display: flex;
 font-weight: var(--n-step-header-font-weight);
 margin-left: 9px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cE("title", `
 white-space: nowrap;
 flex: 0;
 `)]), cE("description", `
 color: var(--n-description-text-color);
 margin-top: 12px;
 margin-left: 9px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), cB("step-indicator", `
 background-color: var(--n-indicator-color);
 box-shadow: 0 0 0 1px var(--n-indicator-border-color);
 height: var(--n-indicator-size);
 width: var(--n-indicator-size);
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [cB("step-indicator-slot", `
 position: relative;
 width: var(--n-indicator-icon-size);
 height: var(--n-indicator-icon-size);
 font-size: var(--n-indicator-icon-size);
 line-height: var(--n-indicator-icon-size);
 `, [cE("index", `
 display: inline-block;
 text-align: center;
 position: absolute;
 left: 0;
 top: 0;
 font-size: var(--n-indicator-index-font-size);
 width: var(--n-indicator-icon-size);
 height: var(--n-indicator-icon-size);
 line-height: var(--n-indicator-icon-size);
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()]), cB("icon", `
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()]), cB("base-icon", `
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()])])]), cM("vertical", "flex-direction: column;", [cNotM("show-description", [c$1(">", [cB("step", "padding-bottom: 8px;")])]), c$1(">", [cB("step", "margin-bottom: 16px;", [c$1("&:last-child", "margin-bottom: 0;"), c$1(">", [cB("step-indicator", [c$1(">", [cB("step-splitor", `
 position: absolute;
 bottom: -8px;
 width: 1px;
 margin: 0 !important;
 left: calc(var(--n-indicator-size) / 2);
 height: calc(100% - var(--n-indicator-size));
 `)])]), cB("step-content", [cE("description", "margin-top: 8px;")])])])])])]);
      function stepWithIndex(step, i) {
        if (typeof step !== "object" || step === null || Array.isArray(step)) {
          return null;
        }
        if (!step.props)
          step.props = {};
        step.props.internalIndex = i + 1;
        return step;
      }
      function stepsWithIndex(steps) {
        return steps.map((step, i) => stepWithIndex(step, i));
      }
      const stepsProps = Object.assign(Object.assign({}, useTheme.props), { current: Number, status: {
        type: String,
        default: "process"
      }, size: {
        type: String,
        default: "medium"
      }, vertical: Boolean, "onUpdate:current": [Function, Array], onUpdateCurrent: [Function, Array] });
      const stepsInjectionKey = createInjectionKey("n-steps");
      const Steps = vue.defineComponent({
        name: "Steps",
        props: stepsProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl("Steps", mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme("Steps", "-steps", style$h, stepsLight$1, props, mergedClsPrefixRef);
          vue.provide(stepsInjectionKey, {
            props,
            mergedThemeRef: themeRef,
            mergedClsPrefixRef,
            stepsSlots: slots
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef
          };
        },
        render() {
          const { mergedClsPrefix } = this;
          return vue.h("div", { class: [
            `${mergedClsPrefix}-steps`,
            this.rtlEnabled && `${mergedClsPrefix}-steps--rtl`,
            this.vertical && `${mergedClsPrefix}-steps--vertical`
          ] }, stepsWithIndex(flatten$3(getSlot$1(this))));
        }
      });
      const stepProps = {
        status: String,
        title: String,
        description: String,
        disabled: Boolean,
        // index will be filled by parent steps, not user
        internalIndex: {
          type: Number,
          default: 0
        }
      };
      const Step = vue.defineComponent({
        name: "Step",
        props: stepProps,
        setup(props) {
          const NSteps = vue.inject(stepsInjectionKey, null);
          if (!NSteps)
            throwError("step", "`n-step` must be placed inside `n-steps`.");
          const { inlineThemeDisabled } = useConfig();
          const { props: stepsProps2, mergedThemeRef, mergedClsPrefixRef, stepsSlots } = NSteps;
          const verticalRef = vue.computed(() => {
            return stepsProps2.vertical;
          });
          const mergedStatusRef = vue.computed(() => {
            const { status } = props;
            if (status) {
              return status;
            } else {
              const { internalIndex } = props;
              const { current } = stepsProps2;
              if (current === void 0)
                return "process";
              if (internalIndex < current) {
                return "finish";
              } else if (internalIndex === current) {
                return stepsProps2.status || "process";
              } else if (internalIndex > current) {
                return "wait";
              }
            }
            return "process";
          });
          const cssVarsRef = vue.computed(() => {
            const { value: status } = mergedStatusRef;
            const { size: size2 } = stepsProps2;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { stepHeaderFontWeight, [createKey("stepHeaderFontSize", size2)]: stepHeaderFontSize, [createKey("indicatorIndexFontSize", size2)]: indicatorIndexFontSize, [createKey("indicatorSize", size2)]: indicatorSize, [createKey("indicatorIconSize", size2)]: indicatorIconSize, [createKey("indicatorTextColor", status)]: indicatorTextColor, [createKey("indicatorBorderColor", status)]: indicatorBorderColor, [createKey("headerTextColor", status)]: headerTextColor, [createKey("splitorColor", status)]: splitorColor, [createKey("indicatorColor", status)]: indicatorColor, [createKey("descriptionTextColor", status)]: descriptionTextColor } } = mergedThemeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-description-text-color": descriptionTextColor,
              "--n-header-text-color": headerTextColor,
              "--n-indicator-border-color": indicatorBorderColor,
              "--n-indicator-color": indicatorColor,
              "--n-indicator-icon-size": indicatorIconSize,
              "--n-indicator-index-font-size": indicatorIndexFontSize,
              "--n-indicator-size": indicatorSize,
              "--n-indicator-text-color": indicatorTextColor,
              "--n-splitor-color": splitorColor,
              "--n-step-header-font-size": stepHeaderFontSize,
              "--n-step-header-font-weight": stepHeaderFontWeight
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("step", vue.computed(() => {
            const { value: status } = mergedStatusRef;
            const { size: size2 } = stepsProps2;
            return `${status[0]}${size2[0]}`;
          }), cssVarsRef, stepsProps2) : void 0;
          const handleStepClick = vue.computed(() => {
            if (props.disabled)
              return void 0;
            const { onUpdateCurrent, "onUpdate:current": _onUpdateCurrent } = stepsProps2;
            return onUpdateCurrent || _onUpdateCurrent ? () => {
              if (onUpdateCurrent) {
                call(onUpdateCurrent, props.internalIndex);
              }
              if (_onUpdateCurrent) {
                call(_onUpdateCurrent, props.internalIndex);
              }
            } : void 0;
          });
          return {
            stepsSlots,
            mergedClsPrefix: mergedClsPrefixRef,
            vertical: verticalRef,
            mergedStatus: mergedStatusRef,
            handleStepClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix, onRender, handleStepClick, disabled } = this;
          const descriptionNode = resolveWrappedSlot(this.$slots.default, (children) => {
            const mergedDescription = children || this.description;
            if (mergedDescription) {
              return vue.h("div", { class: `${mergedClsPrefix}-step-content__description` }, mergedDescription);
            }
            return null;
          });
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-step`,
              disabled && `${mergedClsPrefix}-step--disabled`,
              !disabled && handleStepClick && `${mergedClsPrefix}-step--clickable`,
              this.themeClass,
              descriptionNode && `${mergedClsPrefix}-step--show-description`,
              `${mergedClsPrefix}-step--${this.mergedStatus}-status`
            ], style: this.cssVars, onClick: handleStepClick },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-step-indicator` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-step-indicator-slot` },
                vue.h(NIconSwitchTransition, null, {
                  default: () => {
                    return resolveWrappedSlot(this.$slots.icon, (icon) => {
                      const { mergedStatus, stepsSlots } = this;
                      return !(mergedStatus === "finish" || mergedStatus === "error") ? icon || vue.h("div", { key: this.internalIndex, class: `${mergedClsPrefix}-step-indicator-slot__index` }, this.internalIndex) : mergedStatus === "finish" ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, key: "finish" }, {
                        default: () => resolveSlot(stepsSlots["finish-icon"], () => [
                          vue.h(FinishedIcon, null)
                        ])
                      }) : mergedStatus === "error" ? vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix, key: "error" }, {
                        default: () => resolveSlot(stepsSlots["error-icon"], () => [
                          vue.h(ErrorIcon$1, null)
                        ])
                      }) : null;
                    });
                  }
                })
              ),
              this.vertical ? vue.h("div", { class: `${mergedClsPrefix}-step-splitor` }) : null
            ),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-step-content` },
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-step-content-header` },
                vue.h("div", { class: `${mergedClsPrefix}-step-content-header__title` }, resolveSlot(this.$slots.title, () => [this.title])),
                !this.vertical ? vue.h("div", { class: `${mergedClsPrefix}-step-splitor` }) : null
              ),
              descriptionNode
            )
          );
        }
      });
      const style$g = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
        left: "50%",
        top: "50%",
        originalTransform: "translateX(-50%) translateY(-50%)"
      })]), cE("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c$1("&:focus", [cE("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM("round", [cE("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM("rubber-band", [cM("pressed", [cE("rail", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cE("rail", [c$1("&:active", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cM("active", [cM("pressed", [cE("rail", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE("rail", [c$1("&:active", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM("active", [cE("rail", [cE("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM("active", [cE("rail", "background-color: var(--n-rail-color-active);")]), cM("loading", [cE("rail", `
 cursor: wait;
 `)]), cM("disabled", [cE("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
      const switchProps = Object.assign(Object.assign({}, useTheme.props), {
        size: {
          type: String,
          default: "medium"
        },
        value: {
          type: [String, Number, Boolean],
          default: void 0
        },
        loading: Boolean,
        defaultValue: {
          type: [String, Number, Boolean],
          default: false
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        round: {
          type: Boolean,
          default: true
        },
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        checkedValue: {
          type: [String, Number, Boolean],
          default: true
        },
        uncheckedValue: {
          type: [String, Number, Boolean],
          default: false
        },
        railStyle: Function,
        rubberBand: {
          type: Boolean,
          default: true
        },
        /** @deprecated */
        onChange: [Function, Array]
      });
      let supportCssMax;
      const NSwitch = vue.defineComponent({
        name: "Switch",
        props: switchProps,
        setup(props) {
          if (supportCssMax === void 0) {
            if (typeof CSS !== "undefined") {
              if (typeof CSS.supports !== "undefined") {
                supportCssMax = CSS.supports("width", "max(1px)");
              } else {
                supportCssMax = false;
              }
            } else {
              supportCssMax = true;
            }
          }
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Switch", "-switch", style$g, switchLight$1, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const checkedRef = vue.computed(() => {
            return mergedValueRef.value === props.checkedValue;
          });
          const pressedRef = vue.ref(false);
          const focusedRef = vue.ref(false);
          const mergedRailStyleRef = vue.computed(() => {
            const { railStyle } = props;
            if (!railStyle)
              return void 0;
            return railStyle({ focused: focusedRef.value, checked: checkedRef.value });
          });
          function doUpdateValue(value) {
            const { "onUpdate:value": _onUpdateValue, onChange, onUpdateValue } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (onChange)
              call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function doFocus() {
            const { nTriggerFormFocus } = formItem;
            nTriggerFormFocus();
          }
          function doBlur() {
            const { nTriggerFormBlur } = formItem;
            nTriggerFormBlur();
          }
          function handleClick2() {
            if (props.loading || mergedDisabledRef.value)
              return;
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
          }
          function handleFocus() {
            focusedRef.value = true;
            doFocus();
          }
          function handleBlur() {
            focusedRef.value = false;
            doBlur();
            pressedRef.value = false;
          }
          function handleKeyup(e) {
            if (props.loading || mergedDisabledRef.value)
              return;
            if (e.key === " ") {
              if (mergedValueRef.value !== props.checkedValue) {
                doUpdateValue(props.checkedValue);
              } else {
                doUpdateValue(props.uncheckedValue);
              }
              pressedRef.value = false;
            }
          }
          function handleKeydown(e) {
            if (props.loading || mergedDisabledRef.value)
              return;
            if (e.key === " ") {
              e.preventDefault();
              pressedRef.value = true;
            }
          }
          const cssVarsRef = vue.computed(() => {
            const { value: size2 } = mergedSizeRef;
            const { self: { opacityDisabled, railColor, railColorActive, buttonBoxShadow, buttonColor, boxShadowFocus, loadingColor, textColor, iconColor, [createKey("buttonHeight", size2)]: buttonHeight, [createKey("buttonWidth", size2)]: buttonWidth, [createKey("buttonWidthPressed", size2)]: buttonWidthPressed, [createKey("railHeight", size2)]: railHeight, [createKey("railWidth", size2)]: railWidth, [createKey("railBorderRadius", size2)]: railBorderRadius, [createKey("buttonBorderRadius", size2)]: buttonBorderRadius }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            let offset;
            let height;
            let width;
            if (supportCssMax) {
              offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
              height = `max(${railHeight}, ${buttonHeight})`;
              width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
            } else {
              offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
              height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
              width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
            }
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-button-border-radius": buttonBorderRadius,
              "--n-button-box-shadow": buttonBoxShadow,
              "--n-button-color": buttonColor,
              "--n-button-width": buttonWidth,
              "--n-button-width-pressed": buttonWidthPressed,
              "--n-button-height": buttonHeight,
              "--n-height": height,
              "--n-offset": offset,
              "--n-opacity-disabled": opacityDisabled,
              "--n-rail-border-radius": railBorderRadius,
              "--n-rail-color": railColor,
              "--n-rail-color-active": railColorActive,
              "--n-rail-height": railHeight,
              "--n-rail-width": railWidth,
              "--n-width": width,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-loading-color": loadingColor,
              "--n-text-color": textColor,
              "--n-icon-color": iconColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", vue.computed(() => {
            return mergedSizeRef.value[0];
          }), cssVarsRef, props) : void 0;
          return {
            handleClick: handleClick2,
            handleBlur,
            handleFocus,
            handleKeyup,
            handleKeydown,
            mergedRailStyle: mergedRailStyleRef,
            pressed: pressedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            checked: checkedRef,
            mergedDisabled: mergedDisabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix, mergedDisabled, checked, mergedRailStyle, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const { checked: checkedSlot, unchecked: uncheckedSlot, icon: iconSlot, "checked-icon": checkedIconSlot, "unchecked-icon": uncheckedIconSlot } = $slots;
          const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
          return vue.h(
            "div",
            { role: "switch", "aria-checked": checked, class: [
              `${mergedClsPrefix}-switch`,
              this.themeClass,
              hasIcon && `${mergedClsPrefix}-switch--icon`,
              checked && `${mergedClsPrefix}-switch--active`,
              mergedDisabled && `${mergedClsPrefix}-switch--disabled`,
              this.round && `${mergedClsPrefix}-switch--round`,
              this.loading && `${mergedClsPrefix}-switch--loading`,
              this.pressed && `${mergedClsPrefix}-switch--pressed`,
              this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`
            ], tabindex: !this.mergedDisabled ? 0 : void 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-switch__rail`, "aria-hidden": "true", style: mergedRailStyle },
              resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
                if (checkedSlotChildren || uncheckedSlotChildren) {
                  return vue.h(
                    "div",
                    { "aria-hidden": true, class: `${mergedClsPrefix}-switch__children-placeholder` },
                    vue.h(
                      "div",
                      { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                      vue.h("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }),
                      checkedSlotChildren
                    ),
                    vue.h(
                      "div",
                      { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                      vue.h("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }),
                      uncheckedSlotChildren
                    )
                  );
                }
                return null;
              })),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-switch__button` },
                resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
                  return vue.h(NIconSwitchTransition, null, {
                    default: () => this.loading ? vue.h(NBaseLoading, { key: "loading", clsPrefix: mergedClsPrefix, strokeWidth: 20 }) : this.checked && (checkedIcon || icon) ? vue.h("div", { class: `${mergedClsPrefix}-switch__button-icon`, key: checkedIcon ? "checked-icon" : "icon" }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? vue.h("div", { class: `${mergedClsPrefix}-switch__button-icon`, key: uncheckedIcon ? "unchecked-icon" : "icon" }, uncheckedIcon || icon) : null
                  });
                }))),
                resolveWrappedSlot(checkedSlot, (children) => children && vue.h("div", { key: "checked", class: `${mergedClsPrefix}-switch__checked` }, children)),
                resolveWrappedSlot(uncheckedSlot, (children) => children && vue.h("div", { key: "unchecked", class: `${mergedClsPrefix}-switch__unchecked` }, children))
              )
            )
          );
        }
      });
      const style$f = c$1([cB("table", `
 font-size: var(--n-font-size);
 font-variant-numeric: tabular-nums;
 line-height: var(--n-line-height);
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 text-align: left;
 border-collapse: separate;
 border-spacing: 0;
 overflow: hidden;
 background-color: var(--n-td-color);
 border-color: var(--n-merged-border-color);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 --n-merged-border-color: var(--n-border-color);
 `, [c$1("th", `
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 text-align: inherit;
 padding: var(--n-th-padding);
 vertical-align: inherit;
 text-transform: none;
 border: 0px solid var(--n-merged-border-color);
 font-weight: var(--n-th-font-weight);
 color: var(--n-th-text-color);
 background-color: var(--n-th-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 border-right: 1px solid var(--n-merged-border-color);
 `, [c$1("&:last-child", `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), c$1("td", `
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 padding: var(--n-td-padding);
 color: var(--n-td-text-color);
 background-color: var(--n-td-color);
 border: 0px solid var(--n-merged-border-color);
 border-right: 1px solid var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 `, [c$1("&:last-child", `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), cM("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `, [c$1("tr", [c$1("&:last-child", [c$1("td", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `)])])]), cM("single-line", [c$1("th", `
 border-right: 0px solid var(--n-merged-border-color);
 `), c$1("td", `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), cM("single-column", [c$1("tr", [c$1("&:not(:last-child)", [c$1("td", `
 border-bottom: 0px solid var(--n-merged-border-color);
 `)])])]), cM("striped", [c$1("tr:nth-of-type(even)", [c$1("td", "background-color: var(--n-td-color-striped)")])]), cNotM("bottom-bordered", [c$1("tr", [c$1("&:last-child", [c$1("td", `
 border-bottom: 0px solid var(--n-merged-border-color);
 `)])])])]), insideModal(cB("table", `
 background-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `, [c$1("th", `
 background-color: var(--n-th-color-modal);
 `), c$1("td", `
 background-color: var(--n-td-color-modal);
 `)])), insidePopover(cB("table", `
 background-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `, [c$1("th", `
 background-color: var(--n-th-color-popover);
 `), c$1("td", `
 background-color: var(--n-td-color-popover);
 `)]))]);
      const tableProps = Object.assign(Object.assign({}, useTheme.props), { bordered: {
        type: Boolean,
        default: true
      }, bottomBordered: {
        type: Boolean,
        default: true
      }, singleLine: {
        type: Boolean,
        default: true
      }, striped: Boolean, singleColumn: Boolean, size: {
        type: String,
        default: "medium"
      } });
      const Table = vue.defineComponent({
        name: "Table",
        props: tableProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Table", "-table", style$f, tableLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Table", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { size: size2 } = props;
            const { self: { borderColor, tdColor, tdColorModal, tdColorPopover, thColor, thColorModal, thColorPopover, thTextColor, tdTextColor, borderRadius, thFontWeight, lineHeight: lineHeight2, borderColorModal, borderColorPopover, tdColorStriped, tdColorStripedModal, tdColorStripedPopover, [createKey("fontSize", size2)]: fontSize2, [createKey("tdPadding", size2)]: tdPadding, [createKey("thPadding", size2)]: thPadding }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-td-color": tdColor,
              "--n-td-color-modal": tdColorModal,
              "--n-td-color-popover": tdColorPopover,
              "--n-td-text-color": tdTextColor,
              "--n-border-color": borderColor,
              "--n-border-color-modal": borderColorModal,
              "--n-border-color-popover": borderColorPopover,
              "--n-border-radius": borderRadius,
              "--n-font-size": fontSize2,
              "--n-th-color": thColor,
              "--n-th-color-modal": thColorModal,
              "--n-th-color-popover": thColorPopover,
              "--n-th-font-weight": thFontWeight,
              "--n-th-text-color": thTextColor,
              "--n-line-height": lineHeight2,
              "--n-td-padding": tdPadding,
              "--n-th-padding": thPadding,
              "--n-td-color-striped": tdColorStriped,
              "--n-td-color-striped-modal": tdColorStripedModal,
              "--n-td-color-striped-popover": tdColorStripedPopover
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("table", vue.computed(() => {
            return props.size[0];
          }), cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("table", { class: [
            `${mergedClsPrefix}-table`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-table--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-table--bottom-bordered`]: this.bottomBordered,
              [`${mergedClsPrefix}-table--bordered`]: this.bordered,
              [`${mergedClsPrefix}-table--single-line`]: this.singleLine,
              [`${mergedClsPrefix}-table--single-column`]: this.singleColumn,
              [`${mergedClsPrefix}-table--striped`]: this.striped
            }
          ], style: this.cssVars }, this.$slots);
        }
      });
      const Th = vue.defineComponent({
        name: "Th",
        render() {
          return vue.h("th", null, this.$slots);
        }
      });
      const Tr = vue.defineComponent({
        name: "Tr",
        render() {
          return vue.h("tr", null, this.$slots);
        }
      });
      const Td = vue.defineComponent({
        name: "Td",
        render() {
          return vue.h("td", null, this.$slots);
        }
      });
      const Thead = vue.defineComponent({
        name: "Thead",
        render() {
          return vue.h("thead", null, this.$slots);
        }
      });
      const Tbody = vue.defineComponent({
        name: "Tbody",
        render() {
          return vue.h("tbody", null, this.$slots);
        }
      });
      const tabsInjectionKey = createInjectionKey("n-tabs");
      const tabPaneProps = {
        tab: [String, Number, Object, Function],
        name: {
          type: [String, Number],
          required: true
        },
        disabled: Boolean,
        displayDirective: {
          type: String,
          default: "if"
        },
        closable: {
          type: Boolean,
          default: void 0
        },
        tabProps: Object,
        /** @deprecated */
        label: [String, Number, Object, Function]
      };
      const TabPane = vue.defineComponent({
        __TAB_PANE__: true,
        name: "TabPane",
        alias: ["TabPanel"],
        props: tabPaneProps,
        setup(props) {
          const NTab = vue.inject(tabsInjectionKey, null);
          if (!NTab) {
            throwError("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`.");
          }
          return {
            style: NTab.paneStyleRef,
            class: NTab.paneClassRef,
            mergedClsPrefix: NTab.mergedClsPrefixRef
          };
        },
        render() {
          return vue.h("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
        }
      });
      const tabProps = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, omit(tabPaneProps, ["displayDirective"]));
      const Tab = vue.defineComponent({
        __TAB__: true,
        inheritAttrs: false,
        name: "Tab",
        props: tabProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            valueRef,
            typeRef,
            closableRef,
            tabStyleRef,
            tabChangeIdRef,
            onBeforeLeaveRef,
            triggerRef,
            handleAdd,
            activateTab,
            handleClose
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(tabsInjectionKey);
          return {
            trigger: triggerRef,
            mergedClosable: vue.computed(() => {
              if (props.internalAddable)
                return false;
              const { closable } = props;
              if (closable === void 0)
                return closableRef.value;
              return closable;
            }),
            style: tabStyleRef,
            clsPrefix: mergedClsPrefixRef,
            value: valueRef,
            type: typeRef,
            handleClose(e) {
              e.stopPropagation();
              if (props.disabled)
                return;
              handleClose(props.name);
            },
            activateTab() {
              if (props.disabled)
                return;
              if (props.internalAddable) {
                handleAdd();
                return;
              }
              const { name: nameProp } = props;
              const id = ++tabChangeIdRef.id;
              if (nameProp !== valueRef.value) {
                const { value: onBeforeLeave } = onBeforeLeaveRef;
                if (!onBeforeLeave) {
                  activateTab(nameProp);
                } else {
                  void Promise.resolve(onBeforeLeave(props.name, valueRef.value)).then((allowLeave) => {
                    if (allowLeave && tabChangeIdRef.id === id) {
                      activateTab(nameProp);
                    }
                  });
                }
              }
            }
          };
        },
        render() {
          const { internalAddable, clsPrefix, name, disabled, label, tab, value, mergedClosable, style: style2, trigger: trigger2, $slots: { default: defaultSlot } } = this;
          const mergedTab = label !== null && label !== void 0 ? label : tab;
          return vue.h(
            "div",
            { class: `${clsPrefix}-tabs-tab-wrapper` },
            this.internalLeftPadded ? vue.h("div", { class: `${clsPrefix}-tabs-tab-pad` }) : null,
            vue.h(
              "div",
              Object.assign({ key: name, "data-name": name, "data-disabled": disabled ? true : void 0 }, vue.mergeProps({
                class: [
                  `${clsPrefix}-tabs-tab`,
                  value === name && `${clsPrefix}-tabs-tab--active`,
                  disabled && `${clsPrefix}-tabs-tab--disabled`,
                  mergedClosable && `${clsPrefix}-tabs-tab--closable`,
                  internalAddable && `${clsPrefix}-tabs-tab--addable`
                ],
                onClick: trigger2 === "click" ? this.activateTab : void 0,
                onMouseenter: trigger2 === "hover" ? this.activateTab : void 0,
                style: internalAddable ? void 0 : style2
              }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)),
              vue.h("span", { class: `${clsPrefix}-tabs-tab__label` }, internalAddable ? vue.h(
                vue.Fragment,
                null,
                vue.h("div", { class: `${clsPrefix}-tabs-tab__height-placeholder` }, ""),
                vue.h(NBaseIcon, { clsPrefix }, {
                  default: () => vue.h(AddIcon, null)
                })
              ) : defaultSlot ? defaultSlot() : typeof mergedTab === "object" ? mergedTab : render$1(mergedTab !== null && mergedTab !== void 0 ? mergedTab : name)),
              mergedClosable && this.type === "card" ? vue.h(NBaseClose, { clsPrefix, class: `${clsPrefix}-tabs-tab__close`, onClick: this.handleClose, disabled }) : null
            )
          );
        }
      });
      const style$e = cB("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [cM("segment-type", [cB("tabs-rail", [c$1("&.transition-disabled", "color: red;", [cB("tabs-tab", `
 transition: none;
 `)])])]), cM("top", [cB("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), cM("left", [cB("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), cM("left, right", `
 flex-direction: row;
 `, [cB("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), cM("right", `
 flex-direction: row-reverse;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), cB("tabs-bar", `
 left: 0;
 `)]), cM("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), cB("tabs-bar", `
 top: 0;
 `)]), cB("tabs-rail", `
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cM("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 `), c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), cM("flex", [cB("tabs-nav", {
        width: "100%"
      }, [cB("tabs-wrapper", {
        width: "100%"
      }, [cB("tabs-tab", {
        marginRight: 0
      })])])]), cB("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [cE("prefix, suffix", `
 display: flex;
 align-items: center;
 `), cE("prefix", "padding-right: 16px;"), cE("suffix", "padding-left: 16px;")]), cM("top, bottom", [cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), c$1("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cM("left, right", [cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), c$1("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cB("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [cB("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), c$1("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), cB("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), cB("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), cB("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), cB("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("disabled", {
        cursor: "not-allowed"
      }), cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 display: flex;
 align-items: center;
 `)]), cB("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&.transition-disabled", `
 transition: none;
 `), cM("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), cB("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), cB("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [c$1("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), c$1("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), c$1("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), cB("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), cM("line-type, bar-type", [cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [c$1("&:hover", {
        color: "var(--n-tab-text-color-hover)"
      }), cM("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), cM("disabled", {
        color: "var(--n-tab-text-color-disabled)"
      })])]), cB("tabs-nav", [cM("line-type", [cM("top", [cE("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 bottom: -1px;
 `)]), cM("left", [cE("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 right: -1px;
 `)]), cM("right", [cE("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 left: -1px;
 `)]), cM("bottom", [cE("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 top: -1px;
 `)]), cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-bar", `
 border-radius: 0;
 `)]), cM("card-type", [cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [cM("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 `, [cE("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), cM("closable", "padding-right: 8px;"), cM("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), cM("disabled", "color: var(--n-tab-text-color-disabled);")]), cB("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);")]), cM("left, right", [cB("tabs-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])])]), cM("top", [cM("card-type", [cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-bottom: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), cM("left", [cM("card-type", [cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-right: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), cM("right", [cM("card-type", [cB("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-left: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), cM("bottom", [cM("card-type", [cB("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-top: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]);
      const tabsProps = Object.assign(Object.assign({}, useTheme.props), {
        value: [String, Number],
        defaultValue: [String, Number],
        trigger: {
          type: String,
          default: "click"
        },
        type: {
          type: String,
          default: "bar"
        },
        closable: Boolean,
        justifyContent: String,
        size: {
          type: String,
          default: "medium"
        },
        placement: {
          type: String,
          default: "top"
        },
        tabStyle: [String, Object],
        barWidth: Number,
        paneClass: String,
        paneStyle: [String, Object],
        paneWrapperClass: String,
        paneWrapperStyle: [String, Object],
        addable: [Boolean, Object],
        tabsPadding: {
          type: Number,
          default: 0
        },
        animated: Boolean,
        onBeforeLeave: Function,
        onAdd: Function,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onClose: [Function, Array],
        // deprecated
        labelSize: String,
        activeName: [String, Number],
        onActiveNameChange: [Function, Array]
      });
      const Tabs = vue.defineComponent({
        name: "Tabs",
        props: tabsProps,
        setup(props, { slots }) {
          var _a, _b, _c, _d;
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Tabs", "-tabs", style$e, tabsLight$1, props, mergedClsPrefixRef);
          const tabsElRef = vue.ref(null);
          const barElRef = vue.ref(null);
          const scrollWrapperElRef = vue.ref(null);
          const addTabInstRef = vue.ref(null);
          const xScrollInstRef = vue.ref(null);
          const startReachedRef = vue.ref(true);
          const endReachedRef = vue.ref(true);
          const compitableSizeRef = useCompitable(props, ["labelSize", "size"]);
          const compitableValueRef = useCompitable(props, ["activeName", "value"]);
          const uncontrolledValueRef = vue.ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten$3(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);
          const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);
          const tabChangeIdRef = { id: 0 };
          const tabWrapperStyleRef = vue.computed(() => {
            if (!props.justifyContent || props.type === "card")
              return void 0;
            return {
              display: "flex",
              justifyContent: props.justifyContent
            };
          });
          vue.watch(mergedValueRef, () => {
            tabChangeIdRef.id = 0;
            updateCurrentBarStyle();
            updateCurrentScrollPosition();
          });
          function getCurrentEl() {
            var _a2;
            const { value } = mergedValueRef;
            if (value === null)
              return null;
            const tabEl = (_a2 = tabsElRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`[data-name="${value}"]`);
            return tabEl;
          }
          function updateBarStyle(tabEl) {
            if (props.type === "card")
              return;
            const { value: barEl } = barElRef;
            if (!barEl)
              return;
            if (tabEl) {
              const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
              const { barWidth, placement } = props;
              if (tabEl.dataset.disabled === "true") {
                barEl.classList.add(disabledClassName);
              } else {
                barEl.classList.remove(disabledClassName);
              }
              if (["top", "bottom"].includes(placement)) {
                clearBarStyle(["top", "maxHeight", "height"]);
                if (typeof barWidth === "number" && tabEl.offsetWidth >= barWidth) {
                  const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
                  barEl.style.left = `${offsetDiffLeft}px`;
                  barEl.style.maxWidth = `${barWidth}px`;
                } else {
                  barEl.style.left = `${tabEl.offsetLeft}px`;
                  barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
                }
                barEl.style.width = "8192px";
                void barEl.offsetWidth;
              } else {
                clearBarStyle(["left", "maxWidth", "width"]);
                if (typeof barWidth === "number" && tabEl.offsetHeight >= barWidth) {
                  const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;
                  barEl.style.top = `${offsetDiffTop}px`;
                  barEl.style.maxHeight = `${barWidth}px`;
                } else {
                  barEl.style.top = `${tabEl.offsetTop}px`;
                  barEl.style.maxHeight = `${tabEl.offsetHeight}px`;
                }
                barEl.style.height = "8192px";
                void barEl.offsetHeight;
              }
            }
          }
          function clearBarStyle(styleProps) {
            const { value: barEl } = barElRef;
            if (!barEl)
              return;
            for (const prop of styleProps) {
              barEl.style[prop] = "";
            }
          }
          function updateCurrentBarStyle() {
            if (props.type === "card")
              return;
            const tabEl = getCurrentEl();
            if (tabEl) {
              updateBarStyle(tabEl);
            }
          }
          function updateCurrentScrollPosition(smooth) {
            var _a2;
            const scrollWrapperEl = (_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el;
            if (!scrollWrapperEl)
              return;
            const tabEl = getCurrentEl();
            if (!tabEl)
              return;
            const { scrollLeft: scrollWrapperElScrollLeft, offsetWidth: scrollWrapperElOffsetWidth } = scrollWrapperEl;
            const { offsetLeft: tabElOffsetLeft, offsetWidth: tabElOffsetWidth } = tabEl;
            if (scrollWrapperElScrollLeft > tabElOffsetLeft) {
              scrollWrapperEl.scrollTo({
                top: 0,
                left: tabElOffsetLeft,
                behavior: "smooth"
              });
            } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {
              scrollWrapperEl.scrollTo({
                top: 0,
                left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,
                behavior: "smooth"
              });
            }
          }
          const tabsPaneWrapperRef = vue.ref(null);
          let fromHeight = 0;
          let hangingTransition = null;
          function onAnimationBeforeLeave(el) {
            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
            if (tabsPaneWrapperEl) {
              fromHeight = el.getBoundingClientRect().height;
              const fromHeightPx = `${fromHeight}px`;
              const applyFromStyle = () => {
                tabsPaneWrapperEl.style.height = fromHeightPx;
                tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
              };
              if (!hangingTransition) {
                hangingTransition = applyFromStyle;
              } else {
                applyFromStyle();
                hangingTransition();
                hangingTransition = null;
              }
            }
          }
          function onAnimationEnter(el) {
            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
            if (tabsPaneWrapperEl) {
              const targetHeight = el.getBoundingClientRect().height;
              const applyTargetStyle = () => {
                void document.body.offsetHeight;
                tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
                tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;
              };
              if (!hangingTransition) {
                hangingTransition = applyTargetStyle;
              } else {
                hangingTransition();
                hangingTransition = null;
                applyTargetStyle();
              }
            }
          }
          function onAnimationAfterEnter() {
            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
            if (tabsPaneWrapperEl) {
              tabsPaneWrapperEl.style.maxHeight = "";
              tabsPaneWrapperEl.style.height = "";
            }
          }
          const renderNameListRef = { value: [] };
          const animationDirectionRef = vue.ref("next");
          function activateTab(panelName) {
            const currentValue = mergedValueRef.value;
            let dir = "next";
            for (const name of renderNameListRef.value) {
              if (name === currentValue) {
                break;
              }
              if (name === panelName) {
                dir = "prev";
                break;
              }
            }
            animationDirectionRef.value = dir;
            doUpdateValue(panelName);
          }
          function doUpdateValue(panelName) {
            const { onActiveNameChange, onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
            if (onActiveNameChange) {
              call(onActiveNameChange, panelName);
            }
            if (onUpdateValue)
              call(onUpdateValue, panelName);
            if (_onUpdateValue)
              call(_onUpdateValue, panelName);
            uncontrolledValueRef.value = panelName;
          }
          function handleClose(panelName) {
            const { onClose } = props;
            if (onClose)
              call(onClose, panelName);
          }
          function updateBarPositionInstantly() {
            const { value: barEl } = barElRef;
            if (!barEl)
              return;
            const disableTransitionClassName = "transition-disabled";
            barEl.classList.add(disableTransitionClassName);
            updateCurrentBarStyle();
            barEl.classList.remove(disableTransitionClassName);
          }
          let memorizedWidth = 0;
          function _handleNavResize(entry) {
            var _b2;
            if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
              return;
            }
            if (memorizedWidth === entry.contentRect.width) {
              return;
            }
            memorizedWidth = entry.contentRect.width;
            const { type: type2 } = props;
            if (type2 === "line" || type2 === "bar") {
              {
                updateBarPositionInstantly();
              }
            }
            if (type2 !== "segment") {
              deriveScrollShadow((_b2 = xScrollInstRef.value) === null || _b2 === void 0 ? void 0 : _b2.$el);
            }
          }
          const handleNavResize = throttle(_handleNavResize, 64);
          vue.watch([() => props.justifyContent, () => props.size], () => {
            void vue.nextTick(() => {
              const { type: type2 } = props;
              if (type2 === "line" || type2 === "bar") {
                updateBarPositionInstantly();
              }
            });
          });
          const addTabFixedRef = vue.ref(false);
          function _handleTabsResize(entry) {
            var _a2;
            const { target, contentRect: { width } } = entry;
            const containerWidth = target.parentElement.offsetWidth;
            if (!addTabFixedRef.value) {
              if (containerWidth < width) {
                addTabFixedRef.value = true;
              }
            } else {
              const { value: addTabInst } = addTabInstRef;
              if (!addTabInst)
                return;
              if (containerWidth - width > addTabInst.$el.offsetWidth) {
                addTabFixedRef.value = false;
              }
            }
            deriveScrollShadow((_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el);
          }
          const handleTabsResize = throttle(_handleTabsResize, 64);
          function handleAdd() {
            const { onAdd } = props;
            if (onAdd)
              onAdd();
            void vue.nextTick(() => {
              const currentEl = getCurrentEl();
              const { value: xScrollInst } = xScrollInstRef;
              if (!currentEl || !xScrollInst)
                return;
              xScrollInst.scrollTo({
                left: currentEl.offsetLeft,
                top: 0,
                behavior: "smooth"
              });
            });
          }
          function deriveScrollShadow(el) {
            if (!el)
              return;
            const { placement } = props;
            if (placement === "top" || placement === "bottom") {
              const { scrollLeft, scrollWidth, offsetWidth } = el;
              startReachedRef.value = scrollLeft <= 0;
              endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
            } else {
              const { scrollTop, scrollHeight, offsetHeight } = el;
              startReachedRef.value = scrollTop <= 0;
              endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;
            }
          }
          const handleScroll = throttle((e) => {
            deriveScrollShadow(e.target);
          }, 64);
          vue.provide(tabsInjectionKey, {
            triggerRef: vue.toRef(props, "trigger"),
            tabStyleRef: vue.toRef(props, "tabStyle"),
            paneClassRef: vue.toRef(props, "paneClass"),
            paneStyleRef: vue.toRef(props, "paneStyle"),
            mergedClsPrefixRef,
            typeRef: vue.toRef(props, "type"),
            closableRef: vue.toRef(props, "closable"),
            valueRef: mergedValueRef,
            tabChangeIdRef,
            onBeforeLeaveRef: vue.toRef(props, "onBeforeLeave"),
            activateTab,
            handleClose,
            handleAdd
          });
          onFontsReady(() => {
            updateCurrentBarStyle();
            updateCurrentScrollPosition();
          });
          vue.watchEffect(() => {
            const { value: el } = scrollWrapperElRef;
            if (!el)
              return;
            const { value: clsPrefix } = mergedClsPrefixRef;
            const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;
            const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;
            if (startReachedRef.value) {
              el.classList.remove(shadowStartClass);
            } else {
              el.classList.add(shadowStartClass);
            }
            if (endReachedRef.value) {
              el.classList.remove(shadowEndClass);
            } else {
              el.classList.add(shadowEndClass);
            }
          });
          const tabsRailElRef = vue.ref(null);
          vue.watch(mergedValueRef, () => {
            if (props.type === "segment") {
              const tabsRailEl = tabsRailElRef.value;
              if (tabsRailEl) {
                void vue.nextTick(() => {
                  tabsRailEl.classList.add("transition-disabled");
                  void tabsRailEl.offsetWidth;
                  tabsRailEl.classList.remove("transition-disabled");
                });
              }
            }
          });
          const exposedMethods = {
            syncBarPosition: () => {
              updateCurrentBarStyle();
            }
          };
          const cssVarsRef = vue.computed(() => {
            const { value: size2 } = compitableSizeRef;
            const { type: type2 } = props;
            const typeSuffix = {
              card: "Card",
              bar: "Bar",
              line: "Line",
              segment: "Segment"
            }[type2];
            const sizeType = `${size2}${typeSuffix}`;
            const { self: { barColor, closeIconColor, closeIconColorHover, closeIconColorPressed, tabColor, tabBorderColor, paneTextColor, tabFontWeight, tabBorderRadius, tabFontWeightActive, colorSegment, fontWeightStrong, tabColorSegment, closeSize, closeIconSize, closeColorHover, closeColorPressed, closeBorderRadius, [createKey("panePadding", size2)]: panePadding, [createKey("tabPadding", sizeType)]: tabPadding, [createKey("tabPaddingVertical", sizeType)]: tabPaddingVertical, [createKey("tabGap", sizeType)]: tabGap, [createKey("tabGap", `${sizeType}Vertical`)]: tabGapVertical, [createKey("tabTextColor", type2)]: tabTextColor, [createKey("tabTextColorActive", type2)]: tabTextColorActive, [createKey("tabTextColorHover", type2)]: tabTextColorHover, [createKey("tabTextColorDisabled", type2)]: tabTextColorDisabled, [createKey("tabFontSize", size2)]: tabFontSize }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color-segment": colorSegment,
              "--n-bar-color": barColor,
              "--n-tab-font-size": tabFontSize,
              "--n-tab-text-color": tabTextColor,
              "--n-tab-text-color-active": tabTextColorActive,
              "--n-tab-text-color-disabled": tabTextColorDisabled,
              "--n-tab-text-color-hover": tabTextColorHover,
              "--n-pane-text-color": paneTextColor,
              "--n-tab-border-color": tabBorderColor,
              "--n-tab-border-radius": tabBorderRadius,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-tab-color": tabColor,
              "--n-tab-font-weight": tabFontWeight,
              "--n-tab-font-weight-active": tabFontWeightActive,
              "--n-tab-padding": tabPadding,
              "--n-tab-padding-vertical": tabPaddingVertical,
              "--n-tab-gap": tabGap,
              "--n-tab-gap-vertical": tabGapVertical,
              "--n-pane-padding-left": getMargin(panePadding, "left"),
              "--n-pane-padding-right": getMargin(panePadding, "right"),
              "--n-pane-padding-top": getMargin(panePadding, "top"),
              "--n-pane-padding-bottom": getMargin(panePadding, "bottom"),
              "--n-font-weight-strong": fontWeightStrong,
              "--n-tab-color-segment": tabColorSegment
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("tabs", vue.computed(() => {
            return `${compitableSizeRef.value[0]}${props.type[0]}`;
          }), cssVarsRef, props) : void 0;
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            renderedNames: /* @__PURE__ */ new Set(),
            tabsRailElRef,
            tabsPaneWrapperRef,
            tabsElRef,
            barElRef,
            addTabInstRef,
            xScrollInstRef,
            scrollWrapperElRef,
            addTabFixed: addTabFixedRef,
            tabWrapperStyle: tabWrapperStyleRef,
            handleNavResize,
            mergedSize: compitableSizeRef,
            handleScroll,
            handleTabsResize,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            animationDirection: animationDirectionRef,
            renderNameListRef,
            onAnimationBeforeLeave,
            onAnimationEnter,
            onAnimationAfterEnter,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedMethods);
        },
        render() {
          const { mergedClsPrefix, type: type2, placement, addTabFixed, addable, mergedSize, renderNameListRef, onRender, paneWrapperClass, paneWrapperStyle, $slots: { default: defaultSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const tabPaneChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
            return v.type.__TAB_PANE__ === true;
          }) : [];
          const tabChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
            return v.type.__TAB__ === true;
          }) : [];
          const showPane = !tabChildren.length;
          const isCard = type2 === "card";
          const isSegment = type2 === "segment";
          const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
          renderNameListRef.value = [];
          const scrollContent = () => {
            const tabs = vue.h(
              "div",
              { style: this.tabWrapperStyle, class: [`${mergedClsPrefix}-tabs-wrapper`] },
              mergedJustifyContent ? null : vue.h("div", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }),
              showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
                renderNameListRef.value.push(tabPaneVNode.props.name);
                return justifyTabDynamicProps(vue.h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === "center" || mergedJustifyContent === "start" || mergedJustifyContent === "end") }), tabPaneVNode.children ? {
                  default: tabPaneVNode.children.tab
                } : void 0));
              }) : tabChildren.map((tabVNode, index) => {
                renderNameListRef.value.push(tabVNode.props.name);
                if (index !== 0 && !mergedJustifyContent) {
                  return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));
                } else {
                  return justifyTabDynamicProps(tabVNode);
                }
              }),
              !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null,
              mergedJustifyContent ? null : vue.h("div", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } })
            );
            return vue.h(
              "div",
              { ref: "tabsElRef", class: `${mergedClsPrefix}-tabs-nav-scroll-content` },
              isCard && addable ? vue.h(VResizeObserver, { onResize: this.handleTabsResize }, {
                default: () => tabs
              }) : tabs,
              isCard ? vue.h("div", { class: `${mergedClsPrefix}-tabs-pad` }) : null,
              isCard ? null : vue.h("div", { ref: "barElRef", class: `${mergedClsPrefix}-tabs-bar` })
            );
          };
          const resolvedPlacement = isSegment ? "top" : placement;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-tabs`,
              this.themeClass,
              `${mergedClsPrefix}-tabs--${type2}-type`,
              `${mergedClsPrefix}-tabs--${mergedSize}-size`,
              mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`,
              `${mergedClsPrefix}-tabs--${resolvedPlacement}`
            ], style: this.cssVars },
            vue.h(
              "div",
              { class: [
                // the class should be applied here since it's possible
                // to make tabs nested in tabs, style may influence each
                // other. adding a class will make it easy to write the
                // style.
                `${mergedClsPrefix}-tabs-nav--${type2}-type`,
                `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`,
                `${mergedClsPrefix}-tabs-nav`
              ] },
              resolveWrappedSlot(prefixSlot, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-tabs-nav__prefix` }, children)),
              isSegment ? vue.h("div", { class: `${mergedClsPrefix}-tabs-rail`, ref: "tabsRailElRef" }, showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
                renderNameListRef.value.push(tabPaneVNode.props.name);
                return vue.h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 }), tabPaneVNode.children ? {
                  default: tabPaneVNode.children.tab
                } : void 0);
              }) : tabChildren.map((tabVNode, index) => {
                renderNameListRef.value.push(tabVNode.props.name);
                if (index === 0) {
                  return tabVNode;
                } else {
                  return createLeftPaddedTabVNode(tabVNode);
                }
              })) : vue.h(VResizeObserver, { onResize: this.handleNavResize }, {
                default: () => vue.h("div", { class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(resolvedPlacement) ? vue.h(VXScroll, { ref: "xScrollInstRef", onScroll: this.handleScroll }, {
                  default: scrollContent
                }) : vue.h("div", { class: `${mergedClsPrefix}-tabs-nav-y-scroll`, onScroll: this.handleScroll }, scrollContent()))
              }),
              addTabFixed && addable && isCard ? createAddTag(addable, true) : null,
              resolveWrappedSlot(suffixSlot, (children) => children && vue.h("div", { class: `${mergedClsPrefix}-tabs-nav__suffix` }, children))
            ),
            showPane && (this.animated && (resolvedPlacement === "top" || resolvedPlacement === "bottom") ? vue.h("div", { ref: "tabsPaneWrapperRef", style: paneWrapperStyle, class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass] }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames))
          );
        }
      });
      function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
        const children = [];
        tabPaneVNodes.forEach((vNode) => {
          const { name, displayDirective, "display-directive": _displayDirective } = vNode.props;
          const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
          const show = value === name;
          if (vNode.key !== void 0) {
            vNode.key = name;
          }
          if (show || matchDisplayDirective("show") || matchDisplayDirective("show:lazy") && renderedNames.has(name)) {
            if (!renderedNames.has(name)) {
              renderedNames.add(name);
            }
            const useVShow = !matchDisplayDirective("if");
            children.push(useVShow ? vue.withDirectives(vNode, [[vue.vShow, show]]) : vNode);
          }
        });
        if (!animationDirection) {
          return children;
        }
        return vue.h(vue.TransitionGroup, { name: `${animationDirection}-transition`, onBeforeLeave, onEnter, onAfterEnter }, { default: () => children });
      }
      function createAddTag(addable, internalLeftPadded) {
        return vue.h(Tab, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded, disabled: typeof addable === "object" && addable.disabled });
      }
      function createLeftPaddedTabVNode(tabVNode) {
        const modifiedVNode = vue.cloneVNode(tabVNode);
        if (modifiedVNode.props) {
          modifiedVNode.props.internalLeftPadded = true;
        } else {
          modifiedVNode.props = {
            internalLeftPadded: true
          };
        }
        return modifiedVNode;
      }
      function justifyTabDynamicProps(tabVNode) {
        if (Array.isArray(tabVNode.dynamicProps)) {
          if (!tabVNode.dynamicProps.includes("internalLeftPadded")) {
            tabVNode.dynamicProps.push("internalLeftPadded");
          }
        } else {
          tabVNode.dynamicProps = ["internalLeftPadded"];
        }
        return tabVNode;
      }
      const style$d = cB("thing", `
 display: flex;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
`, [cB("thing-avatar", `
 margin-right: 12px;
 margin-top: 2px;
 `), cB("thing-avatar-header-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 `, [cB("thing-header-wrapper", `
 flex: 1;
 `)]), cB("thing-main", `
 flex-grow: 1;
 `, [cB("thing-header", `
 display: flex;
 margin-bottom: 4px;
 justify-content: space-between;
 align-items: center;
 `, [cE("title", `
 font-size: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-title-text-color);
 `)]), cE("description", [c$1("&:not(:last-child)", `
 margin-bottom: 4px;
 `)]), cE("content", [c$1("&:not(:first-child)", `
 margin-top: 12px;
 `)]), cE("footer", [c$1("&:not(:first-child)", `
 margin-top: 12px;
 `)]), cE("action", [c$1("&:not(:first-child)", `
 margin-top: 12px;
 `)])])]);
      const thingProps = Object.assign(Object.assign({}, useTheme.props), { title: String, titleExtra: String, description: String, descriptionStyle: [String, Object], content: String, contentStyle: [String, Object], contentIndented: Boolean });
      const Thing = vue.defineComponent({
        name: "Thing",
        props: thingProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme("Thing", "-thing", style$d, thingLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Thing", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { self: { titleTextColor, textColor, titleFontWeight, fontSize: fontSize2 }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-text-color": textColor,
              "--n-title-font-weight": titleFontWeight,
              "--n-title-text-color": titleTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("thing", void 0, cssVarsRef, props) : void 0;
          return () => {
            var _a;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            const rtlEnabled = rtlEnabledRef ? rtlEnabledRef.value : false;
            (_a = themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender) === null || _a === void 0 ? void 0 : _a.call(themeClassHandle);
            return vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-thing`,
                themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
                rtlEnabled && `${mergedClsPrefix}-thing--rtl`
              ], style: inlineThemeDisabled ? void 0 : cssVarsRef.value },
              slots.avatar && props.contentIndented ? vue.h("div", { class: `${mergedClsPrefix}-thing-avatar` }, slots.avatar()) : null,
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-thing-main` },
                !props.contentIndented && (slots.header || props.title || slots["header-extra"] || props.titleExtra || slots.avatar) ? vue.h(
                  "div",
                  { class: `${mergedClsPrefix}-thing-avatar-header-wrapper` },
                  slots.avatar ? vue.h("div", { class: `${mergedClsPrefix}-thing-avatar` }, slots.avatar()) : null,
                  slots.header || props.title || slots["header-extra"] || props.titleExtra ? vue.h(
                    "div",
                    { class: `${mergedClsPrefix}-thing-header-wrapper` },
                    vue.h(
                      "div",
                      { class: `${mergedClsPrefix}-thing-header` },
                      slots.header || props.title ? vue.h("div", { class: `${mergedClsPrefix}-thing-header__title` }, slots.header ? slots.header() : props.title) : null,
                      slots["header-extra"] || props.titleExtra ? vue.h("div", { class: `${mergedClsPrefix}-thing-header__extra` }, slots["header-extra"] ? slots["header-extra"]() : props.titleExtra) : null
                    ),
                    slots.description || props.description ? vue.h("div", { class: `${mergedClsPrefix}-thing-main__description`, style: props.descriptionStyle }, slots.description ? slots.description() : props.description) : null
                  ) : null
                ) : vue.h(
                  vue.Fragment,
                  null,
                  slots.header || props.title || slots["header-extra"] || props.titleExtra ? vue.h(
                    "div",
                    { class: `${mergedClsPrefix}-thing-header` },
                    slots.header || props.title ? vue.h("div", { class: `${mergedClsPrefix}-thing-header__title` }, slots.header ? slots.header() : props.title) : null,
                    slots["header-extra"] || props.titleExtra ? vue.h("div", { class: `${mergedClsPrefix}-thing-header__extra` }, slots["header-extra"] ? slots["header-extra"]() : props.titleExtra) : null
                  ) : null,
                  slots.description || props.description ? vue.h("div", { class: `${mergedClsPrefix}-thing-main__description`, style: props.descriptionStyle }, slots.description ? slots.description() : props.description) : null
                ),
                slots.default || props.content ? vue.h("div", { class: `${mergedClsPrefix}-thing-main__content`, style: props.contentStyle }, slots.default ? slots.default() : props.content) : null,
                slots.footer ? vue.h("div", { class: `${mergedClsPrefix}-thing-main__footer` }, slots.footer()) : null,
                slots.action ? vue.h("div", { class: `${mergedClsPrefix}-thing-main__action` }, slots.action()) : null
              )
            );
          };
        }
      });
      const timeProps = {
        time: {
          type: [Number, Date],
          default: void 0
          // For unix or non unix mode, it should be different default value
        },
        type: {
          type: String,
          default: "datetime"
        },
        to: {
          type: [Number, Date],
          default: void 0
          // the same as `time` prop
        },
        unix: Boolean,
        format: String,
        text: Boolean,
        timeZone: String
      };
      const Time = vue.defineComponent({
        name: "Time",
        props: timeProps,
        setup(props) {
          const now2 = Date.now();
          const { localeRef, dateLocaleRef } = useLocale("Time");
          const mergedFormatRef = vue.computed(() => {
            const { timeZone } = props;
            if (timeZone) {
              return (time2, _format, options) => {
                return formatInTimeZone(time2, timeZone, _format, options);
              };
            }
            return format$4;
          });
          const dateFnsOptionsRef = vue.computed(() => {
            return {
              locale: dateLocaleRef.value.locale
            };
          });
          const mergedTimeRef = vue.computed(() => {
            const { time: time2 } = props;
            if (props.unix) {
              if (time2 === void 0)
                return now2;
              return fromUnixTime(typeof time2 === "number" ? time2 : time2.valueOf());
            }
            return time2 !== null && time2 !== void 0 ? time2 : now2;
          });
          const mergedToRef = vue.computed(() => {
            const { to } = props;
            if (props.unix) {
              if (to === void 0)
                return now2;
              return fromUnixTime(typeof to === "number" ? to : to.valueOf());
            }
            return to !== null && to !== void 0 ? to : now2;
          });
          const renderedTimeRef = vue.computed(() => {
            if (props.format) {
              return mergedFormatRef.value(mergedTimeRef.value, props.format, dateFnsOptionsRef.value);
            } else if (props.type === "date") {
              return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateFormat, dateFnsOptionsRef.value);
            } else if (props.type === "datetime") {
              return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateTimeFormat, dateFnsOptionsRef.value);
            } else {
              return formatDistanceStrict(mergedTimeRef.value, mergedToRef.value, {
                addSuffix: true,
                locale: dateLocaleRef.value.locale
              });
            }
          });
          return {
            renderedTime: renderedTimeRef
          };
        },
        render() {
          return this.text ? vue.createTextVNode(this.renderedTime) : vue.h("time", [this.renderedTime]);
        }
      });
      const lineHeight = 1.25;
      const style$c = cB("timeline", `
 position: relative;
 width: 100%;
 display: flex;
 flex-direction: column;
 line-height: ${lineHeight};
`, [cM("horizontal", `
 flex-direction: row;
 `, [c$1(">", [cB("timeline-item", `
 flex-shrink: 0;
 padding-right: 40px;
 `, [cM("dashed-line-type", [c$1(">", [cB("timeline-item-timeline", [cE("line", `
 background-image: linear-gradient(90deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 10px 1px;
 `)])])]), c$1(">", [cB("timeline-item-content", `
 margin-top: calc(var(--n-icon-size) + 12px);
 `, [c$1(">", [cE("meta", `
 margin-top: 6px;
 margin-bottom: unset;
 `)])]), cB("timeline-item-timeline", `
 width: 100%;
 height: calc(var(--n-icon-size) + 12px);
 `, [cE("line", `
 left: var(--n-icon-size);
 top: calc(var(--n-icon-size) / 2 - 1px);
 right: 0px;
 width: unset;
 height: 2px;
 `)])])])])]), cM("right-placement", [cB("timeline-item", [cB("timeline-item-content", `
 text-align: right;
 margin-right: calc(var(--n-icon-size) + 12px);
 `), cB("timeline-item-timeline", `
 width: var(--n-icon-size);
 right: 0;
 `)])]), cM("left-placement", [cB("timeline-item", [cB("timeline-item-content", `
 margin-left: calc(var(--n-icon-size) + 12px);
 `), cB("timeline-item-timeline", `
 left: 0;
 `)])]), cB("timeline-item", `
 position: relative;
 `, [c$1("&:last-child", [cB("timeline-item-timeline", [cE("line", `
 display: none;
 `)]), cB("timeline-item-content", [cE("meta", `
 margin-bottom: 0;
 `)])]), cB("timeline-item-content", [cE("title", `
 margin: var(--n-title-margin);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE("content", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-content-font-size);
 color: var(--n-content-text-color);
 `), cE("meta", `
 transition: color .3s var(--n-bezier);
 font-size: 12px;
 margin-top: 6px;
 margin-bottom: 20px;
 color: var(--n-meta-text-color);
 `)]), cM("dashed-line-type", [cB("timeline-item-timeline", [cE("line", `
 --n-color-start: var(--n-line-color);
 transition: --n-color-start .3s var(--n-bezier);
 background-color: transparent;
 background-image: linear-gradient(180deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 1px 10px;
 `)])]), cB("timeline-item-timeline", `
 width: calc(var(--n-icon-size) + 12px);
 position: absolute;
 top: calc(var(--n-title-font-size) * ${lineHeight} / 2 - var(--n-icon-size) / 2);
 height: 100%;
 `, [cE("circle", `
 border: var(--n-circle-border);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 border-radius: var(--n-icon-size);
 box-sizing: border-box;
 `), cE("icon", `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cE("line", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 top: var(--n-icon-size);
 left: calc(var(--n-icon-size) / 2 - 1px);
 bottom: 0px;
 width: 2px;
 background-color: var(--n-line-color);
 `)])])]);
      const timelineProps = Object.assign(Object.assign({}, useTheme.props), { horizontal: Boolean, itemPlacement: {
        type: String,
        default: "left"
      }, size: {
        type: String,
        default: "medium"
      }, iconSize: Number });
      const timelineInjectionKey = createInjectionKey("n-timeline");
      const Timeline = vue.defineComponent({
        name: "Timeline",
        props: timelineProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("Timeline", "-timeline", style$c, timelineLight$1, props, mergedClsPrefixRef);
          vue.provide(timelineInjectionKey, {
            props,
            mergedThemeRef: themeRef,
            mergedClsPrefixRef
          });
          return () => {
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            return vue.h("div", { class: [
              `${mergedClsPrefix}-timeline`,
              props.horizontal && `${mergedClsPrefix}-timeline--horizontal`,
              `${mergedClsPrefix}-timeline--${props.size}-size`,
              !props.horizontal && `${mergedClsPrefix}-timeline--${props.itemPlacement}-placement`
            ] }, slots);
          };
        }
      });
      const timelineItemProps = {
        time: [String, Number],
        title: String,
        content: String,
        color: String,
        lineType: {
          type: String,
          default: "default"
        },
        type: {
          type: String,
          default: "default"
        }
      };
      const TimelineItem = vue.defineComponent({
        name: "TimelineItem",
        props: timelineItemProps,
        setup(props) {
          const NTimeline = vue.inject(timelineInjectionKey);
          if (!NTimeline) {
            throwError("timeline-item", "`n-timeline-item` must be placed inside `n-timeline`.");
          }
          useHoudini();
          const { inlineThemeDisabled } = useConfig();
          const cssVarsRef = vue.computed(() => {
            const { props: { size: size2, iconSize: iconSizeProp }, mergedThemeRef } = NTimeline;
            const { type: type2 } = props;
            const { self: { titleTextColor, contentTextColor, metaTextColor, lineColor, titleFontWeight, contentFontSize, [createKey("iconSize", size2)]: iconSize, [createKey("titleMargin", size2)]: titleMargin, [createKey("titleFontSize", size2)]: titleFontSize, [createKey("circleBorder", type2)]: circleBorder, [createKey("iconColor", type2)]: iconColor }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = mergedThemeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-circle-border": circleBorder,
              "--n-icon-color": iconColor,
              "--n-content-font-size": contentFontSize,
              "--n-content-text-color": contentTextColor,
              "--n-line-color": lineColor,
              "--n-meta-text-color": metaTextColor,
              "--n-title-font-size": titleFontSize,
              "--n-title-font-weight": titleFontWeight,
              "--n-title-margin": titleMargin,
              "--n-title-text-color": titleTextColor,
              "--n-icon-size": formatLength(iconSizeProp) || iconSize
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("timeline-item", vue.computed(() => {
            const { props: { size: size2, iconSize: iconSizeProp } } = NTimeline;
            const { type: type2 } = props;
            return `${size2[0]}${iconSizeProp || "a"}${type2[0]}`;
          }), cssVarsRef, NTimeline.props) : void 0;
          return {
            mergedClsPrefix: NTimeline.mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const { mergedClsPrefix, color, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-timeline-item`,
              this.themeClass,
              `${mergedClsPrefix}-timeline-item--${this.type}-type`,
              `${mergedClsPrefix}-timeline-item--${this.lineType}-line-type`
            ], style: this.cssVars },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-timeline-item-timeline` },
              vue.h("div", { class: `${mergedClsPrefix}-timeline-item-timeline__line` }),
              resolveWrappedSlot($slots.icon, (children) => {
                return children ? vue.h("div", { class: `${mergedClsPrefix}-timeline-item-timeline__icon`, style: { color } }, children) : vue.h("div", { class: `${mergedClsPrefix}-timeline-item-timeline__circle`, style: { borderColor: color } });
              })
            ),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-timeline-item-content` },
              resolveWrappedSlot($slots.header, (children) => {
                const mergedChildren = children || this.title;
                if (mergedChildren) {
                  return vue.h("div", { class: `${mergedClsPrefix}-timeline-item-content__title` }, children || this.title);
                }
                return null;
              }),
              vue.h("div", { class: `${mergedClsPrefix}-timeline-item-content__content` }, resolveSlot($slots.default, () => [this.content])),
              vue.h("div", { class: `${mergedClsPrefix}-timeline-item-content__meta` }, resolveSlot($slots.footer, () => [this.time]))
            )
          );
        }
      });
      const transferInjectionKey = createInjectionKey("n-transfer");
      const NTransferHeader = vue.defineComponent({
        name: "TransferHeader",
        props: {
          size: {
            type: String,
            required: true
          },
          source: Boolean,
          onCheckedAll: Function,
          onClearAll: Function,
          title: String
        },
        setup(props) {
          const {
            targetOptionsRef,
            canNotSelectAnythingRef,
            canBeClearedRef,
            allCheckedRef,
            mergedThemeRef,
            disabledRef,
            mergedClsPrefixRef,
            srcOptionsLengthRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(transferInjectionKey);
          const { localeRef } = useLocale("Transfer");
          return () => {
            const { source, onClearAll, onCheckedAll } = props;
            const { value: mergedTheme } = mergedThemeRef;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            const { value: locale2 } = localeRef;
            const buttonSize = props.size === "large" ? "small" : "tiny";
            const { title } = props;
            return vue.h(
              "div",
              { class: `${mergedClsPrefix}-transfer-list-header` },
              title && vue.h("div", { class: `${mergedClsPrefix}-transfer-list-header__title` }, title),
              source && vue.h(NButton, { class: `${mergedClsPrefix}-transfer-list-header__button`, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: buttonSize, tertiary: true, onClick: allCheckedRef.value ? onClearAll : onCheckedAll, disabled: canNotSelectAnythingRef.value || disabledRef.value }, {
                default: () => allCheckedRef.value ? locale2.unselectAll : locale2.selectAll
              }),
              !source && canBeClearedRef.value && vue.h(NButton, { class: `${mergedClsPrefix}-transfer-list-header__button`, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: buttonSize, tertiary: true, onClick: onClearAll, disabled: disabledRef.value }, {
                default: () => locale2.clearAll
              }),
              vue.h("div", { class: `${mergedClsPrefix}-transfer-list-header__extra` }, source ? locale2.total(srcOptionsLengthRef.value) : locale2.selected(targetOptionsRef.value.length))
            );
          };
        }
      });
      const NTransferListItem = vue.defineComponent({
        name: "NTransferListItem",
        props: {
          source: Boolean,
          label: {
            type: String,
            required: true
          },
          value: {
            type: [String, Number],
            required: true
          },
          disabled: Boolean,
          option: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const {
            targetValueSetRef,
            mergedClsPrefixRef,
            mergedThemeRef,
            handleItemCheck,
            renderSourceLabelRef,
            renderTargetLabelRef,
            showSelectedRef
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          } = vue.inject(transferInjectionKey);
          const checkedRef = useMemo(() => targetValueSetRef.value.has(props.value));
          function handleClick2() {
            if (!props.disabled) {
              handleItemCheck(!checkedRef.value, props.value);
            }
          }
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            checked: checkedRef,
            showSelected: showSelectedRef,
            renderSourceLabel: renderSourceLabelRef,
            renderTargetLabel: renderTargetLabelRef,
            handleClick: handleClick2
          };
        },
        render() {
          const { disabled, mergedTheme, mergedClsPrefix, label, checked, source, renderSourceLabel, renderTargetLabel } = this;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-transfer-list-item`,
              disabled && `${mergedClsPrefix}-transfer-list-item--disabled`,
              source ? `${mergedClsPrefix}-transfer-list-item--source` : `${mergedClsPrefix}-transfer-list-item--target`
            ], onClick: source ? this.handleClick : void 0 },
            vue.h("div", { class: `${mergedClsPrefix}-transfer-list-item__background` }),
            source && this.showSelected && vue.h(
              "div",
              { class: `${mergedClsPrefix}-transfer-list-item__checkbox` },
              vue.h(NCheckbox, { theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, disabled, checked })
            ),
            vue.h("div", { class: `${mergedClsPrefix}-transfer-list-item__label`, title: getTitleAttribute(label) }, source ? renderSourceLabel ? renderSourceLabel({
              option: this.option
            }) : label : renderTargetLabel ? renderTargetLabel({
              option: this.option
            }) : label),
            !source && !disabled && vue.h(NBaseClose, { focusable: false, class: `${mergedClsPrefix}-transfer-list-item__close`, clsPrefix: mergedClsPrefix, onClick: this.handleClick })
          );
        }
      });
      const NTransferList = vue.defineComponent({
        name: "TransferList",
        props: {
          virtualScroll: {
            type: Boolean,
            required: true
          },
          itemSize: {
            type: Number,
            required: true
          },
          options: {
            type: Array,
            required: true
          },
          disabled: {
            type: Boolean,
            required: true
          },
          source: Boolean
        },
        setup() {
          const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey);
          const scrollerInstRef = vue.ref(null);
          const vlInstRef = vue.ref(null);
          function syncVLScroller() {
            var _a;
            (_a = scrollerInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function scrollContainer() {
            const { value } = vlInstRef;
            if (!value)
              return null;
            const { listElRef } = value;
            return listElRef;
          }
          function scrollContent() {
            const { value } = vlInstRef;
            if (!value)
              return null;
            const { itemsElRef } = value;
            return itemsElRef;
          }
          return {
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            scrollerInstRef,
            vlInstRef,
            syncVLScroller,
            scrollContainer,
            scrollContent
          };
        },
        render() {
          const { mergedTheme, options } = this;
          if (options.length === 0) {
            return vue.h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty });
          }
          const { mergedClsPrefix, virtualScroll, source, disabled, syncVLScroller } = this;
          return vue.h(NScrollbar, { ref: "scrollerInstRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: virtualScroll ? this.scrollContainer : void 0, content: virtualScroll ? this.scrollContent : void 0 }, {
            default: () => virtualScroll ? vue.h(VVirtualList, { ref: "vlInstRef", style: { height: "100%" }, class: `${mergedClsPrefix}-transfer-list-content`, items: this.options, itemSize: this.itemSize, showScrollbar: false, onResize: syncVLScroller, onScroll: syncVLScroller, keyField: "value" }, {
              default: ({ item }) => {
                const { source: source2, disabled: disabled2 } = this;
                return vue.h(NTransferListItem, { source: source2, key: item.value, value: item.value, disabled: item.disabled || disabled2, label: item.label, option: item });
              }
            }) : vue.h("div", { class: `${mergedClsPrefix}-transfer-list-content` }, options.map((option) => vue.h(NTransferListItem, { source, key: option.value, value: option.value, disabled: option.disabled || disabled, label: option.label, option })))
          });
        }
      });
      const NTransferFilter = vue.defineComponent({
        name: "TransferFilter",
        props: {
          value: String,
          placeholder: String,
          disabled: Boolean,
          onUpdateValue: {
            type: Function,
            required: true
          }
        },
        setup() {
          const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey);
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef
          };
        },
        render() {
          const { mergedTheme, mergedClsPrefix } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-transfer-filter` },
            vue.h(NInput, { value: this.value, onUpdateValue: this.onUpdateValue, disabled: this.disabled, placeholder: this.placeholder, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, clearable: true, size: "small" }, {
              "clear-icon-placeholder": () => vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(SearchIcon, null) })
            })
          );
        }
      });
      function useTransferData(props) {
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
        const optionsMapRef = vue.computed(() => {
          const map2 = /* @__PURE__ */ new Map();
          (props.options || []).forEach((opt) => map2.set(opt.value, opt));
          return map2;
        });
        const targetValueSetRef = vue.computed(() => new Set(mergedValueRef.value || []));
        const targetOptionsRef = vue.computed(() => {
          const optionMap = optionsMapRef.value;
          const targetOptions = [];
          (mergedValueRef.value || []).forEach((v) => {
            const option = optionMap.get(v);
            if (option) {
              targetOptions.push(option);
            }
          });
          return targetOptions;
        });
        const srcPatternRef = vue.ref("");
        const tgtPatternRef = vue.ref("");
        const mergedSrcFilterableRef = vue.computed(() => {
          return props.sourceFilterable || !!props.filterable;
        });
        const filteredSrcOptionsRef = vue.computed(() => {
          const { showSelected, options, filter } = props;
          if (!mergedSrcFilterableRef.value) {
            if (showSelected) {
              return options;
            } else {
              return options.filter((option) => !targetValueSetRef.value.has(option.value));
            }
          }
          return options.filter((option) => {
            return filter(srcPatternRef.value, option, "source") && (showSelected || !targetValueSetRef.value.has(option.value));
          });
        });
        const filteredTgtOptionsRef = vue.computed(() => {
          if (!props.targetFilterable)
            return targetOptionsRef.value;
          const { filter } = props;
          return targetOptionsRef.value.filter((opt) => filter(tgtPatternRef.value, opt, "target"));
        });
        const mergedValueSetRef = vue.computed(() => {
          const { value } = mergedValueRef;
          if (value === null)
            return /* @__PURE__ */ new Set();
          return new Set(value);
        });
        const valueSetForCheckAllRef = vue.computed(() => {
          const values = new Set(mergedValueSetRef.value);
          filteredSrcOptionsRef.value.forEach((option) => {
            if (!option.disabled && !values.has(option.value)) {
              values.add(option.value);
            }
          });
          return values;
        });
        const valueSetForUncheckAllRef = vue.computed(() => {
          const values = new Set(mergedValueSetRef.value);
          filteredSrcOptionsRef.value.forEach((option) => {
            if (!option.disabled && values.has(option.value)) {
              values.delete(option.value);
            }
          });
          return values;
        });
        const valueSetForClearRef = vue.computed(() => {
          const values = new Set(mergedValueSetRef.value);
          filteredTgtOptionsRef.value.forEach((option) => {
            if (!option.disabled) {
              values.delete(option.value);
            }
          });
          return values;
        });
        const canNotSelectAnythingRef = vue.computed(() => {
          return filteredSrcOptionsRef.value.every((option) => option.disabled);
        });
        const allCheckedRef = vue.computed(() => {
          if (!filteredSrcOptionsRef.value.length) {
            return false;
          }
          const mergedValueSet = mergedValueSetRef.value;
          return filteredSrcOptionsRef.value.every((option) => option.disabled || mergedValueSet.has(option.value));
        });
        const canBeClearedRef = vue.computed(() => {
          return filteredTgtOptionsRef.value.some((option) => !option.disabled);
        });
        function handleSrcFilterUpdateValue(value) {
          srcPatternRef.value = value !== null && value !== void 0 ? value : "";
        }
        function handleTgtFilterUpdateValue(value) {
          tgtPatternRef.value = value !== null && value !== void 0 ? value : "";
        }
        return {
          uncontrolledValueRef,
          mergedValueRef,
          targetValueSetRef,
          valueSetForCheckAllRef,
          valueSetForUncheckAllRef,
          valueSetForClearRef,
          filteredTgtOptionsRef,
          filteredSrcOptionsRef,
          targetOptionsRef,
          canNotSelectAnythingRef,
          canBeClearedRef,
          allCheckedRef,
          srcPatternRef,
          tgtPatternRef,
          mergedSrcFilterableRef,
          handleSrcFilterUpdateValue,
          handleTgtFilterUpdateValue
        };
      }
      const style$b = cB("transfer", `
 width: 100%;
 font-size: var(--n-font-size);
 height: 300px;
 display: flex;
 flex-wrap: nowrap;
 word-break: break-word;
`, [cM("disabled", [cB("transfer-list", [cB("transfer-list-header", [cE("title", `
 color: var(--n-header-text-color-disabled);
 `), cE("extra", `
 color: var(--n-header-extra-text-color-disabled);
 `)])])]), cB("transfer-list", `
 flex: 1;
 min-width: 0;
 height: inherit;
 display: flex;
 flex-direction: column;
 background-clip: padding-box;
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-list-color);
 `, [cM("source", `
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE("border", "border-right: 1px solid var(--n-divider-color);")]), cM("target", `
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE("border", "border-left: none;")]), cE("border", `
 padding: 0 12px;
 border: 1px solid var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), cB("transfer-list-header", `
 min-height: var(--n-header-height);
 box-sizing: border-box;
 display: flex;
 padding: 12px 12px 10px 12px;
 align-items: center;
 background-clip: padding-box;
 border-radius: inherit;
 border-bottom-left-radius: 0;
 border-bottom-right-radius: 0;
 line-height: 1.5;
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("> *:not(:first-child)", `
 margin-left: 8px;
 `), cE("title", `
 flex: 1;
 min-width: 0;
 line-height: 1.5;
 font-size: var(--n-header-font-size);
 font-weight: var(--n-header-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-header-text-color);
 `), cE("button", `
 position: relative;
 `), cE("extra", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-extra-font-size);
 margin-right: 0;
 white-space: nowrap;
 color: var(--n-header-extra-text-color);
 `)]), cB("transfer-list-body", `
 flex-basis: 0;
 flex-grow: 1;
 box-sizing: border-box;
 position: relative;
 display: flex;
 flex-direction: column;
 border-radius: inherit;
 border-top-left-radius: 0;
 border-top-right-radius: 0;
 `, [cB("transfer-filter", `
 padding: 4px 12px 8px 12px;
 box-sizing: border-box;
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("transfer-list-flex-container", `
 flex: 1;
 position: relative;
 `, [cB("scrollbar", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 height: unset;
 `), cB("empty", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 `), cB("transfer-list-content", `
 padding: 0;
 margin: 0;
 position: relative;
 `, [cB("transfer-list-item", `
 padding: 0 12px;
 min-height: var(--n-item-height);
 display: flex;
 align-items: center;
 color: var(--n-item-text-color);
 position: relative;
 transition: color .3s var(--n-bezier);
 `, [cE("background", `
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cE("checkbox", `
 position: relative;
 margin-right: 8px;
 `), cE("close", `
 opacity: 0;
 pointer-events: none;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 position: relative;
 min-width: 0;
 flex-grow: 1;
 `), cM("source", "cursor: pointer;"), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `), cNotM("disabled", [c$1("&:hover", [cE("background", "background-color: var(--n-item-color-pending);"), cE("close", `
 opacity: 1;
 pointer-events: all;
 `)])])])])])])])]);
      const transferProps = Object.assign(Object.assign({}, useTheme.props), { value: Array, defaultValue: {
        type: Array,
        default: null
      }, options: {
        type: Array,
        default: () => []
      }, disabled: {
        type: Boolean,
        default: void 0
      }, virtualScroll: Boolean, sourceTitle: String, targetTitle: String, filterable: {
        type: Boolean,
        default: void 0
      }, sourceFilterable: Boolean, targetFilterable: Boolean, showSelected: {
        type: Boolean,
        default: true
      }, sourceFilterPlaceholder: String, targetFilterPlaceholder: String, filter: {
        type: Function,
        default: (pattern2, option) => {
          if (!pattern2)
            return true;
          return ~("" + option.label).toLowerCase().indexOf(("" + pattern2).toLowerCase());
        }
      }, size: String, renderSourceLabel: Function, renderTargetLabel: Function, renderSourceList: Function, renderTargetList: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] });
      const Transfer = vue.defineComponent({
        name: "Transfer",
        props: transferProps,
        setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("Transfer", "-transfer", style$b, transferLight$2, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const itemSizeRef = vue.computed(() => {
            const { value: size2 } = mergedSizeRef;
            const { self: { [createKey("itemHeight", size2)]: itemSize } } = themeRef.value;
            return depx(itemSize);
          });
          const { uncontrolledValueRef, mergedValueRef, targetValueSetRef, valueSetForCheckAllRef, valueSetForUncheckAllRef, valueSetForClearRef, filteredTgtOptionsRef, filteredSrcOptionsRef, targetOptionsRef, canNotSelectAnythingRef, canBeClearedRef, allCheckedRef, srcPatternRef, tgtPatternRef, mergedSrcFilterableRef, handleSrcFilterUpdateValue, handleTgtFilterUpdateValue } = useTransferData(props);
          function doUpdateValue(value) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue, onChange } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            if (onUpdateValue)
              call(onUpdateValue, value);
            if (_onUpdateValue)
              call(_onUpdateValue, value);
            if (onChange)
              call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function handleSourceCheckAll() {
            doUpdateValue([...valueSetForCheckAllRef.value]);
          }
          function handleSourceUncheckAll() {
            doUpdateValue([...valueSetForUncheckAllRef.value]);
          }
          function handleTargetClearAll() {
            doUpdateValue([...valueSetForClearRef.value]);
          }
          function handleItemCheck(checked, optionValue) {
            if (checked) {
              doUpdateValue((mergedValueRef.value || []).concat(optionValue));
            } else {
              doUpdateValue((mergedValueRef.value || []).filter((v) => v !== optionValue));
            }
          }
          function handleChecked(optionValueList) {
            doUpdateValue(optionValueList);
          }
          vue.provide(transferInjectionKey, {
            targetValueSetRef,
            mergedClsPrefixRef,
            disabledRef: mergedDisabledRef,
            mergedThemeRef: themeRef,
            targetOptionsRef,
            canNotSelectAnythingRef,
            canBeClearedRef,
            allCheckedRef,
            srcOptionsLengthRef: vue.computed(() => props.options.length),
            handleItemCheck,
            renderSourceLabelRef: vue.toRef(props, "renderSourceLabel"),
            renderTargetLabelRef: vue.toRef(props, "renderTargetLabel"),
            showSelectedRef: vue.toRef(props, "showSelected")
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedDisabled: mergedDisabledRef,
            itemSize: itemSizeRef,
            isMounted: isMounted(),
            mergedTheme: themeRef,
            filteredSrcOpts: filteredSrcOptionsRef,
            filteredTgtOpts: filteredTgtOptionsRef,
            srcPattern: srcPatternRef,
            tgtPattern: tgtPatternRef,
            mergedSize: mergedSizeRef,
            mergedSrcFilterable: mergedSrcFilterableRef,
            handleSrcFilterUpdateValue,
            handleTgtFilterUpdateValue,
            handleSourceCheckAll,
            handleSourceUncheckAll,
            handleTargetClearAll,
            handleItemCheck,
            handleChecked,
            cssVars: vue.computed(() => {
              const { value: size2 } = mergedSizeRef;
              const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { borderRadius, borderColor, listColor, titleTextColor, titleTextColorDisabled, extraTextColor, itemTextColor, itemColorPending, itemTextColorDisabled, titleFontWeight, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, closeIconSize, closeSize, dividerColor, extraTextColorDisabled, [createKey("extraFontSize", size2)]: extraFontSize, [createKey("fontSize", size2)]: fontSize2, [createKey("titleFontSize", size2)]: titleFontSize, [createKey("itemHeight", size2)]: itemHeight, [createKey("headerHeight", size2)]: headerHeight } } = themeRef.value;
              return {
                "--n-bezier": cubicBezierEaseInOut2,
                "--n-border-color": borderColor,
                "--n-border-radius": borderRadius,
                "--n-extra-font-size": extraFontSize,
                "--n-font-size": fontSize2,
                "--n-header-font-size": titleFontSize,
                "--n-header-extra-text-color": extraTextColor,
                "--n-header-extra-text-color-disabled": extraTextColorDisabled,
                "--n-header-font-weight": titleFontWeight,
                "--n-header-text-color": titleTextColor,
                "--n-header-text-color-disabled": titleTextColorDisabled,
                "--n-item-color-pending": itemColorPending,
                "--n-item-height": itemHeight,
                "--n-item-text-color": itemTextColor,
                "--n-item-text-color-disabled": itemTextColorDisabled,
                "--n-list-color": listColor,
                "--n-header-height": headerHeight,
                "--n-close-size": closeSize,
                "--n-close-icon-size": closeIconSize,
                "--n-close-color-hover": closeColorHover,
                "--n-close-color-pressed": closeColorPressed,
                "--n-close-icon-color": closeIconColor,
                "--n-close-icon-color-hover": closeIconColorHover,
                "--n-close-icon-color-pressed": closeIconColorPressed,
                "--n-divider-color": dividerColor
              };
            })
          };
        },
        render() {
          const { mergedClsPrefix, renderSourceList, renderTargetList, mergedTheme, mergedSrcFilterable, targetFilterable } = this;
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-transfer`,
              this.mergedDisabled && `${mergedClsPrefix}-transfer--disabled`
            ], style: this.cssVars },
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--source` },
              vue.h(NTransferHeader, { source: true, title: this.sourceTitle, onCheckedAll: this.handleSourceCheckAll, onClearAll: this.handleSourceUncheckAll, size: this.mergedSize }),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-transfer-list-body` },
                mergedSrcFilterable ? vue.h(NTransferFilter, { onUpdateValue: this.handleSrcFilterUpdateValue, value: this.srcPattern, disabled: this.mergedDisabled, placeholder: this.sourceFilterPlaceholder }) : null,
                vue.h("div", { class: `${mergedClsPrefix}-transfer-list-flex-container` }, renderSourceList ? vue.h(NScrollbar, { theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => renderSourceList({
                    onCheck: this.handleChecked,
                    checkedOptions: this.filteredTgtOpts,
                    pattern: this.srcPattern
                  })
                }) : vue.h(NTransferList, { source: true, options: this.filteredSrcOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, itemSize: this.itemSize }))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-transfer-list__border` })
            ),
            vue.h(
              "div",
              { class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--target` },
              vue.h(NTransferHeader, { onClearAll: this.handleTargetClearAll, size: this.mergedSize, title: this.targetTitle }),
              vue.h(
                "div",
                { class: `${mergedClsPrefix}-transfer-list-body` },
                targetFilterable ? vue.h(NTransferFilter, { onUpdateValue: this.handleTgtFilterUpdateValue, value: this.tgtPattern, disabled: this.mergedDisabled, placeholder: this.sourceFilterPlaceholder }) : null,
                vue.h("div", { class: `${mergedClsPrefix}-transfer-list-flex-container` }, renderTargetList ? vue.h(NScrollbar, { theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                  default: () => renderTargetList({
                    onCheck: this.handleChecked,
                    checkedOptions: this.filteredTgtOpts,
                    pattern: this.tgtPattern
                  })
                }) : vue.h(NTransferList, { options: this.filteredTgtOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, itemSize: this.itemSize }))
              ),
              vue.h("div", { class: `${mergedClsPrefix}-transfer-list__border` })
            )
          );
        }
      });
      const treeSelectInjectionKey = createInjectionKey("n-tree-select");
      const treeInjectionKey = createInjectionKey("n-tree");
      const NTreeNodeSwitcher = vue.defineComponent({
        name: "NTreeSwitcher",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          expanded: Boolean,
          selected: Boolean,
          hide: Boolean,
          loading: Boolean,
          onClick: Function
        },
        setup(props) {
          const { renderSwitcherIconRef } = vue.inject(treeInjectionKey, null);
          return () => {
            const { clsPrefix } = props;
            return vue.h(
              "span",
              { "data-switcher": true, class: [
                `${clsPrefix}-tree-node-switcher`,
                props.expanded && `${clsPrefix}-tree-node-switcher--expanded`,
                props.hide && `${clsPrefix}-tree-node-switcher--hide`
              ], onClick: props.onClick },
              vue.h(
                "div",
                { class: `${clsPrefix}-tree-node-switcher__icon` },
                vue.h(NIconSwitchTransition, null, {
                  default: () => {
                    if (props.loading) {
                      return vue.h(NBaseLoading, { clsPrefix, key: "loading", radius: 85, strokeWidth: 20 });
                    }
                    const { value: renderSwitcherIcon } = renderSwitcherIconRef;
                    return renderSwitcherIcon ? renderSwitcherIcon({
                      expanded: props.expanded,
                      selected: props.selected
                    }) : vue.h(NBaseIcon, { clsPrefix, key: "switcher" }, { default: () => vue.h(SwitcherIcon, null) });
                  }
                })
              )
            );
          };
        }
      });
      const NTreeNodeCheckbox = vue.defineComponent({
        name: "NTreeNodeCheckbox",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          right: Boolean,
          focusable: Boolean,
          disabled: Boolean,
          checked: Boolean,
          indeterminate: Boolean,
          onCheck: Function
        },
        setup(props) {
          const NTree2 = vue.inject(treeInjectionKey);
          function doCheck(value) {
            const { onCheck } = props;
            if (onCheck) {
              onCheck(value);
            }
          }
          function handleUpdateValue(value) {
            if (props.indeterminate) {
              doCheck(false);
            } else {
              doCheck(value);
            }
          }
          return {
            handleUpdateValue,
            mergedTheme: NTree2.mergedThemeRef
          };
        },
        render() {
          const { clsPrefix, mergedTheme, checked, indeterminate, disabled, focusable, handleUpdateValue } = this;
          return vue.h(
            "span",
            { class: [
              `${clsPrefix}-tree-node-checkbox`,
              this.right && `${clsPrefix}-tree-node-checkbox--right`
            ], "data-checkbox": true },
            vue.h(NCheckbox, { focusable, disabled, theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, checked, indeterminate, onUpdateChecked: handleUpdateValue })
          );
        }
      });
      const NTreeNodeContent = vue.defineComponent({
        name: "TreeNodeContent",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          disabled: Boolean,
          checked: Boolean,
          selected: Boolean,
          onClick: Function,
          onDragstart: Function,
          tmNode: {
            type: Object,
            required: true
          },
          nodeProps: Object
        },
        setup(props) {
          const { renderLabelRef, renderPrefixRef, renderSuffixRef, labelFieldRef } = (
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            vue.inject(treeInjectionKey)
          );
          const selfRef = vue.ref(null);
          function doClick(e) {
            const { onClick } = props;
            if (onClick)
              onClick(e);
          }
          function handleClick2(e) {
            doClick(e);
          }
          return {
            selfRef,
            renderLabel: renderLabelRef,
            renderPrefix: renderPrefixRef,
            renderSuffix: renderSuffixRef,
            labelField: labelFieldRef,
            handleClick: handleClick2
          };
        },
        render() {
          const { clsPrefix, labelField, nodeProps, checked = false, selected = false, renderLabel, renderPrefix, renderSuffix, handleClick: handleClick2, onDragstart, tmNode: { rawNode, rawNode: { prefix: prefix2, suffix: suffix2, [labelField]: label } } } = this;
          return vue.h(
            "span",
            Object.assign({}, nodeProps, { ref: "selfRef", class: [`${clsPrefix}-tree-node-content`, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.class], onClick: handleClick2, draggable: onDragstart === void 0 ? void 0 : true, onDragstart }),
            renderPrefix || prefix2 ? vue.h("div", { class: `${clsPrefix}-tree-node-content__prefix` }, renderPrefix ? renderPrefix({
              option: rawNode,
              selected,
              checked
            }) : render$1(prefix2)) : null,
            vue.h("div", { class: `${clsPrefix}-tree-node-content__text` }, renderLabel ? renderLabel({
              option: rawNode,
              selected,
              checked
            }) : render$1(label)),
            renderSuffix || suffix2 ? vue.h("div", { class: `${clsPrefix}-tree-node-content__suffix` }, renderSuffix ? renderSuffix({
              option: rawNode,
              selected,
              checked
            }) : render$1(suffix2)) : null
          );
        }
      });
      function renderDropMark({ position, offsetLevel, indent, el }) {
        const style2 = {
          position: "absolute",
          boxSizing: "border-box",
          right: 0
        };
        if (position === "inside") {
          style2.left = 0;
          style2.top = 0;
          style2.bottom = 0;
          style2.borderRadius = "inherit";
          style2.boxShadow = "inset 0 0 0 2px var(--n-drop-mark-color)";
        } else {
          const cssPosition = position === "before" ? "top" : "bottom";
          style2[cssPosition] = 0;
          style2.left = `${el.offsetLeft + 6 - offsetLevel * indent}px`;
          style2.height = "2px";
          style2.backgroundColor = "var(--n-drop-mark-color)";
          style2.transformOrigin = cssPosition;
          style2.borderRadius = "1px";
          style2.transform = position === "before" ? "translateY(-4px)" : "translateY(4px)";
        }
        return vue.h("div", { style: style2 });
      }
      function defaultAllowDrop({ dropPosition, node }) {
        if (node.isLeaf === false)
          return true;
        if (node.children) {
          return true;
        }
        return dropPosition !== "inside";
      }
      function useMergedCheckStrategy(props) {
        return vue.computed(() => props.leafOnly ? "child" : props.checkStrategy);
      }
      function isNodeDisabled(node, disabledField) {
        return !!node.rawNode[disabledField];
      }
      function traverse(nodes, childrenField, callback, callbackAfter) {
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
          callback(node);
          traverse(node[childrenField], childrenField, callback, callbackAfter);
          callbackAfter(node);
        });
      }
      function keysWithFilter(nodes, pattern2, keyField, childrenField, filter) {
        const keys2 = /* @__PURE__ */ new Set();
        const highlightKeySet = /* @__PURE__ */ new Set();
        const path = [];
        traverse(nodes, childrenField, (node) => {
          path.push(node);
          if (filter(pattern2, node)) {
            highlightKeySet.add(node[keyField]);
            for (let i = path.length - 2; i >= 0; --i) {
              if (!keys2.has(path[i][keyField])) {
                keys2.add(path[i][keyField]);
              } else {
                return;
              }
            }
          }
        }, () => {
          path.pop();
        });
        return {
          expandedKeys: Array.from(keys2),
          highlightKeySet
        };
      }
      if (isBrowser$2 && Image) {
        const emptyImage = new Image();
        emptyImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      }
      function filterTree(tree, filter, pattern2, keyField, childrenField) {
        const visitedTailKeys = /* @__PURE__ */ new Set();
        const visitedNonTailKeys = /* @__PURE__ */ new Set();
        const highlightKeySet = /* @__PURE__ */ new Set();
        const expandedKeys = [];
        const filteredTree = [];
        const path = [];
        function visit(t) {
          t.forEach((n) => {
            path.push(n);
            if (filter(pattern2, n)) {
              visitedTailKeys.add(n[keyField]);
              highlightKeySet.add(n[keyField]);
              for (let i = path.length - 2; i >= 0; --i) {
                const key = path[i][keyField];
                if (!visitedNonTailKeys.has(key)) {
                  visitedNonTailKeys.add(key);
                  if (visitedTailKeys.has(key)) {
                    visitedTailKeys.delete(key);
                  }
                } else {
                  break;
                }
              }
            }
            const children = n[childrenField];
            if (children) {
              visit(children);
            }
            path.pop();
          });
        }
        visit(tree);
        function build(t, sibs) {
          t.forEach((n) => {
            const key = n[keyField];
            const isVisitedTail = visitedTailKeys.has(key);
            const isVisitedNonTail = visitedNonTailKeys.has(key);
            if (!isVisitedTail && !isVisitedNonTail)
              return;
            const children = n[childrenField];
            if (children) {
              if (isVisitedTail) {
                sibs.push(n);
              } else {
                expandedKeys.push(key);
                const clonedNode = Object.assign(Object.assign({}, n), { [childrenField]: [] });
                sibs.push(clonedNode);
                build(children, clonedNode[childrenField]);
              }
            } else {
              sibs.push(n);
            }
          });
        }
        build(tree, filteredTree);
        return {
          filteredTree,
          highlightKeySet,
          expandedKeys
        };
      }
      const TreeNode = vue.defineComponent({
        name: "TreeNode",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const NTree2 = vue.inject(treeInjectionKey);
          const { droppingNodeParentRef, droppingMouseNodeRef, draggingNodeRef, droppingPositionRef, droppingOffsetLevelRef, nodePropsRef, indentRef, blockLineRef, checkboxPlacementRef, checkOnClickRef, disabledFieldRef } = NTree2;
          const checkboxDisabledRef = useMemo(() => !!props.tmNode.rawNode.checkboxDisabled);
          const nodeIsDisabledRef = useMemo(() => {
            return isNodeDisabled(props.tmNode, disabledFieldRef.value);
          });
          const disabledRef = useMemo(() => NTree2.disabledRef.value || nodeIsDisabledRef.value);
          const resolvedNodePropsRef = vue.computed(() => {
            const { value: nodeProps } = nodePropsRef;
            if (!nodeProps)
              return void 0;
            return nodeProps({ option: props.tmNode.rawNode });
          });
          const contentInstRef = vue.ref(null);
          const contentElRef = { value: null };
          vue.onMounted(() => {
            contentElRef.value = contentInstRef.value.$el;
          });
          function handleSwitcherClick() {
            const { tmNode } = props;
            if (!tmNode.isLeaf && !tmNode.shallowLoaded) {
              if (!NTree2.loadingKeysRef.value.has(tmNode.key)) {
                NTree2.loadingKeysRef.value.add(tmNode.key);
              } else {
                return;
              }
              const { onLoadRef: { value: onLoad } } = NTree2;
              if (onLoad) {
                void onLoad(tmNode.rawNode).then((value) => {
                  if (value !== false) {
                    NTree2.handleSwitcherClick(tmNode);
                  }
                }).finally(() => {
                  NTree2.loadingKeysRef.value.delete(tmNode.key);
                });
              }
            } else {
              NTree2.handleSwitcherClick(tmNode);
            }
          }
          const selectableRef = useMemo(() => !nodeIsDisabledRef.value && NTree2.selectableRef.value && (NTree2.internalTreeSelect ? NTree2.mergedCheckStrategyRef.value !== "child" || NTree2.multipleRef.value && NTree2.cascadeRef.value || props.tmNode.isLeaf : true));
          const checkableRef = useMemo(() => NTree2.checkableRef.value && (NTree2.cascadeRef.value || NTree2.mergedCheckStrategyRef.value !== "child" || props.tmNode.isLeaf));
          const checkedRef = useMemo(() => NTree2.displayedCheckedKeysRef.value.includes(props.tmNode.key));
          const mergedCheckOnClickRef = useMemo(() => {
            const { value: checkable } = checkableRef;
            if (!checkable)
              return false;
            const { value: checkOnClick } = checkOnClickRef;
            if (typeof checkOnClick === "boolean") {
              return checkOnClick;
            }
            return checkOnClick(props.tmNode.rawNode);
          });
          function _handleClick(e) {
            const { value: expandOnClick } = NTree2.expandOnClickRef;
            const { value: selectable } = selectableRef;
            const { value: mergedCheckOnClick } = mergedCheckOnClickRef;
            if (!selectable && !expandOnClick && !mergedCheckOnClick)
              return;
            if (happensIn(e, "checkbox") || happensIn(e, "switcher"))
              return;
            const { tmNode } = props;
            if (selectable) {
              NTree2.handleSelect(tmNode);
            }
            if (expandOnClick && !tmNode.isLeaf) {
              handleSwitcherClick();
            }
            if (mergedCheckOnClick) {
              handleCheck(!checkedRef.value);
            }
          }
          function handleContentClick(e) {
            var _a, _b;
            if (blockLineRef.value)
              return;
            if (!disabledRef.value)
              _handleClick(e);
            (_b = (_a = resolvedNodePropsRef.value) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
          }
          function handleLineClick(e) {
            var _a, _b;
            if (!blockLineRef.value)
              return;
            if (!disabledRef.value) {
              _handleClick(e);
            }
            (_b = (_a = resolvedNodePropsRef.value) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
          }
          function handleCheck(checked) {
            NTree2.handleCheck(props.tmNode, checked);
          }
          function handleDragStart(e) {
            NTree2.handleDragStart({
              event: e,
              node: props.tmNode
            });
          }
          function handleDragEnter(e) {
            if (e.currentTarget !== e.target) {
              return;
            }
            NTree2.handleDragEnter({
              event: e,
              node: props.tmNode
            });
          }
          function handleDragOver(e) {
            e.preventDefault();
            NTree2.handleDragOver({
              event: e,
              node: props.tmNode
            });
          }
          function handleDragEnd(e) {
            NTree2.handleDragEnd({
              event: e,
              node: props.tmNode
            });
          }
          function handleDragLeave(e) {
            if (e.currentTarget !== e.target) {
              return;
            }
            NTree2.handleDragLeave({
              event: e,
              node: props.tmNode
            });
          }
          function handleDrop(e) {
            e.preventDefault();
            if (droppingPositionRef.value !== null) {
              NTree2.handleDrop({
                event: e,
                node: props.tmNode,
                dropPosition: droppingPositionRef.value
              });
            }
          }
          return {
            showDropMark: useMemo(() => {
              const { value: draggingNode } = draggingNodeRef;
              if (!draggingNode)
                return;
              const { value: droppingPosition } = droppingPositionRef;
              if (!droppingPosition)
                return;
              const { value: droppingMouseNode } = droppingMouseNodeRef;
              if (!droppingMouseNode) {
                return;
              }
              const { tmNode } = props;
              if (tmNode.key === droppingMouseNode.key)
                return true;
              return false;
            }),
            showDropMarkAsParent: useMemo(() => {
              const { value: droppingNodeParent } = droppingNodeParentRef;
              if (!droppingNodeParent)
                return false;
              const { tmNode } = props;
              const { value: droppingPosition } = droppingPositionRef;
              if (droppingPosition === "before" || droppingPosition === "after") {
                return droppingNodeParent.key === tmNode.key;
              }
              return false;
            }),
            pending: useMemo(() => NTree2.pendingNodeKeyRef.value === props.tmNode.key),
            loading: useMemo(() => NTree2.loadingKeysRef.value.has(props.tmNode.key)),
            highlight: useMemo(() => {
              var _a;
              return (_a = NTree2.highlightKeySetRef.value) === null || _a === void 0 ? void 0 : _a.has(props.tmNode.key);
            }),
            checked: checkedRef,
            indeterminate: useMemo(() => NTree2.displayedIndeterminateKeysRef.value.includes(props.tmNode.key)),
            selected: useMemo(() => NTree2.mergedSelectedKeysRef.value.includes(props.tmNode.key)),
            expanded: useMemo(() => NTree2.mergedExpandedKeysRef.value.includes(props.tmNode.key)),
            disabled: disabledRef,
            checkable: checkableRef,
            mergedCheckOnClick: mergedCheckOnClickRef,
            checkboxDisabled: checkboxDisabledRef,
            selectable: selectableRef,
            expandOnClick: NTree2.expandOnClickRef,
            internalScrollable: NTree2.internalScrollableRef,
            draggable: NTree2.draggableRef,
            blockLine: blockLineRef,
            nodeProps: resolvedNodePropsRef,
            checkboxFocusable: NTree2.internalCheckboxFocusableRef,
            droppingPosition: droppingPositionRef,
            droppingOffsetLevel: droppingOffsetLevelRef,
            indent: indentRef,
            checkboxPlacement: checkboxPlacementRef,
            contentInstRef,
            contentElRef,
            handleCheck,
            handleDrop,
            handleDragStart,
            handleDragEnter,
            handleDragOver,
            handleDragEnd,
            handleDragLeave,
            handleLineClick,
            handleContentClick,
            handleSwitcherClick
          };
        },
        render() {
          const { tmNode, clsPrefix, checkable, expandOnClick, selectable, selected, checked, highlight, draggable, blockLine, indent, disabled, pending, internalScrollable, nodeProps, checkboxPlacement } = this;
          const dragEventHandlers = draggable && !disabled ? {
            onDragenter: this.handleDragEnter,
            onDragleave: this.handleDragLeave,
            onDragend: this.handleDragEnd,
            onDrop: this.handleDrop,
            onDragover: this.handleDragOver
          } : void 0;
          const dataKey = internalScrollable ? createDataKey(tmNode.key) : void 0;
          const checkboxOnRight = checkboxPlacement === "right";
          const checkboxNode = checkable ? vue.h(NTreeNodeCheckbox, { right: checkboxOnRight, focusable: this.checkboxFocusable, disabled: disabled || this.checkboxDisabled, clsPrefix, checked: this.checked, indeterminate: this.indeterminate, onCheck: this.handleCheck }) : null;
          return vue.h(
            "div",
            Object.assign({ class: `${clsPrefix}-tree-node-wrapper` }, dragEventHandlers),
            vue.h(
              "div",
              Object.assign({}, blockLine ? nodeProps : void 0, { class: [
                `${clsPrefix}-tree-node`,
                {
                  [`${clsPrefix}-tree-node--selected`]: selected,
                  [`${clsPrefix}-tree-node--checkable`]: checkable,
                  [`${clsPrefix}-tree-node--highlight`]: highlight,
                  [`${clsPrefix}-tree-node--pending`]: pending,
                  [`${clsPrefix}-tree-node--disabled`]: disabled,
                  [`${clsPrefix}-tree-node--selectable`]: selectable,
                  [`${clsPrefix}-tree-node--clickable`]: selectable || expandOnClick || this.mergedCheckOnClick
                },
                nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.class
              ], "data-key": dataKey, draggable: draggable && blockLine, onClick: this.handleLineClick, onDragstart: draggable && blockLine && !disabled ? this.handleDragStart : void 0 }),
              repeat(tmNode.level, vue.h(
                "div",
                { class: `${clsPrefix}-tree-node-indent` },
                vue.h("div", { style: { width: `${indent}px` } })
              )),
              vue.h(NTreeNodeSwitcher, { clsPrefix, expanded: this.expanded, selected, loading: this.loading, hide: tmNode.isLeaf, onClick: this.handleSwitcherClick }),
              !checkboxOnRight ? checkboxNode : null,
              vue.h(NTreeNodeContent, { ref: "contentInstRef", clsPrefix, checked, selected, onClick: this.handleContentClick, nodeProps: blockLine ? void 0 : nodeProps, onDragstart: draggable && !blockLine && !disabled ? this.handleDragStart : void 0, tmNode }),
              draggable ? this.showDropMark ? renderDropMark({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                el: this.contentElRef.value,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                position: this.droppingPosition,
                offsetLevel: this.droppingOffsetLevel,
                indent
              }) : this.showDropMarkAsParent ? renderDropMark({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                el: this.contentElRef.value,
                position: "inside",
                offsetLevel: this.droppingOffsetLevel,
                indent
              }) : null : null,
              checkboxOnRight ? checkboxNode : null
            )
          );
        }
      });
      const NTreeNode = TreeNode;
      function useKeyboard({ props, fNodesRef, mergedExpandedKeysRef, mergedSelectedKeysRef, handleSelect, handleSwitcherClick }) {
        const { value: mergedSelectedKeys } = mergedSelectedKeysRef;
        const treeSelectInjection = vue.inject(treeSelectInjectionKey, null);
        const pendingNodeKeyRef = treeSelectInjection ? treeSelectInjection.pendingNodeKeyRef : vue.ref(mergedSelectedKeys.length ? mergedSelectedKeys[mergedSelectedKeys.length - 1] : null);
        function handleKeydown(e) {
          if (!props.keyboard)
            return;
          const { value: pendingNodeKey } = pendingNodeKeyRef;
          if (pendingNodeKey === null) {
            if (e.key === "ArrowDown" || e.key === "ArrowUp") {
              e.preventDefault();
            }
            if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.key)) {
              if (pendingNodeKey === null) {
                const { value: fNodes } = fNodesRef;
                let fIndex = 0;
                while (fIndex < fNodes.length) {
                  if (!fNodes[fIndex].disabled) {
                    pendingNodeKeyRef.value = fNodes[fIndex].key;
                    break;
                  }
                  fIndex += 1;
                }
              }
            }
          } else {
            const { value: fNodes } = fNodesRef;
            let fIndex = fNodes.findIndex((tmNode) => tmNode.key === pendingNodeKey);
            if (!~fIndex)
              return;
            if (e.key === "Enter") {
              handleSelect(fNodes[fIndex]);
            } else if (e.key === "ArrowDown") {
              e.preventDefault();
              fIndex += 1;
              while (fIndex < fNodes.length) {
                if (!fNodes[fIndex].disabled) {
                  pendingNodeKeyRef.value = fNodes[fIndex].key;
                  break;
                }
                fIndex += 1;
              }
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              fIndex -= 1;
              while (fIndex >= 0) {
                if (!fNodes[fIndex].disabled) {
                  pendingNodeKeyRef.value = fNodes[fIndex].key;
                  break;
                }
                fIndex -= 1;
              }
            } else if (e.key === "ArrowLeft") {
              const pendingNode = fNodes[fIndex];
              if (pendingNode.isLeaf || !mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
                const parentTmNode = pendingNode.getParent();
                if (parentTmNode) {
                  pendingNodeKeyRef.value = parentTmNode.key;
                }
              } else {
                handleSwitcherClick(pendingNode);
              }
            } else if (e.key === "ArrowRight") {
              const pendingNode = fNodes[fIndex];
              if (pendingNode.isLeaf)
                return;
              if (!mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
                handleSwitcherClick(pendingNode);
              } else {
                fIndex += 1;
                while (fIndex < fNodes.length) {
                  if (!fNodes[fIndex].disabled) {
                    pendingNodeKeyRef.value = fNodes[fIndex].key;
                    break;
                  }
                  fIndex += 1;
                }
              }
            }
          }
        }
        return {
          pendingNodeKeyRef,
          handleKeydown
        };
      }
      const MotionWrapper = vue.defineComponent({
        name: "TreeMotionWrapper",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          height: Number,
          nodes: {
            type: Array,
            required: true
          },
          mode: {
            type: String,
            required: true
          },
          onAfterEnter: {
            type: Function,
            required: true
          }
        },
        render() {
          const { clsPrefix } = this;
          return vue.h(NFadeInExpandTransition, { onAfterEnter: this.onAfterEnter, appear: true, reverse: this.mode === "collapse" }, {
            default: () => vue.h("div", { class: [
              `${clsPrefix}-tree-motion-wrapper`,
              `${clsPrefix}-tree-motion-wrapper--${this.mode}`
            ], style: {
              height: pxfy(this.height)
            } }, this.nodes.map((node) => vue.h(NTreeNode, { clsPrefix, tmNode: node })))
          });
        }
      });
      const style$a = cB("tree", `
 font-size: var(--n-font-size);
 outline: none;
`, [c$1("ul, li", `
 margin: 0;
 padding: 0;
 list-style: none;
 `), c$1(">", [cB("tree-node", [c$1("&:first-child", {
        marginTop: 0
      })])]), cB("tree-node-indent", `
 flex-grow: 0;
 flex-shrink: 0;
 height: 0;
 `), cB("tree-motion-wrapper", [cM("expand", [fadeInHeightExpandTransition({
        duration: "0.2s"
      })]), cM("collapse", [fadeInHeightExpandTransition({
        duration: "0.2s",
        reverse: true
      })])]), cB("tree-node-wrapper", `
 box-sizing: border-box;
 padding: 3px 0;
 `), cB("tree-node", `
 transform: translate3d(0,0,0);
 position: relative;
 display: flex;
 border-radius: var(--n-node-border-radius);
 transition: background-color .3s var(--n-bezier);
 `, [cM("highlight", [cB("tree-node-content", [cE("text", {
        borderBottomColor: "var(--n-node-text-color-disabled)"
      })])]), cM("disabled", [cB("tree-node-content", `
 color: var(--n-node-text-color-disabled);
 cursor: not-allowed;
 `)]), cNotM("disabled", [cM("clickable", [cB("tree-node-content", `
 cursor: pointer;
 `)])])]), cM("block-node", [cB("tree-node-content", `
 flex: 1;
 min-width: 0;
 `)]), cNotM("block-line", [cB("tree-node", [cNotM("disabled", [cB("tree-node-content", [c$1("&:hover", {
        backgroundColor: "var(--n-node-color-hover)"
      })]), cM("selectable", [cB("tree-node-content", [c$1("&:active", {
        backgroundColor: "var(--n-node-color-pressed)"
      })])]), cM("pending", [cB("tree-node-content", `
 background-color: var(--n-node-color-hover);
 `)]), cM("selected", [cB("tree-node-content", {
        backgroundColor: "var(--n-node-color-active)"
      })])])])]), cM("block-line", [cB("tree-node", [cNotM("disabled", [c$1("&:hover", {
        backgroundColor: "var(--n-node-color-hover)"
      }), cM("pending", `
 background-color: var(--n-node-color-hover);
 `), cM("selectable", [cNotM("selected", [c$1("&:active", {
        backgroundColor: "var(--n-node-color-pressed)"
      })])]), cM("selected", {
        backgroundColor: "var(--n-node-color-active)"
      })]), cM("disabled", `
 cursor: not-allowed;
 `)])]), cB("tree-node-switcher", `
 cursor: pointer;
 display: inline-flex;
 flex-shrink: 0;
 height: 24px;
 width: 24px;
 align-items: center;
 justify-content: center;
 transition: transform .15s var(--n-bezier);
 vertical-align: bottom;
 `, [cE("icon", `
 position: relative;
 height: 14px;
 width: 14px;
 display: flex;
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 font-size: 14px;
 `, [cB("icon", [iconSwitchTransition()]), cB("base-loading", `
 color: var(--n-loading-color);
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("base-icon", [iconSwitchTransition()])]), cM("hide", {
        visibility: "hidden"
      }), cM("expanded", {
        transform: "rotate(90deg)"
      })]), cB("tree-node-checkbox", `
 display: inline-flex;
 height: 24px;
 width: 16px;
 vertical-align: bottom;
 align-items: center;
 justify-content: center;
 margin-right: 4px;
 `, [cM("right", "margin-left: 4px;")]), cM("checkable", [cB("tree-node-content", `
 padding: 0 6px;
 `)]), cB("tree-node-content", `
 position: relative;
 display: inline-flex;
 align-items: center;
 min-height: 24px;
 box-sizing: border-box;
 line-height: 1.5;
 vertical-align: bottom;
 padding: 0 6px 0 4px;
 cursor: default;
 border-radius: var(--n-node-border-radius);
 text-decoration-color: #0000;
 text-decoration-line: underline;
 color: var(--n-node-text-color);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1("&:last-child", {
        marginBottom: 0
      }), cE("prefix", `
 display: inline-flex;
 margin-right: 8px;
 `), cE("text", `
 border-bottom: 1px solid #0000;
 transition: border-color .3s var(--n-bezier);
 flex-grow: 1;
 max-width: 100%;
 `), cE("suffix", `
 display: inline-flex;
 `)]), cE("empty", "margin: auto;")]);
      var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const ITEM_SIZE = 30;
      function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {
        const settledGetChildren = getChildren || ((node) => {
          return node[childrenField];
        });
        return {
          getIsGroup() {
            return false;
          },
          getKey(node) {
            return node[keyField];
          },
          getChildren: settledGetChildren,
          getDisabled(node) {
            return !!(node[disabledField] || node.checkboxDisabled);
          }
        };
      }
      const treeSharedProps = {
        allowCheckingNotLoaded: Boolean,
        filter: Function,
        defaultExpandAll: Boolean,
        expandedKeys: Array,
        keyField: {
          type: String,
          default: "key"
        },
        labelField: {
          type: String,
          default: "label"
        },
        childrenField: {
          type: String,
          default: "children"
        },
        disabledField: {
          type: String,
          default: "disabled"
        },
        defaultExpandedKeys: {
          type: Array,
          default: () => []
        },
        indeterminateKeys: Array,
        renderSwitcherIcon: Function,
        onUpdateIndeterminateKeys: [Function, Array],
        "onUpdate:indeterminateKeys": [Function, Array],
        onUpdateExpandedKeys: [Function, Array],
        "onUpdate:expandedKeys": [Function, Array]
      };
      const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { accordion: Boolean, showIrrelevantNodes: { type: Boolean, default: true }, data: {
        type: Array,
        default: () => []
      }, expandOnDragenter: {
        type: Boolean,
        default: true
      }, expandOnClick: Boolean, checkOnClick: {
        type: [Boolean, Function],
        default: false
      }, cancelable: {
        type: Boolean,
        default: true
      }, checkable: Boolean, draggable: Boolean, blockNode: Boolean, blockLine: Boolean, disabled: Boolean, checkedKeys: Array, defaultCheckedKeys: {
        type: Array,
        default: () => []
      }, selectedKeys: Array, defaultSelectedKeys: {
        type: Array,
        default: () => []
      }, multiple: Boolean, pattern: {
        type: String,
        default: ""
      }, onLoad: Function, cascade: Boolean, selectable: {
        type: Boolean,
        default: true
      }, indent: {
        type: Number,
        default: 16
      }, allowDrop: {
        type: Function,
        default: defaultAllowDrop
      }, animated: {
        type: Boolean,
        default: true
      }, checkboxPlacement: {
        type: String,
        default: "left"
      }, virtualScroll: Boolean, watchProps: Array, renderLabel: Function, renderPrefix: Function, renderSuffix: Function, nodeProps: Function, keyboard: {
        type: Boolean,
        default: true
      }, getChildren: Function, onDragenter: [Function, Array], onDragleave: [Function, Array], onDragend: [Function, Array], onDragstart: [Function, Array], onDragover: [Function, Array], onDrop: [Function, Array], onUpdateCheckedKeys: [Function, Array], "onUpdate:checkedKeys": [Function, Array], onUpdateSelectedKeys: [Function, Array], "onUpdate:selectedKeys": [Function, Array] }), treeSharedProps), {
        // internal props for tree-select
        internalTreeSelect: Boolean,
        internalScrollable: Boolean,
        internalScrollablePadding: String,
        // use it to display
        internalRenderEmpty: Function,
        internalHighlightKeySet: Object,
        internalUnifySelectCheck: Boolean,
        internalCheckboxFocusable: {
          type: Boolean,
          default: true
        },
        internalFocusable: {
          // Make tree-select take over keyboard operations
          type: Boolean,
          default: true
        },
        checkStrategy: {
          type: String,
          default: "all"
        },
        /**
         * @deprecated
         */
        leafOnly: Boolean
      });
      const NTree = vue.defineComponent({
        name: "Tree",
        props: treeProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl("Tree", mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme("Tree", "-tree", style$a, treeLight$1, props, mergedClsPrefixRef);
          const selfElRef = vue.ref(null);
          const scrollbarInstRef = vue.ref(null);
          const virtualListInstRef = vue.ref(null);
          function getScrollContainer() {
            var _a;
            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
          }
          function getScrollContent() {
            var _a;
            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
          }
          const mergedFilterRef = vue.computed(() => {
            const { filter } = props;
            if (filter)
              return filter;
            const { labelField } = props;
            return (pattern2, node) => {
              if (!pattern2.length)
                return true;
              const label = node[labelField];
              if (typeof label === "string") {
                return label.toLowerCase().includes(pattern2.toLowerCase());
              }
              return false;
            };
          });
          const filteredTreeInfoRef = vue.computed(() => {
            const { pattern: pattern2 } = props;
            if (!pattern2) {
              return {
                filteredTree: props.data,
                highlightKeySet: null,
                expandedKeys: void 0
              };
            }
            if (!pattern2.length || !mergedFilterRef.value) {
              return {
                filteredTree: props.data,
                highlightKeySet: null,
                expandedKeys: void 0
              };
            }
            return filterTree(props.data, mergedFilterRef.value, pattern2, props.keyField, props.childrenField);
          });
          const displayTreeMateRef = vue.computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));
          const treeSelectInjection = vue.inject(treeSelectInjectionKey, null);
          const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;
          const { watchProps } = props;
          const uncontrolledCheckedKeysRef = vue.ref([]);
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultCheckedKeys")) {
            vue.watchEffect(() => {
              uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
            });
          } else {
            uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
          }
          const controlledCheckedKeysRef = vue.toRef(props, "checkedKeys");
          const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);
          const checkedStatusRef = vue.computed(() => {
            const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {
              cascade: props.cascade,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
            return value;
          });
          const mergedCheckStrategyRef = useMergedCheckStrategy(props);
          const displayedCheckedKeysRef = vue.computed(() => {
            return checkedStatusRef.value.checkedKeys;
          });
          const displayedIndeterminateKeysRef = vue.computed(() => {
            const { indeterminateKeys } = props;
            if (indeterminateKeys !== void 0)
              return indeterminateKeys;
            return checkedStatusRef.value.indeterminateKeys;
          });
          const uncontrolledSelectedKeysRef = vue.ref([]);
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultSelectedKeys")) {
            vue.watchEffect(() => {
              uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
            });
          } else {
            uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
          }
          const controlledSelectedKeysRef = vue.toRef(props, "selectedKeys");
          const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);
          const uncontrolledExpandedKeysRef = vue.ref([]);
          const initUncontrolledExpandedKeys = (keys2) => {
            uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys2 === void 0 ? props.defaultExpandedKeys : keys2;
          };
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultExpandedKeys")) {
            vue.watchEffect(() => {
              initUncontrolledExpandedKeys(void 0);
            });
          } else {
            vue.watchEffect(() => {
              initUncontrolledExpandedKeys(props.defaultExpandedKeys);
            });
          }
          const controlledExpandedKeysRef = vue.toRef(props, "expandedKeys");
          const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
          const fNodesRef = vue.computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));
          const { pendingNodeKeyRef, handleKeydown } = useKeyboard({
            props,
            mergedSelectedKeysRef,
            fNodesRef,
            mergedExpandedKeysRef,
            handleSelect,
            handleSwitcherClick
          });
          let expandTimerId = null;
          let nodeKeyToBeExpanded = null;
          const uncontrolledHighlightKeySetRef = vue.ref(/* @__PURE__ */ new Set());
          const controlledHighlightKeySetRef = vue.computed(() => {
            return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;
          });
          const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);
          const loadingKeysRef = vue.ref(/* @__PURE__ */ new Set());
          const expandedNonLoadingKeysRef = vue.computed(() => {
            return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));
          });
          let dragStartX = 0;
          const draggingNodeRef = vue.ref(null);
          const droppingNodeRef = vue.ref(null);
          const droppingMouseNodeRef = vue.ref(null);
          const droppingPositionRef = vue.ref(null);
          const droppingOffsetLevelRef = vue.ref(0);
          const droppingNodeParentRef = vue.computed(() => {
            const { value: droppingNode } = droppingNodeRef;
            if (!droppingNode)
              return null;
            return droppingNode.parent;
          });
          vue.watch(vue.toRef(props, "data"), () => {
            loadingKeysRef.value.clear();
            pendingNodeKeyRef.value = null;
            resetDndState();
          }, {
            deep: false
          });
          let expandAnimationDisabled = false;
          const disableExpandAnimationForOneTick = () => {
            expandAnimationDisabled = true;
            void vue.nextTick(() => {
              expandAnimationDisabled = false;
            });
          };
          let memoizedExpandedKeys;
          vue.watch(vue.toRef(props, "pattern"), (value, oldValue) => {
            if (props.showIrrelevantNodes) {
              memoizedExpandedKeys = void 0;
              if (value) {
                const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);
                uncontrolledHighlightKeySetRef.value = highlightKeySet;
                disableExpandAnimationForOneTick();
                doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), { node: null, action: "filter" });
              } else {
                uncontrolledHighlightKeySetRef.value = /* @__PURE__ */ new Set();
              }
            } else {
              if (!value.length) {
                if (memoizedExpandedKeys !== void 0) {
                  disableExpandAnimationForOneTick();
                  doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), { node: null, action: "filter" });
                }
              } else {
                if (!oldValue.length) {
                  memoizedExpandedKeys = mergedExpandedKeysRef.value;
                }
                const { expandedKeys } = filteredTreeInfoRef.value;
                if (expandedKeys !== void 0) {
                  disableExpandAnimationForOneTick();
                  doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {
                    node: null,
                    action: "filter"
                  });
                }
              }
            }
          });
          function triggerLoading(node) {
            return __awaiter$3(this, void 0, void 0, function* () {
              const { onLoad } = props;
              if (!onLoad) {
                yield Promise.resolve();
                return;
              }
              const { value: loadingKeys } = loadingKeysRef;
              if (!loadingKeys.has(node.key)) {
                loadingKeys.add(node.key);
                try {
                  const loadResult = yield onLoad(node.rawNode);
                  if (loadResult === false) {
                    resetDragExpandState();
                  }
                } catch (loadError) {
                  console.error(loadError);
                  resetDragExpandState();
                }
                loadingKeys.delete(node.key);
              }
            });
          }
          vue.watchEffect(() => {
            var _a;
            const { value: displayTreeMate } = displayTreeMateRef;
            if (!displayTreeMate)
              return;
            const { getNode } = displayTreeMate;
            (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
              const node = getNode(key);
              if (node && !node.shallowLoaded) {
                void triggerLoading(node);
              }
            });
          });
          const aipRef = vue.ref(false);
          const afNodesRef = vue.ref([]);
          vue.watch(expandedNonLoadingKeysRef, (value, prevValue) => {
            if (!props.animated || expandAnimationDisabled) {
              void vue.nextTick(syncScrollbar);
              return;
            }
            const prevVSet = new Set(prevValue);
            let addedKey = null;
            let removedKey = null;
            for (const expandedKey of value) {
              if (!prevVSet.has(expandedKey)) {
                if (addedKey !== null)
                  return;
                addedKey = expandedKey;
              }
            }
            const currentVSet = new Set(value);
            for (const expandedKey of prevValue) {
              if (!currentVSet.has(expandedKey)) {
                if (removedKey !== null)
                  return;
                removedKey = expandedKey;
              }
            }
            if (addedKey === null && removedKey === null) {
              return;
            }
            const { virtualScroll } = props;
            const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;
            const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;
            let baseExpandedKeys;
            if (addedKey !== null) {
              baseExpandedKeys = prevValue;
            }
            if (removedKey !== null) {
              if (baseExpandedKeys === void 0) {
                baseExpandedKeys = value;
              } else {
                baseExpandedKeys = baseExpandedKeys.filter((key) => key !== removedKey);
              }
            }
            aipRef.value = true;
            afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);
            if (addedKey !== null) {
              const expandedNodeIndex = afNodesRef.value.findIndex((node) => node.key === addedKey);
              if (~expandedNodeIndex) {
                const children = (
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  afNodesRef.value[expandedNodeIndex].children
                );
                if (children) {
                  const expandedChildren = flatten$1(children, value);
                  afNodesRef.value.splice(expandedNodeIndex + 1, 0, {
                    __motion: true,
                    mode: "expand",
                    height: virtualScroll ? expandedChildren.length * ITEM_SIZE : void 0,
                    nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren
                  });
                }
              }
            }
            if (removedKey !== null) {
              const collapsedNodeIndex = afNodesRef.value.findIndex((node) => node.key === removedKey);
              if (~collapsedNodeIndex) {
                const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;
                if (!collapsedNodeChildren)
                  return;
                aipRef.value = true;
                const collapsedChildren = flatten$1(collapsedNodeChildren, value);
                afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {
                  __motion: true,
                  mode: "collapse",
                  height: virtualScroll ? collapsedChildren.length * ITEM_SIZE : void 0,
                  nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren
                });
              }
            }
          });
          const getFIndexRef = vue.computed(() => {
            return createIndexGetter(fNodesRef.value);
          });
          const mergedFNodesRef = vue.computed(() => {
            if (aipRef.value)
              return afNodesRef.value;
            else
              return fNodesRef.value;
          });
          function syncScrollbar() {
            const { value: scrollbarInst } = scrollbarInstRef;
            if (scrollbarInst)
              scrollbarInst.sync();
          }
          function handleAfterEnter() {
            aipRef.value = false;
            if (props.virtualScroll) {
              void vue.nextTick(syncScrollbar);
            }
          }
          function getOptionsByKeys(keys2) {
            const { getNode } = dataTreeMateRef.value;
            return keys2.map((key) => {
              var _a;
              return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
            });
          }
          function doUpdateExpandedKeys(value, option, meta) {
            const { "onUpdate:expandedKeys": _onUpdateExpandedKeys, onUpdateExpandedKeys } = props;
            uncontrolledExpandedKeysRef.value = value;
            if (_onUpdateExpandedKeys) {
              call(_onUpdateExpandedKeys, value, option, meta);
            }
            if (onUpdateExpandedKeys) {
              call(onUpdateExpandedKeys, value, option, meta);
            }
          }
          function doUpdateCheckedKeys(value, option, meta) {
            const { "onUpdate:checkedKeys": _onUpdateCheckedKeys, onUpdateCheckedKeys } = props;
            uncontrolledCheckedKeysRef.value = value;
            if (onUpdateCheckedKeys) {
              call(onUpdateCheckedKeys, value, option, meta);
            }
            if (_onUpdateCheckedKeys) {
              call(_onUpdateCheckedKeys, value, option, meta);
            }
          }
          function doUpdateIndeterminateKeys(value, option) {
            const { "onUpdate:indeterminateKeys": _onUpdateIndeterminateKeys, onUpdateIndeterminateKeys } = props;
            if (_onUpdateIndeterminateKeys) {
              call(_onUpdateIndeterminateKeys, value, option);
            }
            if (onUpdateIndeterminateKeys) {
              call(onUpdateIndeterminateKeys, value, option);
            }
          }
          function doUpdateSelectedKeys(value, option, meta) {
            const { "onUpdate:selectedKeys": _onUpdateSelectedKeys, onUpdateSelectedKeys } = props;
            uncontrolledSelectedKeysRef.value = value;
            if (onUpdateSelectedKeys) {
              call(onUpdateSelectedKeys, value, option, meta);
            }
            if (_onUpdateSelectedKeys) {
              call(_onUpdateSelectedKeys, value, option, meta);
            }
          }
          function doDragEnter(info) {
            const { onDragenter } = props;
            if (onDragenter)
              call(onDragenter, info);
          }
          function doDragLeave(info) {
            const { onDragleave } = props;
            if (onDragleave)
              call(onDragleave, info);
          }
          function doDragEnd(info) {
            const { onDragend } = props;
            if (onDragend)
              call(onDragend, info);
          }
          function doDragStart(info) {
            const { onDragstart } = props;
            if (onDragstart)
              call(onDragstart, info);
          }
          function doDragOver(info) {
            const { onDragover } = props;
            if (onDragover)
              call(onDragover, info);
          }
          function doDrop(info) {
            const { onDrop } = props;
            if (onDrop)
              call(onDrop, info);
          }
          function resetDndState() {
            resetDragState();
            resetDropState();
          }
          function resetDragState() {
            draggingNodeRef.value = null;
          }
          function resetDropState() {
            droppingOffsetLevelRef.value = 0;
            droppingNodeRef.value = null;
            droppingMouseNodeRef.value = null;
            droppingPositionRef.value = null;
            resetDragExpandState();
          }
          function resetDragExpandState() {
            if (expandTimerId) {
              window.clearTimeout(expandTimerId);
              expandTimerId = null;
            }
            nodeKeyToBeExpanded = null;
          }
          function handleCheck(node, checked) {
            if (props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            if (props.internalUnifySelectCheck && !props.multiple) {
              handleSelect(node);
              return;
            }
            const checkedAction = checked ? "check" : "uncheck";
            const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {
              cascade: props.cascade,
              checkStrategy: mergedCheckStrategyRef.value,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
            doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {
              node: node.rawNode,
              action: checkedAction
            });
            doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));
          }
          function toggleExpand(node) {
            if (props.disabled)
              return;
            const { key } = node;
            const { value: mergedExpandedKeys } = mergedExpandedKeysRef;
            const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);
            if (~index) {
              const expandedKeysAfterChange = Array.from(mergedExpandedKeys);
              expandedKeysAfterChange.splice(index, 1);
              doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {
                node: node.rawNode,
                action: "collapse"
              });
            } else {
              const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);
              if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {
                return;
              }
              let nextKeys;
              if (props.accordion) {
                const siblingKeySet = new Set(node.siblings.map(({ key: key2 }) => key2));
                nextKeys = mergedExpandedKeys.filter((expandedKey) => {
                  return !siblingKeySet.has(expandedKey);
                });
                nextKeys.push(key);
              } else {
                nextKeys = mergedExpandedKeys.concat(key);
              }
              doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {
                node: node.rawNode,
                action: "expand"
              });
            }
          }
          function handleSwitcherClick(node) {
            if (props.disabled || aipRef.value)
              return;
            toggleExpand(node);
          }
          function handleSelect(node) {
            if (props.disabled || !props.selectable) {
              return;
            }
            pendingNodeKeyRef.value = node.key;
            if (props.internalUnifySelectCheck) {
              const { value: { checkedKeys, indeterminateKeys } } = checkedStatusRef;
              if (props.multiple) {
                handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));
              } else {
                doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {
                  node: node.rawNode,
                  action: "check"
                });
              }
            }
            if (props.multiple) {
              const selectedKeys = Array.from(mergedSelectedKeysRef.value);
              const index = selectedKeys.findIndex((key) => key === node.key);
              if (~index) {
                if (props.cancelable) {
                  selectedKeys.splice(index, 1);
                }
              } else if (!~index) {
                selectedKeys.push(node.key);
              }
              doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {
                node: node.rawNode,
                action: ~index ? "unselect" : "select"
              });
            } else {
              const selectedKeys = mergedSelectedKeysRef.value;
              if (selectedKeys.includes(node.key)) {
                if (props.cancelable) {
                  doUpdateSelectedKeys([], [], {
                    node: node.rawNode,
                    action: "unselect"
                  });
                }
              } else {
                doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {
                  node: node.rawNode,
                  action: "select"
                });
              }
            }
          }
          function expandDragEnterNode(node) {
            if (expandTimerId) {
              window.clearTimeout(expandTimerId);
              expandTimerId = null;
            }
            if (node.isLeaf)
              return;
            nodeKeyToBeExpanded = node.key;
            const expand = () => {
              if (nodeKeyToBeExpanded !== node.key)
                return;
              const { value: droppingMouseNode } = droppingMouseNodeRef;
              if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {
                const nextKeys = mergedExpandedKeysRef.value.concat(node.key);
                doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {
                  node: node.rawNode,
                  action: "expand"
                });
              }
              expandTimerId = null;
              nodeKeyToBeExpanded = null;
            };
            if (!node.shallowLoaded) {
              expandTimerId = window.setTimeout(() => {
                void triggerLoading(node).then(() => {
                  expand();
                });
              }, 1e3);
            } else {
              expandTimerId = window.setTimeout(() => {
                expand();
              }, 1e3);
            }
          }
          function handleDragEnter({ event, node }) {
            if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            handleDragOver({ event, node }, false);
            doDragEnter({ event, node: node.rawNode });
          }
          function handleDragLeave({ event, node }) {
            if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            doDragLeave({ event, node: node.rawNode });
          }
          function handleDragLeaveTree(e) {
            if (e.target !== e.currentTarget)
              return;
            resetDropState();
          }
          function handleDragEnd({ event, node }) {
            resetDndState();
            if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            doDragEnd({ event, node: node.rawNode });
          }
          function handleDragStart({ event, node }) {
            if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            dragStartX = event.clientX;
            draggingNodeRef.value = node;
            doDragStart({ event, node: node.rawNode });
          }
          function handleDragOver({ event, node }, emit = true) {
            var _a;
            if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            const { value: draggingNode } = draggingNodeRef;
            if (!draggingNode)
              return;
            const { allowDrop, indent } = props;
            if (emit)
              doDragOver({ event, node: node.rawNode });
            const el = event.currentTarget;
            const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();
            const eventOffsetY = event.clientY - elClientTop;
            let mousePosition;
            const allowDropInside = allowDrop({
              node: node.rawNode,
              dropPosition: "inside",
              phase: "drag"
            });
            if (allowDropInside) {
              if (eventOffsetY <= 8) {
                mousePosition = "before";
              } else if (eventOffsetY >= elOffsetHeight - 8) {
                mousePosition = "after";
              } else {
                mousePosition = "inside";
              }
            } else {
              if (eventOffsetY <= elOffsetHeight / 2) {
                mousePosition = "before";
              } else {
                mousePosition = "after";
              }
            }
            const { value: getFindex } = getFIndexRef;
            let finalDropNode;
            let finalDropPosition;
            const hoverNodeFIndex = getFindex(node.key);
            if (hoverNodeFIndex === null) {
              resetDropState();
              return;
            }
            let mouseAtExpandedNonLeafNode = false;
            if (mousePosition === "inside") {
              finalDropNode = node;
              finalDropPosition = "inside";
            } else {
              if (mousePosition === "before") {
                if (node.isFirstChild) {
                  finalDropNode = node;
                  finalDropPosition = "before";
                } else {
                  finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];
                  finalDropPosition = "after";
                }
              } else {
                finalDropNode = node;
                finalDropPosition = "after";
              }
            }
            if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {
              mouseAtExpandedNonLeafNode = true;
              if (finalDropPosition === "after") {
                finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];
                if (!finalDropNode) {
                  finalDropNode = node;
                  finalDropPosition = "inside";
                } else {
                  finalDropPosition = "before";
                }
              }
            }
            const droppingMouseNode = finalDropNode;
            droppingMouseNodeRef.value = droppingMouseNode;
            if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {
              finalDropPosition = "after";
            }
            if (finalDropPosition === "after") {
              let offset = dragStartX - event.clientX;
              let offsetLevel = 0;
              while (offset >= indent / 2 && // divide by 2 to make it easier to trigger
              finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {
                offset -= indent;
                offsetLevel += 1;
                finalDropNode = finalDropNode.parent;
              }
              droppingOffsetLevelRef.value = offsetLevel;
            } else {
              droppingOffsetLevelRef.value = 0;
            }
            if (draggingNode.contains(finalDropNode) || finalDropPosition === "inside" && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {
              if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key)
                ;
              else {
                resetDropState();
                return;
              }
            }
            if (!allowDrop({
              node: finalDropNode.rawNode,
              dropPosition: finalDropPosition,
              phase: "drag"
            })) {
              resetDropState();
              return;
            }
            if (draggingNode.key === finalDropNode.key) {
              resetDragExpandState();
            } else {
              if (nodeKeyToBeExpanded !== finalDropNode.key) {
                if (finalDropPosition === "inside") {
                  if (props.expandOnDragenter) {
                    expandDragEnterNode(finalDropNode);
                    if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {
                      resetDndState();
                      return;
                    }
                  } else {
                    if (!finalDropNode.shallowLoaded) {
                      resetDndState();
                      return;
                    }
                  }
                } else {
                  resetDragExpandState();
                }
              } else {
                if (finalDropPosition !== "inside") {
                  resetDragExpandState();
                }
              }
            }
            droppingPositionRef.value = finalDropPosition;
            droppingNodeRef.value = finalDropNode;
          }
          function handleDrop({ event, node, dropPosition }) {
            if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
              return;
            }
            const { value: draggingNode } = draggingNodeRef;
            const { value: droppingNode } = droppingNodeRef;
            const { value: droppingPosition } = droppingPositionRef;
            if (!draggingNode || !droppingNode || !droppingPosition) {
              return;
            }
            if (!props.allowDrop({
              node: droppingNode.rawNode,
              dropPosition: droppingPosition,
              phase: "drag"
            })) {
              return;
            }
            if (draggingNode.key === droppingNode.key) {
              return;
            }
            if (droppingPosition === "before") {
              const nextNode = draggingNode.getNext({ includeDisabled: true });
              if (nextNode) {
                if (nextNode.key === droppingNode.key) {
                  resetDropState();
                  return;
                }
              }
            }
            if (droppingPosition === "after") {
              const prevNode = draggingNode.getPrev({ includeDisabled: true });
              if (prevNode) {
                if (prevNode.key === droppingNode.key) {
                  resetDropState();
                  return;
                }
              }
            }
            doDrop({
              event,
              node: droppingNode.rawNode,
              dragNode: draggingNode.rawNode,
              dropPosition
            });
            resetDndState();
          }
          function handleScroll() {
            syncScrollbar();
          }
          function handleResize() {
            syncScrollbar();
          }
          function handleFocusout(e) {
            var _a;
            if (props.virtualScroll || props.internalScrollable) {
              const { value: scrollbarInst } = scrollbarInstRef;
              if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {
                return;
              }
              pendingNodeKeyRef.value = null;
            } else {
              const { value: selfEl } = selfElRef;
              if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))
                return;
              pendingNodeKeyRef.value = null;
            }
          }
          vue.watch(pendingNodeKeyRef, (value) => {
            var _a, _b;
            if (value === null)
              return;
            if (props.virtualScroll) {
              (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ key: value });
            } else if (props.internalScrollable) {
              const { value: scrollbarInst } = scrollbarInstRef;
              if (scrollbarInst === null)
                return;
              const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key="${createDataKey(value)}"]`);
              if (!targetEl)
                return;
              scrollbarInst.scrollTo({
                el: targetEl
              });
            }
          });
          vue.provide(treeInjectionKey, {
            loadingKeysRef,
            highlightKeySetRef: mergedHighlightKeySetRef,
            displayedCheckedKeysRef,
            displayedIndeterminateKeysRef,
            mergedSelectedKeysRef,
            mergedExpandedKeysRef,
            mergedThemeRef: themeRef,
            mergedCheckStrategyRef,
            nodePropsRef: vue.toRef(props, "nodeProps"),
            disabledRef: vue.toRef(props, "disabled"),
            checkableRef: vue.toRef(props, "checkable"),
            selectableRef: vue.toRef(props, "selectable"),
            expandOnClickRef: vue.toRef(props, "expandOnClick"),
            onLoadRef: vue.toRef(props, "onLoad"),
            draggableRef: vue.toRef(props, "draggable"),
            blockLineRef: vue.toRef(props, "blockLine"),
            indentRef: vue.toRef(props, "indent"),
            cascadeRef: vue.toRef(props, "cascade"),
            checkOnClickRef: vue.toRef(props, "checkOnClick"),
            checkboxPlacementRef: props.checkboxPlacement,
            droppingMouseNodeRef,
            droppingNodeParentRef,
            draggingNodeRef,
            droppingPositionRef,
            droppingOffsetLevelRef,
            fNodesRef,
            pendingNodeKeyRef,
            disabledFieldRef: vue.toRef(props, "disabledField"),
            internalScrollableRef: vue.toRef(props, "internalScrollable"),
            internalCheckboxFocusableRef: vue.toRef(props, "internalCheckboxFocusable"),
            internalTreeSelect: props.internalTreeSelect,
            renderLabelRef: vue.toRef(props, "renderLabel"),
            renderPrefixRef: vue.toRef(props, "renderPrefix"),
            renderSuffixRef: vue.toRef(props, "renderSuffix"),
            renderSwitcherIconRef: vue.toRef(props, "renderSwitcherIcon"),
            labelFieldRef: vue.toRef(props, "labelField"),
            multipleRef: vue.toRef(props, "multiple"),
            handleSwitcherClick,
            handleDragEnd,
            handleDragEnter,
            handleDragLeave,
            handleDragStart,
            handleDrop,
            handleDragOver,
            handleSelect,
            handleCheck
          });
          function scrollTo(options) {
            var _a;
            (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);
          }
          const exposedMethods = {
            handleKeydown,
            scrollTo,
            getCheckedData: () => {
              if (!props.checkable)
                return { keys: [], options: [] };
              const { checkedKeys } = checkedStatusRef.value;
              return {
                keys: checkedKeys,
                options: getOptionsByKeys(checkedKeys)
              };
            },
            getIndeterminateData: () => {
              if (!props.checkable)
                return { keys: [], options: [] };
              const { indeterminateKeys } = checkedStatusRef.value;
              return {
                keys: indeterminateKeys,
                options: getOptionsByKeys(indeterminateKeys)
              };
            }
          };
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { fontSize: fontSize2, nodeBorderRadius, nodeColorHover, nodeColorPressed, nodeColorActive, arrowColor, loadingColor, nodeTextColor, nodeTextColorDisabled, dropMarkColor } } = themeRef.value;
            return {
              "--n-arrow-color": arrowColor,
              "--n-loading-color": loadingColor,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-node-border-radius": nodeBorderRadius,
              "--n-node-color-active": nodeColorActive,
              "--n-node-color-hover": nodeColorHover,
              "--n-node-color-pressed": nodeColorPressed,
              "--n-node-text-color": nodeTextColor,
              "--n-node-text-color-disabled": nodeTextColorDisabled,
              "--n-drop-mark-color": dropMarkColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("tree", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
            rtlEnabled: rtlEnabledRef,
            fNodes: mergedFNodesRef,
            aip: aipRef,
            selfElRef,
            virtualListInstRef,
            scrollbarInstRef,
            handleFocusout,
            handleDragLeaveTree,
            handleScroll,
            getScrollContainer,
            getScrollContent,
            handleAfterEnter,
            handleResize,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const { fNodes, internalRenderEmpty } = this;
          if (!fNodes.length && internalRenderEmpty) {
            return internalRenderEmpty();
          }
          const { mergedClsPrefix, blockNode, blockLine, draggable, disabled, internalFocusable, checkable, handleKeydown, rtlEnabled, handleFocusout } = this;
          const mergedFocusable = internalFocusable && !disabled;
          const tabindex = mergedFocusable ? "0" : void 0;
          const treeClass = [
            `${mergedClsPrefix}-tree`,
            rtlEnabled && `${mergedClsPrefix}-tree--rtl`,
            checkable && `${mergedClsPrefix}-tree--checkable`,
            (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,
            blockLine && `${mergedClsPrefix}-tree--block-line`
          ];
          const createNode = (tmNode) => {
            return "__motion" in tmNode ? vue.h(MotionWrapper, { height: tmNode.height, nodes: tmNode.nodes, clsPrefix: mergedClsPrefix, mode: tmNode.mode, onAfterEnter: this.handleAfterEnter }) : vue.h(NTreeNode, { key: tmNode.key, tmNode, clsPrefix: mergedClsPrefix });
          };
          if (this.virtualScroll) {
            const { mergedTheme, internalScrollablePadding } = this;
            const padding = getMargin(internalScrollablePadding || "0");
            return vue.h(XScrollbar, { ref: "scrollbarInstRef", onDragleave: draggable ? this.handleDragLeaveTree : void 0, container: this.getScrollContainer, content: this.getScrollContent, class: treeClass, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, tabindex, onKeydown: mergedFocusable ? handleKeydown : void 0, onFocusout: mergedFocusable ? handleFocusout : void 0 }, {
              default: () => {
                var _a2;
                (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
                return vue.h(VVirtualList, { ref: "virtualListInstRef", items: this.fNodes, itemSize: ITEM_SIZE, ignoreItemResize: this.aip, paddingTop: padding.top, paddingBottom: padding.bottom, class: this.themeClass, style: [
                  this.cssVars,
                  {
                    paddingLeft: padding.left,
                    paddingRight: padding.right
                  }
                ], onScroll: this.handleScroll, onResize: this.handleResize, showScrollbar: false, itemResizable: true }, {
                  default: ({ item }) => createNode(item)
                });
              }
            });
          }
          const { internalScrollable } = this;
          treeClass.push(this.themeClass);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          if (internalScrollable) {
            return vue.h(XScrollbar, { class: treeClass, tabindex, onKeydown: mergedFocusable ? handleKeydown : void 0, onFocusout: mergedFocusable ? handleFocusout : void 0, style: this.cssVars, contentStyle: { padding: this.internalScrollablePadding } }, {
              default: () => vue.h("div", { onDragleave: draggable ? this.handleDragLeaveTree : void 0, ref: "selfElRef" }, this.fNodes.map(createNode))
            });
          } else {
            return vue.h("div", { class: treeClass, tabindex, ref: "selfElRef", style: this.cssVars, onKeydown: mergedFocusable ? handleKeydown : void 0, onFocusout: mergedFocusable ? handleFocusout : void 0, onDragleave: draggable ? this.handleDragLeaveTree : void 0 }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [
              vue.h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })
            ]) : fNodes.map(createNode));
          }
        }
      });
      function treeOption2SelectOption(tmNode, labelField) {
        const { rawNode } = tmNode;
        return Object.assign(Object.assign({}, rawNode), { label: rawNode[labelField], value: tmNode.key });
      }
      function treeOption2SelectOptionWithPath(tmNode, path, separator, labelField) {
        const { rawNode } = tmNode;
        return Object.assign(Object.assign({}, rawNode), { value: tmNode.key, label: path.map((v) => v.rawNode[labelField]).join(separator) });
      }
      const style$9 = c$1([cB("tree-select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB("tree-select-menu", `
 position: relative;
 overflow: hidden;
 margin: 4px 0;
 transition: box-shadow .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-menu-border-radius);
 box-shadow: var(--n-menu-box-shadow);
 background-color: var(--n-menu-color);
 outline: none;
 `, [cB("tree", "max-height: var(--n-menu-height);"), cE("empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE("action", `
 padding: var(--n-action-padding);
 transition: 
 color .3s var(--n-bezier);
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), fadeInScaleUpTransition()])]);
      const treeSelectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { bordered: {
        type: Boolean,
        default: true
      }, cascade: Boolean, checkable: Boolean, clearable: Boolean, clearFilterAfterSelect: {
        type: Boolean,
        default: true
      }, consistentMenuWidth: {
        type: Boolean,
        default: true
      }, defaultShow: Boolean, defaultValue: {
        type: [String, Number, Array],
        default: null
      }, disabled: {
        type: Boolean,
        default: void 0
      }, filterable: Boolean, checkStrategy: {
        type: String,
        default: "all"
      }, loading: Boolean, maxTagCount: [String, Number], multiple: Boolean, showPath: Boolean, separator: {
        type: String,
        default: " / "
      }, options: {
        type: Array,
        default: () => []
      }, placeholder: String, placement: {
        type: String,
        default: "bottom-start"
      }, show: {
        type: Boolean,
        default: void 0
      }, size: String, value: [String, Number, Array], to: useAdjustedTo.propTo, menuProps: Object, virtualScroll: {
        type: Boolean,
        default: true
      }, status: String, renderTag: Function }), treeSharedProps), {
        renderLabel: Function,
        renderPrefix: Function,
        renderSuffix: Function,
        nodeProps: Function,
        onBlur: Function,
        onFocus: Function,
        onLoad: Function,
        onUpdateShow: [Function, Array],
        onUpdateValue: [Function, Array],
        "onUpdate:value": [Function, Array],
        "onUpdate:show": [Function, Array],
        /**
         * @deprecated
         */
        leafOnly: Boolean
      });
      const TreeSelect = vue.defineComponent({
        name: "TreeSelect",
        props: treeSelectProps,
        setup(props) {
          const followerInstRef = vue.ref(null);
          const triggerInstRef = vue.ref(null);
          const treeInstRef = vue.ref(null);
          const menuElRef = vue.ref(null);
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const { localeRef } = useLocale("Select");
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef, nTriggerFormBlur, nTriggerFormChange, nTriggerFormFocus, nTriggerFormInput } = useFormItem(props);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const uncontrolledShowRef = vue.ref(props.defaultShow);
          const controlledShowRef = vue.toRef(props, "show");
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const patternRef = vue.ref("");
          const mergedFilterRef = vue.computed(() => {
            const { filter } = props;
            if (filter)
              return filter;
            const { labelField } = props;
            return (pattern2, node) => {
              if (!pattern2.length)
                return true;
              return node[labelField].toLowerCase().includes(pattern2.toLowerCase());
            };
          });
          const dataTreeMateRef = vue.computed(() => createTreeMate(props.options, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, void 0)));
          const { value: initMergedValue } = mergedValueRef;
          const pendingNodeKeyRef = vue.ref(props.checkable ? null : Array.isArray(initMergedValue) && initMergedValue.length ? initMergedValue[initMergedValue.length - 1] : null);
          const mergedCascadeRef = vue.computed(() => {
            return props.multiple && props.cascade && props.checkable;
          });
          const uncontrolledExpandedKeysRef = vue.ref(props.defaultExpandAll ? void 0 : props.defaultExpandedKeys || props.expandedKeys);
          const controlledExpandedKeysRef = vue.toRef(props, "expandedKeys");
          const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
          const focusedRef = vue.ref(false);
          const mergedPlaceholderRef = vue.computed(() => {
            const { placeholder } = props;
            if (placeholder !== void 0)
              return placeholder;
            return localeRef.value.placeholder;
          });
          const treeSelectedKeysRef = vue.computed(() => {
            if (props.checkable)
              return [];
            return treeCheckedKeysRef.value;
          });
          const treeCheckedKeysRef = vue.computed(() => {
            const { value: mergedValue } = mergedValueRef;
            if (props.multiple) {
              if (Array.isArray(mergedValue))
                return mergedValue;
              else
                return [];
            } else {
              if (mergedValue === null || Array.isArray(mergedValue))
                return [];
              else
                return [mergedValue];
            }
          });
          const selectedOptionRef = vue.computed(() => {
            const { multiple, showPath, separator, labelField } = props;
            if (multiple)
              return null;
            const { value: mergedValue } = mergedValueRef;
            if (!Array.isArray(mergedValue) && mergedValue !== null) {
              const { value: treeMate } = dataTreeMateRef;
              const tmNode = treeMate.getNode(mergedValue);
              if (tmNode !== null) {
                return showPath ? treeOption2SelectOptionWithPath(tmNode, treeMate.getPath(mergedValue).treeNodePath, separator, labelField) : treeOption2SelectOption(tmNode, labelField);
              }
            }
            return null;
          });
          const selectedOptionsRef = vue.computed(() => {
            const { multiple, showPath, separator } = props;
            if (!multiple)
              return null;
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue)) {
              const res = [];
              const { value: treeMate } = dataTreeMateRef;
              const { checkedKeys } = treeMate.getCheckedKeys(mergedValue, {
                checkStrategy: props.checkStrategy,
                cascade: mergedCascadeRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              });
              const { labelField } = props;
              checkedKeys.forEach((value) => {
                const tmNode = treeMate.getNode(value);
                if (tmNode !== null) {
                  res.push(showPath ? treeOption2SelectOptionWithPath(tmNode, treeMate.getPath(value).treeNodePath, separator, labelField) : treeOption2SelectOption(tmNode, labelField));
                }
              });
              return res;
            }
            return [];
          });
          const menuPaddingRef = vue.computed(() => {
            const { self: { menuPadding } } = themeRef.value;
            return menuPadding;
          });
          function focusSelection() {
            var _a;
            (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function focusSelectionInput() {
            var _a;
            (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function doUpdateShow(value) {
            const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
            if (onUpdateShow)
              call(onUpdateShow, value);
            if (_onUpdateShow)
              call(_onUpdateShow, value);
            uncontrolledShowRef.value = value;
          }
          function doUpdateValue(value, option, meta) {
            const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
            if (onUpdateValue) {
              call(onUpdateValue, value, option, meta);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value, option, meta);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function doUpdateIndeterminateKeys(value, option) {
            const { onUpdateIndeterminateKeys, "onUpdate:indeterminateKeys": _onUpdateIndeterminateKeys } = props;
            if (onUpdateIndeterminateKeys) {
              call(onUpdateIndeterminateKeys, value, option);
            }
            if (_onUpdateIndeterminateKeys) {
              call(_onUpdateIndeterminateKeys, value, option);
            }
          }
          function doUpdateExpandedKeys(keys2, option, meta) {
            const { onUpdateExpandedKeys, "onUpdate:expandedKeys": _onUpdateExpandedKeys } = props;
            if (onUpdateExpandedKeys) {
              call(onUpdateExpandedKeys, keys2, option, meta);
            }
            if (_onUpdateExpandedKeys) {
              call(_onUpdateExpandedKeys, keys2, option, meta);
            }
            uncontrolledExpandedKeysRef.value = keys2;
          }
          function doFocus(e) {
            const { onFocus } = props;
            if (onFocus)
              onFocus(e);
            nTriggerFormFocus();
          }
          function doBlur(e) {
            closeMenu();
            const { onBlur } = props;
            if (onBlur)
              onBlur(e);
            nTriggerFormBlur();
          }
          function closeMenu() {
            doUpdateShow(false);
          }
          function openMenu() {
            if (!mergedDisabledRef.value) {
              patternRef.value = "";
              doUpdateShow(true);
              if (props.filterable) {
                focusSelectionInput();
              }
            }
          }
          function handleMenuLeave() {
            patternRef.value = "";
          }
          function handleMenuClickoutside(e) {
            var _a;
            if (mergedShowRef.value) {
              if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                closeMenu();
              }
            }
          }
          function handleTriggerClick() {
            if (mergedDisabledRef.value)
              return;
            if (!mergedShowRef.value) {
              openMenu();
            } else {
              if (!props.filterable) {
                closeMenu();
              }
            }
          }
          function getOptionsByKeys(keys2) {
            const { value: { getNode } } = dataTreeMateRef;
            return keys2.map((key) => {
              var _a;
              return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
            });
          }
          function handleUpdateCheckedKeys(keys2, _, meta) {
            const options = getOptionsByKeys(keys2);
            const action = meta.action === "check" ? "select" : "unselect";
            const node = meta.node;
            if (props.multiple) {
              doUpdateValue(keys2, options, { node, action });
              if (props.filterable) {
                focusSelectionInput();
                if (props.clearFilterAfterSelect)
                  patternRef.value = "";
              }
            } else {
              keys2.length ? doUpdateValue(keys2[0], options[0] || null, {
                node,
                action
              }) : doUpdateValue(null, null, { node, action });
              closeMenu();
              focusSelection();
            }
          }
          function handleUpdateIndeterminateKeys(keys2) {
            if (props.checkable) {
              doUpdateIndeterminateKeys(keys2, getOptionsByKeys(keys2));
            }
          }
          function handleTriggerFocus(e) {
            var _a;
            if ((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
              return;
            focusedRef.value = true;
            doFocus(e);
          }
          function handleTriggerBlur(e) {
            var _a;
            if ((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
              return;
            focusedRef.value = false;
            doBlur(e);
          }
          function handleMenuFocusin(e) {
            var _a, _b, _c;
            if (((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) || ((_c = (_b = triggerInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) === null || _c === void 0 ? void 0 : _c.contains(e.relatedTarget))) {
              return;
            }
            focusedRef.value = true;
            doFocus(e);
          }
          function handleMenuFocusout(e) {
            var _a, _b, _c;
            if (((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) || ((_c = (_b = triggerInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) === null || _c === void 0 ? void 0 : _c.contains(e.relatedTarget))) {
              return;
            }
            focusedRef.value = false;
            doBlur(e);
          }
          function handleClear(e) {
            e.stopPropagation();
            const { multiple } = props;
            if (!multiple && props.filterable) {
              closeMenu();
            }
            if (multiple) {
              doUpdateValue([], [], { node: null, action: "clear" });
            } else {
              doUpdateValue(null, null, { node: null, action: "clear" });
            }
          }
          function handleDeleteOption(option) {
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue)) {
              const { value: treeMate } = dataTreeMateRef;
              const { checkedKeys: checkedKeysValue } = treeMate.getCheckedKeys(mergedValue, {
                cascade: mergedCascadeRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              });
              const index = checkedKeysValue.findIndex((key) => key === option.value);
              if (~index) {
                const checkedKeyToBeRemoved = checkedKeysValue[index];
                const checkOptionToBeRemoved = getOptionsByKeys([
                  checkedKeyToBeRemoved
                ])[0];
                if (props.checkable) {
                  const { checkedKeys } = treeMate.uncheck(option.value, checkedKeysValue, {
                    checkStrategy: props.checkStrategy,
                    cascade: mergedCascadeRef.value,
                    allowNotLoaded: props.allowCheckingNotLoaded
                  });
                  doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys), {
                    node: checkOptionToBeRemoved,
                    action: "delete"
                  });
                } else {
                  const nextValue = Array.from(checkedKeysValue);
                  nextValue.splice(index, 1);
                  doUpdateValue(nextValue, getOptionsByKeys(nextValue), {
                    node: checkOptionToBeRemoved,
                    action: "delete"
                  });
                }
              }
            }
          }
          function handlePatternInput(e) {
            const { value } = e.target;
            patternRef.value = value;
          }
          function treeHandleKeydown(e) {
            const { value: treeInst } = treeInstRef;
            if (treeInst) {
              treeInst.handleKeydown(e);
            }
          }
          function handleKeydown(e) {
            if (e.key === "Enter") {
              if (mergedShowRef.value) {
                treeHandleKeydown(e);
                if (!props.multiple) {
                  closeMenu();
                  focusSelection();
                }
              } else {
                openMenu();
              }
              e.preventDefault();
            } else if (e.key === "Escape") {
              if (mergedShowRef.value) {
                markEventEffectPerformed(e);
                closeMenu();
                focusSelection();
              }
            } else {
              if (mergedShowRef.value) {
                treeHandleKeydown(e);
              } else if (e.key === "ArrowDown") {
                openMenu();
              }
            }
          }
          function handleTabOut() {
            closeMenu();
            focusSelection();
          }
          function handleMenuMousedown(e) {
            if (!happensIn(e, "action"))
              e.preventDefault();
          }
          const selectionRenderTagRef = vue.computed(() => {
            const { renderTag } = props;
            if (!renderTag)
              return void 0;
            return function selectionRenderTag({ option, handleClose }) {
              const { value } = option;
              if (value !== void 0) {
                const treeOption = dataTreeMateRef.value.getNode(value);
                if (treeOption) {
                  return renderTag({ option: treeOption.rawNode, handleClose });
                }
              }
              return value;
            };
          });
          vue.provide(treeSelectInjectionKey, {
            pendingNodeKeyRef,
            dataTreeMate: dataTreeMateRef
          });
          function handleTriggerOrMenuResize() {
            var _a;
            if (!mergedShowRef.value)
              return;
            (_a = followerInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          useOnResize(menuElRef, handleTriggerOrMenuResize);
          const mergedCheckStrategyRef = useMergedCheckStrategy(props);
          const exposedCheckedStatusRef = vue.computed(() => {
            if (props.checkable) {
              const mergedValue = mergedValueRef.value;
              if (props.multiple && Array.isArray(mergedValue)) {
                return dataTreeMateRef.value.getCheckedKeys(mergedValue, {
                  cascade: props.cascade,
                  checkStrategy: mergedCheckStrategyRef.value,
                  allowNotLoaded: props.allowCheckingNotLoaded
                });
              } else {
                return {
                  checkedKeys: Array.isArray(mergedValue) || mergedValue === null ? [] : [mergedValue],
                  indeterminateKeys: []
                };
              }
            }
            return {
              checkedKeys: [],
              indeterminateKeys: []
            };
          });
          const exposedMethods = {
            getCheckedData: () => {
              const { checkedKeys } = exposedCheckedStatusRef.value;
              return { keys: checkedKeys, options: getOptionsByKeys(checkedKeys) };
            },
            getIndeterminateData: () => {
              const { indeterminateKeys } = exposedCheckedStatusRef.value;
              return {
                keys: indeterminateKeys,
                options: getOptionsByKeys(indeterminateKeys)
              };
            },
            focus: () => {
              var _a;
              return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          const themeRef = useTheme("TreeSelect", "-tree-select", style$9, treeSelectLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { menuBoxShadow, menuBorderRadius, menuColor, menuHeight, actionPadding, actionDividerColor, actionTextColor } } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow,
              "--n-menu-border-radius": menuBorderRadius,
              "--n-menu-color": menuColor,
              "--n-menu-height": menuHeight,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-action-padding": actionPadding,
              "--n-action-text-color": actionTextColor,
              "--n-action-divider-color": actionDividerColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("tree-select", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedMethods), {
            menuElRef,
            mergedStatus: mergedStatusRef,
            triggerInstRef,
            followerInstRef,
            treeInstRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            mergedShow: mergedShowRef,
            namespace: namespaceRef,
            adjustedTo: useAdjustedTo(props),
            isMounted: isMounted(),
            focused: focusedRef,
            menuPadding: menuPaddingRef,
            mergedPlaceholder: mergedPlaceholderRef,
            mergedExpandedKeys: mergedExpandedKeysRef,
            treeSelectedKeys: treeSelectedKeysRef,
            treeCheckedKeys: treeCheckedKeysRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            selectedOption: selectedOptionRef,
            selectedOptions: selectedOptionsRef,
            pattern: patternRef,
            pendingNodeKey: pendingNodeKeyRef,
            mergedCascade: mergedCascadeRef,
            mergedFilter: mergedFilterRef,
            selectionRenderTag: selectionRenderTagRef,
            handleTriggerOrMenuResize,
            doUpdateExpandedKeys,
            handleMenuLeave,
            handleTriggerClick,
            handleMenuClickoutside,
            handleUpdateCheckedKeys,
            handleUpdateIndeterminateKeys,
            handleTriggerFocus,
            handleTriggerBlur,
            handleMenuFocusin,
            handleMenuFocusout,
            handleClear,
            handleDeleteOption,
            handlePatternInput,
            handleKeydown,
            handleTabOut,
            handleMenuMousedown,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const { mergedTheme, mergedClsPrefix, $slots } = this;
          return vue.h(
            "div",
            { class: `${mergedClsPrefix}-tree-select` },
            vue.h(VBinder, null, {
              default: () => [
                vue.h(VTarget, null, {
                  default: () => vue.h(NInternalSelection, { ref: "triggerInstRef", onResize: this.handleTriggerOrMenuResize, status: this.mergedStatus, focused: this.focused, clsPrefix: mergedClsPrefix, theme: mergedTheme.peers.InternalSelection, themeOverrides: mergedTheme.peerOverrides.InternalSelection, renderTag: this.selectionRenderTag, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, size: this.mergedSize, bordered: this.bordered, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, active: this.mergedShow, loading: this.loading, multiple: this.multiple, maxTagCount: this.maxTagCount, showArrow: true, filterable: this.filterable, clearable: this.clearable, pattern: this.pattern, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onClick: this.handleTriggerClick, onFocus: this.handleTriggerFocus, onBlur: this.handleTriggerBlur, onDeleteOption: this.handleDeleteOption, onKeydown: this.handleKeydown }, {
                    arrow: () => {
                      var _a, _b;
                      return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)];
                    }
                  })
                }),
                vue.h(VFollower, { ref: "followerInstRef", show: this.mergedShow, placement: this.placement, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target" }, {
                  default: () => vue.h(vue.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onLeave: this.handleMenuLeave }, {
                    default: () => {
                      var _a;
                      if (!this.mergedShow)
                        return null;
                      const { mergedClsPrefix: mergedClsPrefix2, checkable, multiple, menuProps: menuProps2, options } = this;
                      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                      return vue.withDirectives(vue.h(
                        "div",
                        Object.assign({}, menuProps2, { class: [
                          `${mergedClsPrefix2}-tree-select-menu`,
                          menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.class,
                          this.themeClass
                        ], ref: "menuElRef", style: [
                          (menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.style) || "",
                          this.cssVars
                        ], tabindex: 0, onMousedown: this.handleMenuMousedown, onKeydown: this.handleKeydown, onFocusin: this.handleMenuFocusin, onFocusout: this.handleMenuFocusout }),
                        vue.h(NTree, { ref: "treeInstRef", blockLine: true, allowCheckingNotLoaded: this.allowCheckingNotLoaded, showIrrelevantNodes: false, animated: false, pattern: this.pattern, filter: this.mergedFilter, data: options, cancelable: multiple, labelField: this.labelField, keyField: this.keyField, disabledField: this.disabledField, childrenField: this.childrenField, theme: mergedTheme.peers.Tree, themeOverrides: mergedTheme.peerOverrides.Tree, defaultExpandAll: this.defaultExpandAll, defaultExpandedKeys: this.defaultExpandedKeys, expandedKeys: this.mergedExpandedKeys, checkedKeys: this.treeCheckedKeys, selectedKeys: this.treeSelectedKeys, checkable, checkStrategy: this.checkStrategy, cascade: this.mergedCascade, leafOnly: this.leafOnly, multiple: this.multiple, renderLabel: this.renderLabel, renderPrefix: this.renderPrefix, renderSuffix: this.renderSuffix, renderSwitcherIcon: this.renderSwitcherIcon, nodeProps: this.nodeProps, virtualScroll: this.consistentMenuWidth && this.virtualScroll, internalTreeSelect: true, internalUnifySelectCheck: true, internalScrollable: true, internalScrollablePadding: this.menuPadding, internalFocusable: false, internalCheckboxFocusable: false, internalRenderEmpty: () => vue.h("div", { class: `${mergedClsPrefix2}-tree-select-menu__empty` }, resolveSlot($slots.empty, () => [
                          vue.h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
                        ])), onLoad: this.onLoad, onUpdateCheckedKeys: this.handleUpdateCheckedKeys, onUpdateIndeterminateKeys: this.handleUpdateIndeterminateKeys, onUpdateExpandedKeys: this.doUpdateExpandedKeys }),
                        resolveWrappedSlot($slots.action, (children) => {
                          return children ? vue.h("div", { class: `${mergedClsPrefix2}-tree-select-menu__action`, "data-action": true }, children) : null;
                        }),
                        vue.h(FocusDetector, { onFocus: this.handleTabOut })
                      ), [
                        [
                          clickoutside$1,
                          this.handleMenuClickoutside,
                          void 0,
                          { capture: true }
                        ]
                      ]);
                    }
                  })
                })
              ]
            })
          );
        }
      });
      const style$8 = cB("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [c$1("&:first-child", {
        marginTop: 0
      }), cM("prefix-bar", {
        position: "relative",
        paddingLeft: "var(--n-prefix-width)"
      }, [cM("align-text", {
        paddingLeft: 0
      }, [c$1("&::before", {
        left: "calc(-1 * var(--n-prefix-width))"
      })]), c$1("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), c$1("&::before", {
        backgroundColor: "var(--n-bar-color)"
      })])]);
      const headerProps = Object.assign(Object.assign({}, useTheme.props), { type: {
        type: String,
        default: "default"
      }, prefix: String, alignText: Boolean });
      const createHeader = (level) => vue.defineComponent({
        name: `H${level}`,
        props: headerProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-h", style$8, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { type: type2 } = props;
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { headerFontWeight, headerTextColor, [createKey("headerPrefixWidth", level)]: prefixWidth, [createKey("headerFontSize", level)]: fontSize2, [createKey("headerMargin", level)]: margin, [createKey("headerBarWidth", level)]: barWidth, [createKey("headerBarColor", type2)]: barColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-margin": margin,
              "--n-bar-color": barColor,
              "--n-bar-width": barWidth,
              "--n-font-weight": headerFontWeight,
              "--n-text-color": headerTextColor,
              "--n-prefix-width": prefixWidth
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass(`h${level}`, vue.computed(() => props.type[0]), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { prefix: prefix2, alignText, mergedClsPrefix, cssVars, $slots } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(`h${level}`, {
            class: [
              `${mergedClsPrefix}-h`,
              `${mergedClsPrefix}-h${level}`,
              this.themeClass,
              {
                [`${mergedClsPrefix}-h--prefix-bar`]: prefix2,
                [`${mergedClsPrefix}-h--align-text`]: alignText
              }
            ],
            style: cssVars
          }, $slots);
        }
      });
      const NH1 = createHeader("1");
      const NH2 = createHeader("2");
      const NH3 = createHeader("3");
      const NH4 = createHeader("4");
      const NH5 = createHeader("5");
      const NH6 = createHeader("6");
      const style$7 = cB("a", `
 cursor: pointer;
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 text-decoration-color: var(--n-text-color);
 color: var(--n-text-color);
`);
      const aProps = Object.assign({}, useTheme.props);
      const a = vue.defineComponent({
        name: "A",
        props: aProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-a", style$7, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { aTextColor } } = themeRef.value;
            return {
              "--n-text-color": aTextColor,
              "--n-bezier": cubicBezierEaseInOut2
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("a", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("a", { class: [`${this.mergedClsPrefix}-a`, this.themeClass], style: this.cssVars }, this.$slots);
        }
      });
      const style$6 = cB("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [c$1("&:first-child", "margin-top: 0;"), c$1("&:last-child", "margin-bottom: 0;")]);
      const pProps = Object.assign(Object.assign({}, useTheme.props), { depth: [String, Number] });
      const p = vue.defineComponent({
        name: "P",
        props: pProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-p", style$6, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { depth } = props;
            const typeSafeDepth = depth || "1";
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { pFontSize, pLineHeight, pMargin, pTextColor, [`pTextColor${typeSafeDepth}Depth`]: depthTextColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": pFontSize,
              "--n-line-height": pLineHeight,
              "--n-margin": pMargin,
              "--n-text-color": depth === void 0 ? pTextColor : depthTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("p", vue.computed(() => `${props.depth || ""}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
        }
      });
      const style$5 = cB("blockquote", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 margin: 0;
 margin-top: 12px;
 margin-bottom: 12px;
 box-sizing: border-box;
 padding-left: 12px;
 border-left: 4px solid var(--n-prefix-color);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [c$1("&:first-child", {
        marginTop: 0
      }), c$1("&:last-child", {
        marginBottom: 0
      }), cM("align-text", {
        marginLeft: "-16px"
      })]);
      const blockquoteProps = Object.assign(Object.assign({}, useTheme.props), { alignText: Boolean });
      const blockquote = vue.defineComponent({
        name: "Blockquote",
        props: blockquoteProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-blockquote", style$5, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { blockquoteTextColor, blockquotePrefixColor, blockquoteLineHeight, blockquoteFontSize } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": blockquoteFontSize,
              "--n-line-height": blockquoteLineHeight,
              "--n-prefix-color": blockquotePrefixColor,
              "--n-text-color": blockquoteTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("blockquote", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("blockquote", { class: [
            `${mergedClsPrefix}-blockquote`,
            this.themeClass,
            this.alignText && `${mergedClsPrefix}-blockquote--align-text`
          ], style: this.cssVars }, this.$slots);
        }
      });
      const style$4 = cB("hr", `
 margin: 12px 0;
 transition: border-color .3s var(--n-bezier);
 border-left: none;
 border-right: none;
 border-bottom: none;
 border-top: 1px solid var(--n-color);
`);
      const hr = vue.defineComponent({
        name: "Hr",
        props: Object.assign({}, useTheme.props),
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-hr", style$4, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { hrColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": hrColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("hr", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("hr", { class: [`${this.mergedClsPrefix}-hr`, this.themeClass], style: this.cssVars });
        }
      });
      const liStyle = c$1("li", {
        transition: "color .3s var(--n-bezier)",
        lineHeight: "var(--n-line-height)",
        margin: "var(--n-li-margin)",
        marginBottom: 0,
        color: "var(--n-text-color)"
      });
      const childStyle = [c$1("&:first-child", `
 margin-top: 0;
 `), c$1("&:last-child", `
 margin-bottom: 0;
 `)];
      const style$3 = c$1([cB("ol", {
        fontSize: "var(--n-font-size)",
        padding: "var(--n-ol-padding)"
      }, [cM("align-text", {
        paddingLeft: 0
      }), liStyle, childStyle]), cB("ul", {
        fontSize: "var(--n-font-size)",
        padding: "var(--n-ul-padding)"
      }, [cM("align-text", {
        paddingLeft: 0
      }), liStyle, childStyle])]);
      const ulProps = Object.assign(Object.assign({}, useTheme.props), { alignText: Boolean });
      const ul = vue.defineComponent({
        name: "Ul",
        props: ulProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-xl", style$3, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { olPadding, ulPadding, liMargin, liTextColor, liLineHeight, liFontSize } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": liFontSize,
              "--n-line-height": liLineHeight,
              "--n-text-color": liTextColor,
              "--n-li-margin": liMargin,
              "--n-ol-padding": olPadding,
              "--n-ul-padding": ulPadding
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("ul", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("ul", { class: [
            `${mergedClsPrefix}-ul`,
            this.themeClass,
            this.alignText && `${mergedClsPrefix}-ul--align-text`
          ], style: this.cssVars }, this.$slots);
        }
      });
      const olProps = Object.assign(Object.assign({}, useTheme.props), { alignText: Boolean });
      const ol = vue.defineComponent({
        name: "Ol",
        props: olProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-xl", style$3, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { olPadding, ulPadding, liMargin, liTextColor, liLineHeight, liFontSize } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": liFontSize,
              "--n-line-height": liLineHeight,
              "--n-text-color": liTextColor,
              "--n-li-margin": liMargin,
              "--n-ol-padding": olPadding,
              "--n-ul-padding": ulPadding
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("ol", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("ol", { class: [
            `${mergedClsPrefix}-ol`,
            this.themeClass,
            this.alignText && `${mergedClsPrefix}-ol--align-text`
          ], style: this.cssVars }, this.$slots);
        }
      });
      const li = vue.defineComponent({
        name: "Li",
        render() {
          return vue.h("li", null, this.$slots);
        }
      });
      const style$2 = cB("text", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cM("italic", {
        fontStyle: "italic"
      }), cM("underline", {
        textDecoration: "underline"
      }), cM("code", `
 line-height: 1.4;
 display: inline-block;
 font-family: var(--n-font-famliy-mono);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 box-sizing: border-box;
 padding: .05em .35em 0 .35em;
 border-radius: var(--n-code-border-radius);
 font-size: .9em;
 color: var(--n-code-text-color);
 background-color: var(--n-code-color);
 border: var(--n-code-border);
 `)]);
      const textProps = Object.assign(Object.assign({}, useTheme.props), {
        code: Boolean,
        type: {
          type: String,
          default: "default"
        },
        delete: Boolean,
        strong: Boolean,
        italic: Boolean,
        underline: Boolean,
        depth: [String, Number],
        tag: String,
        // deprecated
        as: {
          type: String,
          validator: () => {
            return true;
          },
          default: void 0
        }
      });
      const NText = vue.defineComponent({
        name: "Text",
        props: textProps,
        setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Typography", "-text", style$2, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const { depth, type: type2 } = props;
            const textColorKey = type2 === "default" ? depth === void 0 ? "textColor" : `textColor${depth}Depth` : createKey("textColor", type2);
            const { common: { fontWeightStrong, fontFamilyMono, cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { codeTextColor, codeBorderRadius, codeColor, codeBorder, [textColorKey]: textColor } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-font-weight-strong": fontWeightStrong,
              "--n-font-famliy-mono": fontFamilyMono,
              "--n-code-border-radius": codeBorderRadius,
              "--n-code-text-color": codeTextColor,
              "--n-code-color": codeColor,
              "--n-code-border": codeBorder
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("text", vue.computed(() => `${props.type[0]}${props.depth || ""}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            compitableTag: useCompitable(props, ["as", "tag"]),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a, _b, _c;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const textClass = [
            `${mergedClsPrefix}-text`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-text--code`]: this.code,
              [`${mergedClsPrefix}-text--delete`]: this.delete,
              [`${mergedClsPrefix}-text--strong`]: this.strong,
              [`${mergedClsPrefix}-text--italic`]: this.italic,
              [`${mergedClsPrefix}-text--underline`]: this.underline
            }
          ];
          const children = (_c = (_b = this.$slots).default) === null || _c === void 0 ? void 0 : _c.call(_b);
          return this.code ? vue.h("code", { class: textClass, style: this.cssVars }, this.delete ? vue.h("del", null, children) : children) : this.delete ? vue.h("del", { class: textClass, style: this.cssVars }, children) : vue.h(this.compitableTag || "span", { class: textClass, style: this.cssVars }, children);
        }
      });
      const uploadInjectionKey = createInjectionKey("n-upload");
      const uploadDraggerKey = "__UPLOAD_DRAGGER__";
      const NUploadDragger = vue.defineComponent({
        name: "UploadDragger",
        [uploadDraggerKey]: true,
        setup(_, { slots }) {
          const NUpload = vue.inject(uploadInjectionKey, null);
          if (!NUpload) {
            throwError("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`.");
          }
          return () => {
            const { mergedClsPrefixRef: { value: mergedClsPrefix }, mergedDisabledRef: { value: mergedDisabled }, maxReachedRef: { value: maxReached } } = NUpload;
            return vue.h("div", { class: [
              `${mergedClsPrefix}-upload-dragger`,
              (mergedDisabled || maxReached) && `${mergedClsPrefix}-upload-dragger--disabled`
            ] }, slots);
          };
        }
      });
      var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const isImageFileType = (type2) => type2.includes("image/");
      const getExtname = (url = "") => {
        const temp = url.split("/");
        const filename = temp[temp.length - 1];
        const filenameWithoutSuffix = filename.split(/#|\?/)[0];
        return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
      };
      const imageExtensionRegex = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i;
      const isImageFile = (file) => {
        if (file.type) {
          return isImageFileType(file.type);
        }
        const fileNameExtension = getExtname(file.name || "");
        if (imageExtensionRegex.test(fileNameExtension)) {
          return true;
        }
        const url = file.thumbnailUrl || file.url || "";
        const urlExtension = getExtname(url);
        if (/^data:image\//.test(url) || imageExtensionRegex.test(urlExtension)) {
          return true;
        }
        return false;
      };
      function createImageDataUrl(file) {
        return __awaiter$2(this, void 0, void 0, function* () {
          return yield new Promise((resolve) => {
            if (!file.type || !isImageFileType(file.type)) {
              resolve("");
              return;
            }
            resolve(window.URL.createObjectURL(file));
          });
        });
      }
      const environmentSupportFile = isBrowser$2 && window.FileReader && window.File;
      function isFileSystemDirectoryEntry(item) {
        return item.isDirectory;
      }
      function isFileSystemFileEntry(item) {
        return item.isFile;
      }
      function getFilesFromEntries(entries, directory) {
        return __awaiter$2(this, void 0, void 0, function* () {
          const fileAndEntries = [];
          let _resolve;
          let requestCallbackCount = 0;
          function lock() {
            requestCallbackCount++;
          }
          function unlock() {
            requestCallbackCount--;
            if (!requestCallbackCount) {
              _resolve(fileAndEntries);
            }
          }
          function _getFilesFromEntries(entries2) {
            entries2.forEach((entry) => {
              if (!entry)
                return;
              lock();
              if (directory && isFileSystemDirectoryEntry(entry)) {
                const directoryReader = entry.createReader();
                lock();
                directoryReader.readEntries((entries3) => {
                  _getFilesFromEntries(entries3);
                  unlock();
                }, () => {
                  unlock();
                });
              } else if (isFileSystemFileEntry(entry)) {
                lock();
                entry.file((file) => {
                  fileAndEntries.push({ file, entry, source: "dnd" });
                  unlock();
                }, () => {
                  unlock();
                });
              }
              unlock();
            });
          }
          yield new Promise((resolve) => {
            _resolve = resolve;
            _getFilesFromEntries(entries);
          });
          return fileAndEntries;
        });
      }
      function createSettledFileInfo(fileInfo) {
        const { id, name, percentage, status, url, file, thumbnailUrl, type: type2, fullPath, batchId } = fileInfo;
        return {
          id,
          name,
          percentage: percentage !== null && percentage !== void 0 ? percentage : null,
          status,
          url: url !== null && url !== void 0 ? url : null,
          file: file !== null && file !== void 0 ? file : null,
          thumbnailUrl: thumbnailUrl !== null && thumbnailUrl !== void 0 ? thumbnailUrl : null,
          type: type2 !== null && type2 !== void 0 ? type2 : null,
          fullPath: fullPath !== null && fullPath !== void 0 ? fullPath : null,
          batchId: batchId !== null && batchId !== void 0 ? batchId : null
        };
      }
      function matchType(name, mimeType, accept) {
        name = name.toLowerCase();
        mimeType = mimeType.toLocaleLowerCase();
        accept = accept.toLocaleLowerCase();
        const acceptAtoms = accept.split(",").map((acceptAtom) => acceptAtom.trim()).filter(Boolean);
        return acceptAtoms.some((acceptAtom) => {
          if (acceptAtom.startsWith(".")) {
            if (name.endsWith(acceptAtom))
              return true;
          } else if (acceptAtom.includes("/")) {
            const [type2, subtype] = mimeType.split("/");
            const [acceptType, acceptSubtype] = acceptAtom.split("/");
            if (acceptType === "*" || type2 && acceptType && acceptType === type2) {
              if (acceptSubtype === "*" || subtype && acceptSubtype && acceptSubtype === subtype) {
                return true;
              }
            }
          } else {
            return true;
          }
          return false;
        });
      }
      const download = (url, name) => {
        if (!url)
          return;
        const a2 = document.createElement("a");
        a2.href = url;
        if (name !== void 0) {
          a2.download = name;
        }
        document.body.appendChild(a2);
        a2.click();
        document.body.removeChild(a2);
      };
      const NUploadTrigger = vue.defineComponent({
        name: "UploadTrigger",
        props: {
          abstract: Boolean
        },
        setup(props, { slots }) {
          const NUpload = vue.inject(uploadInjectionKey, null);
          if (!NUpload) {
            throwError("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
          }
          const { mergedClsPrefixRef, mergedDisabledRef, maxReachedRef, listTypeRef, dragOverRef, openOpenFileDialog, draggerInsideRef, handleFileAddition, mergedDirectoryDndRef, triggerStyleRef } = NUpload;
          const isImageCardTypeRef = vue.computed(() => listTypeRef.value === "image-card");
          function handleTriggerClick() {
            if (mergedDisabledRef.value || maxReachedRef.value)
              return;
            openOpenFileDialog();
          }
          function handleTriggerDragOver(e) {
            e.preventDefault();
            dragOverRef.value = true;
          }
          function handleTriggerDragEnter(e) {
            e.preventDefault();
            dragOverRef.value = true;
          }
          function handleTriggerDragLeave(e) {
            e.preventDefault();
            dragOverRef.value = false;
          }
          function handleTriggerDrop(e) {
            var _a;
            e.preventDefault();
            if (!draggerInsideRef.value || mergedDisabledRef.value || maxReachedRef.value) {
              dragOverRef.value = false;
              return;
            }
            const dataTransferItems = (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.items;
            if (dataTransferItems === null || dataTransferItems === void 0 ? void 0 : dataTransferItems.length) {
              void getFilesFromEntries(Array.from(dataTransferItems).map((item) => item.webkitGetAsEntry()), mergedDirectoryDndRef.value).then((files) => {
                handleFileAddition(files);
              }).finally(() => {
                dragOverRef.value = false;
              });
            } else {
              dragOverRef.value = false;
            }
          }
          return () => {
            var _a;
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            return props.abstract ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
              handleClick: handleTriggerClick,
              handleDrop: handleTriggerDrop,
              handleDragOver: handleTriggerDragOver,
              handleDragEnter: handleTriggerDragEnter,
              handleDragLeave: handleTriggerDragLeave
            }) : vue.h("div", { class: [
              `${mergedClsPrefix}-upload-trigger`,
              (mergedDisabledRef.value || maxReachedRef.value) && `${mergedClsPrefix}-upload-trigger--disabled`,
              isImageCardTypeRef.value && `${mergedClsPrefix}-upload-trigger--image-card`
            ], style: triggerStyleRef.value, onClick: handleTriggerClick, onDrop: handleTriggerDrop, onDragover: handleTriggerDragOver, onDragenter: handleTriggerDragEnter, onDragleave: handleTriggerDragLeave }, isImageCardTypeRef.value ? vue.h(NUploadDragger, null, {
              default: () => resolveSlot(slots.default, () => [
                vue.h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => vue.h(AddIcon, null) })
              ])
            }) : slots);
          };
        }
      });
      const NUploadProgress = vue.defineComponent({
        name: "UploadProgress",
        props: {
          show: Boolean,
          percentage: {
            type: Number,
            required: true
          },
          status: {
            type: String,
            required: true
          }
        },
        setup() {
          const NUpload = vue.inject(uploadInjectionKey);
          return {
            mergedTheme: NUpload.mergedThemeRef
          };
        },
        render() {
          return vue.h(NFadeInExpandTransition, null, {
            default: () => this.show ? vue.h(NProgress, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null
          });
        }
      });
      const imageIcon = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" },
        vue.h(
          "g",
          { fill: "none" },
          vue.h("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" })
        )
      );
      const documentIcon = vue.h(
        "svg",
        { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" },
        vue.h(
          "g",
          { fill: "none" },
          vue.h("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" })
        )
      );
      var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const buttonThemeOverrides = {
        paddingMedium: "0 3px",
        heightMedium: "24px",
        iconSizeMedium: "18px"
      };
      const NUploadFile = vue.defineComponent({
        name: "UploadFile",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          file: {
            type: Object,
            required: true
          },
          listType: {
            type: String,
            required: true
          }
        },
        setup(props) {
          const NUpload = vue.inject(uploadInjectionKey);
          const imageRef = vue.ref(null);
          const thumbnailUrlRef = vue.ref("");
          const progressStatusRef = vue.computed(() => {
            const { file } = props;
            if (file.status === "finished")
              return "success";
            if (file.status === "error")
              return "error";
            return "info";
          });
          const buttonTypeRef = vue.computed(() => {
            const { file } = props;
            if (file.status === "error")
              return "error";
            return void 0;
          });
          const showProgressRef = vue.computed(() => {
            const { file } = props;
            return file.status === "uploading";
          });
          const showCancelButtonRef = vue.computed(() => {
            if (!NUpload.showCancelButtonRef.value)
              return false;
            const { file } = props;
            return ["uploading", "pending", "error"].includes(file.status);
          });
          const showRemoveButtonRef = vue.computed(() => {
            if (!NUpload.showRemoveButtonRef.value)
              return false;
            const { file } = props;
            return ["finished"].includes(file.status);
          });
          const showDownloadButtonRef = vue.computed(() => {
            if (!NUpload.showDownloadButtonRef.value)
              return false;
            const { file } = props;
            return ["finished"].includes(file.status);
          });
          const showRetryButtonRef = vue.computed(() => {
            if (!NUpload.showRetryButtonRef.value)
              return false;
            const { file } = props;
            return ["error"].includes(file.status);
          });
          const mergedThumbnailUrlRef = useMemo(() => {
            return thumbnailUrlRef.value || props.file.thumbnailUrl || props.file.url;
          });
          const showPreviewButtonRef = vue.computed(() => {
            if (!NUpload.showPreviewButtonRef.value)
              return false;
            const { file: { status }, listType } = props;
            return ["finished"].includes(status) && mergedThumbnailUrlRef.value && listType === "image-card";
          });
          function handleRetryClick() {
            NUpload.submit(props.file.id);
          }
          function handleRemoveOrCancelClick(e) {
            e.preventDefault();
            const { file } = props;
            if (["finished", "pending", "error"].includes(file.status)) {
              handleRemove(file);
            } else if (["uploading"].includes(file.status)) {
              handleAbort(file);
            } else {
              warn$2("upload", "The button clicked type is unknown.");
            }
          }
          function handleDownloadClick(e) {
            e.preventDefault();
            handleDownload(props.file);
          }
          function handleRemove(file) {
            const { xhrMap, doChange, onRemoveRef: { value: onRemove }, mergedFileListRef: { value: mergedFileList } } = NUpload;
            void Promise.resolve(onRemove ? onRemove({
              file: Object.assign({}, file),
              fileList: mergedFileList
            }) : true).then((result) => {
              if (result === false)
                return;
              const fileAfterChange = Object.assign({}, file, {
                status: "removed"
              });
              xhrMap.delete(file.id);
              doChange(fileAfterChange, void 0, {
                remove: true
              });
            });
          }
          function handleDownload(file) {
            const { onDownloadRef: { value: onDownload } } = NUpload;
            void Promise.resolve(onDownload ? onDownload(Object.assign({}, file)) : true).then((res) => {
              if (res !== false) {
                download(file.url, file.name);
              }
            });
          }
          function handleAbort(file) {
            const { xhrMap } = NUpload;
            const xhr = xhrMap.get(file.id);
            xhr === null || xhr === void 0 ? void 0 : xhr.abort();
            handleRemove(Object.assign({}, file));
          }
          function handlePreviewClick() {
            const { onPreviewRef: { value: onPreview } } = NUpload;
            if (onPreview) {
              onPreview(props.file);
            } else if (props.listType === "image-card") {
              const { value } = imageRef;
              if (!value)
                return;
              value.click();
            }
          }
          const deriveFileThumbnailUrl = () => __awaiter$1(this, void 0, void 0, function* () {
            const { listType } = props;
            if (listType !== "image" && listType !== "image-card") {
              return;
            }
            if (NUpload.shouldUseThumbnailUrlRef.value(props.file)) {
              thumbnailUrlRef.value = yield NUpload.getFileThumbnailUrlResolver(props.file);
            }
          });
          vue.watchEffect(() => {
            void deriveFileThumbnailUrl();
          });
          return {
            mergedTheme: NUpload.mergedThemeRef,
            progressStatus: progressStatusRef,
            buttonType: buttonTypeRef,
            showProgress: showProgressRef,
            disabled: NUpload.mergedDisabledRef,
            showCancelButton: showCancelButtonRef,
            showRemoveButton: showRemoveButtonRef,
            showDownloadButton: showDownloadButtonRef,
            showRetryButton: showRetryButtonRef,
            showPreviewButton: showPreviewButtonRef,
            mergedThumbnailUrl: mergedThumbnailUrlRef,
            shouldUseThumbnailUrl: NUpload.shouldUseThumbnailUrlRef,
            renderIcon: NUpload.renderIconRef,
            imageRef,
            handleRemoveOrCancelClick,
            handleDownloadClick,
            handleRetryClick,
            handlePreviewClick
          };
        },
        render() {
          const { clsPrefix, mergedTheme, listType, file, renderIcon } = this;
          let icon;
          const isImageType = listType === "image";
          const isImageCardType = listType === "image-card";
          if (isImageType || isImageCardType) {
            icon = !this.shouldUseThumbnailUrl(file) || !this.mergedThumbnailUrl ? vue.h("span", { class: `${clsPrefix}-upload-file-info__thumbnail` }, renderIcon ? renderIcon(file) : isImageFile(file) ? vue.h(NBaseIcon, { clsPrefix }, { default: () => imageIcon }) : vue.h(NBaseIcon, { clsPrefix }, { default: () => documentIcon })) : vue.h("a", { rel: "noopener noreferer", target: "_blank", href: file.url || void 0, class: `${clsPrefix}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, listType === "image-card" ? vue.h(NImage, { src: this.mergedThumbnailUrl || void 0, previewSrc: file.url || void 0, alt: file.name, ref: "imageRef" }) : vue.h("img", { src: this.mergedThumbnailUrl || void 0, alt: file.name }));
          } else {
            icon = vue.h("span", { class: `${clsPrefix}-upload-file-info__thumbnail` }, renderIcon ? renderIcon(file) : vue.h(NBaseIcon, { clsPrefix }, { default: () => vue.h(AttachIcon, null) }));
          }
          const progress = vue.h(NUploadProgress, { show: this.showProgress, percentage: file.percentage || 0, status: this.progressStatus });
          const showName = listType === "text" || listType === "image";
          return vue.h(
            "div",
            { class: [
              `${clsPrefix}-upload-file`,
              `${clsPrefix}-upload-file--${this.progressStatus}-status`,
              file.url && file.status !== "error" && listType !== "image-card" && `${clsPrefix}-upload-file--with-url`,
              `${clsPrefix}-upload-file--${listType}-type`
            ] },
            vue.h(
              "div",
              { class: `${clsPrefix}-upload-file-info` },
              icon,
              vue.h(
                "div",
                { class: `${clsPrefix}-upload-file-info__name` },
                showName && (file.url && file.status !== "error" ? vue.h("a", { rel: "noopener noreferer", target: "_blank", href: file.url || void 0, onClick: this.handlePreviewClick }, file.name) : vue.h("span", { onClick: this.handlePreviewClick }, file.name)),
                isImageType && progress
              ),
              vue.h(
                "div",
                { class: [
                  `${clsPrefix}-upload-file-info__action`,
                  `${clsPrefix}-upload-file-info__action--${listType}-type`
                ] },
                this.showPreviewButton ? vue.h(NButton, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, builtinThemeOverrides: buttonThemeOverrides }, {
                  icon: () => vue.h(NBaseIcon, { clsPrefix }, { default: () => vue.h(EyeIcon, null) })
                }) : null,
                (this.showRemoveButton || this.showCancelButton) && !this.disabled && vue.h(NButton, { key: "cancelOrTrash", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, quaternary: true, builtinThemeOverrides: buttonThemeOverrides, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, {
                  icon: () => vue.h(NIconSwitchTransition, null, {
                    default: () => this.showRemoveButton ? vue.h(NBaseIcon, { clsPrefix, key: "trash" }, { default: () => vue.h(TrashIcon, null) }) : vue.h(NBaseIcon, { clsPrefix, key: "cancel" }, { default: () => vue.h(CancelIcon, null) })
                  })
                }),
                this.showRetryButton && !this.disabled && vue.h(NButton, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, builtinThemeOverrides: buttonThemeOverrides }, {
                  icon: () => vue.h(NBaseIcon, { clsPrefix }, { default: () => vue.h(RetryIcon, null) })
                }),
                this.showDownloadButton ? vue.h(NButton, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, builtinThemeOverrides: buttonThemeOverrides }, {
                  icon: () => vue.h(NBaseIcon, { clsPrefix }, { default: () => vue.h(DownloadIcon, null) })
                }) : null
              )
            ),
            !isImageType && progress
          );
        }
      });
      const NUploadFileList = vue.defineComponent({
        name: "UploadFileList",
        setup(_, { slots }) {
          const NUpload = vue.inject(uploadInjectionKey, null);
          if (!NUpload) {
            throwError("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
          }
          const { abstractRef, mergedClsPrefixRef, listTypeRef, mergedFileListRef, fileListStyleRef, cssVarsRef, themeClassRef, maxReachedRef, showTriggerRef, imageGroupPropsRef } = NUpload;
          const isImageCardTypeRef = vue.computed(() => listTypeRef.value === "image-card");
          const renderFileList = () => mergedFileListRef.value.map((file) => vue.h(NUploadFile, { clsPrefix: mergedClsPrefixRef.value, key: file.id, file, listType: listTypeRef.value }));
          const renderUploadFileList = () => isImageCardTypeRef.value ? vue.h(NImageGroup, Object.assign({}, imageGroupPropsRef.value), { default: renderFileList }) : vue.h(NFadeInExpandTransition, { group: true }, {
            default: renderFileList
          });
          return () => {
            const { value: mergedClsPrefix } = mergedClsPrefixRef;
            const { value: abstract } = abstractRef;
            return vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-upload-file-list`,
                isImageCardTypeRef.value && `${mergedClsPrefix}-upload-file-list--grid`,
                abstract ? themeClassRef === null || themeClassRef === void 0 ? void 0 : themeClassRef.value : void 0
              ], style: [
                abstract && cssVarsRef ? cssVarsRef.value : "",
                fileListStyleRef.value
              ] },
              renderUploadFileList(),
              showTriggerRef.value && !maxReachedRef.value && isImageCardTypeRef.value && vue.h(NUploadTrigger, null, slots)
            );
          };
        }
      });
      const style$1 = c$1([cB("upload", "width: 100%;", [cM("dragger-inside", [cB("upload-trigger", `
 display: block;
 `)]), cM("drag-over", [cB("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), cB("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [c$1("&:hover", `
 border: var(--n-dragger-border-hover);
 `), cM("disabled", `
 cursor: not-allowed;
 `)]), cB("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [c$1("+", [cB("upload-file-list", "margin-top: 8px;")]), cM("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), cM("image-card", `
 width: 96px;
 height: 96px;
 `, [cB("base-icon", `
 font-size: 24px;
 `), cB("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), cB("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [c$1("a, img", "outline: none;"), cM("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [cB("upload-file", "cursor: not-allowed;")]), cM("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), cB("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [fadeInHeightExpandTransition(), cB("progress", [fadeInHeightExpandTransition({
        foldPadding: true
      })]), c$1("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [cB("upload-file-info", [cE("action", `
 opacity: 1;
 `)])]), cM("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [cB("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [cB("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), cE("name", `
 padding: 0 8px;
 `), cE("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [c$1("img", `
 width: 100%;
 `)])])]), cM("text-type", [cB("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), cM("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [cB("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), cB("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [cE("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [c$1("img", `
 width: 100%;
 `)])]), c$1("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), c$1("&:hover", [c$1("&::before", "opacity: 1;"), cB("upload-file-info", [cE("thumbnail", "opacity: .12;")])])]), cM("error-status", [c$1("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), cB("upload-file-info", [cE("name", "color: var(--n-item-text-color-error);"), cE("thumbnail", "color: var(--n-item-text-color-error);")]), cM("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), cM("with-url", `
 cursor: pointer;
 `, [cB("upload-file-info", [cE("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [c$1("a", `
 text-decoration: underline;
 `)])])]), cB("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [cE("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [cB("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), cE("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [cB("button", [c$1("&:not(:last-child)", {
        marginRight: "4px"
      }), cB("base-icon", [c$1("svg", [iconSwitchTransition()])])]), cM("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), cM("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), cE("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [c$1("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), cB("upload-file-input", `
 display: block;
 width: 0;
 height: 0;
 opacity: 0;
 `)]);
      var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      function createXhrHandlers(inst, file, xhr) {
        const { doChange, xhrMap } = inst;
        let percentage = 0;
        function handleXHRError(e) {
          var _a;
          let fileAfterChange = Object.assign({}, file, {
            status: "error",
            percentage
          });
          xhrMap.delete(file.id);
          fileAfterChange = createSettledFileInfo(((_a = inst.onError) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange, event: e })) || fileAfterChange);
          doChange(fileAfterChange, e);
        }
        function handleXHRLoad(e) {
          var _a;
          if (inst.isErrorState) {
            if (inst.isErrorState(xhr)) {
              handleXHRError(e);
              return;
            }
          } else {
            if (xhr.status < 200 || xhr.status >= 300) {
              handleXHRError(e);
              return;
            }
          }
          let fileAfterChange = Object.assign({}, file, {
            status: "finished",
            percentage
          });
          xhrMap.delete(file.id);
          fileAfterChange = createSettledFileInfo(((_a = inst.onFinish) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange, event: e })) || fileAfterChange);
          doChange(fileAfterChange, e);
        }
        return {
          handleXHRLoad,
          handleXHRError,
          handleXHRAbort(e) {
            const fileAfterChange = Object.assign({}, file, {
              status: "removed",
              file: null,
              percentage
            });
            xhrMap.delete(file.id);
            doChange(fileAfterChange, e);
          },
          handleXHRProgress(e) {
            const fileAfterChange = Object.assign({}, file, {
              status: "uploading"
            });
            if (e.lengthComputable) {
              const progress = Math.ceil(e.loaded / e.total * 100);
              fileAfterChange.percentage = progress;
              percentage = progress;
            }
            doChange(fileAfterChange, e);
          }
        };
      }
      function customSubmitImpl(options) {
        const { inst, file, data, headers, withCredentials, action, customRequest } = options;
        const { doChange } = options.inst;
        let percentage = 0;
        customRequest({
          file,
          data,
          headers,
          withCredentials,
          action,
          onProgress(event) {
            const fileAfterChange = Object.assign({}, file, {
              status: "uploading"
            });
            const progress = event.percent;
            fileAfterChange.percentage = progress;
            percentage = progress;
            doChange(fileAfterChange);
          },
          onFinish() {
            var _a;
            let fileAfterChange = Object.assign({}, file, {
              status: "finished",
              percentage
            });
            fileAfterChange = createSettledFileInfo(((_a = inst.onFinish) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange })) || fileAfterChange);
            doChange(fileAfterChange);
          },
          onError() {
            var _a;
            let fileAfterChange = Object.assign({}, file, {
              status: "error",
              percentage
            });
            fileAfterChange = createSettledFileInfo(((_a = inst.onError) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange })) || fileAfterChange);
            doChange(fileAfterChange);
          }
        });
      }
      function registerHandler(inst, file, request) {
        const handlers = createXhrHandlers(inst, file, request);
        request.onabort = handlers.handleXHRAbort;
        request.onerror = handlers.handleXHRError;
        request.onload = handlers.handleXHRLoad;
        if (request.upload) {
          request.upload.onprogress = handlers.handleXHRProgress;
        }
      }
      function unwrapFunctionValue(data, file) {
        if (typeof data === "function") {
          return data({ file });
        }
        if (data)
          return data;
        return {};
      }
      function setHeaders(request, headers, file) {
        const headersObject = unwrapFunctionValue(headers, file);
        if (!headersObject)
          return;
        Object.keys(headersObject).forEach((key) => {
          request.setRequestHeader(key, headersObject[key]);
        });
      }
      function appendData(formData, data, file) {
        const dataObject = unwrapFunctionValue(data, file);
        if (!dataObject)
          return;
        Object.keys(dataObject).forEach((key) => {
          formData.append(key, dataObject[key]);
        });
      }
      function submitImpl(inst, fieldName, file, { method: method2, action, withCredentials, responseType, headers, data }) {
        const request = new XMLHttpRequest();
        request.responseType = responseType;
        inst.xhrMap.set(file.id, request);
        request.withCredentials = withCredentials;
        const formData = new FormData();
        appendData(formData, data, file);
        formData.append(fieldName, file.file);
        registerHandler(inst, file, request);
        if (action !== void 0) {
          request.open(method2.toUpperCase(), action);
          setHeaders(request, headers, file);
          request.send(formData);
          const fileAfterChange = Object.assign({}, file, {
            status: "uploading"
          });
          inst.doChange(fileAfterChange);
        }
      }
      const uploadProps = Object.assign(Object.assign({}, useTheme.props), {
        name: {
          type: String,
          default: "file"
        },
        accept: String,
        action: String,
        customRequest: Function,
        directory: Boolean,
        directoryDnd: { type: Boolean, default: void 0 },
        method: {
          type: String,
          default: "POST"
        },
        multiple: Boolean,
        showFileList: {
          type: Boolean,
          default: true
        },
        data: [Object, Function],
        headers: [Object, Function],
        withCredentials: Boolean,
        responseType: {
          type: String,
          default: ""
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        onChange: Function,
        onRemove: Function,
        onFinish: Function,
        onError: Function,
        onBeforeUpload: Function,
        isErrorState: Function,
        /** currently not used */
        onDownload: Function,
        defaultUpload: {
          type: Boolean,
          default: true
        },
        fileList: Array,
        "onUpdate:fileList": [Function, Array],
        onUpdateFileList: [Function, Array],
        fileListStyle: [String, Object],
        defaultFileList: {
          type: Array,
          default: () => []
        },
        showCancelButton: {
          type: Boolean,
          default: true
        },
        showRemoveButton: {
          type: Boolean,
          default: true
        },
        showDownloadButton: Boolean,
        showRetryButton: {
          type: Boolean,
          default: true
        },
        showPreviewButton: {
          type: Boolean,
          default: true
        },
        listType: {
          type: String,
          default: "text"
        },
        onPreview: Function,
        shouldUseThumbnailUrl: {
          type: Function,
          default: (file) => {
            if (!environmentSupportFile)
              return false;
            return isImageFile(file);
          }
        },
        createThumbnailUrl: Function,
        abstract: Boolean,
        max: Number,
        showTrigger: {
          type: Boolean,
          default: true
        },
        imageGroupProps: Object,
        inputProps: Object,
        triggerStyle: [String, Object],
        renderIcon: Object
      });
      const Upload = vue.defineComponent({
        name: "Upload",
        props: uploadProps,
        setup(props) {
          if (props.abstract && props.listType === "image-card") {
            throwError("upload", "when the list-type is image-card, abstract is not supported.");
          }
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme("Upload", "-upload", style$1, uploadLight$1, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const maxReachedRef = vue.computed(() => {
            const { max } = props;
            if (max !== void 0) {
              return mergedFileListRef.value.length >= max;
            }
            return false;
          });
          const uncontrolledFileListRef = vue.ref(props.defaultFileList);
          const controlledFileListRef = vue.toRef(props, "fileList");
          const inputElRef = vue.ref(null);
          const draggerInsideRef = {
            value: false
          };
          const dragOverRef = vue.ref(false);
          const xhrMap = /* @__PURE__ */ new Map();
          const _mergedFileListRef = useMergedState(controlledFileListRef, uncontrolledFileListRef);
          const mergedFileListRef = vue.computed(() => _mergedFileListRef.value.map(createSettledFileInfo));
          function openOpenFileDialog() {
            var _a;
            (_a = inputElRef.value) === null || _a === void 0 ? void 0 : _a.click();
          }
          function handleFileInputChange(e) {
            const target = e.target;
            handleFileAddition(target.files ? Array.from(target.files).map((file) => ({
              file,
              entry: null,
              source: "input"
            })) : null, e);
            target.value = "";
          }
          function doUpdateFileList(files) {
            const { "onUpdate:fileList": _onUpdateFileList, onUpdateFileList } = props;
            if (_onUpdateFileList)
              call(_onUpdateFileList, files);
            if (onUpdateFileList)
              call(onUpdateFileList, files);
            uncontrolledFileListRef.value = files;
          }
          const mergedMultipleRef = vue.computed(() => props.multiple || props.directory);
          function handleFileAddition(fileAndEntries, e) {
            if (!fileAndEntries || fileAndEntries.length === 0)
              return;
            const { onBeforeUpload } = props;
            fileAndEntries = mergedMultipleRef.value ? fileAndEntries : [fileAndEntries[0]];
            const { max, accept } = props;
            fileAndEntries = fileAndEntries.filter(({ file, source }) => {
              if (source === "dnd" && (accept === null || accept === void 0 ? void 0 : accept.trim())) {
                return matchType(file.name, file.type, accept);
              } else {
                return true;
              }
            });
            if (max) {
              fileAndEntries = fileAndEntries.slice(0, max - mergedFileListRef.value.length);
            }
            const batchId = createId();
            void Promise.all(fileAndEntries.map(({ file, entry }) => __awaiter(this, void 0, void 0, function* () {
              var _a;
              const fileInfo = {
                id: createId(),
                batchId,
                name: file.name,
                status: "pending",
                percentage: 0,
                file,
                url: null,
                type: file.type,
                thumbnailUrl: null,
                fullPath: (_a = entry === null || entry === void 0 ? void 0 : entry.fullPath) !== null && _a !== void 0 ? _a : `/${file.webkitRelativePath || file.name}`
              };
              if (!onBeforeUpload || (yield onBeforeUpload({
                file: fileInfo,
                fileList: mergedFileListRef.value
              })) !== false) {
                return fileInfo;
              }
              return null;
            }))).then((fileInfos) => __awaiter(this, void 0, void 0, function* () {
              let nextTickChain = Promise.resolve();
              fileInfos.forEach((fileInfo) => {
                nextTickChain = nextTickChain.then(vue.nextTick).then(() => {
                  fileInfo && doChange(fileInfo, e, {
                    append: true
                  });
                });
              });
              yield nextTickChain;
            })).then(() => {
              if (props.defaultUpload) {
                submit();
              }
            });
          }
          function submit(fileId) {
            const { method: method2, action, withCredentials, headers, data, name: fieldName } = props;
            const filesToUpload = fileId !== void 0 ? mergedFileListRef.value.filter((file) => file.id === fileId) : mergedFileListRef.value;
            const shouldReupload = fileId !== void 0;
            filesToUpload.forEach((file) => {
              const { status } = file;
              if (status === "pending" || status === "error" && shouldReupload) {
                if (props.customRequest) {
                  customSubmitImpl({
                    inst: {
                      doChange,
                      xhrMap,
                      onFinish: props.onFinish,
                      onError: props.onError
                    },
                    file,
                    action,
                    withCredentials,
                    headers,
                    data,
                    customRequest: props.customRequest
                  });
                } else {
                  submitImpl({
                    doChange,
                    xhrMap,
                    onFinish: props.onFinish,
                    onError: props.onError,
                    isErrorState: props.isErrorState
                  }, fieldName, file, {
                    method: method2,
                    action,
                    withCredentials,
                    responseType: props.responseType,
                    headers,
                    data
                  });
                }
              }
            });
          }
          const doChange = (fileAfterChange, event, options = {
            append: false,
            remove: false
          }) => {
            const { append, remove } = options;
            const fileListAfterChange = Array.from(mergedFileListRef.value);
            const fileIndex = fileListAfterChange.findIndex((file) => file.id === fileAfterChange.id);
            if (append || remove || ~fileIndex) {
              if (append) {
                fileListAfterChange.push(fileAfterChange);
              } else if (remove) {
                fileListAfterChange.splice(fileIndex, 1);
              } else {
                fileListAfterChange.splice(fileIndex, 1, fileAfterChange);
              }
              const { onChange } = props;
              if (onChange) {
                onChange({
                  file: fileAfterChange,
                  fileList: fileListAfterChange,
                  event
                });
              }
              doUpdateFileList(fileListAfterChange);
            }
          };
          function getFileThumbnailUrlResolver(file) {
            var _a;
            if (file.thumbnailUrl)
              return file.thumbnailUrl;
            const { createThumbnailUrl } = props;
            if (createThumbnailUrl) {
              return (_a = createThumbnailUrl(file.file, file)) !== null && _a !== void 0 ? _a : file.url || "";
            }
            if (file.url) {
              return file.url;
            } else if (file.file) {
              return createImageDataUrl(file.file);
            }
            return "";
          }
          const cssVarsRef = vue.computed(() => {
            const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { draggerColor, draggerBorder, draggerBorderHover, itemColorHover, itemColorHoverError, itemTextColorError, itemTextColorSuccess, itemTextColor, itemIconColor, itemDisabledOpacity, lineHeight: lineHeight2, borderRadius, fontSize: fontSize2, itemBorderImageCardError, itemBorderImageCard } } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-dragger-border": draggerBorder,
              "--n-dragger-border-hover": draggerBorderHover,
              "--n-dragger-color": draggerColor,
              "--n-font-size": fontSize2,
              "--n-item-color-hover": itemColorHover,
              "--n-item-color-hover-error": itemColorHoverError,
              "--n-item-disabled-opacity": itemDisabledOpacity,
              "--n-item-icon-color": itemIconColor,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-error": itemTextColorError,
              "--n-item-text-color-success": itemTextColorSuccess,
              "--n-line-height": lineHeight2,
              "--n-item-border-image-card-error": itemBorderImageCardError,
              "--n-item-border-image-card": itemBorderImageCard
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("upload", void 0, cssVarsRef, props) : void 0;
          vue.provide(uploadInjectionKey, {
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            showCancelButtonRef: vue.toRef(props, "showCancelButton"),
            showDownloadButtonRef: vue.toRef(props, "showDownloadButton"),
            showRemoveButtonRef: vue.toRef(props, "showRemoveButton"),
            showRetryButtonRef: vue.toRef(props, "showRetryButton"),
            onRemoveRef: vue.toRef(props, "onRemove"),
            onDownloadRef: vue.toRef(props, "onDownload"),
            mergedFileListRef,
            triggerStyleRef: vue.toRef(props, "triggerStyle"),
            shouldUseThumbnailUrlRef: vue.toRef(props, "shouldUseThumbnailUrl"),
            renderIconRef: vue.toRef(props, "renderIcon"),
            xhrMap,
            submit,
            doChange,
            showPreviewButtonRef: vue.toRef(props, "showPreviewButton"),
            onPreviewRef: vue.toRef(props, "onPreview"),
            getFileThumbnailUrlResolver,
            listTypeRef: vue.toRef(props, "listType"),
            dragOverRef,
            openOpenFileDialog,
            draggerInsideRef,
            handleFileAddition,
            mergedDisabledRef: formItem.mergedDisabledRef,
            maxReachedRef,
            fileListStyleRef: vue.toRef(props, "fileListStyle"),
            abstractRef: vue.toRef(props, "abstract"),
            acceptRef: vue.toRef(props, "accept"),
            cssVarsRef: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClassRef: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            showTriggerRef: vue.toRef(props, "showTrigger"),
            imageGroupPropsRef: vue.toRef(props, "imageGroupProps"),
            mergedDirectoryDndRef: vue.computed(() => {
              var _a;
              return (_a = props.directoryDnd) !== null && _a !== void 0 ? _a : props.directory;
            })
          });
          const exposedMethods = {
            clear: () => {
              uncontrolledFileListRef.value = [];
            },
            submit,
            openOpenFileDialog
          };
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            draggerInsideRef,
            inputElRef,
            mergedTheme: themeRef,
            dragOver: dragOverRef,
            mergedMultiple: mergedMultipleRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            handleFileInputChange
          }, exposedMethods);
        },
        render() {
          var _a, _b;
          const { draggerInsideRef, mergedClsPrefix, $slots, directory, onRender } = this;
          if ($slots.default && !this.abstract) {
            const firstChild = $slots.default()[0];
            if ((_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.type) === null || _a === void 0 ? void 0 : _a[uploadDraggerKey]) {
              draggerInsideRef.value = true;
            }
          }
          const inputNode = vue.h("input", Object.assign({}, this.inputProps, {
            ref: "inputElRef",
            type: "file",
            class: `${mergedClsPrefix}-upload-file-input`,
            accept: this.accept,
            multiple: this.mergedMultiple,
            onChange: this.handleFileInputChange,
            // @ts-expect-error // seems vue-tsc will add the prop, so we can't use expect-error
            webkitdirectory: directory || void 0,
            directory: directory || void 0
          }));
          if (this.abstract) {
            return vue.h(
              vue.Fragment,
              null,
              (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots),
              vue.h(vue.Teleport, { to: "body" }, inputNode)
            );
          }
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(
            "div",
            { class: [
              `${mergedClsPrefix}-upload`,
              draggerInsideRef.value && `${mergedClsPrefix}-upload--dragger-inside`,
              this.dragOver && `${mergedClsPrefix}-upload--drag-over`,
              this.themeClass
            ], style: this.cssVars },
            inputNode,
            this.showTrigger && this.listType !== "image-card" && vue.h(NUploadTrigger, null, $slots),
            this.showFileList && vue.h(NUploadFileList, null, $slots)
          );
        }
      });
      const style = c$1([cB("watermark-container", `
 position: relative;
 `, [cNotM("selectable", `
 user-select: none;
 -webkit-user-select: none;
 `), cM("global-rotate", `
 overflow: hidden;
 `), cM("fullscreen", `
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 position: fixed;
 `)]), cB("watermark", `
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 background-repeat: repeat;
 `, [cM("fullscreen", `
 position: fixed;
 `), cM("global-rotate", `
 position: absolute;
 height: max(284vh, 284vw);
 width: max(284vh, 284vw);
 `)])]);
      function getRatio(context) {
        if (!context) {
          return 1;
        }
        const backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return (window.devicePixelRatio || 1) / backingStore;
      }
      const watermarkProps = Object.assign(Object.assign({}, useTheme.props), { debug: Boolean, cross: Boolean, fullscreen: Boolean, width: {
        type: Number,
        default: 32
      }, height: {
        type: Number,
        default: 32
      }, zIndex: {
        type: Number,
        default: 10
      }, xGap: {
        type: Number,
        default: 0
      }, yGap: {
        type: Number,
        default: 0
      }, yOffset: {
        type: Number,
        default: 0
      }, xOffset: {
        type: Number,
        default: 0
      }, rotate: {
        type: Number,
        default: 0
      }, image: String, imageOpacity: { type: Number, default: 1 }, imageHeight: Number, imageWidth: Number, content: String, selectable: {
        type: Boolean,
        default: true
      }, fontSize: {
        type: Number,
        default: 14
      }, fontFamily: String, fontStyle: {
        type: String,
        default: "normal"
      }, fontVariant: {
        type: String,
        default: ""
      }, fontWeight: {
        type: Number,
        default: 400
      }, fontColor: {
        type: String,
        default: "rgba(128, 128, 128, .3)"
      }, fontStretch: {
        type: String,
        default: ""
      }, lineHeight: {
        type: Number,
        default: 14
      }, globalRotate: {
        type: Number,
        default: 0
      } });
      const Watermark = vue.defineComponent({
        name: "Watermark",
        props: watermarkProps,
        setup(props, { slots }) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme("Watermark", "-watermark", style, watermarkLight$1, props, mergedClsPrefixRef);
          const base64UrlRef = vue.ref("");
          const canvas = isBrowser$2 ? document.createElement("canvas") : null;
          const ctx2 = canvas ? canvas.getContext("2d") : null;
          const fontsReadyRef = vue.ref(false);
          onFontsReady(() => fontsReadyRef.value = true);
          vue.watchEffect(() => {
            if (!canvas)
              return;
            void fontsReadyRef.value;
            const ratio = getRatio(ctx2);
            const { xGap, yGap, width, height, yOffset, xOffset, rotate, image, content, fontColor, fontStyle, fontVariant, fontStretch, fontWeight, fontFamily: fontFamily2, fontSize: fontSize2, lineHeight: lineHeight2, debug } = props;
            const canvasWidth = (xGap + width) * ratio;
            const canvasHeight = (yGap + height) * ratio;
            const canvasOffsetLeft = xOffset * ratio;
            const canvasOffsetTop = yOffset * ratio;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            if (ctx2) {
              ctx2.translate(0, 0);
              const markWidth = width * ratio;
              const markHeight = height * ratio;
              if (debug) {
                ctx2.strokeStyle = "grey";
                ctx2.strokeRect(0, 0, markWidth, markHeight);
              }
              ctx2.rotate(rotate * (Math.PI / 180));
              if (image) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.referrerPolicy = "no-referrer";
                img.src = image;
                img.onload = () => {
                  ctx2.globalAlpha = props.imageOpacity;
                  const { imageWidth, imageHeight } = props;
                  ctx2.drawImage(img, canvasOffsetLeft, canvasOffsetTop, (props.imageWidth || (imageHeight ? img.width * imageHeight / img.height : img.width)) * ratio, (props.imageHeight || (imageWidth ? img.height * imageWidth / img.width : img.height)) * ratio);
                  base64UrlRef.value = canvas.toDataURL();
                };
              } else if (content) {
                if (debug) {
                  ctx2.strokeStyle = "green";
                  ctx2.strokeRect(0, 0, markWidth, markHeight);
                }
                ctx2.font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontStretch} ${fontSize2 * ratio}px/${lineHeight2 * ratio}px ${fontFamily2 || themeRef.value.self.fontFamily}`;
                ctx2.fillStyle = fontColor;
                ctx2.fillText(content, canvasOffsetLeft, canvasOffsetTop + lineHeight2 * ratio);
                base64UrlRef.value = canvas.toDataURL();
              }
            } else {
              warnOnce("watermark", "Canvas is not supported in the browser.");
            }
          });
          return () => {
            var _a;
            const { globalRotate, fullscreen, zIndex } = props;
            const mergedClsPrefix = mergedClsPrefixRef.value;
            const isFullScreenGlobalRotate = globalRotate !== 0 && fullscreen;
            const rotatedImageOffset = "max(142vh, 142vw)";
            const watermarkNode = vue.h("div", { class: [
              `${mergedClsPrefix}-watermark`,
              globalRotate !== 0 && `${mergedClsPrefix}-watermark--global-rotate`,
              fullscreen && `${mergedClsPrefix}-watermark--fullscreen`
            ], style: {
              transform: globalRotate ? `translateX(-50%) translateY(-50%) rotate(${globalRotate}deg)` : void 0,
              zIndex: isFullScreenGlobalRotate ? void 0 : zIndex,
              backgroundSize: `${props.xGap + props.width}px`,
              backgroundPosition: globalRotate === 0 ? props.cross ? `${props.width / 2}px ${props.height / 2}px, 0 0` : "" : props.cross ? `calc(${rotatedImageOffset} + ${props.width / 2}px) calc(${rotatedImageOffset} + ${props.height / 2}px), ${rotatedImageOffset} ${rotatedImageOffset}` : rotatedImageOffset,
              backgroundImage: props.cross ? `url(${base64UrlRef.value}), url(${base64UrlRef.value})` : `url(${base64UrlRef.value})`
            } });
            if (props.fullscreen && !globalRotate)
              return watermarkNode;
            return vue.h(
              "div",
              { class: [
                `${mergedClsPrefix}-watermark-container`,
                globalRotate !== 0 && `${mergedClsPrefix}-watermark-container--global-rotate`,
                fullscreen && `${mergedClsPrefix}-watermark-container--fullscreen`,
                props.selectable && `${mergedClsPrefix}-watermark-container--selectable`
              ], style: {
                zIndex: isFullScreenGlobalRotate ? zIndex : void 0
              } },
              (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots),
              watermarkNode
            );
          };
        }
      });
      const NInjectionExtractor = vue.defineComponent({
        name: "InjectionExtractor",
        props: {
          onSetup: Function
        },
        setup(props, { slots }) {
          var _a;
          (_a = props.onSetup) === null || _a === void 0 ? void 0 : _a.call(props);
          return () => {
            var _a2;
            return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
          };
        }
      });
      const injectionFactoryMap = {
        message: useMessage,
        notification: useNotification,
        loadingBar: useLoadingBar,
        dialog: useDialog
      };
      function createDiscreteApp({ providersAndProps, configProviderProps: configProviderProps2 }) {
        const App = () => {
          return vue.h(NConfigProvider, vue.unref(configProviderProps2), {
            default: () => providersAndProps.map(({ type: type2, Provider, props }) => {
              return vue.h(Provider, vue.unref(props), {
                default: () => vue.h(NInjectionExtractor, {
                  onSetup: () => extractedApi[type2] = injectionFactoryMap[type2]()
                })
              });
            })
          });
        };
        let app2 = vue.createApp(App);
        const extractedApi = {
          app: app2
        };
        let hostEl;
        if (isBrowser$2) {
          hostEl = document.createElement("div");
          document.body.appendChild(hostEl);
          app2.mount(hostEl);
        }
        const unmount2 = () => {
          var _a;
          if (app2 === null || hostEl === null) {
            warn$2("discrete", "unmount call no need because discrete app has been unmounted");
            return;
          }
          app2.unmount();
          (_a = hostEl.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(hostEl);
          hostEl = null;
          app2 = null;
        };
        return Object.assign({ unmount: unmount2 }, extractedApi);
      }
      function createDiscreteApi(includes, { configProviderProps: configProviderProps2, messageProviderProps: messageProviderProps2, dialogProviderProps: dialogProviderProps2, notificationProviderProps: notificationProviderProps2, loadingBarProviderProps: loadingBarProviderProps2 } = {}) {
        const providersAndProps = [];
        includes.forEach((type2) => {
          switch (type2) {
            case "message":
              providersAndProps.push({
                type: type2,
                Provider: NMessageProvider,
                props: messageProviderProps2
              });
              break;
            case "notification":
              providersAndProps.push({
                type: type2,
                Provider: NNotificationProvider,
                props: notificationProviderProps2
              });
              break;
            case "dialog":
              providersAndProps.push({
                type: type2,
                Provider: NDialogProvider,
                props: dialogProviderProps2
              });
              break;
            case "loadingBar":
              providersAndProps.push({
                type: type2,
                Provider: NLoadingBarProvider,
                props: loadingBarProviderProps2
              });
              break;
          }
        });
        const discreteApp = createDiscreteApp({
          providersAndProps,
          configProviderProps: configProviderProps2
        });
        return discreteApp;
      }
      const equationProps = {
        value: String,
        katex: Object,
        katexOptions: Object
      };
      const Equation = vue.defineComponent({
        name: "Equation",
        props: equationProps,
        setup(props) {
          const configProviderContext = vue.inject(configProviderInjectionKey);
          const extractedHtmlInfo = vue.computed(() => {
            var _a;
            const outerHtml = ((_a = props.katex || (configProviderContext === null || configProviderContext === void 0 ? void 0 : configProviderContext.mergedKatexRef.value)) === null || _a === void 0 ? void 0 : _a.renderToString(props.value || "", Object.assign({ throwOnError: false }, props.katexOptions))) || "no katex provided";
            const matchResult = outerHtml.match(/^<([a-z]+)[^>]+class="([^"]+)"[^>]*>/);
            const wrapperTag = (matchResult === null || matchResult === void 0 ? void 0 : matchResult[1]) || "span";
            const wrapperClass = matchResult === null || matchResult === void 0 ? void 0 : matchResult[2];
            const innerHtml = outerHtml.replace(/^<[a-z]+[^>]*>/, "").replace(/<\/[a-z]+>$/, "");
            return { wrapperTag, innerHtml, wrapperClass };
          });
          return () => {
            const { innerHtml, wrapperClass, wrapperTag } = extractedHtmlInfo.value;
            return vue.h(wrapperTag, { class: wrapperClass, innerHTML: innerHtml });
          };
        }
      });
      const components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        NA: a,
        NAffix,
        NAlert: Alert,
        NAnchor: AnchorAdapter,
        NAnchorLink: Link,
        NAutoComplete: AutoComplete,
        NAvatar,
        NAvatarGroup: AvatarGroup,
        NBackTop: BackTop,
        NBadge: Badge,
        NBlockquote: blockquote,
        NBreadcrumb: Breadcrumb,
        NBreadcrumbItem: BreadcrumbItem,
        NButton,
        NButtonGroup,
        NCalendar: Calendar,
        NCard,
        NCarousel: Carousel,
        NCarouselItem,
        NCascader: Cascader,
        NCheckbox,
        NCheckboxGroup,
        NCode,
        NCol,
        NCollapse,
        NCollapseItem,
        NCollapseTransition: CollapseTransition,
        NColorPicker,
        NConfigProvider,
        NCountdown: Countdown,
        NDataTable: DataTable,
        NDatePicker: DatePicker,
        NDescriptions: Descriptions,
        NDescriptionsItem: DescriptionsItem,
        NDialog,
        NDialogProvider,
        NDivider,
        NDrawer: Drawer,
        NDrawerContent: DrawerContent,
        NDropdown,
        NDynamicInput: DynamicInput,
        NDynamicTags: DynamicTags,
        NEl: NElement,
        NElement,
        NEllipsis,
        NEmpty,
        NEquation: Equation,
        NForm: Form,
        NFormItem,
        NFormItemCol,
        NFormItemGi: FormItemGridItem,
        NFormItemGridItem: FormItemGridItem,
        NFormItemRow: FormItemRow,
        NGi,
        NGlobalStyle: GlobalStyle,
        NGradientText: GradientText,
        NGrid,
        NGridItem: NGi,
        NH1,
        NH2,
        NH3,
        NH4,
        NH5,
        NH6,
        NHr: hr,
        NIcon,
        NIconWrapper,
        NImage,
        NImageGroup,
        NInput,
        NInputGroup,
        NInputGroupLabel: InputGroupLabel,
        NInputNumber: InputNumber,
        NLayout: Layout,
        NLayoutContent: LayoutContent,
        NLayoutFooter: LayoutFooter,
        NLayoutHeader: LayoutHeader,
        NLayoutSider: LayoutSider,
        NLegacyTransfer: Transfer$1,
        NLi: li,
        NList: List,
        NListItem: ListItem,
        NLoadingBarProvider,
        NLog: Log,
        NMention: Mention,
        NMenu: Menu,
        NMessageProvider,
        NModal,
        NNotificationProvider,
        NNumberAnimation: NumberAnimation,
        NOl: ol,
        NP: p,
        NPageHeader: PageHeader,
        NPagination,
        NPopconfirm: Popconfirm,
        NPopover,
        NPopselect,
        NProgress,
        NRadio,
        NRadioButton: RadioButton,
        NRadioGroup,
        NRate: Rate,
        NResult: Result,
        NRow,
        NScrollbar: Scrollbar$1,
        NSelect,
        NSkeleton: Skeleton,
        NSlider: Slider,
        NSpace,
        NSpin: Spin,
        NStatistic: Statistic,
        NStep: Step,
        NSteps: Steps,
        NSwitch,
        NTab: Tab,
        NTabPane: TabPane,
        NTable: Table,
        NTabs: Tabs,
        NTag,
        NTbody: Tbody,
        NTd: Td,
        NText,
        NTh: Th,
        NThead: Thead,
        NThing: Thing,
        NTime: Time,
        NTimePicker,
        NTimeline: Timeline,
        NTimelineItem: TimelineItem,
        NTooltip,
        NTr: Tr,
        NTransfer: Transfer,
        NTree,
        NTreeSelect: TreeSelect,
        NUl: ul,
        NUpload: Upload,
        NUploadDragger,
        NUploadFileList,
        NUploadTrigger,
        NWatermark: Watermark,
        NxButton: XButton,
        aProps,
        affixProps,
        alertProps,
        anchorLinkProps,
        anchorProps,
        autoCompleteProps,
        avatarGroupProps,
        avatarProps,
        backTopProps,
        badgeProps,
        blockquoteProps,
        breadcrumbItemProps,
        breadcrumbProps,
        buttonGroupProps,
        buttonProps,
        calendarProps,
        cardProps,
        carouselProps,
        cascaderProps,
        checkboxGroupProps,
        checkboxProps,
        codeProps,
        colProps,
        collapseItemProps,
        collapseProps,
        collapseTransitionProps,
        colorPickerProps,
        configProviderProps,
        countdownProps,
        createDiscreteApi,
        dataTableProps,
        datePickerProps,
        descriptionsItemProps,
        descriptionsProps,
        dialogProps,
        dialogProviderProps,
        dividerProps,
        drawerContentProps,
        drawerProps,
        dropdownProps,
        dynamicInputProps,
        dynamicTagsProps,
        elementProps,
        ellipsisProps,
        emptyProps,
        equationProps,
        formItemGiProps,
        formItemGridItemProps: formItemGiProps,
        formItemProps,
        formProps,
        giProps: gridItemProps,
        gradientTextProps,
        gridItemProps,
        gridProps,
        h1Props: headerProps,
        h2Props: headerProps,
        h3Props: headerProps,
        h4Props: headerProps,
        h5Props: headerProps,
        h6Props: headerProps,
        iconProps,
        iconWrapperProps,
        imageGroupProps,
        imageProps,
        inputGroupLabelProps,
        inputGroupProps,
        inputNumberProps,
        inputProps,
        layoutContentProps: layoutProps,
        layoutFooterProps,
        layoutHeaderProps: headerProps$1,
        layoutProps,
        layoutSiderProps,
        legacyTransferProps: transferProps$1,
        listProps,
        loadingBarProviderProps,
        logProps,
        mentionProps,
        menuProps,
        messageProviderProps,
        modalProps,
        notificationProviderProps,
        numberAnimationProps,
        olProps,
        pProps,
        pageHeaderProps,
        paginationProps,
        popconfirmProps,
        popoverProps,
        popselectProps,
        progressProps,
        radioButtonProps,
        radioGroupProps,
        radioProps,
        rateProps,
        resultProps,
        rowProps,
        scrollbarProps,
        selectProps,
        skeletonProps,
        sliderProps,
        spaceProps,
        spinProps,
        statisticProps,
        stepProps,
        stepsProps,
        switchProps,
        tabPaneProps,
        tabProps,
        tableProps,
        tabsProps,
        tagProps,
        textProps,
        thingProps,
        timePickerProps,
        timeProps,
        timelineItemProps,
        timelineProps,
        tooltipProps,
        transferProps,
        treeProps,
        treeSelectProps,
        ulProps,
        uploadProps,
        useDialog,
        useDialogReactiveList,
        useLoadingBar,
        useMessage,
        useNotification,
        watermarkProps
      }, Symbol.toStringTag, { value: "Module" }));
      const version = "2.34.4";
      function create({ componentPrefix = "N", components: components2 = [] } = {}) {
        const installTargets = [];
        function registerComponent(app2, name, component) {
          const registered = app2.component(componentPrefix + name);
          if (!registered) {
            app2.component(componentPrefix + name, component);
          }
        }
        function install(app2) {
          if (installTargets.includes(app2))
            return;
          installTargets.push(app2);
          components2.forEach((component) => {
            const { name, alias } = component;
            registerComponent(app2, name, component);
            if (alias) {
              alias.forEach((aliasName) => {
                registerComponent(app2, aliasName, component);
              });
            }
          });
        }
        return {
          version,
          componentPrefix,
          install
        };
      }
      const naive = create({
        components: Object.keys(components).map((key) => components[key])
      });
      const naive$1 = naive;
      naive.install;
      const self$1 = () => ({});
      const equationLight = {
        name: "Equation",
        common: commonLight,
        self: self$1
      };
      const equationLight$1 = equationLight;
      const equationDark = {
        name: "Equation",
        common: commonDark,
        self: self$1
      };
      const equationDark$1 = equationDark;
      const darkTheme = {
        name: "dark",
        common: commonDark,
        Alert: alertDark$1,
        Anchor: anchorDark$1,
        AutoComplete: autoCompleteDark$1,
        Avatar: avatarDark$1,
        AvatarGroup: avatarGroupDark$1,
        BackTop: backTopDark$1,
        Badge: badgeDark$1,
        Breadcrumb: breadcrumbDark$1,
        Button: buttonDark$1,
        ButtonGroup: buttonGroupDark$1,
        Calendar: calendarDark$1,
        Card: cardDark$1,
        Carousel: carouselDark$1,
        Cascader: cascaderDark$1,
        Checkbox: checkboxDark$1,
        Code: codeDark$1,
        Collapse: collapseDark$1,
        CollapseTransition: collapseTransitionDark$1,
        ColorPicker: colorPickerDark$1,
        DataTable: dataTableDark$1,
        DatePicker: datePickerDark$1,
        Descriptions: descriptionsDark$1,
        Dialog: dialogDark$1,
        Divider: dividerDark$1,
        Drawer: drawerDark$1,
        Dropdown: dropdownDark$1,
        DynamicInput: dynamicInputDark$1,
        DynamicTags: dynamicTagsDark$1,
        Element: elementDark$1,
        Empty: emptyDark$1,
        Ellipsis: ellipsisDark$1,
        Equation: equationDark$1,
        Form: formDark,
        GradientText: gradientTextDark$1,
        Icon: iconDark$2,
        IconWrapper: iconWrapperDark,
        Image: imageDark,
        Input: inputDark$1,
        InputNumber: inputNumberDark$1,
        LegacyTransfer: legacyTransferDark,
        Layout: layoutDark$1,
        List: listDark$2,
        LoadingBar: loadingBarDark$1,
        Log: logDark$1,
        Menu: menuDark$1,
        Mention: mentionDark,
        Message: messageDark$1,
        Modal: modalDark$1,
        Notification: notificationDark$1,
        PageHeader: pageHeaderDark,
        Pagination: paginationDark$1,
        Popconfirm: popconfirmDark$1,
        Popover: popoverDark$1,
        Popselect: popselectDark,
        Progress: progressDark$1,
        Radio: radioDark$1,
        Rate: rateDark$1,
        Result: resultDark$1,
        Row: rowDark$1,
        Scrollbar: scrollbarDark$1,
        Select: selectDark$1,
        Skeleton: skeletonDark,
        Slider: sliderDark$1,
        Space: spaceDark$1,
        Spin: spinDark$1,
        Statistic: statisticDark$1,
        Steps: stepsDark$1,
        Switch: switchDark$1,
        Table: tableDark$1,
        Tabs: tabsDark$1,
        Tag: tagDark$1,
        Thing: thingDark$1,
        TimePicker: timePickerDark$1,
        Timeline: timelineDark$1,
        Tooltip: tooltipDark$1,
        Transfer: transferDark$2,
        Tree: treeDark$1,
        TreeSelect: treeSelectDark$1,
        Typography: typographyDark$1,
        Upload: uploadDark$1,
        Watermark: watermarkDark$1
      };
      const lightTheme = {
        name: "light",
        common: commonLight,
        Alert: alertLight$1,
        Anchor: anchorLight$1,
        AutoComplete: autoCompleteLight$1,
        Avatar: avatarLight$1,
        AvatarGroup: avatarGroupLight$1,
        BackTop: backTopLight$1,
        Badge: badgeLight$1,
        Breadcrumb: breadcrumbLight$1,
        Button: buttonLight$1,
        ButtonGroup: buttonGroupLight$1,
        Calendar: calendarLight$1,
        Card: cardLight$1,
        Carousel: carouselLight$1,
        Cascader: cascaderLight$1,
        Checkbox: checkboxLight$1,
        Code: codeLight$1,
        Collapse: collapseLight$1,
        CollapseTransition: collapseTransitionLight$1,
        ColorPicker: colorPickerLight$1,
        DataTable: dataTableLight$1,
        DatePicker: datePickerLight$1,
        Descriptions: descriptionsLight$1,
        Dialog: dialogLight$1,
        Divider: dividerLight$1,
        Drawer: drawerLight$1,
        Dropdown: dropdownLight$1,
        DynamicInput: dynamicInputLight$1,
        DynamicTags: dynamicTagsLight$1,
        Element: elementLight$1,
        Empty: emptyLight$1,
        Equation: equationLight$1,
        Ellipsis: ellipsisLight$1,
        Form: formLight$1,
        GradientText: gradientTextLight$1,
        Icon: iconLight$1,
        IconWrapper: iconWrapperLight$1,
        Image: imageLight,
        Input: inputLight$1,
        InputNumber: inputNumberLight$1,
        Layout: layoutLight$1,
        LegacyTransfer: legacyTransferLight,
        List: listLight$1,
        LoadingBar: loadingBarLight$1,
        Log: logLight$1,
        Menu: menuLight$1,
        Mention: mentionLight$1,
        Message: messageLight$1,
        Modal: modalLight$1,
        Notification: notificationLight$1,
        PageHeader: pageHeaderLight,
        Pagination: paginationLight$1,
        Popconfirm: popconfirmLight$1,
        Popover: popoverLight$1,
        Popselect: popselectLight$1,
        Progress: progressLight$1,
        Radio: radioLight$1,
        Rate: rateLight,
        Row: rowLight$1,
        Result: resultLight$1,
        Scrollbar: scrollbarLight$1,
        Skeleton: skeletonLight,
        Select: selectLight$1,
        Slider: sliderLight$1,
        Space: spaceLight$1,
        Spin: spinLight$1,
        Statistic: statisticLight$1,
        Steps: stepsLight$1,
        Switch: switchLight$1,
        Table: tableLight$1,
        Tabs: tabsLight$1,
        Tag: tagLight$1,
        Thing: thingLight$1,
        TimePicker: timePickerLight$1,
        Timeline: timelineLight$1,
        Tooltip: tooltipLight$1,
        Transfer: transferLight$2,
        Tree: treeLight$1,
        TreeSelect: treeSelectLight$1,
        Typography: typographyLight$1,
        Upload: uploadLight$1,
        Watermark: watermarkLight$1
      };
      var isVue2 = false;
      /*!
       * pinia v2.1.6
       * (c) 2023 Eduardo San Martin Morote
       * @license MIT
       */
      let activePinia;
      const setActivePinia = (pinia2) => activePinia = pinia2;
      const piniaSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function isPlainObject$1(o) {
        return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      function createPinia() {
        const scope = vue.effectScope(true);
        const state = scope.run(() => vue.ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia2 = vue.markRaw({
          install(app2) {
            setActivePinia(pinia2);
            {
              pinia2._a = app2;
              app2.provide(piniaSymbol, pinia2);
              app2.config.globalProperties.$pinia = pinia2;
              toBeInstalled.forEach((plugin2) => _p.push(plugin2));
              toBeInstalled = [];
            }
          },
          use(plugin2) {
            if (!this._a && !isVue2) {
              toBeInstalled.push(plugin2);
            } else {
              _p.push(plugin2);
            }
            return this;
          },
          _p,
          // it's actually undefined here
          // @ts-expect-error
          _a: null,
          _e: scope,
          _s: /* @__PURE__ */ new Map(),
          state
        });
        return pinia2;
      }
      const noop$1 = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && vue.getCurrentScope()) {
          vue.onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn) => fn();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        }
        if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function shouldHydrate(obj) {
        return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o) {
        return !!(vue.isRef(o) && o.effect);
      }
      function createOptionsStore(id, options, pinia2, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia2.state.value[id];
        let store;
        function setup2() {
          if (!initialState && true) {
            {
              pinia2.state.value[id] = state ? state() : {};
            }
          }
          const localState = vue.toRefs(pinia2.state.value[id]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            computedGetters[name] = vue.markRaw(vue.computed(() => {
              setActivePinia(pinia2);
              const store2 = pinia2._s.get(id);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id, setup2, options, pinia2, hot, true);
        return store;
      }
      function createSetupStore($id, setup2, options = {}, pinia2, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        const $subscribeOptions = {
          deep: true
          // flush: 'post',
        };
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia2.state.value[$id];
        if (!isOptionsStore && !initialState && true) {
          {
            pinia2.state.value[$id] = {};
          }
        }
        vue.ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia2.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          vue.nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
          /* istanbul ignore next */
          noop$1
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia2._s.delete($id);
        }
        function wrapAction(name, action) {
          return function() {
            setActivePinia(pinia2);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name,
              store,
              after,
              onError
            });
            let ret;
            try {
              ret = action.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
        }
        const partialStore = {
          _p: pinia2,
          // _s: scope,
          $id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => vue.watch(() => pinia2.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = vue.reactive(partialStore);
        pinia2._s.set($id, store);
        const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
        const setupStore = pinia2._e.run(() => {
          scope = vue.effectScope();
          return runWithContext(() => scope.run(setup2));
        });
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
            if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (vue.isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              {
                pinia2.state.value[$id][key] = prop;
              }
            }
          } else if (typeof prop === "function") {
            const actionValue = wrapAction(key, prop);
            {
              setupStore[key] = actionValue;
            }
            optionsForPlugin.actions[key] = prop;
          } else
            ;
        }
        {
          assign(store, setupStore);
          assign(vue.toRaw(store), setupStore);
        }
        Object.defineProperty(store, "$state", {
          get: () => pinia2.state.value[$id],
          set: (state) => {
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        pinia2._p.forEach((extender) => {
          {
            assign(store, scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            })));
          }
        });
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }
      function defineStore(idOrOptions, setup2, setupOptions) {
        let id;
        let options;
        const isSetupStore = typeof setup2 === "function";
        if (typeof idOrOptions === "string") {
          id = idOrOptions;
          options = isSetupStore ? setupOptions : setup2;
        } else {
          options = idOrOptions;
          id = idOrOptions.id;
        }
        function useStore(pinia2, hot) {
          const hasContext = vue.hasInjectionContext();
          pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
          // pinia instance with getActivePinia()
          pinia2 || (hasContext ? vue.inject(piniaSymbol, null) : null);
          if (pinia2)
            setActivePinia(pinia2);
          pinia2 = activePinia;
          if (!pinia2._s.has(id)) {
            if (isSetupStore) {
              createSetupStore(id, setup2, options, pinia2);
            } else {
              createOptionsStore(id, options, pinia2);
            }
          }
          const store = pinia2._s.get(id);
          return store;
        }
        useStore.$id = id;
        return useStore;
      }
      function bind(fn, thisArg) {
        return function wrap() {
          return fn.apply(thisArg, arguments);
        };
      }
      const { toString } = Object.prototype;
      const { getPrototypeOf } = Object;
      const kindOf = ((cache2) => (thing) => {
        const str = toString.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null));
      const kindOfTest = (type2) => {
        type2 = type2.toLowerCase();
        return (thing) => kindOf(thing) === type2;
      };
      const typeOfTest = (type2) => (thing) => typeof thing === type2;
      const { isArray } = Array;
      const isUndefined = typeOfTest("undefined");
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
      }
      const isArrayBuffer = kindOfTest("ArrayBuffer");
      function isArrayBufferView(val) {
        let result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      const isString = typeOfTest("string");
      const isFunction = typeOfTest("function");
      const isNumber = typeOfTest("number");
      const isObject = (thing) => thing !== null && typeof thing === "object";
      const isBoolean = (thing) => thing === true || thing === false;
      const isPlainObject = (val) => {
        if (kindOf(val) !== "object") {
          return false;
        }
        const prototype2 = getPrototypeOf(val);
        return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
      };
      const isDate = kindOfTest("Date");
      const isFile = kindOfTest("File");
      const isBlob = kindOfTest("Blob");
      const isFileList = kindOfTest("FileList");
      const isStream = (val) => isObject(val) && isFunction(val.pipe);
      const isFormData = (thing) => {
        let kind;
        return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
        kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
      };
      const isURLSearchParams = kindOfTest("URLSearchParams");
      const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      function forEach(obj, fn, { allOwnKeys = false } = {}) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        let i;
        let l;
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
          const len2 = keys2.length;
          let key;
          for (i = 0; i < len2; i++) {
            key = keys2[i];
            fn.call(null, obj[key], key, obj);
          }
        }
      }
      function findKey(obj, key) {
        key = key.toLowerCase();
        const keys2 = Object.keys(obj);
        let i = keys2.length;
        let _key;
        while (i-- > 0) {
          _key = keys2[i];
          if (key === _key.toLowerCase()) {
            return _key;
          }
        }
        return null;
      }
      const _global = (() => {
        if (typeof globalThis !== "undefined")
          return globalThis;
        return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      })();
      const isContextDefined = (context) => !isUndefined(context) && context !== _global;
      function merge() {
        const { caseless } = isContextDefined(this) && this || {};
        const result = {};
        const assignValue2 = (val, key) => {
          const targetKey = caseless && findKey(result, key) || key;
          if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
            result[targetKey] = merge(result[targetKey], val);
          } else if (isPlainObject(val)) {
            result[targetKey] = merge({}, val);
          } else if (isArray(val)) {
            result[targetKey] = val.slice();
          } else {
            result[targetKey] = val;
          }
        };
        for (let i = 0, l = arguments.length; i < l; i++) {
          arguments[i] && forEach(arguments[i], assignValue2);
        }
        return result;
      }
      const extend = (a2, b, thisArg, { allOwnKeys } = {}) => {
        forEach(b, (val, key) => {
          if (thisArg && isFunction(val)) {
            a2[key] = bind(val, thisArg);
          } else {
            a2[key] = val;
          }
        }, { allOwnKeys });
        return a2;
      };
      const stripBOM = (content) => {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      };
      const inherits = (constructor, superConstructor, props, descriptors2) => {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
        constructor.prototype.constructor = constructor;
        Object.defineProperty(constructor, "super", {
          value: superConstructor.prototype
        });
        props && Object.assign(constructor.prototype, props);
      };
      const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
        let props;
        let i;
        let prop;
        const merged = {};
        destObj = destObj || {};
        if (sourceObj == null)
          return destObj;
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i = props.length;
          while (i-- > 0) {
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = filter !== false && getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      };
      const endsWith = (str, searchString, position) => {
        str = String(str);
        if (position === void 0 || position > str.length) {
          position = str.length;
        }
        position -= searchString.length;
        const lastIndex = str.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
      const toArray = (thing) => {
        if (!thing)
          return null;
        if (isArray(thing))
          return thing;
        let i = thing.length;
        if (!isNumber(i))
          return null;
        const arr = new Array(i);
        while (i-- > 0) {
          arr[i] = thing[i];
        }
        return arr;
      };
      const isTypedArray = ((TypedArray) => {
        return (thing) => {
          return TypedArray && thing instanceof TypedArray;
        };
      })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
      const forEachEntry = (obj, fn) => {
        const generator = obj && obj[Symbol.iterator];
        const iterator = generator.call(obj);
        let result;
        while ((result = iterator.next()) && !result.done) {
          const pair = result.value;
          fn.call(obj, pair[0], pair[1]);
        }
      };
      const matchAll = (regExp, str) => {
        let matches;
        const arr = [];
        while ((matches = regExp.exec(str)) !== null) {
          arr.push(matches);
        }
        return arr;
      };
      const isHTMLForm = kindOfTest("HTMLFormElement");
      const toCamelCase$1 = (str) => {
        return str.toLowerCase().replace(
          /[-_\s]([a-z\d])(\w*)/g,
          function replacer(m, p1, p2) {
            return p1.toUpperCase() + p2;
          }
        );
      };
      const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
      const isRegExp = kindOfTest("RegExp");
      const reduceDescriptors = (obj, reducer) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(obj);
        const reducedDescriptors = {};
        forEach(descriptors2, (descriptor, name) => {
          let ret;
          if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
          }
        });
        Object.defineProperties(obj, reducedDescriptors);
      };
      const freezeMethods = (obj) => {
        reduceDescriptors(obj, (descriptor, name) => {
          if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
            return false;
          }
          const value = obj[name];
          if (!isFunction(value))
            return;
          descriptor.enumerable = false;
          if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
          }
          if (!descriptor.set) {
            descriptor.set = () => {
              throw Error("Can not rewrite read-only method '" + name + "'");
            };
          }
        });
      };
      const toObjectSet = (arrayOrString, delimiter) => {
        const obj = {};
        const define = (arr) => {
          arr.forEach((value) => {
            obj[value] = true;
          });
        };
        isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
        return obj;
      };
      const noop = () => {
      };
      const toFiniteNumber = (value, defaultValue) => {
        value = +value;
        return Number.isFinite(value) ? value : defaultValue;
      };
      const ALPHA = "abcdefghijklmnopqrstuvwxyz";
      const DIGIT = "0123456789";
      const ALPHABET = {
        DIGIT,
        ALPHA,
        ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
      };
      const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
        let str = "";
        const { length } = alphabet;
        while (size2--) {
          str += alphabet[Math.random() * length | 0];
        }
        return str;
      };
      function isSpecCompliantForm(thing) {
        return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
      }
      const toJSONObject = (obj) => {
        const stack2 = new Array(10);
        const visit = (source, i) => {
          if (isObject(source)) {
            if (stack2.indexOf(source) >= 0) {
              return;
            }
            if (!("toJSON" in source)) {
              stack2[i] = source;
              const target = isArray(source) ? [] : {};
              forEach(source, (value, key) => {
                const reducedValue = visit(value, i + 1);
                !isUndefined(reducedValue) && (target[key] = reducedValue);
              });
              stack2[i] = void 0;
              return target;
            }
          }
          return source;
        };
        return visit(obj, 0);
      };
      const isAsyncFn = kindOfTest("AsyncFunction");
      const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
      const utils$1 = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isBoolean,
        isObject,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isRegExp,
        isFunction,
        isStream,
        isURLSearchParams,
        isTypedArray,
        isFileList,
        forEach,
        merge,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty,
        hasOwnProp: hasOwnProperty,
        // an alias to avoid ESLint no-prototype-builtins detection
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase: toCamelCase$1,
        noop,
        toFiniteNumber,
        findKey,
        global: _global,
        isContextDefined,
        ALPHABET,
        generateString,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable
      };
      function AxiosError(message2, code, config, request, response) {
        Error.call(this);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack;
        }
        this.message = message2;
        this.name = "AxiosError";
        code && (this.code = code);
        config && (this.config = config);
        request && (this.request = request);
        response && (this.response = response);
      }
      utils$1.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        }
      });
      const prototype$1 = AxiosError.prototype;
      const descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
        // eslint-disable-next-line func-names
      ].forEach((code) => {
        descriptors[code] = { value: code };
      });
      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype$1, "isAxiosError", { value: true });
      AxiosError.from = (error, code, config, request, response, customProps) => {
        const axiosError = Object.create(prototype$1);
        utils$1.toFlatObject(error, axiosError, function filter(obj) {
          return obj !== Error.prototype;
        }, (prop) => {
          return prop !== "isAxiosError";
        });
        AxiosError.call(axiosError, error.message, code, config, request, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      const httpAdapter = null;
      function isVisitable(thing) {
        return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
      }
      function removeBrackets(key) {
        return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
      }
      function renderKey(path, key, dots) {
        if (!path)
          return key;
        return path.concat(key).map(function each(token, i) {
          token = removeBrackets(token);
          return !dots && i ? "[" + token + "]" : token;
        }).join(dots ? "." : "");
      }
      function isFlatArray(arr) {
        return utils$1.isArray(arr) && !arr.some(isVisitable);
      }
      const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
        return /^is[A-Z]/.test(prop);
      });
      function toFormData(obj, formData, options) {
        if (!utils$1.isObject(obj)) {
          throw new TypeError("target must be an object");
        }
        formData = formData || new FormData();
        options = utils$1.toFlatObject(options, {
          metaTokens: true,
          dots: false,
          indexes: false
        }, false, function defined(option, source) {
          return !utils$1.isUndefined(source[option]);
        });
        const metaTokens = options.metaTokens;
        const visitor = options.visitor || defaultVisitor;
        const dots = options.dots;
        const indexes = options.indexes;
        const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
        const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
        if (!utils$1.isFunction(visitor)) {
          throw new TypeError("visitor must be a function");
        }
        function convertValue(value) {
          if (value === null)
            return "";
          if (utils$1.isDate(value)) {
            return value.toISOString();
          }
          if (!useBlob && utils$1.isBlob(value)) {
            throw new AxiosError("Blob is not supported. Use a Buffer instead.");
          }
          if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
            return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
          }
          return value;
        }
        function defaultVisitor(value, key, path) {
          let arr = value;
          if (value && !path && typeof value === "object") {
            if (utils$1.endsWith(key, "{}")) {
              key = metaTokens ? key : key.slice(0, -2);
              value = JSON.stringify(value);
            } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
              key = removeBrackets(key);
              arr.forEach(function each(el, index) {
                !(utils$1.isUndefined(el) || el === null) && formData.append(
                  // eslint-disable-next-line no-nested-ternary
                  indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                  convertValue(el)
                );
              });
              return false;
            }
          }
          if (isVisitable(value)) {
            return true;
          }
          formData.append(renderKey(path, key, dots), convertValue(value));
          return false;
        }
        const stack2 = [];
        const exposedHelpers = Object.assign(predicates, {
          defaultVisitor,
          convertValue,
          isVisitable
        });
        function build(value, path) {
          if (utils$1.isUndefined(value))
            return;
          if (stack2.indexOf(value) !== -1) {
            throw Error("Circular reference detected in " + path.join("."));
          }
          stack2.push(value);
          utils$1.forEach(value, function each(el, key) {
            const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
              formData,
              el,
              utils$1.isString(key) ? key.trim() : key,
              path,
              exposedHelpers
            );
            if (result === true) {
              build(el, path ? path.concat(key) : [key]);
            }
          });
          stack2.pop();
        }
        if (!utils$1.isObject(obj)) {
          throw new TypeError("data must be an object");
        }
        build(obj);
        return formData;
      }
      function encode$1(str) {
        const charMap = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
          return charMap[match2];
        });
      }
      function AxiosURLSearchParams(params, options) {
        this._pairs = [];
        params && toFormData(params, this, options);
      }
      const prototype = AxiosURLSearchParams.prototype;
      prototype.append = function append(name, value) {
        this._pairs.push([name, value]);
      };
      prototype.toString = function toString2(encoder) {
        const _encode = encoder ? function(value) {
          return encoder.call(this, value, encode$1);
        } : encode$1;
        return this._pairs.map(function each(pair) {
          return _encode(pair[0]) + "=" + _encode(pair[1]);
        }, "").join("&");
      };
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function buildURL(url, params, options) {
        if (!params) {
          return url;
        }
        const _encode = options && options.encode || encode;
        const serializeFn = options && options.serialize;
        let serializedParams;
        if (serializeFn) {
          serializedParams = serializeFn(params, options);
        } else {
          serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
        }
        if (serializedParams) {
          const hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      }
      class InterceptorManager {
        constructor() {
          this.handlers = [];
        }
        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        }
        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         *
         * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
         */
        eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
        /**
         * Clear all interceptors from the stack
         *
         * @returns {void}
         */
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         *
         * @returns {void}
         */
        forEach(fn) {
          utils$1.forEach(this.handlers, function forEachHandler(h2) {
            if (h2 !== null) {
              fn(h2);
            }
          });
        }
      }
      const InterceptorManager$1 = InterceptorManager;
      const transitionalDefaults = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
      const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
      const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
      const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
      const isStandardBrowserEnv = (() => {
        let product;
        if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      })();
      const isStandardBrowserWebWorkerEnv = (() => {
        return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
      })();
      const platform = {
        isBrowser: true,
        classes: {
          URLSearchParams: URLSearchParams$1,
          FormData: FormData$1,
          Blob: Blob$1
        },
        isStandardBrowserEnv,
        isStandardBrowserWebWorkerEnv,
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
      function toURLEncodedForm(data, options) {
        return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
          visitor: function(value, key, path, helpers) {
            if (platform.isNode && utils$1.isBuffer(value)) {
              this.append(key, value.toString("base64"));
              return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
          }
        }, options));
      }
      function parsePropPath(name) {
        return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
          return match2[0] === "[]" ? "" : match2[1] || match2[0];
        });
      }
      function arrayToObject(arr) {
        const obj = {};
        const keys2 = Object.keys(arr);
        let i;
        const len2 = keys2.length;
        let key;
        for (i = 0; i < len2; i++) {
          key = keys2[i];
          obj[key] = arr[key];
        }
        return obj;
      }
      function formDataToJSON(formData) {
        function buildPath(path, value, target, index) {
          let name = path[index++];
          const isNumericKey = Number.isFinite(+name);
          const isLast = index >= path.length;
          name = !name && utils$1.isArray(target) ? target.length : name;
          if (isLast) {
            if (utils$1.hasOwnProp(target, name)) {
              target[name] = [target[name], value];
            } else {
              target[name] = value;
            }
            return !isNumericKey;
          }
          if (!target[name] || !utils$1.isObject(target[name])) {
            target[name] = [];
          }
          const result = buildPath(path, value, target[name], index);
          if (result && utils$1.isArray(target[name])) {
            target[name] = arrayToObject(target[name]);
          }
          return !isNumericKey;
        }
        if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
          const obj = {};
          utils$1.forEachEntry(formData, (name, value) => {
            buildPath(parsePropPath(name), value, obj, 0);
          });
          return obj;
        }
        return null;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils$1.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils$1.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      const defaults = {
        transitional: transitionalDefaults,
        adapter: ["xhr", "http"],
        transformRequest: [function transformRequest(data, headers) {
          const contentType = headers.getContentType() || "";
          const hasJSONContentType = contentType.indexOf("application/json") > -1;
          const isObjectPayload = utils$1.isObject(data);
          if (isObjectPayload && utils$1.isHTMLForm(data)) {
            data = new FormData(data);
          }
          const isFormData2 = utils$1.isFormData(data);
          if (isFormData2) {
            if (!hasJSONContentType) {
              return data;
            }
            return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
          }
          if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
            return data;
          }
          if (utils$1.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils$1.isURLSearchParams(data)) {
            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return data.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
              return toURLEncodedForm(data, this.formSerializer).toString();
            }
            if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
              const _FormData = this.env && this.env.FormData;
              return toFormData(
                isFileList2 ? { "files[]": data } : data,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType("application/json", false);
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          const transitional = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          const JSONRequested = this.responseType === "json";
          if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
            const silentJSONParsing = transitional && transitional.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: platform.classes.FormData,
          Blob: platform.classes.Blob
        },
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method2) => {
        defaults.headers[method2] = {};
      });
      const defaults$1 = defaults;
      const ignoreDuplicateOf = utils$1.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]);
      const parseHeaders = (rawHeaders) => {
        const parsed = {};
        let key;
        let val;
        let i;
        rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
          i = line.indexOf(":");
          key = line.substring(0, i).trim().toLowerCase();
          val = line.substring(i + 1).trim();
          if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
          }
          if (key === "set-cookie") {
            if (parsed[key]) {
              parsed[key].push(val);
            } else {
              parsed[key] = [val];
            }
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        });
        return parsed;
      };
      const $internals = Symbol("internals");
      function normalizeHeader(header) {
        return header && String(header).trim().toLowerCase();
      }
      function normalizeValue(value) {
        if (value === false || value == null) {
          return value;
        }
        return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
      }
      function parseTokens(str) {
        const tokens = /* @__PURE__ */ Object.create(null);
        const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let match2;
        while (match2 = tokensRE.exec(str)) {
          tokens[match2[1]] = match2[2];
        }
        return tokens;
      }
      const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
      function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
        if (utils$1.isFunction(filter)) {
          return filter.call(this, value, header);
        }
        if (isHeaderNameFilter) {
          value = header;
        }
        if (!utils$1.isString(value))
          return;
        if (utils$1.isString(filter)) {
          return value.indexOf(filter) !== -1;
        }
        if (utils$1.isRegExp(filter)) {
          return filter.test(value);
        }
      }
      function formatHeader(header) {
        return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
          return char.toUpperCase() + str;
        });
      }
      function buildAccessors(obj, header) {
        const accessorName = utils$1.toCamelCase(" " + header);
        ["get", "set", "has"].forEach((methodName) => {
          Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
              return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
          });
        });
      }
      class AxiosHeaders {
        constructor(headers) {
          headers && this.set(headers);
        }
        set(header, valueOrRewrite, rewrite) {
          const self2 = this;
          function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
              throw new Error("header name must be a non-empty string");
            }
            const key = utils$1.findKey(self2, lHeader);
            if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
              self2[key || _header] = normalizeValue(_value);
            }
          }
          const setHeaders2 = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
          if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
            setHeaders2(header, valueOrRewrite);
          } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders2(parseHeaders(header), valueOrRewrite);
          } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
          }
          return this;
        }
        get(header, parser) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            if (key) {
              const value = this[key];
              if (!parser) {
                return value;
              }
              if (parser === true) {
                return parseTokens(value);
              }
              if (utils$1.isFunction(parser)) {
                return parser.call(this, value, key);
              }
              if (utils$1.isRegExp(parser)) {
                return parser.exec(value);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(header, matcher) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
          }
          return false;
        }
        delete(header, matcher) {
          const self2 = this;
          let deleted = false;
          function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
              const key = utils$1.findKey(self2, _header);
              if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                delete self2[key];
                deleted = true;
              }
            }
          }
          if (utils$1.isArray(header)) {
            header.forEach(deleteHeader);
          } else {
            deleteHeader(header);
          }
          return deleted;
        }
        clear(matcher) {
          const keys2 = Object.keys(this);
          let i = keys2.length;
          let deleted = false;
          while (i--) {
            const key = keys2[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
              delete this[key];
              deleted = true;
            }
          }
          return deleted;
        }
        normalize(format2) {
          const self2 = this;
          const headers = {};
          utils$1.forEach(this, (value, header) => {
            const key = utils$1.findKey(headers, header);
            if (key) {
              self2[key] = normalizeValue(value);
              delete self2[header];
              return;
            }
            const normalized = format2 ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
              delete self2[header];
            }
            self2[normalized] = normalizeValue(value);
            headers[normalized] = true;
          });
          return this;
        }
        concat(...targets) {
          return this.constructor.concat(this, ...targets);
        }
        toJSON(asStrings) {
          const obj = /* @__PURE__ */ Object.create(null);
          utils$1.forEach(this, (value, header) => {
            value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
          });
          return obj;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(thing) {
          return thing instanceof this ? thing : new this(thing);
        }
        static concat(first, ...targets) {
          const computed2 = new this(first);
          targets.forEach((target) => computed2.set(target));
          return computed2;
        }
        static accessor(header) {
          const internals = this[$internals] = this[$internals] = {
            accessors: {}
          };
          const accessors = internals.accessors;
          const prototype2 = this.prototype;
          function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
              buildAccessors(prototype2, _header);
              accessors[lHeader] = true;
            }
          }
          utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
          return this;
        }
      }
      AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
        let mapped = key[0].toUpperCase() + key.slice(1);
        return {
          get: () => value,
          set(headerValue) {
            this[mapped] = headerValue;
          }
        };
      });
      utils$1.freezeMethods(AxiosHeaders);
      const AxiosHeaders$1 = AxiosHeaders;
      function transformData(fns, response) {
        const config = this || defaults$1;
        const context = response || config;
        const headers = AxiosHeaders$1.from(context.headers);
        let data = context.data;
        utils$1.forEach(fns, function transform(fn) {
          data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
        });
        headers.normalize();
        return data;
      }
      function isCancel(value) {
        return !!(value && value.__CANCEL__);
      }
      function CanceledError(message2, config, request) {
        AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request);
        this.name = "CanceledError";
      }
      utils$1.inherits(CanceledError, AxiosError, {
        __CANCEL__: true
      });
      function settle(resolve, reject, response) {
        const validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(new AxiosError(
            "Request failed with status code " + response.status,
            [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
            response.config,
            response.request,
            response
          ));
        }
      }
      const cookies = platform.isStandardBrowserEnv ? (
        // Standard browser envs support document.cookie
        function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              const cookie = [];
              cookie.push(name + "=" + encodeURIComponent(value));
              if (utils$1.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
              }
              if (utils$1.isString(path)) {
                cookie.push("path=" + path);
              }
              if (utils$1.isString(domain)) {
                cookie.push("domain=" + domain);
              }
              if (secure === true) {
                cookie.push("secure");
              }
              document.cookie = cookie.join("; ");
            },
            read: function read(name) {
              const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
              return match2 ? decodeURIComponent(match2[3]) : null;
            },
            remove: function remove(name) {
              this.write(name, "", Date.now() - 864e5);
            }
          };
        }()
      ) : (
        // Non standard browser env (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return {
            write: function write() {
            },
            read: function read() {
              return null;
            },
            remove: function remove() {
            }
          };
        }()
      );
      function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      }
      function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      }
      function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      }
      const isURLSameOrigin = platform.isStandardBrowserEnv ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          const msie = /(msie|trident)/i.test(navigator.userAgent);
          const urlParsingNode = document.createElement("a");
          let originURL;
          function resolveURL(url) {
            let href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin2(requestURL) {
            const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return function isURLSameOrigin2() {
            return true;
          };
        }()
      );
      function parseProtocol(url) {
        const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return match2 && match2[1] || "";
      }
      function speedometer(samplesCount, min) {
        samplesCount = samplesCount || 10;
        const bytes = new Array(samplesCount);
        const timestamps = new Array(samplesCount);
        let head2 = 0;
        let tail = 0;
        let firstSampleTS;
        min = min !== void 0 ? min : 1e3;
        return function push(chunkLength) {
          const now2 = Date.now();
          const startedAt = timestamps[tail];
          if (!firstSampleTS) {
            firstSampleTS = now2;
          }
          bytes[head2] = chunkLength;
          timestamps[head2] = now2;
          let i = tail;
          let bytesCount = 0;
          while (i !== head2) {
            bytesCount += bytes[i++];
            i = i % samplesCount;
          }
          head2 = (head2 + 1) % samplesCount;
          if (head2 === tail) {
            tail = (tail + 1) % samplesCount;
          }
          if (now2 - firstSampleTS < min) {
            return;
          }
          const passed = startedAt && now2 - startedAt;
          return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
        };
      }
      function progressEventReducer(listener, isDownloadStream) {
        let bytesNotified = 0;
        const _speedometer = speedometer(50, 250);
        return (e) => {
          const loaded = e.loaded;
          const total = e.lengthComputable ? e.total : void 0;
          const progressBytes = loaded - bytesNotified;
          const rate = _speedometer(progressBytes);
          const inRange = loaded <= total;
          bytesNotified = loaded;
          const data = {
            loaded,
            total,
            progress: total ? loaded / total : void 0,
            bytes: progressBytes,
            rate: rate ? rate : void 0,
            estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
            event: e
          };
          data[isDownloadStream ? "download" : "upload"] = true;
          listener(data);
        };
      }
      const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
      const xhrAdapter = isXHRAdapterSupported && function(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          let requestData = config.data;
          const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
          const responseType = config.responseType;
          let onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          let contentType;
          if (utils$1.isFormData(requestData)) {
            if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
              requestHeaders.setContentType(false);
            } else if (!requestHeaders.getContentType(/^\s*multipart\/form-data/)) {
              requestHeaders.setContentType("multipart/form-data");
            } else if (utils$1.isString(contentType = requestHeaders.getContentType())) {
              requestHeaders.setContentType(contentType.replace(/^\s*(multipart\/form-data);+/, "$1"));
            }
          }
          let request = new XMLHttpRequest();
          if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
          }
          const fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            const responseHeaders = AxiosHeaders$1.from(
              "getAllResponseHeaders" in request && request.getAllResponseHeaders()
            );
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              request
            ));
            request = null;
          };
          if (platform.isStandardBrowserEnv) {
            const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
          requestData === void 0 && requestHeaders.setContentType(null);
          if ("setRequestHeader" in request) {
            utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
              request.setRequestHeader(key, val);
            });
          }
          if (!utils$1.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
          }
          if (config.cancelToken || config.signal) {
            onCanceled = (cancel) => {
              if (!request) {
                return;
              }
              reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          const protocol2 = parseProtocol(fullPath);
          if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
            reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
            return;
          }
          request.send(requestData || null);
        });
      };
      const knownAdapters = {
        http: httpAdapter,
        xhr: xhrAdapter
      };
      utils$1.forEach(knownAdapters, (fn, value) => {
        if (fn) {
          try {
            Object.defineProperty(fn, "name", { value });
          } catch (e) {
          }
          Object.defineProperty(fn, "adapterName", { value });
        }
      });
      const renderReason = (reason) => `- ${reason}`;
      const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
      const adapters = {
        getAdapter: (adapters2) => {
          adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
          const { length } = adapters2;
          let nameOrAdapter;
          let adapter;
          const rejectedReasons = {};
          for (let i = 0; i < length; i++) {
            nameOrAdapter = adapters2[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
              adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
              if (adapter === void 0) {
                throw new AxiosError(`Unknown adapter '${id}'`);
              }
            }
            if (adapter) {
              break;
            }
            rejectedReasons[id || "#" + i] = adapter;
          }
          if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(
              ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
            );
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError(
              `There is no suitable adapter to dispatch the request ` + s,
              "ERR_NOT_SUPPORT"
            );
          }
          return adapter;
        },
        adapters: knownAdapters
      };
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new CanceledError(null, config);
        }
      }
      function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = AxiosHeaders$1.from(config.headers);
        config.data = transformData.call(
          config,
          config.transformRequest
        );
        if (["post", "put", "patch"].indexOf(config.method) !== -1) {
          config.headers.setContentType("application/x-www-form-urlencoded", false);
        }
        const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(
            config,
            config.transformResponse,
            response
          );
          response.headers = AxiosHeaders$1.from(response.headers);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config,
                config.transformResponse,
                reason.response
              );
              reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
            }
          }
          return Promise.reject(reason);
        });
      }
      const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
      function mergeConfig(config1, config2) {
        config2 = config2 || {};
        const config = {};
        function getMergedValue(target, source, caseless) {
          if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
            return utils$1.merge.call({ caseless }, target, source);
          } else if (utils$1.isPlainObject(source)) {
            return utils$1.merge({}, source);
          } else if (utils$1.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(a2, b, caseless) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(a2, b, caseless);
          } else if (!utils$1.isUndefined(a2)) {
            return getMergedValue(void 0, a2, caseless);
          }
        }
        function valueFromConfig2(a2, b) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(void 0, b);
          }
        }
        function defaultToConfig2(a2, b) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(void 0, b);
          } else if (!utils$1.isUndefined(a2)) {
            return getMergedValue(void 0, a2);
          }
        }
        function mergeDirectKeys(a2, b, prop) {
          if (prop in config2) {
            return getMergedValue(a2, b);
          } else if (prop in config1) {
            return getMergedValue(void 0, a2);
          }
        }
        const mergeMap = {
          url: valueFromConfig2,
          method: valueFromConfig2,
          data: valueFromConfig2,
          baseURL: defaultToConfig2,
          transformRequest: defaultToConfig2,
          transformResponse: defaultToConfig2,
          paramsSerializer: defaultToConfig2,
          timeout: defaultToConfig2,
          timeoutMessage: defaultToConfig2,
          withCredentials: defaultToConfig2,
          adapter: defaultToConfig2,
          responseType: defaultToConfig2,
          xsrfCookieName: defaultToConfig2,
          xsrfHeaderName: defaultToConfig2,
          onUploadProgress: defaultToConfig2,
          onDownloadProgress: defaultToConfig2,
          decompress: defaultToConfig2,
          maxContentLength: defaultToConfig2,
          maxBodyLength: defaultToConfig2,
          beforeRedirect: defaultToConfig2,
          transport: defaultToConfig2,
          httpAgent: defaultToConfig2,
          httpsAgent: defaultToConfig2,
          cancelToken: defaultToConfig2,
          socketPath: defaultToConfig2,
          responseEncoding: defaultToConfig2,
          validateStatus: mergeDirectKeys,
          headers: (a2, b) => mergeDeepProperties(headersToObject(a2), headersToObject(b), true)
        };
        utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
          const merge2 = mergeMap[prop] || mergeDeepProperties;
          const configValue = merge2(config1[prop], config2[prop], prop);
          utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      }
      const VERSION = "1.5.1";
      const validators$1 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
        validators$1[type2] = function validator2(thing) {
          return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
        };
      });
      const deprecatedWarnings = {};
      validators$1.transitional = function transitional(validator2, version2, message2) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
        }
        return (value, opt, opts) => {
          if (validator2 === false) {
            throw new AxiosError(
              formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
              AxiosError.ERR_DEPRECATED
            );
          }
          if (version2 && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version2 + " and will be removed in the near future"
              )
            );
          }
          return validator2 ? validator2(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
        }
        const keys2 = Object.keys(options);
        let i = keys2.length;
        while (i-- > 0) {
          const opt = keys2[i];
          const validator2 = schema[opt];
          if (validator2) {
            const value = options[opt];
            const result = value === void 0 || validator2(value, opt, options);
            if (result !== true) {
              throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
          }
        }
      }
      const validator = {
        assertOptions,
        validators: validators$1
      };
      const validators = validator.validators;
      class Axios {
        constructor(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager$1(),
            response: new InterceptorManager$1()
          };
        }
        /**
         * Dispatch a request
         *
         * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
         * @param {?Object} config
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        request(configOrUrl, config) {
          if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
          } else {
            config = configOrUrl || {};
          }
          config = mergeConfig(this.defaults, config);
          const { transitional, paramsSerializer, headers } = config;
          if (transitional !== void 0) {
            validator.assertOptions(transitional, {
              silentJSONParsing: validators.transitional(validators.boolean),
              forcedJSONParsing: validators.transitional(validators.boolean),
              clarifyTimeoutError: validators.transitional(validators.boolean)
            }, false);
          }
          if (paramsSerializer != null) {
            if (utils$1.isFunction(paramsSerializer)) {
              config.paramsSerializer = {
                serialize: paramsSerializer
              };
            } else {
              validator.assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
              }, true);
            }
          }
          config.method = (config.method || this.defaults.method || "get").toLowerCase();
          let contextHeaders = headers && utils$1.merge(
            headers.common,
            headers[config.method]
          );
          headers && utils$1.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            (method2) => {
              delete headers[method2];
            }
          );
          config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
          const requestInterceptorChain = [];
          let synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          const responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          let promise;
          let i = 0;
          let len2;
          if (!synchronousRequestInterceptors) {
            const chain = [dispatchRequest.bind(this), void 0];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len2 = chain.length;
            promise = Promise.resolve(config);
            while (i < len2) {
              promise = promise.then(chain[i++], chain[i++]);
            }
            return promise;
          }
          len2 = requestInterceptorChain.length;
          let newConfig = config;
          i = 0;
          while (i < len2) {
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected.call(this, error);
              break;
            }
          }
          try {
            promise = dispatchRequest.call(this, newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          i = 0;
          len2 = responseInterceptorChain.length;
          while (i < len2) {
            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
          }
          return promise;
        }
        getUri(config) {
          config = mergeConfig(this.defaults, config);
          const fullPath = buildFullPath(config.baseURL, config.url);
          return buildURL(fullPath, config.params, config.paramsSerializer);
        }
      }
      utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
        Axios.prototype[method2] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method: method2,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data, config) {
            return this.request(mergeConfig(config || {}, {
              method: method2,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data
            }));
          };
        }
        Axios.prototype[method2] = generateHTTPMethod();
        Axios.prototype[method2 + "Form"] = generateHTTPMethod(true);
      });
      const Axios$1 = Axios;
      class CancelToken {
        constructor(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          let resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          const token = this;
          this.promise.then((cancel) => {
            if (!token._listeners)
              return;
            let i = token._listeners.length;
            while (i-- > 0) {
              token._listeners[i](cancel);
            }
            token._listeners = null;
          });
          this.promise.then = (onfulfilled) => {
            let _resolve;
            const promise = new Promise((resolve) => {
              token.subscribe(resolve);
              _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
              token.unsubscribe(_resolve);
            };
            return promise;
          };
          executor(function cancel(message2, config, request) {
            if (token.reason) {
              return;
            }
            token.reason = new CanceledError(message2, config, request);
            resolvePromise(token.reason);
          });
        }
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        /**
         * Subscribe to the cancel signal
         */
        subscribe(listener) {
          if (this.reason) {
            listener(this.reason);
            return;
          }
          if (this._listeners) {
            this._listeners.push(listener);
          } else {
            this._listeners = [listener];
          }
        }
        /**
         * Unsubscribe from the cancel signal
         */
        unsubscribe(listener) {
          if (!this._listeners) {
            return;
          }
          const index = this._listeners.indexOf(listener);
          if (index !== -1) {
            this._listeners.splice(index, 1);
          }
        }
        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        static source() {
          let cancel;
          const token = new CancelToken(function executor(c2) {
            cancel = c2;
          });
          return {
            token,
            cancel
          };
        }
      }
      const CancelToken$1 = CancelToken;
      function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      }
      function isAxiosError(payload) {
        return utils$1.isObject(payload) && payload.isAxiosError === true;
      }
      const HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(HttpStatusCode).forEach(([key, value]) => {
        HttpStatusCode[value] = key;
      });
      const HttpStatusCode$1 = HttpStatusCode;
      function createInstance(defaultConfig) {
        const context = new Axios$1(defaultConfig);
        const instance = bind(Axios$1.prototype.request, context);
        utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
        utils$1.extend(instance, context, null, { allOwnKeys: true });
        instance.create = function create2(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      const axios = createInstance(defaults$1);
      axios.Axios = Axios$1;
      axios.CanceledError = CanceledError;
      axios.CancelToken = CancelToken$1;
      axios.isCancel = isCancel;
      axios.VERSION = VERSION;
      axios.toFormData = toFormData;
      axios.AxiosError = AxiosError;
      axios.Cancel = axios.CanceledError;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = spread;
      axios.isAxiosError = isAxiosError;
      axios.mergeConfig = mergeConfig;
      axios.AxiosHeaders = AxiosHeaders$1;
      axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
      axios.getAdapter = adapters.getAdapter;
      axios.HttpStatusCode = HttpStatusCode$1;
      axios.default = axios;
      const axios$1 = axios;
      function getHeader() {
        const userToken = sessionStorage.getItem("userToken");
        const username = sessionStorage.getItem("chineseName");
        if (!userToken) {
          console.error("User token not found in sessionStorage");
          return;
        }
        const tenant = JSON.parse(localStorage.getItem("tenantList")).filter((ten) => {
          console.log(ten.tenantname);
          console.log(sessionStorage.getItem("tenantName"));
          return ten.tenantname == sessionStorage.getItem("tenantName");
        })[0];
        let headers = {
          "idetoken": userToken,
          "Content-Type": "application/json",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.43",
          "ctcode": 7,
          "metamodeltype": 2,
          // "pdcode": '100000000000000000',
          "pdcode": tenant.productcode,
          "pscode": tenant.productseriescode,
          "pvcode": tenant.productversioncode,
          "req_id": 23,
          "tecode": tenant.tenantcode,
          "tenantname": encodeURIComponent(tenant.tenantname),
          "usercode": localStorage.getItem("userCode"),
          "userinfoname": encodeURIComponent(username),
          "username": encodeURIComponent(username)
        };
        return headers;
      }
      async function getBizObjectsData() {
        try {
          const { data } = await axios$1.post("http://121.37.206.131:18001/bizserv/biz/getBizObjects", {}, {
            headers: getHeader()
          });
          return data;
        } catch (error) {
          console.error("axios error:", error);
        }
      }
      async function getProtocol() {
        const temp = document.URL.split("/");
        if (temp.length == 6) {
          let modellogiccode = temp[5];
          try {
            const userToken = sessionStorage.getItem("userToken");
            if (!userToken) {
              console.error("User token not found in sessionStorage");
              return;
            }
            const { data } = await axios$1.post("http://121.37.206.131:18001/bizserv/bizmodel/getModelLogic", {
              "modellogiccode": modellogiccode
            }, {
              headers: getHeader()
            });
            return data;
          } catch (error) {
            console.error("axios error:", error);
          }
        }
      }
      var ActionType = /* @__PURE__ */ ((ActionType2) => {
        ActionType2[ActionType2["ListQuery"] = 1] = "ListQuery";
        ActionType2[ActionType2["SingleQuery"] = 2] = "SingleQuery";
        ActionType2[ActionType2["DataSubmit"] = 3] = "DataSubmit";
        ActionType2[ActionType2["BatchSubmit"] = 4] = "BatchSubmit";
        ActionType2[ActionType2["Import"] = 5] = "Import";
        ActionType2[ActionType2["Export"] = 6] = "Export";
        ActionType2[ActionType2["OfflineDataRetrieval"] = 7] = "OfflineDataRetrieval";
        ActionType2[ActionType2["Flow"] = 8] = "Flow";
        ActionType2[ActionType2["BusinessScheduling"] = 9] = "BusinessScheduling";
        ActionType2[ActionType2["IpaasInterface"] = 10] = "IpaasInterface";
        return ActionType2;
      })(ActionType || {});
      const useFlyStore = defineStore("flyStore", () => {
        const tableDatas = vue.ref();
        const protocol2 = vue.ref();
        const tableDataMap2 = vue.ref(/* @__PURE__ */ new Map());
        const columnDataMap2 = vue.ref(/* @__PURE__ */ new Map());
        const initStatus = vue.ref(false);
        const appMounted = vue.ref(false);
        const ActiveGenerator = vue.ref();
        async function init2() {
          var _a, _b;
          tableDatas.value = (_a = await getBizObjectsData()) == null ? void 0 : _a.resp_data;
          if (document.URL.indexOf("modeledit") != -1 && document.URL.split("/").length == 6) {
            protocol2.value = (_b = await getProtocol()) == null ? void 0 : _b.resp_data;
          }
          tableDatas.value.forEach((data) => {
            tableDataMap2.value.set(data.objectcode, data);
            data.properties.forEach((columnData) => {
              columnDataMap2.value.set(columnData.propertycode, columnData);
            });
          });
        }
        vue.watch(protocol2, async () => {
          console.log(` watch(protocol, () => {`, protocol2.value, appMounted.value, initStatus.value);
          if (appMounted.value) {
            console.log("if (appMounted.value) {");
            initStatus.value = false;
            await vue.nextTick();
            refresh();
            initStatus.value = true;
          } else {
            refresh();
          }
        });
        async function updateProtocol(Timeout = 1e3) {
          setTimeout(async () => {
            protocol2.value = (await getProtocol()).resp_data;
          }, Timeout);
        }
        const insertOrUpdateNameArray = ["", "", "", "", "", "", ""];
        const deletedDataNameArray = [""];
        const refresh = () => {
          const actionType = protocol2.value.actiontype;
          const actioncategory = protocol2.value.actioncategory;
          const Import = actionType == ActionType.Import;
          const Export = actionType == ActionType.Export;
          if (actionType == ActionType.ListQuery || actionType == ActionType.SingleQuery) {
            ActiveGenerator.value = GeneratorName.queryGenerator;
            console.log(`ActiveGenerator.value = "queryGenerator"`);
          } else if (actionType == ActionType.DataSubmit) {
            const modellogicname = protocol2.value.modellogicname;
            if (deletedDataNameArray.some((name) => modellogicname.includes(name))) {
              ActiveGenerator.value = GeneratorName.deletedGenerator;
            } else if (insertOrUpdateNameArray.some((name) => modellogicname.includes(name))) {
              ActiveGenerator.value = GeneratorName.dataSubmitGenerator;
            }
          } else if (actionType == ActionType.BatchSubmit)
            ;
          else if (Import && actioncategory == "1") {
            ActiveGenerator.value = GeneratorName.ExcelImport;
          } else if (Export && actioncategory == "1") {
            ActiveGenerator.value = GeneratorName.ExcelExport;
          } else if (Import && actioncategory == "6") {
            ActiveGenerator.value = GeneratorName.flycodeImport;
          } else if (Export && actioncategory == "7") {
            ActiveGenerator.value = GeneratorName.flycodeExport;
          }
        };
        return {
          tableDatas,
          appMounted,
          ActiveGenerator,
          protocol: protocol2,
          tableDataMap: tableDataMap2,
          columnDataMap: columnDataMap2,
          init: init2,
          updateProtocol,
          initStatus
        };
      });
      function getTableShortName(tableName, relationTableColumnName, seq) {
        const words2 = tableName.split("_");
        const firstLetters = words2.map((word) => word.charAt(0));
        let name = firstLetters.join("");
        if (seq != void 0) {
          name += seq;
        } else {
          if (relationTableColumnName != void 0) {
            name += "_" + relationTableColumnName.slice(0, 3);
          }
        }
        return name;
      }
      const copyToClipboard = (text) => {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
      };
      const addButton = (selector, text, iconClass, clickHandler2, seq, hoverText) => {
        if (selector == void 0) {
          selector = "#beSetting > div.main-content > div.tab-operation > button:nth-child(2)";
        }
        if (document.querySelector(`#beSetting > div.main-content > div.tab-operation > button:nth-child(${2 + seq})`) != null) {
          return;
        }
        if (!document.querySelector(selector)) {
          console.error(`Button not found: ${selector}`);
          return;
        }
        const originalButton = document.querySelector(selector);
        const originalButtonIcon = originalButton.querySelector("i");
        const newButton = originalButton.cloneNode(false);
        const newButtonIcon = originalButtonIcon.cloneNode(true);
        newButtonIcon.classList.replace("ideicon-protocol", iconClass);
        const newButtonSpan = document.createElement("span");
        newButtonSpan.textContent = text;
        newButton.appendChild(newButtonIcon);
        newButton.appendChild(newButtonSpan);
        newButton.addEventListener("click", clickHandler2);
        hoverText ? newButton.title = hoverText : newButton.title = "dwsy";
        originalButton.parentNode.appendChild(newButton);
      };
      function toCamelCase(str) {
        if (!str) {
          return str;
        }
        return str.replace(/_([a-z])/g, (match2, p1) => p1.toUpperCase()).replace(/^([a-z])/g, (match2, p1) => p1.toUpperCase());
      }
      function getPrimaryKey(tablePropertyCode) {
        const flyStore = useFlyStore();
        const tableData = flyStore.tableDataMap.get(tablePropertyCode);
        let primaryKey = {
          pl_dictionary: "dictionaryid",
          pl_orgstruct: "orgstructid",
          pl_region: "regionid"
        }[tableData.tablename];
        if (!primaryKey) {
          for (const columnData of tableData.properties) {
            if (columnData.propertytypecode == "1") {
              primaryKey = columnData.columnname;
              break;
            }
          }
        }
        return primaryKey;
      }
      function levenshteinDistance(str1, str2) {
        const m = str1.length;
        const n = str2.length;
        const dp = Array.from({ length: m + 1 }, () => Array.from({ length: n + 1 }, () => 0));
        for (let i = 0; i <= m; i++) {
          dp[i][0] = i;
        }
        for (let j = 0; j <= n; j++) {
          dp[0][j] = j;
        }
        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1];
            } else {
              dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
            }
          }
        }
        return dp[m][n];
      }
      var PropertyTypeCode = /* @__PURE__ */ ((PropertyTypeCode2) => {
        PropertyTypeCode2[PropertyTypeCode2["PrimaryKey"] = 1] = "PrimaryKey";
        PropertyTypeCode2[PropertyTypeCode2["Name"] = 2] = "Name";
        PropertyTypeCode2[PropertyTypeCode2["Text"] = 3] = "Text";
        PropertyTypeCode2[PropertyTypeCode2["Memo"] = 996007e3] = "Memo";
        PropertyTypeCode2[PropertyTypeCode2["LongText"] = 4] = "LongText";
        PropertyTypeCode2[PropertyTypeCode2["Integer"] = 5] = "Integer";
        PropertyTypeCode2[PropertyTypeCode2["LongInteger"] = 6] = "LongInteger";
        PropertyTypeCode2[PropertyTypeCode2["Decimal"] = 10] = "Decimal";
        PropertyTypeCode2[PropertyTypeCode2["DateTime"] = 7] = "DateTime";
        PropertyTypeCode2[PropertyTypeCode2["TimeRange"] = 30] = "TimeRange";
        PropertyTypeCode2[PropertyTypeCode2["Date"] = 29] = "Date";
        PropertyTypeCode2[PropertyTypeCode2["Status"] = 18] = "Status";
        PropertyTypeCode2[PropertyTypeCode2["Image"] = 16] = "Image";
        PropertyTypeCode2[PropertyTypeCode2["Attachment"] = 26] = "Attachment";
        PropertyTypeCode2[PropertyTypeCode2["Location"] = 17] = "Location";
        PropertyTypeCode2[PropertyTypeCode2["OptionSet"] = 19] = "OptionSet";
        PropertyTypeCode2[PropertyTypeCode2["RelatedObject"] = 2e11] = "RelatedObject";
        PropertyTypeCode2[PropertyTypeCode2["DictionaryObject"] = 1e10] = "DictionaryObject";
        PropertyTypeCode2[PropertyTypeCode2["BusinessObject"] = 1e11] = "BusinessObject";
        PropertyTypeCode2[PropertyTypeCode2["ComplexRelatedObject"] = 3e11] = "ComplexRelatedObject";
        PropertyTypeCode2[PropertyTypeCode2["ThisObject"] = 1e9] = "ThisObject";
        PropertyTypeCode2[PropertyTypeCode2["CreatedBy"] = 8] = "CreatedBy";
        PropertyTypeCode2[PropertyTypeCode2["ModifiedBy"] = 9] = "ModifiedBy";
        PropertyTypeCode2[PropertyTypeCode2["CreatedTime"] = 11] = "CreatedTime";
        PropertyTypeCode2[PropertyTypeCode2["ModifiedTime"] = 12] = "ModifiedTime";
        PropertyTypeCode2[PropertyTypeCode2["Pinyin"] = 31] = "Pinyin";
        PropertyTypeCode2[PropertyTypeCode2["IsDefault"] = 100] = "IsDefault";
        PropertyTypeCode2[PropertyTypeCode2["PhoneNumber"] = 13] = "PhoneNumber";
        PropertyTypeCode2[PropertyTypeCode2["TelephoneNumber"] = 15] = "TelephoneNumber";
        PropertyTypeCode2[PropertyTypeCode2["Email"] = 14] = "Email";
        PropertyTypeCode2[PropertyTypeCode2["PostalCode"] = 27] = "PostalCode";
        PropertyTypeCode2[PropertyTypeCode2["SortOrder"] = 20] = "SortOrder";
        return PropertyTypeCode2;
      })(PropertyTypeCode || {});
      const PropertyTypeName = {
        [
          1
          /* PrimaryKey */
        ]: "",
        [
          2
          /* Name */
        ]: "",
        [
          3
          /* Text */
        ]: "",
        [
          996007e3
          /* Memo */
        ]: "",
        [
          4
          /* LongText */
        ]: "",
        [
          5
          /* Integer */
        ]: "",
        [
          6
          /* LongInteger */
        ]: "",
        [
          10
          /* Decimal */
        ]: "",
        [
          7
          /* DateTime */
        ]: "",
        [
          30
          /* TimeRange */
        ]: "",
        [
          29
          /* Date */
        ]: "",
        [
          18
          /* Status */
        ]: "",
        [
          16
          /* Image */
        ]: "",
        [
          26
          /* Attachment */
        ]: "",
        [
          17
          /* Location */
        ]: "",
        [
          19
          /* OptionSet */
        ]: "",
        [
          1e11
          /* BusinessObject */
        ]: "",
        [
          2e11
          /* RelatedObject */
        ]: "",
        [
          1e10
          /* DictionaryObject */
        ]: "",
        [
          3e11
          /* ComplexRelatedObject */
        ]: "",
        [
          1e9
          /* ThisObject */
        ]: "",
        [
          8
          /* CreatedBy */
        ]: "",
        [
          9
          /* ModifiedBy */
        ]: "",
        [
          11
          /* CreatedTime */
        ]: "",
        [
          12
          /* ModifiedTime */
        ]: "",
        [
          31
          /* Pinyin */
        ]: "",
        [
          100
          /* IsDefault */
        ]: "",
        [
          13
          /* PhoneNumber */
        ]: "",
        [
          15
          /* TelephoneNumber */
        ]: "",
        [
          14
          /* Email */
        ]: "",
        [
          27
          /* PostalCode */
        ]: "",
        [
          20
          /* SortOrder */
        ]: ""
      };
      const DatePropertyCodes = [
        29,
        7,
        30,
        11,
        12
        /* ModifiedTime */
      ];
      function getPropertyTypeName(code) {
        return PropertyTypeName[Number(code)] || "";
      }
      const ignorePropertyType = [
        1,
        17,
        20,
        4,
        16
        /* Image */
      ];
      function getPropertyTypeEmoji(propertyTypeCode) {
        switch (propertyTypeCode) {
          case 1:
            return "";
          case 2:
            return "";
          case 3:
            return "";
          case 996007e3:
            return "";
          case 4:
            return "";
          case 5:
            return "";
          case 6:
            return "";
          case 10:
            return "";
          case 7:
            return "";
          case 30:
            return "";
          case 29:
            return "";
          case 18:
            return "";
          case 16:
            return "";
          case 26:
            return "";
          case 17:
            return "";
          case 19:
            return "";
          case 2e11:
            return "";
          case 1e10:
            return "";
          case 1e11:
            return "";
          case 3e11:
            return "";
          case 1e9:
            return "";
          case 8:
            return "";
          case 9:
            return "";
          case 11:
            return "";
          case 12:
            return "";
          case 31:
            return "";
          case 100:
            return "";
          case 13:
            return "";
          case 15:
            return "";
          case 14:
            return "";
          case 27:
            return "";
          case 20:
            return "";
          default:
            return "";
        }
      }
      function getRandomEmoji(index) {
        const emojis = [
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""],
          ["", ""]
        ];
        const randomIndex = Math.floor(index % emojis.length);
        return emojis[randomIndex];
      }
      function getRandomEmojiByUnicode() {
        const ranges = [
          [128512, 128591],
          //  emoji
          //   [0x1f300, 0x1f5ff], // 
          //   [0x1f680, 0x1f6ff], // 
          [129280, 129535]
          // 
          //   [0x2600, 0x26ff], // 
        ];
        const usedEmojis = [];
        let randomCodePoint;
        let emoji;
        do {
          const randomRange = ranges[Math.floor(Math.random() * ranges.length)];
          const [start, end] = randomRange;
          const codePointRange = end - start + 1;
          randomCodePoint = start + Math.floor(Math.random() * codePointRange);
          emoji = String.fromCodePoint(randomCodePoint);
        } while (usedEmojis.includes(emoji));
        usedEmojis.push(emoji);
        return emoji;
      }
      var Operator = /* @__PURE__ */ ((Operator2) => {
        Operator2["Equal"] = "=";
        Operator2["NotEqual"] = "<>";
        Operator2["GreaterThan"] = ">";
        Operator2["GreaterThanOrEqual"] = ">=";
        Operator2["LessThan"] = "<";
        Operator2["LessThanOrEqual"] = "<=";
        Operator2["Between"] = "BETWEEN";
        Operator2["AND"] = "AND";
        Operator2["IN"] = "IN";
        Operator2["NotBetween"] = "NOT BETWEEN";
        Operator2["Like"] = "LIKE";
        return Operator2;
      })(Operator || {});
      var LikeMatchType = /* @__PURE__ */ ((LikeMatchType2) => {
        LikeMatchType2["StartsWith"] = "StartsWith";
        LikeMatchType2["EndsWith"] = "EndsWith";
        LikeMatchType2["Contains"] = "Contains";
        return LikeMatchType2;
      })(LikeMatchType || {});
      function getOperator(property2) {
        const propertytypecode = Number(property2.propertytypecode);
        if (propertytypecode == PropertyTypeCode.PrimaryKey) {
          return "=";
        }
        if (propertytypecode == PropertyTypeCode.Name) {
          return "LIKE";
        }
        if (propertytypecode == PropertyTypeCode.Text) {
          return "LIKE";
        }
        if (propertytypecode == PropertyTypeCode.DateTime) {
          return "BETWEEN";
        }
        if (propertytypecode == PropertyTypeCode.CreatedBy) {
          return "=";
        }
        if (propertytypecode == PropertyTypeCode.DateTime) {
          return "BETWEEN";
        }
        if (propertytypecode == PropertyTypeCode.CreatedTime) {
          return "BETWEEN";
        }
        if (propertytypecode == PropertyTypeCode.ModifiedTime) {
          return "BETWEEN";
        }
        return "=";
      }
      class ConditionGenerator {
        constructor(condition) {
          __publicField(this, "condition");
          this.condition = condition;
        }
        generateEqualClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} = {IN.${this.condition.tableName}.${this.condition.columnName}}`;
        }
        generateNotEqualClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} <> {IN.${this.condition.tableName}.${this.condition.columnName}}`;
        }
        generateGreaterThanClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} > {IN.${this.condition.tableName}.${this.condition.columnName}}`;
        }
        generateGreaterThanOrEqualClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} >= {IN.${this.condition.tableName}.${this.condition.columnName}}`;
        }
        generateLessThanClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} < {IN.${this.condition.tableName}.${this.condition.columnName}}`;
        }
        generateLessThanOrEqualClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} <= {IN.${this.condition.tableName}.${this.condition.columnName}}`;
        }
        generateBetweenClause() {
          let whereClause = `IN.${this.condition.tableName}.${this.condition.columnName}`;
          const isDate2 = DatePropertyCodes.indexOf(Number(this.condition.propertytypecode)) !== -1;
          const [lvalue, rvalue] = isDate2 ? ["begin", "end"] : ["min", "max"];
          whereClause = whereClause + ` ${"BETWEEN"} { ${lvalue} } ${"AND"} { ${rvalue} }`;
          return whereClause;
        }
        generateNotBetweenClause() {
          return `${this.condition.tableShortName}.${this.condition.columnName} NOT BETWEEN ${this.condition.value} AND ${this.condition.secondValue}`;
        }
        generateLikeClause() {
          this.condition.value;
          const matchType2 = this.condition.like.matchType;
          let likeValue;
          const { tableName, columnName } = this.condition;
          const percent2 = "'%'";
          if (matchType2 === "Contains") {
            likeValue = `{ ${percent2} + {${tableName}.${columnName}} + ${percent2} }`;
          } else if (matchType2 === "StartsWith") {
            likeValue = `{ ${percent2} + {${tableName}.${columnName}} }`;
          } else if (matchType2 === "EndsWith") {
            likeValue = `{ ${tableName}.${columnName}} + ${percent2} }`;
          }
          return `${this.condition.tableShortName}.${this.condition.columnName} ${"LIKE"} ${likeValue}`;
        }
        generateWhereClause() {
          let clause = "";
          switch (this.condition.operator) {
            case "=":
              clause = this.generateEqualClause();
              break;
            case "<>":
              clause = this.generateNotEqualClause();
              break;
            case ">":
              clause = this.generateGreaterThanClause();
              break;
            case ">=":
              clause = this.generateGreaterThanOrEqualClause();
              break;
            case "<":
              clause = this.generateLessThanClause();
              break;
            case "<=":
              clause = this.generateLessThanOrEqualClause();
              break;
            case "BETWEEN":
              clause = this.generateBetweenClause();
              break;
            case "NOT BETWEEN":
              clause = this.generateNotBetweenClause();
              break;
            case "LIKE":
              clause = this.generateLikeClause();
              break;
          }
          return clause;
        }
      }
      const { message } = createDiscreteApi(["message"]);
      let protocol;
      let tableDataMap = /* @__PURE__ */ new Map();
      let columnDataMap = /* @__PURE__ */ new Map();
      const init = () => {
        const flyStore = useFlyStore();
        vue.watchEffect(() => {
          protocol = flyStore.protocol;
          flyStore.tableDatas;
          tableDataMap = flyStore.tableDataMap;
          columnDataMap = flyStore.columnDataMap;
          console.log("modellogicname:", protocol.modellogicname);
        });
      };
      function genQueryModel(outputArray) {
        const queryArgumentArrayMap = /* @__PURE__ */ new Map();
        protocol.input.forEach((input) => {
          queryArgumentArrayMap.set(input.name, input.properties);
        });
        if (outputArray.length == 0) {
          message.error("");
          return;
        }
        return gen(outputArray[0], queryArgumentArrayMap);
      }
      function gen(output, queryArgumentArrayMap) {
        let fquery = "select\n{{selectColumns}}";
        const mainTableName = protocol.input[0].name;
        const columnModelArray = new Array();
        const conditionModelArray = new Array();
        const joinModelArray = new Array();
        const relationTableShortNameMap = /* @__PURE__ */ new Map();
        const relationTableShortNameReverseMapReverse = /* @__PURE__ */ new Map();
        const relationTableColumnMap = /* @__PURE__ */ new Map();
        const needJoinRelationTableMap = /* @__PURE__ */ new Map();
        const queryModel = {
          tableName: mainTableName,
          tableShortName: getTableShortName(mainTableName),
          columns: columnModelArray,
          conditions: conditionModelArray,
          joins: joinModelArray
        };
        const outputTable = tableDataMap.get(output.objectcode);
        const outPropertiesDataMap = output.properties.map((data) => {
          const columnData = columnDataMap.get(data.propertycode);
          if (data.name.indexOf("__") !== -1) {
            const parts = data.name.split("__");
            if (parts.length === 2) {
              relationTableColumnMap.set(data.propertycode, data.name);
              needJoinRelationTableMap.set(parts[0], tableDataMap.get(data.objectcode));
            }
          }
          return columnData;
        });
        const tableShortName = getTableShortName(outputTable.tablename);
        fquery += `
  from ${outputTable.tablename} as ${tableShortName}`;
        needJoinRelationTableMap.forEach((relationTable, columnname) => {
          let tableName = relationTable.tablename;
          if (tableName === "pl_dictionary" || tableName === "pl_orgstruct" || tableName === "pl_region") {
            tableName = relationTable.objectmark;
          }
          let relationTableShortName = getTableShortName(tableName, columnname);
          let seq = 1;
          while (relationTableShortNameReverseMapReverse.get(relationTableShortName) != void 0) {
            relationTableShortName = getTableShortName(tableName, columnname, seq);
            seq++;
          }
          relationTableShortNameMap.set(columnname, relationTableShortName);
          relationTableShortNameReverseMapReverse.set(relationTableShortName, tableName);
          let idField = {
            pl_dictionary: "dictionaryid",
            pl_orgstruct: "orgstructid",
            pl_region: "regionid"
          }[relationTable.tablename] || true;
          if (idField) {
            for (const columnData of relationTable.properties) {
              if (columnData.propertytypecode == "1") {
                idField = columnData.columnname;
                break;
              }
            }
          }
          const joinModel = {
            tableName: tableShortName,
            tableShortName,
            relationTable: {
              name: relationTable.tablename,
              shortName: relationTableShortName,
              idField
            },
            columnName: columnname
          };
          joinModelArray.push(joinModel);
          fquery += `
  left join ${relationTable.tablename} as ${relationTableShortName} `;
          fquery += `on ${tableShortName}.${columnname} = ${relationTableShortName}.${idField}`;
        });
        let selectColumns = outPropertiesDataMap.map((data) => {
          const queryname = relationTableColumnMap.get(data.propertycode);
          relationTableShortNameMap.get(queryname);
          if (queryname === void 0) {
            const columnModel = {
              tableShortName,
              columnName: data.columnname
            };
            columnModelArray.push(columnModel);
            return `  ${tableShortName}.${data.columnname}`;
          } else {
            const [relationTableName, relationColumnName] = queryname.split("__");
            const relationTableShortName = relationTableShortNameMap.get(relationTableName);
            const columnModel = {
              tableShortName: relationTableShortName,
              columnName: relationColumnName,
              queryName: queryname,
              relationTable: {
                //todo 
                name: relationTableName,
                shortName: "",
                idField: ""
              }
            };
            columnModelArray.push(columnModel);
            return `  ${relationTableShortName}.${relationColumnName} as ${queryname}`;
          }
        }).join(",\n");
        fquery = fquery.replace("{{selectColumns}}", selectColumns);
        if ((queryArgumentArrayMap == null ? void 0 : queryArgumentArrayMap.size) > 0) {
          fquery += "\n  where 1=1\n";
        }
        const template = `{#if {{if}}}
 and {{condition}}
{#endif}
`;
        queryArgumentArrayMap.forEach((properties, tableName) => {
          if (tableName === mainTableName) {
            properties.forEach((property2) => {
              if (property2.propertytypecode == "3")
                return;
              const argName = property2.name;
              const operator = getOperator(property2);
              const conditionModel = {
                tableName,
                tableShortName,
                columnName: argName,
                operator,
                value: null,
                secondValue: null,
                like: null
              };
              let condition = `${tableShortName}.${argName} `;
              if (operator == Operator.Equal) {
                conditionModelArray.push(conditionModel);
                condition += operator;
                condition += ` { IN.${tableName}.${argName} }`;
                const blankJudge = template.replace(
                  "{{if}}",
                  `!String.isBlank(IN.${tableName}.${argName})`
                ).replace("{{condition}}", condition);
                fquery += blankJudge;
              }
              if (operator == Operator.Like) {
                conditionModel.like = { matchType: LikeMatchType.Contains };
                conditionModelArray.push(conditionModel);
                condition += operator;
                condition += ` { IN.${tableName}.${argName} }`;
                const blankJudge = template.replace(
                  "{{if}}",
                  `!String.isBlank(IN.${tableName}.${argName})`
                ).replace("{{condition}}", condition);
                fquery += blankJudge;
              }
              if (operator == Operator.Between) {
                conditionModelArray.push(conditionModel);
                if (DatePropertyCodes.indexOf(Number(property2.propertytypecode)) != -1) {
                  condition += ` ${operator} { bengin } ${Operator.AND} { end }`;
                  const blankJudge = template.replace(
                    "{{if}}",
                    `!String.isBlank(begin)&&!String.isBlank(end)`
                  ).replace("{{condition}}", condition);
                  fquery += blankJudge;
                } else {
                  condition += ` ${operator} { value1 } ${Operator.AND} { value2 }`;
                  const blankJudge = template.replace(
                    "{{if}}",
                    `!String.isBlank(value1)&&!String.isBlank(value2)`
                  ).replace("{{condition}}", condition);
                  fquery += blankJudge;
                }
              }
            });
          } else {
            properties.forEach((property2) => {
              const argName = property2.name;
              const conditionModel = {
                tableName,
                tableShortName: relationTableShortNameMap.get(tableName),
                columnName: argName,
                operator: Operator.Equal,
                value: null,
                secondValue: null,
                like: null
              };
              conditionModelArray.push(conditionModel);
              const condition = `${relationTableShortNameMap.get(tableName)}.${argName} = { IN.${tableName}.${argName} }`;
              const q = template.replace(
                "{{if}}",
                `!String.isBlank(IN.${tableName}.${argName})`
              ).replace("{{condition}}", condition);
              fquery += q;
            });
          }
        });
        queryModel.columns = columnModelArray;
        queryModel.joins = joinModelArray;
        queryModel.conditions = conditionModelArray;
        return queryModel;
      }
      function generateSql(queryModel) {
        const selectClause = `SELECT
  ${queryModel.columns.map((c2) => {
        if (c2.queryName == null || c2.queryName == void 0) {
          return `${c2.tableShortName}.${c2.columnName}`;
        } else {
          return `${c2.tableShortName}.${c2.columnName} as ${c2.queryName}`;
        }
      }).join(",\n  ")}`;
        const fromClause = `FROM
  ${queryModel.tableName} as ${queryModel.tableShortName}`;
        const joinClauses = queryModel.joins.map((j) => {
          let lj;
          let on2;
          if (j.relationTable.name != null || j.relationTable.name != void 0) {
            lj = `LEFT JOIN ${j.relationTable.name} as ${j.relationTable.shortName} `;
            on2 = `ON ${j.relationTable.shortName}.${j.relationTable.idField} = ${j.tableShortName}.${j.columnName}`;
          } else {
            lj = `LEFT JOIN ${j.relationTable.name} as ${j.relationTable.shortName} `;
            on2 = `ON ${j.relationTable.name}.${j.columnName} = ${j.tableShortName}.${j.columnName}`;
          }
          return lj.concat(on2);
        });
        const whereClauses = queryModel.conditions.map((c2) => {
          let whereTemplate = `{#if {{if}}}
 and {{condition}}
{#endif}
`;
          const generator = new ConditionGenerator(c2);
          if (c2.operator == Operator.Equal) {
            const juede = `!String.isBlank(IN.${c2.tableName}.${c2.columnName})`;
            const condition = generator.generateWhereClause();
            whereTemplate = whereTemplate.replace("{{if}}", juede).replace("{{condition}}", condition);
          } else if (c2.operator === Operator.Like) {
            const juede = `!String.isBlank(IN.${c2.tableName}.${c2.columnName})`;
            let whereClause2 = generator.generateWhereClause();
            whereTemplate = whereTemplate.replace("{{if}}", juede).replace("{{condition}}", whereClause2);
          } else if (c2.operator === Operator.Between) {
            const isDate2 = DatePropertyCodes.indexOf(Number(c2.propertytypecode)) !== -1;
            const [lvalue, rvalue] = isDate2 ? ["begin", "end"] : ["min", "max"];
            const juede = `!String.isBlank(${lvalue}) && !String.isBlank(${rvalue})`;
            let whereClause2 = generator.generateWhereClause();
            whereTemplate = whereTemplate.replace("{{if}}", juede).replace("{{condition}}", whereClause2);
          }
          return whereTemplate;
        });
        const whereClause = whereClauses.length > 0 ? `WHERE 1=1
${whereClauses.join("")}` : "";
        const sql = `${selectClause}
${fromClause}
${joinClauses.join("\n")}
${whereClause} NORULE;`;
        return sql;
      }
      const _sfc_main$9 = /* @__PURE__ */ vue.defineComponent({
        __name: "saveProtocolWatch",
        setup(__props) {
          const flyStore = useFlyStore();
          vue.onMounted(() => {
            checkSaveProtocol();
          });
          function checkSaveProtocol() {
            const button = document.querySelector("#beSetting > div.main-content > div.tab-footer > button.ant-btn.ant-btn-primary");
            button.addEventListener("click", async () => {
              console.log("updateProtocol");
              await flyStore.updateProtocol();
            });
            document.addEventListener("keydown", async (event) => {
              if (event.ctrlKey && event.key === "s") {
                console.log("updateProtocol");
                await flyStore.updateProtocol();
                event.preventDefault();
              }
            });
          }
          return (_ctx, _cache) => {
            return null;
          };
        }
      });
      const _hoisted_1$6 = {
        class: "flycode-d"
      };
      const _hoisted_2$5 = {
        id: "flyCode",
        "data-lang": "sql",
        style: {
          "height": "690px"
        }
      };
      const _sfc_main$8 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          const message2 = useMessage();
          const flyStore = useFlyStore();
          vue.onMounted(async () => {
            console.log("queryGenerator mounted");
            init();
            addGenQueryElement();
          });
          const fquery = vue.ref("");
          const showCode = vue.ref();
          function addGenQueryElement() {
            if (document.querySelector("#beSetting > div.main-content > div.tab-operation > button:nth-child(3)") != null) {
              return;
            }
            const originalButton = document.querySelector("#beSetting > div.main-content > div.tab-operation > button:nth-child(2)");
            const originalButtonIcon = originalButton.querySelector("i");
            const newButton = originalButton.cloneNode(false);
            const newButtonIcon = originalButtonIcon.cloneNode(true);
            newButtonIcon.classList.replace("ideicon-protocol", "ideicon-db_flycode");
            const newButtonSpan = document.createElement("span");
            newButtonSpan.textContent = "SQL";
            newButton.appendChild(newButtonIcon);
            newButton.appendChild(newButtonSpan);
            newButton.addEventListener("click", () => {
              fquery.value = generateSql(genQueryModel(flyStore.protocol.output));
              copyToClipboard(fquery.value);
              message2.success(() => {
                return vue.h(vue.createVNode(vue.Fragment, null, [vue.createVNode("span", null, [`FlyQuery${getRandomEmojiByUnicode()}`]), vue.createVNode(NButton, {
                  "type": "success",
                  "onClick": async () => {
                    showCode.value = !showCode.value;
                    await vue.nextTick(() => {
                      monaco.editor.colorizeElement(document.getElementById("flyCode"), {
                        theme: "vs-dark"
                      });
                    });
                  }
                }, {
                  default: () => [vue.createTextVNode("")]
                })]));
              });
            });
            originalButton.parentNode.appendChild(newButton);
          }
          return (_ctx, _cache) => {
            const _component_n_modal = vue.resolveComponent("n-modal");
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [vue.createVNode(_component_n_modal, {
              show: showCode.value,
              "onUpdate:show": _cache[0] || (_cache[0] = ($event) => showCode.value = $event),
              preset: "card",
              title: "Flycode",
              style: {
                "width": "900px"
              },
              bordered: false
            }, {
              default: vue.withCtx(() => [vue.createElementVNode("div", _hoisted_1$6, [vue.createElementVNode("pre", _hoisted_2$5, vue.toDisplayString(fquery.value), 1)])]),
              _: 1
            }, 8, ["show"]), vue.createVNode(_sfc_main$9)], 64);
          };
        }
      });
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_registerMenuCommand = /* @__PURE__ */ (() => typeof GM_registerMenuCommand != "undefined" ? GM_registerMenuCommand : void 0)();
      var _GM_setClipboard = /* @__PURE__ */ (() => typeof GM_setClipboard != "undefined" ? GM_setClipboard : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      const head$1 = `var errMsg = "";
var validateFail = false;

`;
      const main$1 = `(function main() {
    validation()

    var isInsert = isInsertFunc()

    if (isInsert) {
        insert()
    } else {
        update()
    }


})()

`;
      const insert$1 = `function insert() {
    var id = FLY.genId();
    IN.{{tableName}}.{{primaryKey}} = id;
    {{CustomInsertCode}}
    DB.insert(IN.{{tableName}});
}

`;
      const update$1 = `function update() {
    var temp = select * from {{tableName}} where {{primaryKey}} = { IN.{{tableName}}.{{primaryKey}} } NORULE;
    if (temp.length == 0){
        throw new ERROR("")
    }

    var {{tableName}} = temp[0]
    {{CustomUpdateCode}}
    DB.update({{tableName}});
}

`;
      const validation = `function validation() {
    {{callFunctions}}
    if (validateFail) {
        throw new ERROR(errMsg);
    }
}

`;
      const validateDictidExistFunc = `/**
* 
* @param {number} dictionaryid -  ID
* @param {string} dictName - 
* @returns {void}
*/
function validateDictidExist(dictionaryid, dictName) {
    var temp = select count(*) from pl_dictionary where dictionaryid = { dictionaryid } NORULE;
    if (temp[0].count == 0) {
        appendErrmsg("" + dictName + "")
    }
}

`;
      const validateBusinessObjectExistTemplet = `
    var temp = select count(*) from {{tableName}} where {{primaryKey}} = {{{businessObjectId}}} NORULE;;
    if (temp[0].count == 0) {
        appendErrmsg("" + {{objectZhName}} + "")
    }
`;
      const appendErrmsg$1 = `
/**
* 
* @param {string} message - 
*/
function appendErrmsg(message) {
    errMsg += message
    validateFail = true
}
`;
      const isInsertFunc$1 = `
/**
 * 
 * @returns {boolean}
 */
function isInsertFunc() {
    var isInsert = false
    if (String.isBlank(IN.{{tableName}}.{{primaryKey}})) {
        isInsert = true
    }
    return isInsert
}
`;
      const updateTemplate = {
        head: head$1,
        main: main$1,
        insert: insert$1,
        update: update$1,
        validation,
        isInsertFunc: isInsertFunc$1,
        appendErrmsg: appendErrmsg$1,
        validateDictidExistFunc,
        validateBusinessObjectExistTemplet
      };
      class ValidateBuilder {
        constructor(propertyName) {
          __publicField(this, "propertyZhName");
          __publicField(this, "propertyName");
          __publicField(this, "propertyTypeCode");
          __publicField(this, "propertyCode");
          __publicField(this, "validateLogic");
          __publicField(this, "errMsg");
          __publicField(this, "required");
          __publicField(this, "validateBusinessObjectExist");
          __publicField(this, "validateDictidExist");
          __publicField(this, "businessPropertyTypeCodes", [PropertyTypeCode.BusinessObject, PropertyTypeCode.CreatedBy, PropertyTypeCode.ModifiedBy]);
          __publicField(this, "primaryKey");
          __publicField(this, "tableName");
          __publicField(this, "message");
          if (propertyName != void 0) {
            this.propertyName = propertyName;
          }
          this.message = useMessage();
        }
        setPropertyZhName(propertyZhName) {
          this.propertyZhName = propertyZhName;
          return this;
        }
        setPropertyName(propertyName) {
          this.propertyName = propertyName;
          return this;
        }
        setPropertyTypeCode(propertyTypeCode) {
          this.propertyTypeCode = propertyTypeCode;
          return this;
        }
        setPropertyCode(propertyCode) {
          this.propertyCode = propertyCode;
          return this;
        }
        setValidateLogic(validateLogic = `
    /* Write your ValidateLogicCode */
`) {
          this.validateLogic = validateLogic;
          return this;
        }
        setErrMsg(errMsg = `errMsg`) {
          this.errMsg = errMsg;
          return this;
        }
        setRequired(required2 = false) {
          this.required = required2;
          return this;
        }
        setDictidExistValidate(validateDictidExist = false) {
          this.validateDictidExist = validateDictidExist;
          return this;
        }
        setBusinessObjectExistValidate(validateBusinessObjectExist = false) {
          this.validateBusinessObjectExist = validateBusinessObjectExist;
          return this;
        }
        setPrimaryKey(primaryKey) {
          this.primaryKey = primaryKey;
          return this;
        }
        setTableName(tableName) {
          this.tableName = tableName;
          return this;
        }
        setPrimaryKeyAndTableName() {
          const flyStore = useFlyStore();
          const columnData = flyStore.columnDataMap.get(this.propertyCode);
          const tableData = flyStore.tableDataMap.get(columnData.relationobjectcode);
          this.tableName = tableData.tablename;
          this.primaryKey = {
            pl_dictionary: "dictionaryid",
            pl_orgstruct: "orgstructid",
            pl_region: "regionid"
          }[tableData.tablename];
          if (!this.primaryKey) {
            for (const columnData2 of tableData.properties) {
              if (columnData2.propertytypecode == "1") {
                this.primaryKey = columnData2.columnname;
                break;
              }
            }
          }
        }
        getCallFunctionName(tableName) {
          return `validate${toCamelCase(this.propertyName)}(IN.${tableName}.${this.propertyName})`;
        }
        build() {
          let code = `function validate${toCamelCase(this.propertyName)}(${this.propertyName}) {
    var validationFailed = false
    {{RequiredVerification}}
    {{ValidateDictidExist}}
    {{ValidateBusinessObjectExist}}
${this.validateLogic}
    if (validationFailed) {
        appendErrmsg("${this.errMsg}");
    }
}
`;
          if (this.required) {
            code = code.replace("{{RequiredVerification}}", `if (String.isBlank(${this.propertyName})) {
        appendErrmsg("${this.propertyZhName}")
    }
`);
          } else {
            code = code.replace(/{{RequiredVerification}}\n?/, ``);
          }
          if (this.validateDictidExist && Number(this.propertyTypeCode) == PropertyTypeCode.DictionaryObject) {
            code = code.replace("{{ValidateDictidExist}}", `validateDictidExist(${this.propertyName},"${this.propertyZhName}")`);
          } else {
            code = code.replace(/\s*{{ValidateDictidExist}}\n?/, ``);
          }
          if (this.validateBusinessObjectExist && this.businessPropertyTypeCodes.indexOf(Number(this.propertyTypeCode)) != -1) {
            this.setPrimaryKeyAndTableName();
            if (!this.primaryKey) {
              this.message.error("");
              return ``;
            }
            const validateBusinessObjectExistCode = updateTemplate.validateBusinessObjectExistTemplet.replace("{{tableName}}", this.tableName).replace("{{primaryKey}}", this.primaryKey).replace("{{businessObjectId}}", this.propertyName).replace("{{objectZhName}}", `"${this.propertyZhName}:" + ${this.propertyName}`);
            code = code.replace("{{ValidateBusinessObjectExist}}", validateBusinessObjectExistCode);
          } else {
            code = code.replace(/\s*{{ValidateBusinessObjectExist}}\n?/, ``);
          }
          return code;
        }
      }
      function generatorCode(enableValidateDictId = false, enableValidateBusinessObjectId = false) {
        const flyStore = useFlyStore();
        const input = flyStore.protocol.input;
        let validateFunctions = new Array();
        let validateFunctionNames = new Array();
        const validateLogic = new ValidateBuilder();
        input.forEach((item) => {
          item.properties.forEach((property2) => {
            let validateFunction;
            if (property2.validation) {
              if (Number(property2.propertytypecode) === PropertyTypeCode.PhoneNumber) {
                validateFunction = validateLogic.setPropertyName(property2.name).setPropertyZhName(property2.propertyname).setValidateLogic(validatePhoneSnippet).setErrMsg(``).build();
                validateFunctions.push(validateFunction);
                console.log(validateFunction);
              } else {
                validateFunction = validateLogic.setPropertyName(property2.name).setPropertyZhName(property2.propertyname).setPropertyTypeCode(property2.propertytypecode).setDictidExistValidate(enableValidateDictId).setBusinessObjectExistValidate(enableValidateBusinessObjectId).setPropertyCode(property2.propertycode).setRequired(property2.required).setValidateLogic().setErrMsg().build();
                validateFunctions.push(validateFunction);
                validateFunctionNames.push(validateLogic.getCallFunctionName(item.name));
                console.log(validateFunction);
              }
            }
          });
        });
        const callValidationFunctions = updateTemplate.validation.replace("{{callFunctions}}", validateFunctionNames.join("\n    "));
        let insertFunc = updateTemplate.insert;
        let updateFunc = updateTemplate.update;
        const tableName = input[0].name;
        const PrimaryKey = getPrimaryKey(input[0].objectcode);
        const CustomInsertCode = () => {
          return "";
        };
        insertFunc = insertFunc.replaceAll("{{tableName}}", tableName).replaceAll("{{primaryKey}}", PrimaryKey).replace("{{CustomInsertCode}}", CustomInsertCode());
        const CustomUpdateCode = () => {
          let replaceValueTemplet = `${tableName}.{{propertyName}} = IN.${tableName}.{{propertyName}}`;
          const codeLens = new Array();
          input[0].properties.forEach((property2) => {
            codeLens.push(replaceValueTemplet.replaceAll("{{propertyName}}", property2.name));
          });
          return codeLens.join(`
    `);
        };
        updateFunc = updateFunc.replaceAll("{{tableName}}", tableName).replaceAll("{{primaryKey}}", PrimaryKey).replace("{{CustomUpdateCode}}", CustomUpdateCode());
        const code = updateTemplate.head.concat(updateTemplate.main).concat(insertFunc).concat(updateFunc).concat(callValidationFunctions).concat(validateFunctions.join("\n")).concat(updateTemplate.appendErrmsg).concat(updateTemplate.validateDictidExistFunc).concat(updateTemplate.isInsertFunc.replace("{{tableName}}", tableName).replace("{{primaryKey}}", PrimaryKey));
        return code;
      }
      const validatePhoneSnippet = `  var phoneReg = /^1[3456789]d{9}$/;
  if (!phoneReg.test(phoneNumber)) { //
    validationFailed = true
  }`;
      const _hoisted_1$5 = /* @__PURE__ */ vue.createElementVNode("div", { id: "code" }, null, -1);
      const _hoisted_2$4 = { style: { "margin-left": "8px" } };
      const _hoisted_3 = /* @__PURE__ */ vue.createElementVNode("span", { style: { "margin-left": "8px" } }, "  ", -1);
      const _hoisted_4 = /* @__PURE__ */ vue.createElementVNode("span", { style: { "margin-left": "8px" } }, "  ", -1);
      const _hoisted_5 = { style: { "float": "right", "margin-top": "15px" } };
      const _hoisted_6 = { class: "flycode-d" };
      const _hoisted_7 = {
        id: "flyCode",
        "data-lang": "javascript",
        style: { "height": "690px" }
      };
      const _sfc_main$7 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          const flyStore = useFlyStore();
          const showModal = vue.ref(false);
          const showCode = vue.ref(false);
          const flycode = vue.ref("");
          const message2 = useMessage();
          const enableValidateDictId = vue.ref(false);
          const enableValidateBusinessObjectId = vue.ref(false);
          const SelectAllProperty = vue.ref(false);
          const SelectAllrequired = vue.ref(false);
          const vCount = vue.ref(0);
          vue.ref(1);
          vue.onMounted(() => {
            console.log("updateGenerator");
            let tempSum = 0;
            flyStore.protocol.input.forEach((input) => {
              input.properties.forEach((property2) => {
                if (ignorePropertyType.indexOf(Number(property2.propertytypecode)) == -1) {
                  property2.validation = true;
                  tempSum++;
                }
              });
            });
            vCount.value += tempSum;
            addButton(null, "Flycode", "ideicon-share", () => {
              showModalFunc();
              console.log("Flycode");
            }, 1);
          });
          const showModalFunc = () => {
            showModal.value = !showModal.value;
          };
          vue.watch(showModal, async () => {
            await vue.nextTick();
            document.querySelectorAll(".validationSwitch").forEach((el) => {
              el.addEventListener("mouseenter", () => {
                el.click();
              });
            });
          });
          const gen2 = () => {
            const code = generatorCode(enableValidateDictId.value, enableValidateBusinessObjectId.value);
            _GM_setClipboard(code, "text");
            message2.success("!" + getRandomEmojiByUnicode());
            showModal.value = false;
          };
          const previewCode = async () => {
            showCode.value = true;
            flycode.value = generatorCode();
            await vue.nextTick();
            monaco.editor.colorizeElement(document.getElementById("flyCode"), {
              theme: "vs-dark"
            });
          };
          const requiredCheck = (value, property2) => {
            if (value && !property2.validation) {
              property2.validation = true;
            }
          };
          const syncVR = (properties) => {
            vCount.value == properties.filter((property2) => {
              if (property2.validation) {
                return property2.validation == property2.required;
              }
            }).length ? SelectAllrequired.value = true : SelectAllrequired.value = false;
          };
          const SelectAllPropertyFunc = (value) => {
            flyStore.protocol.input.forEach((input) => {
              input.properties.forEach((property2) => {
                property2.validation = value;
              });
            });
          };
          const SelectAllrequiredFunc = (value) => {
            flyStore.protocol.input.forEach((input) => {
              input.properties.forEach((property2) => {
                if (property2.validation) {
                  property2.required = value;
                }
              });
            });
          };
          return (_ctx, _cache) => {
            const _component_NCheckbox = vue.resolveComponent("NCheckbox");
            const _component_NListItem = vue.resolveComponent("NListItem");
            const _component_n_switch = vue.resolveComponent("n-switch");
            const _component_n_checkbox = vue.resolveComponent("n-checkbox");
            const _component_NList = vue.resolveComponent("NList");
            const _component_n_tab_pane = vue.resolveComponent("n-tab-pane");
            const _component_n_tabs = vue.resolveComponent("n-tabs");
            const _component_NButton = vue.resolveComponent("NButton");
            const _component_n_card = vue.resolveComponent("n-card");
            const _component_n_modal = vue.resolveComponent("n-modal");
            return vue.openBlock(), vue.createElementBlock("div", null, [
              _hoisted_1$5,
              vue.createVNode(_component_n_modal, {
                show: showModal.value,
                "onUpdate:show": _cache[8] || (_cache[8] = ($event) => showModal.value = $event),
                preset: "card",
                title: "Flycode",
                style: { "width": "700px" },
                bordered: false
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_card, null, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_tabs, {
                        type: "line",
                        animated: "",
                        size: "large"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(_component_n_tab_pane, {
                            name: "validation",
                            tab: ""
                          }, {
                            default: vue.withCtx(() => [
                              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(flyStore).protocol.input, (input) => {
                                return vue.openBlock(), vue.createElementBlock("div", null, [
                                  vue.createVNode(_component_NList, { "show-divider": true }, {
                                    default: vue.withCtx(() => [
                                      vue.createVNode(_component_NListItem, null, {
                                        default: vue.withCtx(() => [
                                          vue.createElementVNode("div", null, [
                                            vue.createVNode(_component_NCheckbox, {
                                              checked: SelectAllProperty.value,
                                              "onUpdate:checked": _cache[0] || (_cache[0] = ($event) => SelectAllProperty.value = $event),
                                              onUpdateChecked: _cache[1] || (_cache[1] = (value, e) => {
                                                SelectAllPropertyFunc(value);
                                              })
                                            }, {
                                              default: vue.withCtx(() => [
                                                vue.createTextVNode(vue.toDisplayString(!SelectAllProperty.value ? "" : ""), 1)
                                              ]),
                                              _: 1
                                            }, 8, ["checked"]),
                                            vue.createVNode(_component_NCheckbox, {
                                              style: { "float": "right" },
                                              checked: SelectAllrequired.value,
                                              "onUpdate:checked": _cache[2] || (_cache[2] = ($event) => SelectAllrequired.value = $event),
                                              onUpdateChecked: _cache[3] || (_cache[3] = (value, e) => {
                                                SelectAllrequiredFunc(value);
                                              })
                                            }, {
                                              default: vue.withCtx(() => [
                                                vue.createTextVNode(vue.toDisplayString(!SelectAllrequired.value ? "" : ""), 1)
                                              ]),
                                              _: 1
                                            }, 8, ["checked"])
                                          ])
                                        ]),
                                        _: 1
                                      }),
                                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(input.properties, (property2, index) => {
                                        return vue.openBlock(), vue.createElementBlock("div", null, [
                                          vue.createVNode(_component_NListItem, { style: { "padding": "8px 0" } }, {
                                            default: vue.withCtx(() => [
                                              vue.createElementVNode("div", null, [
                                                vue.createVNode(_component_n_switch, {
                                                  class: "validationSwitch",
                                                  value: property2.validation,
                                                  "onUpdate:value": ($event) => property2.validation = $event,
                                                  onUpdateValue: (b) => {
                                                    b ? vCount.value++ : vCount.value--;
                                                    vCount.value == input.properties.length ? SelectAllProperty.value = true : SelectAllProperty.value = false;
                                                  },
                                                  size: "large"
                                                }, {
                                                  icon: vue.withCtx(() => [
                                                    vue.createTextVNode(vue.toDisplayString(property2.validation ? vue.unref(getRandomEmoji)(index)[1] : vue.unref(getRandomEmoji)(index)[0]), 1)
                                                  ]),
                                                  _: 2
                                                }, 1032, ["value", "onUpdate:value", "onUpdateValue"]),
                                                vue.createElementVNode("span", _hoisted_2$4, vue.toDisplayString(property2.propertyname) + " (" + vue.toDisplayString(property2.name) + ")-" + vue.toDisplayString(vue.unref(getPropertyTypeName)(property2.propertytypecode)) + " " + vue.toDisplayString(vue.unref(getPropertyTypeEmoji)(Number(property2.propertytypecode))), 1),
                                                vue.createVNode(_component_n_checkbox, {
                                                  checked: property2.required,
                                                  "onUpdate:checked": ($event) => property2.required = $event,
                                                  onUpdateChecked: (b, e) => {
                                                    syncVR(input.properties);
                                                    requiredCheck(b, property2);
                                                  },
                                                  style: { "float": "right" }
                                                }, {
                                                  default: vue.withCtx(() => [
                                                    vue.createTextVNode("  ")
                                                  ]),
                                                  _: 2
                                                }, 1032, ["checked", "onUpdate:checked", "onUpdateChecked"])
                                              ])
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]);
                                      }), 256))
                                    ]),
                                    _: 2
                                  }, 1024)
                                ]);
                              }), 256))
                            ]),
                            _: 1
                          }),
                          vue.createVNode(_component_n_tab_pane, {
                            name: "validationConfig",
                            tab: ""
                          }, {
                            default: vue.withCtx(() => [
                              vue.createElementVNode("div", null, [
                                vue.createVNode(_component_NList, null, {
                                  default: vue.withCtx(() => [
                                    vue.createVNode(_component_NListItem, null, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(_component_n_switch, {
                                          class: "validationSwitch",
                                          value: enableValidateBusinessObjectId.value,
                                          "onUpdate:value": _cache[4] || (_cache[4] = ($event) => enableValidateBusinessObjectId.value = $event),
                                          size: "large"
                                        }, {
                                          icon: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(vue.unref(getRandomEmojiByUnicode)()), 1)
                                          ]),
                                          _: 1
                                        }, 8, ["value"]),
                                        _hoisted_3
                                      ]),
                                      _: 1
                                    }),
                                    vue.createVNode(_component_NListItem, null, {
                                      default: vue.withCtx(() => [
                                        vue.createVNode(_component_n_switch, {
                                          class: "validationSwitch",
                                          value: enableValidateDictId.value,
                                          "onUpdate:value": _cache[5] || (_cache[5] = ($event) => enableValidateDictId.value = $event),
                                          size: "large"
                                        }, {
                                          icon: vue.withCtx(() => [
                                            vue.createTextVNode(vue.toDisplayString(vue.unref(getRandomEmojiByUnicode)()), 1)
                                          ]),
                                          _: 1
                                        }, 8, ["value"]),
                                        _hoisted_4
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ])
                            ]),
                            _: 1
                          }),
                          vue.createVNode(_component_n_tab_pane, {
                            name: "L",
                            tab: "L"
                          })
                        ]),
                        _: 1
                      }),
                      vue.createElementVNode("div", _hoisted_5, [
                        vue.createVNode(_component_NButton, {
                          style: { "margin-right": "15px" },
                          onClick: _cache[6] || (_cache[6] = ($event) => previewCode()),
                          tertiary: "",
                          type: "info"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode("")
                          ]),
                          _: 1
                        }),
                        vue.createVNode(_component_NButton, {
                          onClick: _cache[7] || (_cache[7] = ($event) => gen2()),
                          strong: "",
                          secondary: "",
                          type: "primary"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode("")
                          ]),
                          _: 1
                        })
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["show"]),
              vue.createVNode(_component_n_modal, {
                show: showCode.value,
                "onUpdate:show": _cache[9] || (_cache[9] = ($event) => showCode.value = $event),
                preset: "card",
                title: "Flycode",
                style: { "width": "900px" },
                bordered: false
              }, {
                default: vue.withCtx(() => [
                  vue.createElementVNode("div", _hoisted_6, [
                    vue.createElementVNode("pre", _hoisted_7, vue.toDisplayString(flycode.value), 1)
                  ])
                ]),
                _: 1
              }, 8, ["show"]),
              vue.createVNode(_sfc_main$9)
            ]);
          };
        }
      });
      const _hoisted_1$4 = /* @__PURE__ */ vue.createElementVNode("div", null, null, -1);
      const _hoisted_2$3 = {
        style: {
          "float": "right",
          "margin-top": "15px"
        }
      };
      const _sfc_main$6 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          const showModal = vue.ref(false);
          useFlyStore();
          vue.onMounted(() => {
            addButton(null, "Flycode", "ideicon-share", () => {
              console.log("Flycode");
            }, 1);
          });
          return (_ctx, _cache) => {
            const _component_n_tab_pane = vue.resolveComponent("n-tab-pane");
            const _component_n_tabs = vue.resolveComponent("n-tabs");
            const _component_NButton = vue.resolveComponent("NButton");
            const _component_n_card = vue.resolveComponent("n-card");
            const _component_n_modal = vue.resolveComponent("n-modal");
            return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(_component_n_modal, {
              show: showModal.value,
              "onUpdate:show": _cache[2] || (_cache[2] = ($event) => showModal.value = $event),
              preset: "card",
              title: "Flycode",
              style: {
                "width": "700px"
              },
              bordered: false
            }, {
              default: vue.withCtx(() => [vue.createVNode(_component_n_card, null, {
                default: vue.withCtx(() => [vue.createVNode(_component_n_tabs, {
                  type: "line",
                  animated: "",
                  size: "large"
                }, {
                  default: vue.withCtx(() => [vue.createVNode(_component_n_tab_pane, {
                    name: "xslcolBind",
                    tab: ""
                  }), vue.createVNode(_component_n_tab_pane, {
                    name: "validationConfig",
                    tab: ""
                  }, {
                    default: vue.withCtx(() => [_hoisted_1$4]),
                    _: 1
                  }), vue.createVNode(_component_n_tab_pane, {
                    name: "L",
                    tab: "L"
                  })]),
                  _: 1
                }), vue.createElementVNode("div", _hoisted_2$3, [vue.createVNode(_component_NButton, {
                  style: {
                    "margin-right": "15px"
                  },
                  onClick: _cache[0] || (_cache[0] = () => {
                  }),
                  tertiary: "",
                  type: "info"
                }, {
                  default: vue.withCtx(() => [vue.createTextVNode("")]),
                  _: 1
                }), vue.createVNode(_component_NButton, {
                  onClick: _cache[1] || (_cache[1] = () => {
                  }),
                  strong: "",
                  secondary: "",
                  type: "primary"
                }, {
                  default: vue.withCtx(() => [vue.createTextVNode("")]),
                  _: 1
                })])]),
                _: 1
              })]),
              _: 1
            }, 8, ["show"])]);
          };
        }
      });
      const _hoisted_1$3 = { class: "flycode-d" };
      const _hoisted_2$2 = {
        id: "flyCode",
        "data-lang": "javascript",
        style: { "height": "690px" }
      };
      const _sfc_main$5 = /* @__PURE__ */ vue.defineComponent({
        __name: "CodePreview",
        props: {
          flyCode: {}
        },
        setup(__props) {
          const props = __props;
          vue.onMounted(async () => {
            await vue.nextTick(() => {
              monaco.editor.colorizeElement(document.getElementById("flyCode"), {
                theme: "vs-dark"
              });
            });
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, [
              vue.createElementVNode("pre", _hoisted_2$2, vue.toDisplayString(props.flyCode), 1)
            ]);
          };
        }
      });
      const _hoisted_1$2 = /* @__PURE__ */ vue.createElementVNode("div", null, null, -1);
      const _hoisted_2$1 = { style: { "float": "right", "margin-top": "15px" } };
      const _sfc_main$4 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          const showModal = vue.ref();
          const showCode = vue.ref();
          const flyCode = vue.ref("");
          const flyStore = useFlyStore();
          const checkedRowKeysRef = vue.ref([]);
          const rowData = vue.ref();
          const columns = createColumns({
            play(row) {
              console.log(row);
            }
          });
          vue.onMounted(() => {
            addButton(null, "Flycode", "ideicon-share", () => {
              console.log("Flycode");
              showModalFunc();
            }, 1);
            rowData.value = flyStore.protocol.output[0].properties.map((property2) => {
              return {
                field: property2.name,
                column: property2.propertyname,
                propertycode: property2.propertycode
              };
            });
          });
          const showModalFunc = () => {
            showModal.value = !showModal.value;
          };
          function rowKey(row) {
            return row.propertycode;
          }
          function handleCheck(checkedRowKeys) {
            checkedRowKeysRef.value = checkedRowKeys;
          }
          function createColumns({ play }) {
            return [
              {
                type: "selection"
              },
              {
                title: "field",
                key: "field",
                resizable: true
              },
              {
                title: "column",
                key: "column",
                render(row, index) {
                  return vue.h(NInput, {
                    value: row.column,
                    onUpdateValue(v) {
                      rowData.value[index].column = v;
                    }
                  });
                }
              }
            ];
          }
          const codeGenerator = (preview) => {
            console.log(checkedRowKeysRef.value);
            const bindDataArray = rowData.value.filter((data) => checkedRowKeysRef.value.includes(data.propertycode));
            let code = `var _xlscolBind = ${JSON.stringify(bindDataArray, null, 4)}
`;
            init();
            const fquery = generateSql(genQueryModel(flyStore.protocol.output));
            code = code.concat(`var temp = ${fquery}`);
            code = code.concat(`
OUT.xlsdata = temp`);
            console.log(code);
            if (!preview) {
              _GM_setClipboard(code, "text");
              message.success("" + getRandomEmojiByUnicode());
              showModal.value = !showModal.value;
            }
            return code;
          };
          const previewCode = () => {
            showCode.value = true;
            flyCode.value = codeGenerator(true);
          };
          return (_ctx, _cache) => {
            const _component_n_data_table = vue.resolveComponent("n-data-table");
            const _component_n_tab_pane = vue.resolveComponent("n-tab-pane");
            const _component_n_tabs = vue.resolveComponent("n-tabs");
            const _component_n_card = vue.resolveComponent("n-card");
            const _component_n_modal = vue.resolveComponent("n-modal");
            return vue.openBlock(), vue.createElementBlock("div", null, [
              vue.createVNode(_component_n_modal, {
                show: showModal.value,
                "onUpdate:show": _cache[1] || (_cache[1] = ($event) => showModal.value = $event),
                preset: "card",
                title: "Flycode",
                style: { "width": "800px" },
                bordered: false
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_component_n_card, null, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_n_tabs, {
                        type: "line",
                        animated: "",
                        size: "large"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(_component_n_tab_pane, {
                            name: "xslcolBind",
                            tab: ""
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(_component_n_data_table, {
                                columns: vue.unref(columns),
                                data: rowData.value,
                                striped: "",
                                "row-key": rowKey,
                                "onUpdate:checkedRowKeys": handleCheck,
                                style: { "height": "500px" },
                                "flex-height": ""
                              }, null, 8, ["columns", "data"])
                            ]),
                            _: 1
                          }),
                          vue.createVNode(_component_n_tab_pane, {
                            name: "validationConfig",
                            tab: ""
                          }, {
                            default: vue.withCtx(() => [
                              _hoisted_1$2
                            ]),
                            _: 1
                          }),
                          vue.createVNode(_component_n_tab_pane, {
                            name: "L",
                            tab: "L"
                          })
                        ]),
                        _: 1
                      }),
                      vue.createElementVNode("div", _hoisted_2$1, [
                        vue.createVNode(vue.unref(NButton), {
                          style: { "margin-right": "15px" },
                          onClick: previewCode,
                          tertiary: "",
                          type: "info"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode("")
                          ]),
                          _: 1
                        }),
                        vue.createVNode(vue.unref(NButton), {
                          onClick: _cache[0] || (_cache[0] = ($event) => codeGenerator()),
                          strong: "",
                          secondary: "",
                          type: "primary"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode("")
                          ]),
                          _: 1
                        })
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["show"]),
              vue.createVNode(_component_n_modal, {
                show: showCode.value,
                "onUpdate:show": _cache[2] || (_cache[2] = ($event) => showCode.value = $event),
                preset: "card",
                title: "Flycode",
                style: { "width": "900px" },
                bordered: false
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(_sfc_main$5, {
                    "fly-code": flyCode.value,
                    showCode: showCode.value
                  }, null, 8, ["fly-code", "showCode"])
                ]),
                _: 1
              }, 8, ["show"]),
              vue.createVNode(_sfc_main$9)
            ]);
          };
        }
      });
      /*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
      var current_ansi = 1252;
      var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
      var CS2CP = {
        /*::[*/
        0: 1252,
        /* ANSI */
        /*::[*/
        1: 65001,
        /* DEFAULT */
        /*::[*/
        2: 65001,
        /* SYMBOL */
        /*::[*/
        77: 1e4,
        /* MAC */
        /*::[*/
        128: 932,
        /* SHIFTJIS */
        /*::[*/
        129: 949,
        /* HANGUL */
        /*::[*/
        130: 1361,
        /* JOHAB */
        /*::[*/
        134: 936,
        /* GB2312 */
        /*::[*/
        136: 950,
        /* CHINESEBIG5 */
        /*::[*/
        161: 1253,
        /* GREEK */
        /*::[*/
        162: 1254,
        /* TURKISH */
        /*::[*/
        163: 1258,
        /* VIETNAMESE */
        /*::[*/
        177: 1255,
        /* HEBREW */
        /*::[*/
        178: 1256,
        /* ARABIC */
        /*::[*/
        186: 1257,
        /* BALTIC */
        /*::[*/
        204: 1251,
        /* RUSSIAN */
        /*::[*/
        222: 874,
        /* THAI */
        /*::[*/
        238: 1250,
        /* EASTEUROPE */
        /*::[*/
        255: 1252,
        /* OEM */
        /*::[*/
        69: 6969
        /* MISC */
      };
      var set_ansi = function(cp) {
        if (VALID_ANSI.indexOf(cp) == -1)
          return;
        current_ansi = CS2CP[0] = cp;
      };
      function reset_ansi() {
        set_ansi(1252);
      }
      var set_cp = function(cp) {
        set_ansi(cp);
      };
      function reset_cp() {
        set_cp(1200);
        reset_ansi();
      }
      function char_codes(data) {
        var o = [];
        for (var i = 0, len2 = data.length; i < len2; ++i)
          o[i] = data.charCodeAt(i);
        return o;
      }
      function utf16leread(data) {
        var o = [];
        for (var i = 0; i < data.length >> 1; ++i)
          o[i] = String.fromCharCode(data.charCodeAt(2 * i) + (data.charCodeAt(2 * i + 1) << 8));
        return o.join("");
      }
      function utf16beread(data) {
        var o = [];
        for (var i = 0; i < data.length >> 1; ++i)
          o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
        return o.join("");
      }
      var debom = function(data) {
        var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
        if (c1 == 255 && c2 == 254)
          return utf16leread(data.slice(2));
        if (c1 == 254 && c2 == 255)
          return utf16beread(data.slice(2));
        if (c1 == 65279)
          return data.slice(1);
        return data;
      };
      var _getchar = function _gc1(x) {
        return String.fromCharCode(x);
      };
      var _getansi = function _ga1(x) {
        return String.fromCharCode(x);
      };
      var $cptable;
      var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      function Base64_encode(input) {
        var o = "";
        var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
        for (var i = 0; i < input.length; ) {
          c1 = input.charCodeAt(i++);
          e1 = c1 >> 2;
          c2 = input.charCodeAt(i++);
          e2 = (c1 & 3) << 4 | c2 >> 4;
          c3 = input.charCodeAt(i++);
          e3 = (c2 & 15) << 2 | c3 >> 6;
          e4 = c3 & 63;
          if (isNaN(c2)) {
            e3 = e4 = 64;
          } else if (isNaN(c3)) {
            e4 = 64;
          }
          o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
        }
        return o;
      }
      function Base64_decode(input) {
        var o = "";
        var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
        input = input.replace(/[^\w\+\/\=]/g, "");
        for (var i = 0; i < input.length; ) {
          e1 = Base64_map.indexOf(input.charAt(i++));
          e2 = Base64_map.indexOf(input.charAt(i++));
          c1 = e1 << 2 | e2 >> 4;
          o += String.fromCharCode(c1);
          e3 = Base64_map.indexOf(input.charAt(i++));
          c2 = (e2 & 15) << 4 | e3 >> 2;
          if (e3 !== 64) {
            o += String.fromCharCode(c2);
          }
          e4 = Base64_map.indexOf(input.charAt(i++));
          c3 = (e3 & 3) << 6 | e4;
          if (e4 !== 64) {
            o += String.fromCharCode(c3);
          }
        }
        return o;
      }
      var has_buf = /* @__PURE__ */ function() {
        return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
      }();
      var Buffer_from = /* @__PURE__ */ function() {
        if (typeof Buffer !== "undefined") {
          var nbfs = !Buffer.from;
          if (!nbfs)
            try {
              Buffer.from("foo", "utf8");
            } catch (e) {
              nbfs = true;
            }
          return nbfs ? function(buf, enc) {
            return enc ? new Buffer(buf, enc) : new Buffer(buf);
          } : Buffer.from.bind(Buffer);
        }
        return function() {
        };
      }();
      function new_raw_buf(len2) {
        if (has_buf)
          return Buffer.alloc ? Buffer.alloc(len2) : new Buffer(len2);
        return typeof Uint8Array != "undefined" ? new Uint8Array(len2) : new Array(len2);
      }
      function new_unsafe_buf(len2) {
        if (has_buf)
          return Buffer.allocUnsafe ? Buffer.allocUnsafe(len2) : new Buffer(len2);
        return typeof Uint8Array != "undefined" ? new Uint8Array(len2) : new Array(len2);
      }
      var s2a = function s2a2(s) {
        if (has_buf)
          return Buffer_from(s, "binary");
        return s.split("").map(function(x) {
          return x.charCodeAt(0) & 255;
        });
      };
      function a2s(data) {
        if (Array.isArray(data))
          return data.map(function(c2) {
            return String.fromCharCode(c2);
          }).join("");
        var o = [];
        for (var i = 0; i < data.length; ++i)
          o[i] = String.fromCharCode(data[i]);
        return o.join("");
      }
      function ab2a(data) {
        if (typeof ArrayBuffer == "undefined")
          throw new Error("Unsupported");
        if (data instanceof ArrayBuffer)
          return ab2a(new Uint8Array(data));
        var o = new Array(data.length);
        for (var i = 0; i < data.length; ++i)
          o[i] = data[i];
        return o;
      }
      var bconcat = has_buf ? function(bufs) {
        return Buffer.concat(bufs.map(function(buf) {
          return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
        }));
      } : function(bufs) {
        if (typeof Uint8Array !== "undefined") {
          var i = 0, maxlen = 0;
          for (i = 0; i < bufs.length; ++i)
            maxlen += bufs[i].length;
          var o = new Uint8Array(maxlen);
          var len2 = 0;
          for (i = 0, maxlen = 0; i < bufs.length; maxlen += len2, ++i) {
            len2 = bufs[i].length;
            if (bufs[i] instanceof Uint8Array)
              o.set(bufs[i], maxlen);
            else if (typeof bufs[i] == "string") {
              throw "wtf";
            } else
              o.set(new Uint8Array(bufs[i]), maxlen);
          }
          return o;
        }
        return [].concat.apply([], bufs.map(function(buf) {
          return Array.isArray(buf) ? buf : [].slice.call(buf);
        }));
      };
      function utf8decode(content) {
        var out = [], widx = 0, L = content.length + 250;
        var o = new_raw_buf(content.length + 255);
        for (var ridx = 0; ridx < content.length; ++ridx) {
          var c2 = content.charCodeAt(ridx);
          if (c2 < 128)
            o[widx++] = c2;
          else if (c2 < 2048) {
            o[widx++] = 192 | c2 >> 6 & 31;
            o[widx++] = 128 | c2 & 63;
          } else if (c2 >= 55296 && c2 < 57344) {
            c2 = (c2 & 1023) + 64;
            var d = content.charCodeAt(++ridx) & 1023;
            o[widx++] = 240 | c2 >> 8 & 7;
            o[widx++] = 128 | c2 >> 2 & 63;
            o[widx++] = 128 | d >> 6 & 15 | (c2 & 3) << 4;
            o[widx++] = 128 | d & 63;
          } else {
            o[widx++] = 224 | c2 >> 12 & 15;
            o[widx++] = 128 | c2 >> 6 & 63;
            o[widx++] = 128 | c2 & 63;
          }
          if (widx > L) {
            out.push(o.slice(0, widx));
            widx = 0;
            o = new_raw_buf(65535);
            L = 65530;
          }
        }
        out.push(o.slice(0, widx));
        return bconcat(out);
      }
      var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
      function _strrev(x) {
        var o = "", i = x.length - 1;
        while (i >= 0)
          o += x.charAt(i--);
        return o;
      }
      function pad0(v, d) {
        var t = "" + v;
        return t.length >= d ? t : fill("0", d - t.length) + t;
      }
      function pad_(v, d) {
        var t = "" + v;
        return t.length >= d ? t : fill(" ", d - t.length) + t;
      }
      function rpad_(v, d) {
        var t = "" + v;
        return t.length >= d ? t : t + fill(" ", d - t.length);
      }
      function pad0r1(v, d) {
        var t = "" + Math.round(v);
        return t.length >= d ? t : fill("0", d - t.length) + t;
      }
      function pad0r2(v, d) {
        var t = "" + v;
        return t.length >= d ? t : fill("0", d - t.length) + t;
      }
      var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
      function pad0r(v, d) {
        if (v > p2_32 || v < -p2_32)
          return pad0r1(v, d);
        var i = Math.round(v);
        return pad0r2(i, d);
      }
      function SSF_isgeneral(s, i) {
        i = i || 0;
        return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
      }
      var days = [
        ["Sun", "Sunday"],
        ["Mon", "Monday"],
        ["Tue", "Tuesday"],
        ["Wed", "Wednesday"],
        ["Thu", "Thursday"],
        ["Fri", "Friday"],
        ["Sat", "Saturday"]
      ];
      var months = [
        ["J", "Jan", "January"],
        ["F", "Feb", "February"],
        ["M", "Mar", "March"],
        ["A", "Apr", "April"],
        ["M", "May", "May"],
        ["J", "Jun", "June"],
        ["J", "Jul", "July"],
        ["A", "Aug", "August"],
        ["S", "Sep", "September"],
        ["O", "Oct", "October"],
        ["N", "Nov", "November"],
        ["D", "Dec", "December"]
      ];
      function SSF_init_table(t) {
        if (!t)
          t = {};
        t[0] = "General";
        t[1] = "0";
        t[2] = "0.00";
        t[3] = "#,##0";
        t[4] = "#,##0.00";
        t[9] = "0%";
        t[10] = "0.00%";
        t[11] = "0.00E+00";
        t[12] = "# ?/?";
        t[13] = "# ??/??";
        t[14] = "m/d/yy";
        t[15] = "d-mmm-yy";
        t[16] = "d-mmm";
        t[17] = "mmm-yy";
        t[18] = "h:mm AM/PM";
        t[19] = "h:mm:ss AM/PM";
        t[20] = "h:mm";
        t[21] = "h:mm:ss";
        t[22] = "m/d/yy h:mm";
        t[37] = "#,##0 ;(#,##0)";
        t[38] = "#,##0 ;[Red](#,##0)";
        t[39] = "#,##0.00;(#,##0.00)";
        t[40] = "#,##0.00;[Red](#,##0.00)";
        t[45] = "mm:ss";
        t[46] = "[h]:mm:ss";
        t[47] = "mmss.0";
        t[48] = "##0.0E+0";
        t[49] = "@";
        t[56] = '"/ "hh""mm""ss" "';
        return t;
      }
      var table_fmt = {
        0: "General",
        1: "0",
        2: "0.00",
        3: "#,##0",
        4: "#,##0.00",
        9: "0%",
        10: "0.00%",
        11: "0.00E+00",
        12: "# ?/?",
        13: "# ??/??",
        14: "m/d/yy",
        15: "d-mmm-yy",
        16: "d-mmm",
        17: "mmm-yy",
        18: "h:mm AM/PM",
        19: "h:mm:ss AM/PM",
        20: "h:mm",
        21: "h:mm:ss",
        22: "m/d/yy h:mm",
        37: "#,##0 ;(#,##0)",
        38: "#,##0 ;[Red](#,##0)",
        39: "#,##0.00;(#,##0.00)",
        40: "#,##0.00;[Red](#,##0.00)",
        45: "mm:ss",
        46: "[h]:mm:ss",
        47: "mmss.0",
        48: "##0.0E+0",
        49: "@",
        56: '"/ "hh""mm""ss" "'
      };
      var SSF_default_map = {
        5: 37,
        6: 38,
        7: 39,
        8: 40,
        //  5 -> 37 ...  8 -> 40
        23: 0,
        24: 0,
        25: 0,
        26: 0,
        // 23 ->  0 ... 26 ->  0
        27: 14,
        28: 14,
        29: 14,
        30: 14,
        31: 14,
        // 27 -> 14 ... 31 -> 14
        50: 14,
        51: 14,
        52: 14,
        53: 14,
        54: 14,
        // 50 -> 14 ... 58 -> 14
        55: 14,
        56: 14,
        57: 14,
        58: 14,
        59: 1,
        60: 2,
        61: 3,
        62: 4,
        // 59 ->  1 ... 62 ->  4
        67: 9,
        68: 10,
        // 67 ->  9 ... 68 -> 10
        69: 12,
        70: 13,
        71: 14,
        // 69 -> 12 ... 71 -> 14
        72: 14,
        73: 15,
        74: 16,
        75: 17,
        // 72 -> 14 ... 75 -> 17
        76: 20,
        77: 21,
        78: 22,
        // 76 -> 20 ... 78 -> 22
        79: 45,
        80: 46,
        81: 47,
        // 79 -> 45 ... 81 -> 47
        82: 0
        // 82 ->  0 ... 65536 -> 0 (omitted)
      };
      var SSF_default_str = {
        //  5 -- Currency,   0 decimal, black negative
        5: '"$"#,##0_);\\("$"#,##0\\)',
        63: '"$"#,##0_);\\("$"#,##0\\)',
        //  6 -- Currency,   0 decimal, red   negative
        6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
        64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
        //  7 -- Currency,   2 decimal, black negative
        7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
        65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
        //  8 -- Currency,   2 decimal, red   negative
        8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        // 41 -- Accounting, 0 decimal, No Symbol
        41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
        // 42 -- Accounting, 0 decimal, $  Symbol
        42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
        // 43 -- Accounting, 2 decimal, No Symbol
        43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
        // 44 -- Accounting, 2 decimal, $  Symbol
        44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
      };
      function SSF_frac(x, D, mixed) {
        var sgn = x < 0 ? -1 : 1;
        var B = x * sgn;
        var P_2 = 0, P_1 = 1, P = 0;
        var Q_2 = 1, Q_1 = 0, Q = 0;
        var A = Math.floor(B);
        while (Q_1 < D) {
          A = Math.floor(B);
          P = A * P_1 + P_2;
          Q = A * Q_1 + Q_2;
          if (B - A < 5e-8)
            break;
          B = 1 / (B - A);
          P_2 = P_1;
          P_1 = P;
          Q_2 = Q_1;
          Q_1 = Q;
        }
        if (Q > D) {
          if (Q_1 > D) {
            Q = Q_2;
            P = P_2;
          } else {
            Q = Q_1;
            P = P_1;
          }
        }
        if (!mixed)
          return [0, sgn * P, Q];
        var q = Math.floor(sgn * P / Q);
        return [q, sgn * P - q * Q, Q];
      }
      function SSF_parse_date_code(v, opts, b2) {
        if (v > 2958465 || v < 0)
          return null;
        var date2 = v | 0, time2 = Math.floor(86400 * (v - date2)), dow = 0;
        var dout = [];
        var out = { D: date2, T: time2, u: 86400 * (v - date2) - time2, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
        if (Math.abs(out.u) < 1e-6)
          out.u = 0;
        if (opts && opts.date1904)
          date2 += 1462;
        if (out.u > 0.9999) {
          out.u = 0;
          if (++time2 == 86400) {
            out.T = time2 = 0;
            ++date2;
            ++out.D;
          }
        }
        if (date2 === 60) {
          dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
          dow = 3;
        } else if (date2 === 0) {
          dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
          dow = 6;
        } else {
          if (date2 > 60)
            --date2;
          var d = new Date(1900, 0, 1);
          d.setDate(d.getDate() + date2 - 1);
          dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
          dow = d.getDay();
          if (date2 < 60)
            dow = (dow + 6) % 7;
          if (b2)
            dow = SSF_fix_hijri(d, dout);
        }
        out.y = dout[0];
        out.m = dout[1];
        out.d = dout[2];
        out.S = time2 % 60;
        time2 = Math.floor(time2 / 60);
        out.M = time2 % 60;
        time2 = Math.floor(time2 / 60);
        out.H = time2;
        out.q = dow;
        return out;
      }
      var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
      var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
      var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
      function datenum_local(v, date1904) {
        var epoch = /* @__PURE__ */ v.getTime();
        if (date1904)
          epoch -= 1461 * 24 * 60 * 60 * 1e3;
        else if (v >= SSFbase1904)
          epoch += 24 * 60 * 60 * 1e3;
        return (epoch - (SSFdnthresh + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
      }
      function SSF_strip_decimal(o) {
        return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
      }
      function SSF_normalize_exp(o) {
        if (o.indexOf("E") == -1)
          return o;
        return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
      }
      function SSF_small_exp(v) {
        var w = v < 0 ? 12 : 11;
        var o = SSF_strip_decimal(v.toFixed(12));
        if (o.length <= w)
          return o;
        o = v.toPrecision(10);
        if (o.length <= w)
          return o;
        return v.toExponential(5);
      }
      function SSF_large_exp(v) {
        var o = SSF_strip_decimal(v.toFixed(11));
        return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
      }
      function SSF_general_num(v) {
        var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
        if (V >= -4 && V <= -1)
          o = v.toPrecision(10 + V);
        else if (Math.abs(V) <= 9)
          o = SSF_small_exp(v);
        else if (V === 10)
          o = v.toFixed(10).substr(0, 12);
        else
          o = SSF_large_exp(v);
        return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
      }
      function SSF_general(v, opts) {
        switch (typeof v) {
          case "string":
            return v;
          case "boolean":
            return v ? "TRUE" : "FALSE";
          case "number":
            return (v | 0) === v ? v.toString(10) : SSF_general_num(v);
          case "undefined":
            return "";
          case "object":
            if (v == null)
              return "";
            if (v instanceof Date)
              return SSF_format(14, datenum_local(v, opts && opts.date1904), opts);
        }
        throw new Error("unsupported value in General format: " + v);
      }
      function SSF_fix_hijri(date2, o) {
        o[0] -= 581;
        var dow = date2.getDay();
        if (date2 < 60)
          dow = (dow + 6) % 7;
        return dow;
      }
      function SSF_write_date(type2, fmt, val, ss0) {
        var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
        switch (type2) {
          case 98:
            y = val.y + 543;
          case 121:
            switch (fmt.length) {
              case 1:
              case 2:
                out = y % 100;
                outl = 2;
                break;
              default:
                out = y % 1e4;
                outl = 4;
                break;
            }
            break;
          case 109:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.m;
                outl = fmt.length;
                break;
              case 3:
                return months[val.m - 1][1];
              case 5:
                return months[val.m - 1][0];
              default:
                return months[val.m - 1][2];
            }
            break;
          case 100:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.d;
                outl = fmt.length;
                break;
              case 3:
                return days[val.q][0];
              default:
                return days[val.q][1];
            }
            break;
          case 104:
            switch (fmt.length) {
              case 1:
              case 2:
                out = 1 + (val.H + 11) % 12;
                outl = fmt.length;
                break;
              default:
                throw "bad hour format: " + fmt;
            }
            break;
          case 72:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.H;
                outl = fmt.length;
                break;
              default:
                throw "bad hour format: " + fmt;
            }
            break;
          case 77:
            switch (fmt.length) {
              case 1:
              case 2:
                out = val.M;
                outl = fmt.length;
                break;
              default:
                throw "bad minute format: " + fmt;
            }
            break;
          case 115:
            if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000")
              throw "bad second format: " + fmt;
            if (val.u === 0 && (fmt == "s" || fmt == "ss"))
              return pad0(val.S, fmt.length);
            if (ss0 >= 2)
              tt = ss0 === 3 ? 1e3 : 100;
            else
              tt = ss0 === 1 ? 10 : 1;
            ss = Math.round(tt * (val.S + val.u));
            if (ss >= 60 * tt)
              ss = 0;
            if (fmt === "s")
              return ss === 0 ? "0" : "" + ss / tt;
            o = pad0(ss, 2 + ss0);
            if (fmt === "ss")
              return o.substr(0, 2);
            return "." + o.substr(2, fmt.length - 1);
          case 90:
            switch (fmt) {
              case "[h]":
              case "[hh]":
                out = val.D * 24 + val.H;
                break;
              case "[m]":
              case "[mm]":
                out = (val.D * 24 + val.H) * 60 + val.M;
                break;
              case "[s]":
              case "[ss]":
                out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
                break;
              default:
                throw "bad abstime format: " + fmt;
            }
            outl = fmt.length === 3 ? 1 : 2;
            break;
          case 101:
            out = y;
            outl = 1;
            break;
        }
        var outstr = outl > 0 ? pad0(out, outl) : "";
        return outstr;
      }
      function commaify(s) {
        var w = 3;
        if (s.length <= w)
          return s;
        var j = s.length % w, o = s.substr(0, j);
        for (; j != s.length; j += w)
          o += (o.length > 0 ? "," : "") + s.substr(j, w);
        return o;
      }
      var pct1 = /%/g;
      function write_num_pct(type2, fmt, val) {
        var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
        return write_num(type2, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
      }
      function write_num_cm(type2, fmt, val) {
        var idx = fmt.length - 1;
        while (fmt.charCodeAt(idx - 1) === 44)
          --idx;
        return write_num(type2, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
      }
      function write_num_exp(fmt, val) {
        var o;
        var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
        if (fmt.match(/^#+0.0E\+0$/)) {
          if (val == 0)
            return "0.0E+0";
          else if (val < 0)
            return "-" + write_num_exp(fmt, -val);
          var period = fmt.indexOf(".");
          if (period === -1)
            period = fmt.indexOf("E");
          var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
          if (ee < 0)
            ee += period;
          o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
          if (o.indexOf("e") === -1) {
            var fakee = Math.floor(Math.log(val) * Math.LOG10E);
            if (o.indexOf(".") === -1)
              o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
            else
              o += "E+" + (fakee - ee);
            while (o.substr(0, 2) === "0.") {
              o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
              o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
            }
            o = o.replace(/\+-/, "-");
          }
          o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
            return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
          });
        } else
          o = val.toExponential(idx);
        if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
          o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
        if (fmt.match(/E\-/) && o.match(/e\+/))
          o = o.replace(/e\+/, "e");
        return o.replace("e", "E");
      }
      var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
      function write_num_f1(r, aval, sign) {
        var den = parseInt(r[4], 10), rr = Math.round(aval * den), base2 = Math.floor(rr / den);
        var myn = rr - base2 * den, myd = den;
        return sign + (base2 === 0 ? "" : "" + base2) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
      }
      function write_num_f2(r, aval, sign) {
        return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
      }
      var dec1 = /^#*0*\.([0#]+)/;
      var closeparen = /\).*[0#]/;
      var phone = /\(###\) ###\\?-####/;
      function hashq(str) {
        var o = "", cc;
        for (var i = 0; i != str.length; ++i)
          switch (cc = str.charCodeAt(i)) {
            case 35:
              break;
            case 63:
              o += " ";
              break;
            case 48:
              o += "0";
              break;
            default:
              o += String.fromCharCode(cc);
          }
        return o;
      }
      function rnd(val, d) {
        var dd = Math.pow(10, d);
        return "" + Math.round(val * dd) / dd;
      }
      function dec(val, d) {
        var _frac = val - Math.floor(val), dd = Math.pow(10, d);
        if (d < ("" + Math.round(_frac * dd)).length)
          return 0;
        return Math.round(_frac * dd);
      }
      function carry(val, d) {
        if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
          return 1;
        }
        return 0;
      }
      function flr(val) {
        if (val < 2147483647 && val > -2147483648)
          return "" + (val >= 0 ? val | 0 : val - 1 | 0);
        return "" + Math.floor(val);
      }
      function write_num_flt(type2, fmt, val) {
        if (type2.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
          var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
          if (val >= 0)
            return write_num_flt("n", ffmt, val);
          return "(" + write_num_flt("n", ffmt, -val) + ")";
        }
        if (fmt.charCodeAt(fmt.length - 1) === 44)
          return write_num_cm(type2, fmt, val);
        if (fmt.indexOf("%") !== -1)
          return write_num_pct(type2, fmt, val);
        if (fmt.indexOf("E") !== -1)
          return write_num_exp(fmt, val);
        if (fmt.charCodeAt(0) === 36)
          return "$" + write_num_flt(type2, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
        var o;
        var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
        if (fmt.match(/^00+$/))
          return sign + pad0r(aval, fmt.length);
        if (fmt.match(/^[#?]+$/)) {
          o = pad0r(val, 0);
          if (o === "0")
            o = "";
          return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
        }
        if (r = fmt.match(frac1))
          return write_num_f1(r, aval, sign);
        if (fmt.match(/^#+0+$/))
          return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
        if (r = fmt.match(dec1)) {
          o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
            return "." + $1 + fill("0", hashq(
              /*::(*/
              r[1]
            ).length - $1.length);
          });
          return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
        }
        fmt = fmt.replace(/^#+([0.])/, "$1");
        if (r = fmt.match(/^(0*)\.(#*)$/)) {
          return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
        }
        if (r = fmt.match(/^#{1,3},##0(\.?)$/))
          return sign + commaify(pad0r(aval, 0));
        if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
          return val < 0 ? "-" + write_num_flt(type2, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
        }
        if (r = fmt.match(/^#,#*,#0/))
          return write_num_flt(type2, fmt.replace(/^#,#*,/, ""), val);
        if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
          o = _strrev(write_num_flt(type2, fmt.replace(/[\\-]/g, ""), val));
          ri = 0;
          return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
            return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
          }));
        }
        if (fmt.match(phone)) {
          o = write_num_flt(type2, "##########", val);
          return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
        }
        var oa = "";
        if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri = Math.min(
            /*::String(*/
            r[4].length,
            7
          );
          ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
          o = "" + sign;
          oa = write_num(
            "n",
            /*::String(*/
            r[1],
            ff[1]
          );
          if (oa.charAt(oa.length - 1) == " ")
            oa = oa.substr(0, oa.length - 1) + "0";
          o += oa + /*::String(*/
          r[2] + "/" + /*::String(*/
          r[3];
          oa = rpad_(ff[2], ri);
          if (oa.length < r[4].length)
            oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
          o += oa;
          return o;
        }
        if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri = Math.min(Math.max(r[1].length, r[4].length), 7);
          ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
          return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
        }
        if (r = fmt.match(/^[#0?]+$/)) {
          o = pad0r(val, 0);
          if (fmt.length <= o.length)
            return o;
          return hashq(fmt.substr(0, fmt.length - o.length)) + o;
        }
        if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
          o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
          ri = o.indexOf(".");
          var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
          return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
        }
        if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
          ri = dec(val, r[1].length);
          return val < 0 ? "-" + write_num_flt(type2, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
            return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
          }) + "." + pad0(ri, r[1].length);
        }
        switch (fmt) {
          case "###,##0.00":
            return write_num_flt(type2, "#,##0.00", val);
          case "###,###":
          case "##,###":
          case "#,###":
            var x = commaify(pad0r(aval, 0));
            return x !== "0" ? sign + x : "";
          case "###,###.00":
            return write_num_flt(type2, "###,##0.00", val).replace(/^0\./, ".");
          case "#,###.00":
            return write_num_flt(type2, "#,##0.00", val).replace(/^0\./, ".");
        }
        throw new Error("unsupported format |" + fmt + "|");
      }
      function write_num_cm2(type2, fmt, val) {
        var idx = fmt.length - 1;
        while (fmt.charCodeAt(idx - 1) === 44)
          --idx;
        return write_num(type2, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
      }
      function write_num_pct2(type2, fmt, val) {
        var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
        return write_num(type2, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
      }
      function write_num_exp2(fmt, val) {
        var o;
        var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
        if (fmt.match(/^#+0.0E\+0$/)) {
          if (val == 0)
            return "0.0E+0";
          else if (val < 0)
            return "-" + write_num_exp2(fmt, -val);
          var period = fmt.indexOf(".");
          if (period === -1)
            period = fmt.indexOf("E");
          var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
          if (ee < 0)
            ee += period;
          o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
          if (!o.match(/[Ee]/)) {
            var fakee = Math.floor(Math.log(val) * Math.LOG10E);
            if (o.indexOf(".") === -1)
              o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
            else
              o += "E+" + (fakee - ee);
            o = o.replace(/\+-/, "-");
          }
          o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
            return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
          });
        } else
          o = val.toExponential(idx);
        if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
          o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
        if (fmt.match(/E\-/) && o.match(/e\+/))
          o = o.replace(/e\+/, "e");
        return o.replace("e", "E");
      }
      function write_num_int(type2, fmt, val) {
        if (type2.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
          var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
          if (val >= 0)
            return write_num_int("n", ffmt, val);
          return "(" + write_num_int("n", ffmt, -val) + ")";
        }
        if (fmt.charCodeAt(fmt.length - 1) === 44)
          return write_num_cm2(type2, fmt, val);
        if (fmt.indexOf("%") !== -1)
          return write_num_pct2(type2, fmt, val);
        if (fmt.indexOf("E") !== -1)
          return write_num_exp2(fmt, val);
        if (fmt.charCodeAt(0) === 36)
          return "$" + write_num_int(type2, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
        var o;
        var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
        if (fmt.match(/^00+$/))
          return sign + pad0(aval, fmt.length);
        if (fmt.match(/^[#?]+$/)) {
          o = "" + val;
          if (val === 0)
            o = "";
          return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
        }
        if (r = fmt.match(frac1))
          return write_num_f2(r, aval, sign);
        if (fmt.match(/^#+0+$/))
          return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
        if (r = fmt.match(dec1)) {
          o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
          o = o.replace(/\.(\d*)$/, function($$, $1) {
            return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
          });
          return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
        }
        fmt = fmt.replace(/^#+([0.])/, "$1");
        if (r = fmt.match(/^(0*)\.(#*)$/)) {
          return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
        }
        if (r = fmt.match(/^#{1,3},##0(\.?)$/))
          return sign + commaify("" + aval);
        if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
          return val < 0 ? "-" + write_num_int(type2, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
        }
        if (r = fmt.match(/^#,#*,#0/))
          return write_num_int(type2, fmt.replace(/^#,#*,/, ""), val);
        if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
          o = _strrev(write_num_int(type2, fmt.replace(/[\\-]/g, ""), val));
          ri = 0;
          return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
            return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
          }));
        }
        if (fmt.match(phone)) {
          o = write_num_int(type2, "##########", val);
          return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
        }
        var oa = "";
        if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri = Math.min(
            /*::String(*/
            r[4].length,
            7
          );
          ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
          o = "" + sign;
          oa = write_num(
            "n",
            /*::String(*/
            r[1],
            ff[1]
          );
          if (oa.charAt(oa.length - 1) == " ")
            oa = oa.substr(0, oa.length - 1) + "0";
          o += oa + /*::String(*/
          r[2] + "/" + /*::String(*/
          r[3];
          oa = rpad_(ff[2], ri);
          if (oa.length < r[4].length)
            oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
          o += oa;
          return o;
        }
        if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri = Math.min(Math.max(r[1].length, r[4].length), 7);
          ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
          return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
        }
        if (r = fmt.match(/^[#0?]+$/)) {
          o = "" + val;
          if (fmt.length <= o.length)
            return o;
          return hashq(fmt.substr(0, fmt.length - o.length)) + o;
        }
        if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
          o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
          ri = o.indexOf(".");
          var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
          return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
        }
        if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
          return val < 0 ? "-" + write_num_int(type2, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
            return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
          }) + "." + pad0(0, r[1].length);
        }
        switch (fmt) {
          case "###,###":
          case "##,###":
          case "#,###":
            var x = commaify("" + aval);
            return x !== "0" ? sign + x : "";
          default:
            if (fmt.match(/\.[0#?]*$/))
              return write_num_int(type2, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
        }
        throw new Error("unsupported format |" + fmt + "|");
      }
      function write_num(type2, fmt, val) {
        return (val | 0) === val ? write_num_int(type2, fmt, val) : write_num_flt(type2, fmt, val);
      }
      function SSF_split_fmt(fmt) {
        var out = [];
        var in_str = false;
        for (var i = 0, j = 0; i < fmt.length; ++i)
          switch (
            /*cc=*/
            fmt.charCodeAt(i)
          ) {
            case 34:
              in_str = !in_str;
              break;
            case 95:
            case 42:
            case 92:
              ++i;
              break;
            case 59:
              out[out.length] = fmt.substr(j, i - j);
              j = i + 1;
          }
        out[out.length] = fmt.substr(j);
        if (in_str === true)
          throw new Error("Format |" + fmt + "| unterminated string ");
        return out;
      }
      var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
      function fmt_is_date(fmt) {
        var i = 0, c2 = "", o = "";
        while (i < fmt.length) {
          switch (c2 = fmt.charAt(i)) {
            case "G":
              if (SSF_isgeneral(fmt, i))
                i += 6;
              i++;
              break;
            case '"':
              for (
                ;
                /*cc=*/
                fmt.charCodeAt(++i) !== 34 && i < fmt.length;
              ) {
              }
              ++i;
              break;
            case "\\":
              i += 2;
              break;
            case "_":
              i += 2;
              break;
            case "@":
              ++i;
              break;
            case "B":
            case "b":
              if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2")
                return true;
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              return true;
            case "A":
            case "a":
            case "":
              if (fmt.substr(i, 3).toUpperCase() === "A/P")
                return true;
              if (fmt.substr(i, 5).toUpperCase() === "AM/PM")
                return true;
              if (fmt.substr(i, 5).toUpperCase() === "/")
                return true;
              ++i;
              break;
            case "[":
              o = c2;
              while (fmt.charAt(i++) !== "]" && i < fmt.length)
                o += fmt.charAt(i);
              if (o.match(SSF_abstime))
                return true;
              break;
            case ".":
            case "0":
            case "#":
              while (i < fmt.length && ("0#?.,E+-%".indexOf(c2 = fmt.charAt(++i)) > -1 || c2 == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
              }
              break;
            case "?":
              while (fmt.charAt(++i) === c2) {
              }
              break;
            case "*":
              ++i;
              if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
                ++i;
              break;
            case "(":
            case ")":
              ++i;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
              }
              break;
            case " ":
              ++i;
              break;
            default:
              ++i;
              break;
          }
        }
        return false;
      }
      function eval_fmt(fmt, v, opts, flen) {
        var out = [], o = "", i = 0, c2 = "", lst = "t", dt, j, cc;
        var hr2 = "H";
        while (i < fmt.length) {
          switch (c2 = fmt.charAt(i)) {
            case "G":
              if (!SSF_isgeneral(fmt, i))
                throw new Error("unrecognized character " + c2 + " in " + fmt);
              out[out.length] = { t: "G", v: "General" };
              i += 7;
              break;
            case '"':
              for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; )
                o += String.fromCharCode(cc);
              out[out.length] = { t: "t", v: o };
              ++i;
              break;
            case "\\":
              var w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
              out[out.length] = { t, v: w };
              ++i;
              break;
            case "_":
              out[out.length] = { t: "t", v: " " };
              i += 2;
              break;
            case "@":
              out[out.length] = { t: "T", v };
              ++i;
              break;
            case "B":
            case "b":
              if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
                if (dt == null) {
                  dt = SSF_parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
                  if (dt == null)
                    return "";
                }
                out[out.length] = { t: "X", v: fmt.substr(i, 2) };
                lst = c2;
                i += 2;
                break;
              }
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
              c2 = c2.toLowerCase();
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              if (v < 0)
                return "";
              if (dt == null) {
                dt = SSF_parse_date_code(v, opts);
                if (dt == null)
                  return "";
              }
              o = c2;
              while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c2)
                o += c2;
              if (c2 === "m" && lst.toLowerCase() === "h")
                c2 = "M";
              if (c2 === "h")
                c2 = hr2;
              out[out.length] = { t: c2, v: o };
              lst = c2;
              break;
            case "A":
            case "a":
            case "":
              var q = { t: c2, v: c2 };
              if (dt == null)
                dt = SSF_parse_date_code(v, opts);
              if (fmt.substr(i, 3).toUpperCase() === "A/P") {
                if (dt != null)
                  q.v = dt.H >= 12 ? "P" : "A";
                q.t = "T";
                hr2 = "h";
                i += 3;
              } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
                if (dt != null)
                  q.v = dt.H >= 12 ? "PM" : "AM";
                q.t = "T";
                i += 5;
                hr2 = "h";
              } else if (fmt.substr(i, 5).toUpperCase() === "/") {
                if (dt != null)
                  q.v = dt.H >= 12 ? "" : "";
                q.t = "T";
                i += 5;
                hr2 = "h";
              } else {
                q.t = "t";
                ++i;
              }
              if (dt == null && q.t === "T")
                return "";
              out[out.length] = q;
              lst = c2;
              break;
            case "[":
              o = c2;
              while (fmt.charAt(i++) !== "]" && i < fmt.length)
                o += fmt.charAt(i);
              if (o.slice(-1) !== "]")
                throw 'unterminated "[" block: |' + o + "|";
              if (o.match(SSF_abstime)) {
                if (dt == null) {
                  dt = SSF_parse_date_code(v, opts);
                  if (dt == null)
                    return "";
                }
                out[out.length] = { t: "Z", v: o.toLowerCase() };
                lst = o.charAt(1);
              } else if (o.indexOf("$") > -1) {
                o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
                if (!fmt_is_date(fmt))
                  out[out.length] = { t: "t", v: o };
              }
              break;
            case ".":
              if (dt != null) {
                o = c2;
                while (++i < fmt.length && (c2 = fmt.charAt(i)) === "0")
                  o += c2;
                out[out.length] = { t: "s", v: o };
                break;
              }
            case "0":
            case "#":
              o = c2;
              while (++i < fmt.length && "0#?.,E+-%".indexOf(c2 = fmt.charAt(i)) > -1)
                o += c2;
              out[out.length] = { t: "n", v: o };
              break;
            case "?":
              o = c2;
              while (fmt.charAt(++i) === c2)
                o += c2;
              out[out.length] = { t: c2, v: o };
              lst = c2;
              break;
            case "*":
              ++i;
              if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
                ++i;
              break;
            case "(":
            case ")":
              out[out.length] = { t: flen === 1 ? "t" : c2, v: c2 };
              ++i;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              o = c2;
              while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1)
                o += fmt.charAt(i);
              out[out.length] = { t: "D", v: o };
              break;
            case " ":
              out[out.length] = { t: c2, v: c2 };
              ++i;
              break;
            case "$":
              out[out.length] = { t: "t", v: "$" };
              ++i;
              break;
            default:
              if (",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(c2) === -1)
                throw new Error("unrecognized character " + c2 + " in " + fmt);
              out[out.length] = { t: "t", v: c2 };
              ++i;
              break;
          }
        }
        var bt = 0, ss0 = 0, ssm;
        for (i = out.length - 1, lst = "t"; i >= 0; --i) {
          switch (out[i].t) {
            case "h":
            case "H":
              out[i].t = hr2;
              lst = "h";
              if (bt < 1)
                bt = 1;
              break;
            case "s":
              if (ssm = out[i].v.match(/\.0+$/))
                ss0 = Math.max(ss0, ssm[0].length - 1);
              if (bt < 3)
                bt = 3;
            case "d":
            case "y":
            case "M":
            case "e":
              lst = out[i].t;
              break;
            case "m":
              if (lst === "s") {
                out[i].t = "M";
                if (bt < 2)
                  bt = 2;
              }
              break;
            case "X":
              break;
            case "Z":
              if (bt < 1 && out[i].v.match(/[Hh]/))
                bt = 1;
              if (bt < 2 && out[i].v.match(/[Mm]/))
                bt = 2;
              if (bt < 3 && out[i].v.match(/[Ss]/))
                bt = 3;
          }
        }
        switch (bt) {
          case 0:
            break;
          case 1:
            if (dt.u >= 0.5) {
              dt.u = 0;
              ++dt.S;
            }
            if (dt.S >= 60) {
              dt.S = 0;
              ++dt.M;
            }
            if (dt.M >= 60) {
              dt.M = 0;
              ++dt.H;
            }
            break;
          case 2:
            if (dt.u >= 0.5) {
              dt.u = 0;
              ++dt.S;
            }
            if (dt.S >= 60) {
              dt.S = 0;
              ++dt.M;
            }
            break;
        }
        var nstr = "", jj;
        for (i = 0; i < out.length; ++i) {
          switch (out[i].t) {
            case "t":
            case "T":
            case " ":
            case "D":
              break;
            case "X":
              out[i].v = "";
              out[i].t = ";";
              break;
            case "d":
            case "m":
            case "y":
            case "h":
            case "H":
            case "M":
            case "s":
            case "e":
            case "b":
            case "Z":
              out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
              out[i].t = "t";
              break;
            case "n":
            case "?":
              jj = i + 1;
              while (out[jj] != null && ((c2 = out[jj].t) === "?" || c2 === "D" || (c2 === " " || c2 === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c2 === " " || c2 === "n" || c2 === ")") || c2 === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
                out[i].v += out[jj].v;
                out[jj] = { v: "", t: ";" };
                ++jj;
              }
              nstr += out[i].v;
              i = jj - 1;
              break;
            case "G":
              out[i].t = "t";
              out[i].v = SSF_general(v, opts);
              break;
          }
        }
        var vv = "", myv, ostr;
        if (nstr.length > 0) {
          if (nstr.charCodeAt(0) == 40) {
            myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
            ostr = write_num("n", nstr, myv);
          } else {
            myv = v < 0 && flen > 1 ? -v : v;
            ostr = write_num("n", nstr, myv);
            if (myv < 0 && out[0] && out[0].t == "t") {
              ostr = ostr.substr(1);
              out[0].v = "-" + out[0].v;
            }
          }
          jj = ostr.length - 1;
          var decpt = out.length;
          for (i = 0; i < out.length; ++i)
            if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
              decpt = i;
              break;
            }
          var lasti = out.length;
          if (decpt === out.length && ostr.indexOf("E") === -1) {
            for (i = out.length - 1; i >= 0; --i) {
              if (out[i] == null || "n?".indexOf(out[i].t) === -1)
                continue;
              if (jj >= out[i].v.length - 1) {
                jj -= out[i].v.length;
                out[i].v = ostr.substr(jj + 1, out[i].v.length);
              } else if (jj < 0)
                out[i].v = "";
              else {
                out[i].v = ostr.substr(0, jj + 1);
                jj = -1;
              }
              out[i].t = "t";
              lasti = i;
            }
            if (jj >= 0 && lasti < out.length)
              out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
          } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
            jj = ostr.indexOf(".") - 1;
            for (i = decpt; i >= 0; --i) {
              if (out[i] == null || "n?".indexOf(out[i].t) === -1)
                continue;
              j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
              vv = out[i].v.substr(j + 1);
              for (; j >= 0; --j) {
                if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#"))
                  vv = ostr.charAt(jj--) + vv;
              }
              out[i].v = vv;
              out[i].t = "t";
              lasti = i;
            }
            if (jj >= 0 && lasti < out.length)
              out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
            jj = ostr.indexOf(".") + 1;
            for (i = decpt; i < out.length; ++i) {
              if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt)
                continue;
              j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
              vv = out[i].v.substr(0, j);
              for (; j < out[i].v.length; ++j) {
                if (jj < ostr.length)
                  vv += ostr.charAt(jj++);
              }
              out[i].v = vv;
              out[i].t = "t";
              lasti = i;
            }
          }
        }
        for (i = 0; i < out.length; ++i)
          if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
            myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
            out[i].v = write_num(out[i].t, out[i].v, myv);
            out[i].t = "t";
          }
        var retval = "";
        for (i = 0; i !== out.length; ++i)
          if (out[i] != null)
            retval += out[i].v;
        return retval;
      }
      var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
      function chkcond(v, rr) {
        if (rr == null)
          return false;
        var thresh = parseFloat(rr[2]);
        switch (rr[1]) {
          case "=":
            if (v == thresh)
              return true;
            break;
          case ">":
            if (v > thresh)
              return true;
            break;
          case "<":
            if (v < thresh)
              return true;
            break;
          case "<>":
            if (v != thresh)
              return true;
            break;
          case ">=":
            if (v >= thresh)
              return true;
            break;
          case "<=":
            if (v <= thresh)
              return true;
            break;
        }
        return false;
      }
      function choose_fmt(f, v) {
        var fmt = SSF_split_fmt(f);
        var l = fmt.length, lat = fmt[l - 1].indexOf("@");
        if (l < 4 && lat > -1)
          --l;
        if (fmt.length > 4)
          throw new Error("cannot find right format for |" + fmt.join("|") + "|");
        if (typeof v !== "number")
          return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
        switch (fmt.length) {
          case 1:
            fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
            break;
          case 2:
            fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
            break;
          case 3:
            fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
            break;
        }
        var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
        if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1)
          return [l, ff];
        if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
          var m1 = fmt[0].match(cfregex2);
          var m2 = fmt[1].match(cfregex2);
          return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
        }
        return [l, ff];
      }
      function SSF_format(fmt, v, o) {
        if (o == null)
          o = {};
        var sfmt = "";
        switch (typeof fmt) {
          case "string":
            if (fmt == "m/d/yy" && o.dateNF)
              sfmt = o.dateNF;
            else
              sfmt = fmt;
            break;
          case "number":
            if (fmt == 14 && o.dateNF)
              sfmt = o.dateNF;
            else
              sfmt = (o.table != null ? o.table : table_fmt)[fmt];
            if (sfmt == null)
              sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
            if (sfmt == null)
              sfmt = SSF_default_str[fmt] || "General";
            break;
        }
        if (SSF_isgeneral(sfmt, 0))
          return SSF_general(v, o);
        if (v instanceof Date)
          v = datenum_local(v, o.date1904);
        var f = choose_fmt(sfmt, v);
        if (SSF_isgeneral(f[1]))
          return SSF_general(v, o);
        if (v === true)
          v = "TRUE";
        else if (v === false)
          v = "FALSE";
        else if (v === "" || v == null)
          return "";
        return eval_fmt(f[1], v, o, f[0]);
      }
      function SSF_load(fmt, idx) {
        if (typeof idx != "number") {
          idx = +idx || -1;
          for (var i = 0; i < 392; ++i) {
            if (table_fmt[i] == void 0) {
              if (idx < 0)
                idx = i;
              continue;
            }
            if (table_fmt[i] == fmt) {
              idx = i;
              break;
            }
          }
          if (idx < 0)
            idx = 391;
        }
        table_fmt[idx] = fmt;
        return idx;
      }
      function make_ssf() {
        table_fmt = SSF_init_table();
      }
      var SSFImplicit = {
        "5": '"$"#,##0_);\\("$"#,##0\\)',
        "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
        "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
        "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        "23": "General",
        "24": "General",
        "25": "General",
        "26": "General",
        "27": "m/d/yy",
        "28": "m/d/yy",
        "29": "m/d/yy",
        "30": "m/d/yy",
        "31": "m/d/yy",
        "32": "h:mm:ss",
        "33": "h:mm:ss",
        "34": "h:mm:ss",
        "35": "h:mm:ss",
        "36": "m/d/yy",
        "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
        "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
        "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
        "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
        "50": "m/d/yy",
        "51": "m/d/yy",
        "52": "m/d/yy",
        "53": "m/d/yy",
        "54": "m/d/yy",
        "55": "m/d/yy",
        "56": "m/d/yy",
        "57": "m/d/yy",
        "58": "m/d/yy",
        "59": "0",
        "60": "0.00",
        "61": "#,##0",
        "62": "#,##0.00",
        "63": '"$"#,##0_);\\("$"#,##0\\)',
        "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
        "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
        "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
        "67": "0%",
        "68": "0.00%",
        "69": "# ?/?",
        "70": "# ??/??",
        "71": "m/d/yy",
        "72": "m/d/yy",
        "73": "d-mmm-yy",
        "74": "d-mmm",
        "75": "mmm-yy",
        "76": "h:mm",
        "77": "h:mm:ss",
        "78": "m/d/yy h:mm",
        "79": "mm:ss",
        "80": "[h]:mm:ss",
        "81": "mmss.0"
      };
      var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
      function dateNF_regex(dateNF) {
        var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
        fmt = fmt.replace(dateNFregex, "(\\d+)");
        return new RegExp("^" + fmt + "$");
      }
      function dateNF_fix(str, dateNF, match2) {
        var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
        (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
          var v = parseInt(match2[i + 1], 10);
          switch (n.toLowerCase().charAt(0)) {
            case "y":
              Y = v;
              break;
            case "d":
              d = v;
              break;
            case "h":
              H = v;
              break;
            case "s":
              S = v;
              break;
            case "m":
              if (H >= 0)
                M = v;
              else
                m = v;
              break;
          }
        });
        if (S >= 0 && M == -1 && m >= 0) {
          M = m;
          m = -1;
        }
        var datestr = ("" + (Y >= 0 ? Y : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
        if (datestr.length == 7)
          datestr = "0" + datestr;
        if (datestr.length == 8)
          datestr = "20" + datestr;
        var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
        if (H == -1 && M == -1 && S == -1)
          return datestr;
        if (Y == -1 && m == -1 && d == -1)
          return timestr;
        return datestr + "T" + timestr;
      }
      var CRC32 = /* @__PURE__ */ function() {
        var CRC322 = {};
        CRC322.version = "1.2.0";
        function signed_crc_table() {
          var c2 = 0, table = new Array(256);
          for (var n = 0; n != 256; ++n) {
            c2 = n;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
            table[n] = c2;
          }
          return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
        }
        var T0 = signed_crc_table();
        function slice_by_16_tables(T) {
          var c2 = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
          for (n = 0; n != 256; ++n)
            table[n] = T[n];
          for (n = 0; n != 256; ++n) {
            v = T[n];
            for (c2 = 256 + n; c2 < 4096; c2 += 256)
              v = table[c2] = v >>> 8 ^ T[v & 255];
          }
          var out = [];
          for (n = 1; n != 16; ++n)
            out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
          return out;
        }
        var TT = slice_by_16_tables(T0);
        var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
        var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
        var Tb = TT[10], Tc = TT[11], Td2 = TT[12], Te = TT[13], Tf = TT[14];
        function crc32_bstr(bstr, seed) {
          var C = seed ^ -1;
          for (var i = 0, L = bstr.length; i < L; )
            C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
          return ~C;
        }
        function crc32_buf(B, seed) {
          var C = seed ^ -1, L = B.length - 15, i = 0;
          for (; i < L; )
            C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td2[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
          L += 15;
          while (i < L)
            C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
          return ~C;
        }
        function crc32_str(str, seed) {
          var C = seed ^ -1;
          for (var i = 0, L = str.length, c2 = 0, d = 0; i < L; ) {
            c2 = str.charCodeAt(i++);
            if (c2 < 128) {
              C = C >>> 8 ^ T0[(C ^ c2) & 255];
            } else if (c2 < 2048) {
              C = C >>> 8 ^ T0[(C ^ (192 | c2 >> 6 & 31)) & 255];
              C = C >>> 8 ^ T0[(C ^ (128 | c2 & 63)) & 255];
            } else if (c2 >= 55296 && c2 < 57344) {
              c2 = (c2 & 1023) + 64;
              d = str.charCodeAt(i++) & 1023;
              C = C >>> 8 ^ T0[(C ^ (240 | c2 >> 8 & 7)) & 255];
              C = C >>> 8 ^ T0[(C ^ (128 | c2 >> 2 & 63)) & 255];
              C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c2 & 3) << 4)) & 255];
              C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
            } else {
              C = C >>> 8 ^ T0[(C ^ (224 | c2 >> 12 & 15)) & 255];
              C = C >>> 8 ^ T0[(C ^ (128 | c2 >> 6 & 63)) & 255];
              C = C >>> 8 ^ T0[(C ^ (128 | c2 & 63)) & 255];
            }
          }
          return ~C;
        }
        CRC322.table = T0;
        CRC322.bstr = crc32_bstr;
        CRC322.buf = crc32_buf;
        CRC322.str = crc32_str;
        return CRC322;
      }();
      var CFB = /* @__PURE__ */ function _CFB() {
        var exports2 = {};
        exports2.version = "1.2.1";
        function namecmp(l, r) {
          var L = l.split("/"), R = r.split("/");
          for (var i2 = 0, c2 = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
            if (c2 = L[i2].length - R[i2].length)
              return c2;
            if (L[i2] != R[i2])
              return L[i2] < R[i2] ? -1 : 1;
          }
          return L.length - R.length;
        }
        function dirname(p2) {
          if (p2.charAt(p2.length - 1) == "/")
            return p2.slice(0, -1).indexOf("/") === -1 ? p2 : dirname(p2.slice(0, -1));
          var c2 = p2.lastIndexOf("/");
          return c2 === -1 ? p2 : p2.slice(0, c2 + 1);
        }
        function filename(p2) {
          if (p2.charAt(p2.length - 1) == "/")
            return filename(p2.slice(0, -1));
          var c2 = p2.lastIndexOf("/");
          return c2 === -1 ? p2 : p2.slice(c2 + 1);
        }
        function write_dos_date(buf, date2) {
          if (typeof date2 === "string")
            date2 = new Date(date2);
          var hms = date2.getHours();
          hms = hms << 6 | date2.getMinutes();
          hms = hms << 5 | date2.getSeconds() >>> 1;
          buf.write_shift(2, hms);
          var ymd = date2.getFullYear() - 1980;
          ymd = ymd << 4 | date2.getMonth() + 1;
          ymd = ymd << 5 | date2.getDate();
          buf.write_shift(2, ymd);
        }
        function parse_dos_date(buf) {
          var hms = buf.read_shift(2) & 65535;
          var ymd = buf.read_shift(2) & 65535;
          var val = /* @__PURE__ */ new Date();
          var d = ymd & 31;
          ymd >>>= 5;
          var m = ymd & 15;
          ymd >>>= 4;
          val.setMilliseconds(0);
          val.setFullYear(ymd + 1980);
          val.setMonth(m - 1);
          val.setDate(d);
          var S = hms & 31;
          hms >>>= 5;
          var M = hms & 63;
          hms >>>= 6;
          val.setHours(hms);
          val.setMinutes(M);
          val.setSeconds(S << 1);
          return val;
        }
        function parse_extra_field(blob) {
          prep_blob(blob, 0);
          var o = (
            /*::(*/
            {}
          );
          var flags = 0;
          while (blob.l <= blob.length - 4) {
            var type2 = blob.read_shift(2);
            var sz = blob.read_shift(2), tgt = blob.l + sz;
            var p2 = {};
            switch (type2) {
              case 21589:
                {
                  flags = blob.read_shift(1);
                  if (flags & 1)
                    p2.mtime = blob.read_shift(4);
                  if (sz > 5) {
                    if (flags & 2)
                      p2.atime = blob.read_shift(4);
                    if (flags & 4)
                      p2.ctime = blob.read_shift(4);
                  }
                  if (p2.mtime)
                    p2.mt = new Date(p2.mtime * 1e3);
                }
                break;
            }
            blob.l = tgt;
            o[type2] = p2;
          }
          return o;
        }
        var fs;
        function get_fs() {
          return fs || (fs = {});
        }
        function parse2(file, options) {
          if (file[0] == 80 && file[1] == 75)
            return parse_zip2(file, options);
          if ((file[0] | 32) == 109 && (file[1] | 32) == 105)
            return parse_mad(file, options);
          if (file.length < 512)
            throw new Error("CFB file size " + file.length + " < 512");
          var mver = 3;
          var ssz = 512;
          var nmfs = 0;
          var difat_sec_cnt = 0;
          var dir_start = 0;
          var minifat_start = 0;
          var difat_start = 0;
          var fat_addrs = [];
          var blob = (
            /*::(*/
            file.slice(0, 512)
          );
          prep_blob(blob, 0);
          var mv = check_get_mver(blob);
          mver = mv[0];
          switch (mver) {
            case 3:
              ssz = 512;
              break;
            case 4:
              ssz = 4096;
              break;
            case 0:
              if (mv[1] == 0)
                return parse_zip2(file, options);
            default:
              throw new Error("Major Version: Expected 3 or 4 saw " + mver);
          }
          if (ssz !== 512) {
            blob = /*::(*/
            file.slice(0, ssz);
            prep_blob(
              blob,
              28
              /* blob.l */
            );
          }
          var header = file.slice(0, ssz);
          check_shifts(blob, mver);
          var dir_cnt = blob.read_shift(4, "i");
          if (mver === 3 && dir_cnt !== 0)
            throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
          blob.l += 4;
          dir_start = blob.read_shift(4, "i");
          blob.l += 4;
          blob.chk("00100000", "Mini Stream Cutoff Size: ");
          minifat_start = blob.read_shift(4, "i");
          nmfs = blob.read_shift(4, "i");
          difat_start = blob.read_shift(4, "i");
          difat_sec_cnt = blob.read_shift(4, "i");
          for (var q2 = -1, j = 0; j < 109; ++j) {
            q2 = blob.read_shift(4, "i");
            if (q2 < 0)
              break;
            fat_addrs[j] = q2;
          }
          var sectors = sectorify(file, ssz);
          sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
          var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
          sector_list[dir_start].name = "!Directory";
          if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
            sector_list[minifat_start].name = "!MiniFAT";
          sector_list[fat_addrs[0]].name = "!FAT";
          sector_list.fat_addrs = fat_addrs;
          sector_list.ssz = ssz;
          var files = {}, Paths = [], FileIndex = [], FullPaths = [];
          read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
          build_full_paths(FileIndex, FullPaths, Paths);
          Paths.shift();
          var o = {
            FileIndex,
            FullPaths
          };
          if (options && options.raw)
            o.raw = { header, sectors };
          return o;
        }
        function check_get_mver(blob) {
          if (blob[blob.l] == 80 && blob[blob.l + 1] == 75)
            return [0, 0];
          blob.chk(HEADER_SIGNATURE, "Header Signature: ");
          blob.l += 16;
          var mver = blob.read_shift(2, "u");
          return [blob.read_shift(2, "u"), mver];
        }
        function check_shifts(blob, mver) {
          var shift = 9;
          blob.l += 2;
          switch (shift = blob.read_shift(2)) {
            case 9:
              if (mver != 3)
                throw new Error("Sector Shift: Expected 9 saw " + shift);
              break;
            case 12:
              if (mver != 4)
                throw new Error("Sector Shift: Expected 12 saw " + shift);
              break;
            default:
              throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
          }
          blob.chk("0600", "Mini Sector Shift: ");
          blob.chk("000000000000", "Reserved: ");
        }
        function sectorify(file, ssz) {
          var nsectors = Math.ceil(file.length / ssz) - 1;
          var sectors = [];
          for (var i2 = 1; i2 < nsectors; ++i2)
            sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
          sectors[nsectors - 1] = file.slice(nsectors * ssz);
          return sectors;
        }
        function build_full_paths(FI, FP, Paths) {
          var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
          var dad = [], q2 = [];
          for (; i2 < pl; ++i2) {
            dad[i2] = q2[i2] = i2;
            FP[i2] = Paths[i2];
          }
          for (; j < q2.length; ++j) {
            i2 = q2[j];
            L = FI[i2].L;
            R = FI[i2].R;
            C = FI[i2].C;
            if (dad[i2] === i2) {
              if (L !== -1 && dad[L] !== L)
                dad[i2] = dad[L];
              if (R !== -1 && dad[R] !== R)
                dad[i2] = dad[R];
            }
            if (C !== -1)
              dad[C] = i2;
            if (L !== -1 && i2 != dad[i2]) {
              dad[L] = dad[i2];
              if (q2.lastIndexOf(L) < j)
                q2.push(L);
            }
            if (R !== -1 && i2 != dad[i2]) {
              dad[R] = dad[i2];
              if (q2.lastIndexOf(R) < j)
                q2.push(R);
            }
          }
          for (i2 = 1; i2 < pl; ++i2)
            if (dad[i2] === i2) {
              if (R !== -1 && dad[R] !== R)
                dad[i2] = dad[R];
              else if (L !== -1 && dad[L] !== L)
                dad[i2] = dad[L];
            }
          for (i2 = 1; i2 < pl; ++i2) {
            if (FI[i2].type === 0)
              continue;
            j = i2;
            if (j != dad[j])
              do {
                j = dad[j];
                FP[i2] = FP[j] + "/" + FP[i2];
              } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
            dad[i2] = -1;
          }
          FP[0] += "/";
          for (i2 = 1; i2 < pl; ++i2) {
            if (FI[i2].type !== 2)
              FP[i2] += "/";
          }
        }
        function get_mfat_entry(entry, payload, mini) {
          var start = entry.start, size2 = entry.size;
          var o = [];
          var idx = start;
          while (mini && size2 > 0 && idx >= 0) {
            o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
            size2 -= MSSZ;
            idx = __readInt32LE(mini, idx * 4);
          }
          if (o.length === 0)
            return new_buf(0);
          return bconcat(o).slice(0, entry.size);
        }
        function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
          var q2 = ENDOFCHAIN;
          if (idx === ENDOFCHAIN) {
            if (cnt !== 0)
              throw new Error("DIFAT chain shorter than expected");
          } else if (idx !== -1) {
            var sector = sectors[idx], m = (ssz >>> 2) - 1;
            if (!sector)
              return;
            for (var i2 = 0; i2 < m; ++i2) {
              if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN)
                break;
              fat_addrs.push(q2);
            }
            sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
          }
        }
        function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
          var buf = [], buf_chain = [];
          if (!chkd)
            chkd = [];
          var modulus = ssz - 1, j = 0, jj = 0;
          for (j = start; j >= 0; ) {
            chkd[j] = true;
            buf[buf.length] = j;
            buf_chain.push(sectors[j]);
            var addr = fat_addrs[Math.floor(j * 4 / ssz)];
            jj = j * 4 & modulus;
            if (ssz < 4 + jj)
              throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
            if (!sectors[addr])
              break;
            j = __readInt32LE(sectors[addr], jj);
          }
          return { nodes: buf, data: __toBuffer([buf_chain]) };
        }
        function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
          var sl = sectors.length, sector_list = [];
          var chkd = [], buf = [], buf_chain = [];
          var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
          for (i2 = 0; i2 < sl; ++i2) {
            buf = [];
            k = i2 + dir_start;
            if (k >= sl)
              k -= sl;
            if (chkd[k])
              continue;
            buf_chain = [];
            var seen = [];
            for (j = k; j >= 0; ) {
              seen[j] = true;
              chkd[j] = true;
              buf[buf.length] = j;
              buf_chain.push(sectors[j]);
              var addr = fat_addrs[Math.floor(j * 4 / ssz)];
              jj = j * 4 & modulus;
              if (ssz < 4 + jj)
                throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
              if (!sectors[addr])
                break;
              j = __readInt32LE(sectors[addr], jj);
              if (seen[j])
                break;
            }
            sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
          }
          return sector_list;
        }
        function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
          var minifat_store = 0, pl = Paths.length ? 2 : 0;
          var sector = sector_list[dir_start].data;
          var i2 = 0, namelen = 0, name;
          for (; i2 < sector.length; i2 += 128) {
            var blob = (
              /*::(*/
              sector.slice(i2, i2 + 128)
            );
            prep_blob(blob, 64);
            namelen = blob.read_shift(2);
            name = __utf16le(blob, 0, namelen - pl);
            Paths.push(name);
            var o = {
              name,
              type: blob.read_shift(1),
              color: blob.read_shift(1),
              L: blob.read_shift(4, "i"),
              R: blob.read_shift(4, "i"),
              C: blob.read_shift(4, "i"),
              clsid: blob.read_shift(16),
              state: blob.read_shift(4, "i"),
              start: 0,
              size: 0
            };
            var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
            if (ctime !== 0)
              o.ct = read_date(blob, blob.l - 8);
            var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
            if (mtime !== 0)
              o.mt = read_date(blob, blob.l - 8);
            o.start = blob.read_shift(4, "i");
            o.size = blob.read_shift(4, "i");
            if (o.size < 0 && o.start < 0) {
              o.size = o.type = 0;
              o.start = ENDOFCHAIN;
              o.name = "";
            }
            if (o.type === 5) {
              minifat_store = o.start;
              if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
                sector_list[minifat_store].name = "!StreamData";
            } else if (o.size >= 4096) {
              o.storage = "fat";
              if (sector_list[o.start] === void 0)
                sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
              sector_list[o.start].name = o.name;
              o.content = sector_list[o.start].data.slice(0, o.size);
            } else {
              o.storage = "minifat";
              if (o.size < 0)
                o.size = 0;
              else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
                o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
              }
            }
            if (o.content)
              prep_blob(o.content, 0);
            files[name] = o;
            FileIndex.push(o);
          }
        }
        function read_date(blob, offset) {
          return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
        }
        function read_file(filename2, options) {
          get_fs();
          return parse2(fs.readFileSync(filename2), options);
        }
        function read(blob, options) {
          var type2 = options && options.type;
          if (!type2) {
            if (has_buf && Buffer.isBuffer(blob))
              type2 = "buffer";
          }
          switch (type2 || "base64") {
            case "file":
              return read_file(blob, options);
            case "base64":
              return parse2(s2a(Base64_decode(blob)), options);
            case "binary":
              return parse2(s2a(blob), options);
          }
          return parse2(
            /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
            blob,
            options
          );
        }
        function init_cfb(cfb, opts) {
          var o = opts || {}, root2 = o.root || "Root Entry";
          if (!cfb.FullPaths)
            cfb.FullPaths = [];
          if (!cfb.FileIndex)
            cfb.FileIndex = [];
          if (cfb.FullPaths.length !== cfb.FileIndex.length)
            throw new Error("inconsistent CFB structure");
          if (cfb.FullPaths.length === 0) {
            cfb.FullPaths[0] = root2 + "/";
            cfb.FileIndex[0] = { name: root2, type: 5 };
          }
          if (o.CLSID)
            cfb.FileIndex[0].clsid = o.CLSID;
          seed_cfb(cfb);
        }
        function seed_cfb(cfb) {
          var nm = "Sh33tJ5";
          if (CFB.find(cfb, "/" + nm))
            return;
          var p2 = new_buf(4);
          p2[0] = 55;
          p2[1] = p2[3] = 50;
          p2[2] = 54;
          cfb.FileIndex.push({ name: nm, type: 2, content: p2, size: 4, L: 69, R: 69, C: 69 });
          cfb.FullPaths.push(cfb.FullPaths[0] + nm);
          rebuild_cfb(cfb);
        }
        function rebuild_cfb(cfb, f) {
          init_cfb(cfb);
          var gc = false, s = false;
          for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
            var _file = cfb.FileIndex[i2];
            switch (_file.type) {
              case 0:
                if (s)
                  gc = true;
                else {
                  cfb.FileIndex.pop();
                  cfb.FullPaths.pop();
                }
                break;
              case 1:
              case 2:
              case 5:
                s = true;
                if (isNaN(_file.R * _file.L * _file.C))
                  gc = true;
                if (_file.R > -1 && _file.L > -1 && _file.R == _file.L)
                  gc = true;
                break;
              default:
                gc = true;
                break;
            }
          }
          if (!gc && !f)
            return;
          var now2 = new Date(1987, 1, 19), j = 0;
          var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
          var data = [];
          for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
            fullPaths[cfb.FullPaths[i2]] = true;
            if (cfb.FileIndex[i2].type === 0)
              continue;
            data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
          }
          for (i2 = 0; i2 < data.length; ++i2) {
            var dad = dirname(data[i2][0]);
            s = fullPaths[dad];
            if (!s) {
              data.push([dad, {
                name: filename(dad).replace("/", ""),
                type: 1,
                clsid: HEADER_CLSID,
                ct: now2,
                mt: now2,
                content: null
              }]);
              fullPaths[dad] = true;
            }
          }
          data.sort(function(x, y) {
            return namecmp(x[0], y[0]);
          });
          cfb.FullPaths = [];
          cfb.FileIndex = [];
          for (i2 = 0; i2 < data.length; ++i2) {
            cfb.FullPaths[i2] = data[i2][0];
            cfb.FileIndex[i2] = data[i2][1];
          }
          for (i2 = 0; i2 < data.length; ++i2) {
            var elt = cfb.FileIndex[i2];
            var nm = cfb.FullPaths[i2];
            elt.name = filename(nm).replace("/", "");
            elt.L = elt.R = elt.C = -(elt.color = 1);
            elt.size = elt.content ? elt.content.length : 0;
            elt.start = 0;
            elt.clsid = elt.clsid || HEADER_CLSID;
            if (i2 === 0) {
              elt.C = data.length > 1 ? 1 : -1;
              elt.size = 0;
              elt.type = 5;
            } else if (nm.slice(-1) == "/") {
              for (j = i2 + 1; j < data.length; ++j)
                if (dirname(cfb.FullPaths[j]) == nm)
                  break;
              elt.C = j >= data.length ? -1 : j;
              for (j = i2 + 1; j < data.length; ++j)
                if (dirname(cfb.FullPaths[j]) == dirname(nm))
                  break;
              elt.R = j >= data.length ? -1 : j;
              elt.type = 1;
            } else {
              if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm))
                elt.R = i2 + 1;
              elt.type = 2;
            }
          }
        }
        function _write(cfb, options) {
          var _opts = options || {};
          if (_opts.fileType == "mad")
            return write_mad(cfb, _opts);
          rebuild_cfb(cfb);
          switch (_opts.fileType) {
            case "zip":
              return write_zip(cfb, _opts);
          }
          var L = function(cfb2) {
            var mini_size = 0, fat_size = 0;
            for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
              var file2 = cfb2.FileIndex[i3];
              if (!file2.content)
                continue;
              var flen2 = file2.content.length;
              if (flen2 > 0) {
                if (flen2 < 4096)
                  mini_size += flen2 + 63 >> 6;
                else
                  fat_size += flen2 + 511 >> 9;
              }
            }
            var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
            var mini_cnt = mini_size + 7 >> 3;
            var mfat_cnt = mini_size + 127 >> 7;
            var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
            var fat_cnt = fat_base + 127 >> 7;
            var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
            while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt)
              difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
            var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
            cfb2.FileIndex[0].size = mini_size << 6;
            L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
            return L2;
          }(cfb);
          var o = new_buf(L[7] << 9);
          var i2 = 0, T = 0;
          {
            for (i2 = 0; i2 < 8; ++i2)
              o.write_shift(1, HEADER_SIG[i2]);
            for (i2 = 0; i2 < 8; ++i2)
              o.write_shift(2, 0);
            o.write_shift(2, 62);
            o.write_shift(2, 3);
            o.write_shift(2, 65534);
            o.write_shift(2, 9);
            o.write_shift(2, 6);
            for (i2 = 0; i2 < 3; ++i2)
              o.write_shift(2, 0);
            o.write_shift(4, 0);
            o.write_shift(4, L[2]);
            o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
            o.write_shift(4, 0);
            o.write_shift(4, 1 << 12);
            o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
            o.write_shift(4, L[3]);
            o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
            o.write_shift(4, L[1]);
            for (i2 = 0; i2 < 109; ++i2)
              o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
          }
          if (L[1]) {
            for (T = 0; T < L[1]; ++T) {
              for (; i2 < 236 + T * 127; ++i2)
                o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
              o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
            }
          }
          var chainit = function(w) {
            for (T += w; i2 < T - 1; ++i2)
              o.write_shift(-4, i2 + 1);
            if (w) {
              ++i2;
              o.write_shift(-4, ENDOFCHAIN);
            }
          };
          T = i2 = 0;
          for (T += L[1]; i2 < T; ++i2)
            o.write_shift(-4, consts.DIFSECT);
          for (T += L[2]; i2 < T; ++i2)
            o.write_shift(-4, consts.FATSECT);
          chainit(L[3]);
          chainit(L[4]);
          var j = 0, flen = 0;
          var file = cfb.FileIndex[0];
          for (; j < cfb.FileIndex.length; ++j) {
            file = cfb.FileIndex[j];
            if (!file.content)
              continue;
            flen = file.content.length;
            if (flen < 4096)
              continue;
            file.start = T;
            chainit(flen + 511 >> 9);
          }
          chainit(L[6] + 7 >> 3);
          while (o.l & 511)
            o.write_shift(-4, consts.ENDOFCHAIN);
          T = i2 = 0;
          for (j = 0; j < cfb.FileIndex.length; ++j) {
            file = cfb.FileIndex[j];
            if (!file.content)
              continue;
            flen = file.content.length;
            if (!flen || flen >= 4096)
              continue;
            file.start = T;
            chainit(flen + 63 >> 6);
          }
          while (o.l & 511)
            o.write_shift(-4, consts.ENDOFCHAIN);
          for (i2 = 0; i2 < L[4] << 2; ++i2) {
            var nm = cfb.FullPaths[i2];
            if (!nm || nm.length === 0) {
              for (j = 0; j < 17; ++j)
                o.write_shift(4, 0);
              for (j = 0; j < 3; ++j)
                o.write_shift(4, -1);
              for (j = 0; j < 12; ++j)
                o.write_shift(4, 0);
              continue;
            }
            file = cfb.FileIndex[i2];
            if (i2 === 0)
              file.start = file.size ? file.start - 1 : ENDOFCHAIN;
            var _nm = i2 === 0 && _opts.root || file.name;
            flen = 2 * (_nm.length + 1);
            o.write_shift(64, _nm, "utf16le");
            o.write_shift(2, flen);
            o.write_shift(1, file.type);
            o.write_shift(1, file.color);
            o.write_shift(-4, file.L);
            o.write_shift(-4, file.R);
            o.write_shift(-4, file.C);
            if (!file.clsid)
              for (j = 0; j < 4; ++j)
                o.write_shift(4, 0);
            else
              o.write_shift(16, file.clsid, "hex");
            o.write_shift(4, file.state || 0);
            o.write_shift(4, 0);
            o.write_shift(4, 0);
            o.write_shift(4, 0);
            o.write_shift(4, 0);
            o.write_shift(4, file.start);
            o.write_shift(4, file.size);
            o.write_shift(4, 0);
          }
          for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
            file = cfb.FileIndex[i2];
            if (file.size >= 4096) {
              o.l = file.start + 1 << 9;
              if (has_buf && Buffer.isBuffer(file.content)) {
                file.content.copy(o, o.l, 0, file.size);
                o.l += file.size + 511 & -512;
              } else {
                for (j = 0; j < file.size; ++j)
                  o.write_shift(1, file.content[j]);
                for (; j & 511; ++j)
                  o.write_shift(1, 0);
              }
            }
          }
          for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
            file = cfb.FileIndex[i2];
            if (file.size > 0 && file.size < 4096) {
              if (has_buf && Buffer.isBuffer(file.content)) {
                file.content.copy(o, o.l, 0, file.size);
                o.l += file.size + 63 & -64;
              } else {
                for (j = 0; j < file.size; ++j)
                  o.write_shift(1, file.content[j]);
                for (; j & 63; ++j)
                  o.write_shift(1, 0);
              }
            }
          }
          if (has_buf) {
            o.l = o.length;
          } else {
            while (o.l < o.length)
              o.write_shift(1, 0);
          }
          return o;
        }
        function find2(cfb, path) {
          var UCFullPaths = cfb.FullPaths.map(function(x) {
            return x.toUpperCase();
          });
          var UCPaths = UCFullPaths.map(function(x) {
            var y = x.split("/");
            return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
          });
          var k = false;
          if (path.charCodeAt(0) === 47) {
            k = true;
            path = UCFullPaths[0].slice(0, -1) + path;
          } else
            k = path.indexOf("/") !== -1;
          var UCPath = path.toUpperCase();
          var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
          if (w !== -1)
            return cfb.FileIndex[w];
          var m = !UCPath.match(chr1);
          UCPath = UCPath.replace(chr0, "");
          if (m)
            UCPath = UCPath.replace(chr1, "!");
          for (w = 0; w < UCFullPaths.length; ++w) {
            if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath)
              return cfb.FileIndex[w];
            if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath)
              return cfb.FileIndex[w];
          }
          return null;
        }
        var MSSZ = 64;
        var ENDOFCHAIN = -2;
        var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
        var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
        var HEADER_CLSID = "00000000000000000000000000000000";
        var consts = {
          /* 2.1 Compund File Sector Numbers and Types */
          MAXREGSECT: -6,
          DIFSECT: -4,
          FATSECT: -3,
          ENDOFCHAIN,
          FREESECT: -1,
          /* 2.2 Compound File Header */
          HEADER_SIGNATURE,
          HEADER_MINOR_VERSION: "3e00",
          MAXREGSID: -6,
          NOSTREAM: -1,
          HEADER_CLSID,
          /* 2.6.1 Compound File Directory Entry */
          EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
        };
        function write_file(cfb, filename2, options) {
          get_fs();
          var o = _write(cfb, options);
          fs.writeFileSync(filename2, o);
        }
        function a2s2(o) {
          var out = new Array(o.length);
          for (var i2 = 0; i2 < o.length; ++i2)
            out[i2] = String.fromCharCode(o[i2]);
          return out.join("");
        }
        function write(cfb, options) {
          var o = _write(cfb, options);
          switch (options && options.type || "buffer") {
            case "file":
              get_fs();
              fs.writeFileSync(options.filename, o);
              return o;
            case "binary":
              return typeof o == "string" ? o : a2s2(o);
            case "base64":
              return Base64_encode(typeof o == "string" ? o : a2s2(o));
            case "buffer":
              if (has_buf)
                return Buffer.isBuffer(o) ? o : Buffer_from(o);
            case "array":
              return typeof o == "string" ? s2a(o) : o;
          }
          return o;
        }
        var _zlib;
        function use_zlib(zlib) {
          try {
            var InflateRaw = zlib.InflateRaw;
            var InflRaw = new InflateRaw();
            InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
            if (InflRaw.bytesRead)
              _zlib = zlib;
            else
              throw new Error("zlib does not expose bytesRead");
          } catch (e) {
            console.error("cannot use native zlib: " + (e.message || e));
          }
        }
        function _inflateRawSync(payload, usz) {
          if (!_zlib)
            return _inflate(payload, usz);
          var InflateRaw = _zlib.InflateRaw;
          var InflRaw = new InflateRaw();
          var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
          payload.l += InflRaw.bytesRead;
          return out;
        }
        function _deflateRawSync(payload) {
          return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
        }
        var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
        var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
        function bit_swap_8(n) {
          var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
          return (t >> 16 | t >> 8 | t) & 255;
        }
        var use_typed_arrays = typeof Uint8Array !== "undefined";
        var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
        for (var q = 0; q < 1 << 8; ++q)
          bitswap8[q] = bit_swap_8(q);
        function bit_swap_n(n, b) {
          var rev = bitswap8[n & 255];
          if (b <= 8)
            return rev >>> 8 - b;
          rev = rev << 8 | bitswap8[n >> 8 & 255];
          if (b <= 16)
            return rev >>> 16 - b;
          rev = rev << 8 | bitswap8[n >> 16 & 255];
          return rev >>> 24 - b;
        }
        function read_bits_2(buf, bl) {
          var w = bl & 7, h2 = bl >>> 3;
          return (buf[h2] | (w <= 6 ? 0 : buf[h2 + 1] << 8)) >>> w & 3;
        }
        function read_bits_3(buf, bl) {
          var w = bl & 7, h2 = bl >>> 3;
          return (buf[h2] | (w <= 5 ? 0 : buf[h2 + 1] << 8)) >>> w & 7;
        }
        function read_bits_4(buf, bl) {
          var w = bl & 7, h2 = bl >>> 3;
          return (buf[h2] | (w <= 4 ? 0 : buf[h2 + 1] << 8)) >>> w & 15;
        }
        function read_bits_5(buf, bl) {
          var w = bl & 7, h2 = bl >>> 3;
          return (buf[h2] | (w <= 3 ? 0 : buf[h2 + 1] << 8)) >>> w & 31;
        }
        function read_bits_7(buf, bl) {
          var w = bl & 7, h2 = bl >>> 3;
          return (buf[h2] | (w <= 1 ? 0 : buf[h2 + 1] << 8)) >>> w & 127;
        }
        function read_bits_n(buf, bl, n) {
          var w = bl & 7, h2 = bl >>> 3, f = (1 << n) - 1;
          var v = buf[h2] >>> w;
          if (n < 8 - w)
            return v & f;
          v |= buf[h2 + 1] << 8 - w;
          if (n < 16 - w)
            return v & f;
          v |= buf[h2 + 2] << 16 - w;
          if (n < 24 - w)
            return v & f;
          v |= buf[h2 + 3] << 24 - w;
          return v & f;
        }
        function write_bits_3(buf, bl, v) {
          var w = bl & 7, h2 = bl >>> 3;
          if (w <= 5)
            buf[h2] |= (v & 7) << w;
          else {
            buf[h2] |= v << w & 255;
            buf[h2 + 1] = (v & 7) >> 8 - w;
          }
          return bl + 3;
        }
        function write_bits_1(buf, bl, v) {
          var w = bl & 7, h2 = bl >>> 3;
          v = (v & 1) << w;
          buf[h2] |= v;
          return bl + 1;
        }
        function write_bits_8(buf, bl, v) {
          var w = bl & 7, h2 = bl >>> 3;
          v <<= w;
          buf[h2] |= v & 255;
          v >>>= 8;
          buf[h2 + 1] = v;
          return bl + 8;
        }
        function write_bits_16(buf, bl, v) {
          var w = bl & 7, h2 = bl >>> 3;
          v <<= w;
          buf[h2] |= v & 255;
          v >>>= 8;
          buf[h2 + 1] = v & 255;
          buf[h2 + 2] = v >>> 8;
          return bl + 16;
        }
        function realloc(b, sz) {
          var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
          if (L >= sz)
            return b;
          if (has_buf) {
            var o = new_unsafe_buf(M);
            if (b.copy)
              b.copy(o);
            else
              for (; i2 < b.length; ++i2)
                o[i2] = b[i2];
            return o;
          } else if (use_typed_arrays) {
            var a2 = new Uint8Array(M);
            if (a2.set)
              a2.set(b);
            else
              for (; i2 < L; ++i2)
                a2[i2] = b[i2];
            return a2;
          }
          b.length = M;
          return b;
        }
        function zero_fill_array(n) {
          var o = new Array(n);
          for (var i2 = 0; i2 < n; ++i2)
            o[i2] = 0;
          return o;
        }
        function build_tree(clens, cmap, MAX) {
          var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
          var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
          for (i2 = 0; i2 < 32; ++i2)
            bl_count[i2] = 0;
          for (i2 = L; i2 < MAX; ++i2)
            clens[i2] = 0;
          L = clens.length;
          var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
          for (i2 = 0; i2 < L; ++i2) {
            bl_count[w = clens[i2]]++;
            if (maxlen < w)
              maxlen = w;
            ctree[i2] = 0;
          }
          bl_count[0] = 0;
          for (i2 = 1; i2 <= maxlen; ++i2)
            bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
          for (i2 = 0; i2 < L; ++i2) {
            ccode = clens[i2];
            if (ccode != 0)
              ctree[i2] = bl_count[ccode + 16]++;
          }
          var cleni = 0;
          for (i2 = 0; i2 < L; ++i2) {
            cleni = clens[i2];
            if (cleni != 0) {
              ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
              for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
                cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
            }
          }
          return maxlen;
        }
        var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
        var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
        if (!use_typed_arrays) {
          for (var i = 0; i < 512; ++i)
            fix_lmap[i] = 0;
          for (i = 0; i < 32; ++i)
            fix_dmap[i] = 0;
        }
        (function() {
          var dlens = [];
          var i2 = 0;
          for (; i2 < 32; i2++)
            dlens.push(5);
          build_tree(dlens, fix_dmap, 32);
          var clens = [];
          i2 = 0;
          for (; i2 <= 143; i2++)
            clens.push(8);
          for (; i2 <= 255; i2++)
            clens.push(9);
          for (; i2 <= 279; i2++)
            clens.push(7);
          for (; i2 <= 287; i2++)
            clens.push(8);
          build_tree(clens, fix_lmap, 288);
        })();
        var _deflateRaw = /* @__PURE__ */ function _deflateRawIIFE() {
          var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
          var j = 0, k = 0;
          for (; j < DST_LN.length - 1; ++j) {
            for (; k < DST_LN[j + 1]; ++k)
              DST_LN_RE[k] = j;
          }
          for (; k < 32768; ++k)
            DST_LN_RE[k] = 29;
          var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
          for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
            for (; k < LEN_LN[j + 1]; ++k)
              LEN_LN_RE[k] = j;
          }
          function write_stored(data, out) {
            var boff = 0;
            while (boff < data.length) {
              var L = Math.min(65535, data.length - boff);
              var h2 = boff + L == data.length;
              out.write_shift(1, +h2);
              out.write_shift(2, L);
              out.write_shift(2, ~L & 65535);
              while (L-- > 0)
                out[out.l++] = data[boff++];
            }
            return out.l;
          }
          function write_huff_fixed(data, out) {
            var bl = 0;
            var boff = 0;
            var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
            while (boff < data.length) {
              var L = (
                /* data.length - boff; */
                Math.min(65535, data.length - boff)
              );
              if (L < 10) {
                bl = write_bits_3(out, bl, +!!(boff + L == data.length));
                if (bl & 7)
                  bl += 8 - (bl & 7);
                out.l = bl / 8 | 0;
                out.write_shift(2, L);
                out.write_shift(2, ~L & 65535);
                while (L-- > 0)
                  out[out.l++] = data[boff++];
                bl = out.l * 8;
                continue;
              }
              bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
              var hash = 0;
              while (L-- > 0) {
                var d = data[boff];
                hash = (hash << 5 ^ d) & 32767;
                var match2 = -1, mlen = 0;
                if (match2 = addrs[hash]) {
                  match2 |= boff & ~32767;
                  if (match2 > boff)
                    match2 -= 32768;
                  if (match2 < boff)
                    while (data[match2 + mlen] == data[boff + mlen] && mlen < 250)
                      ++mlen;
                }
                if (mlen > 2) {
                  d = LEN_LN_RE[mlen];
                  if (d <= 22)
                    bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
                  else {
                    write_bits_8(out, bl, 3);
                    bl += 5;
                    write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                    bl += 3;
                  }
                  var len_eb = d < 8 ? 0 : d - 4 >> 2;
                  if (len_eb > 0) {
                    write_bits_16(out, bl, mlen - LEN_LN[d]);
                    bl += len_eb;
                  }
                  d = DST_LN_RE[boff - match2];
                  bl = write_bits_8(out, bl, bitswap8[d] >> 3);
                  bl -= 3;
                  var dst_eb = d < 4 ? 0 : d - 2 >> 1;
                  if (dst_eb > 0) {
                    write_bits_16(out, bl, boff - match2 - DST_LN[d]);
                    bl += dst_eb;
                  }
                  for (var q2 = 0; q2 < mlen; ++q2) {
                    addrs[hash] = boff & 32767;
                    hash = (hash << 5 ^ data[boff]) & 32767;
                    ++boff;
                  }
                  L -= mlen - 1;
                } else {
                  if (d <= 143)
                    d = d + 48;
                  else
                    bl = write_bits_1(out, bl, 1);
                  bl = write_bits_8(out, bl, bitswap8[d]);
                  addrs[hash] = boff & 32767;
                  ++boff;
                }
              }
              bl = write_bits_8(out, bl, 0) - 1;
            }
            out.l = (bl + 7) / 8 | 0;
            return out.l;
          }
          return function _deflateRaw2(data, out) {
            if (data.length < 8)
              return write_stored(data, out);
            return write_huff_fixed(data, out);
          };
        }();
        function _deflate(data) {
          var buf = new_buf(50 + Math.floor(data.length * 1.1));
          var off2 = _deflateRaw(data, buf);
          return buf.slice(0, off2);
        }
        var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
        var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
        var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
        var dyn_len_1 = 1, dyn_len_2 = 1;
        function dyn(data, boff) {
          var _HLIT = read_bits_5(data, boff) + 257;
          boff += 5;
          var _HDIST = read_bits_5(data, boff) + 1;
          boff += 5;
          var _HCLEN = read_bits_4(data, boff) + 4;
          boff += 4;
          var w = 0;
          var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
          var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          var maxlen = 1;
          var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
          var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
          var L = clens.length;
          for (var i2 = 0; i2 < _HCLEN; ++i2) {
            clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
            if (maxlen < w)
              maxlen = w;
            bl_count[w]++;
            boff += 3;
          }
          var ccode = 0;
          bl_count[0] = 0;
          for (i2 = 1; i2 <= maxlen; ++i2)
            next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
          for (i2 = 0; i2 < L; ++i2)
            if ((ccode = clens[i2]) != 0)
              ctree[i2] = next_code[ccode]++;
          var cleni = 0;
          for (i2 = 0; i2 < L; ++i2) {
            cleni = clens[i2];
            if (cleni != 0) {
              ccode = bitswap8[ctree[i2]] >> 8 - cleni;
              for (var j = (1 << 7 - cleni) - 1; j >= 0; --j)
                dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
            }
          }
          var hcodes = [];
          maxlen = 1;
          for (; hcodes.length < _HLIT + _HDIST; ) {
            ccode = dyn_cmap[read_bits_7(data, boff)];
            boff += ccode & 7;
            switch (ccode >>>= 3) {
              case 16:
                w = 3 + read_bits_2(data, boff);
                boff += 2;
                ccode = hcodes[hcodes.length - 1];
                while (w-- > 0)
                  hcodes.push(ccode);
                break;
              case 17:
                w = 3 + read_bits_3(data, boff);
                boff += 3;
                while (w-- > 0)
                  hcodes.push(0);
                break;
              case 18:
                w = 11 + read_bits_7(data, boff);
                boff += 7;
                while (w-- > 0)
                  hcodes.push(0);
                break;
              default:
                hcodes.push(ccode);
                if (maxlen < ccode)
                  maxlen = ccode;
                break;
            }
          }
          var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
          for (i2 = _HLIT; i2 < 286; ++i2)
            h1[i2] = 0;
          for (i2 = _HDIST; i2 < 30; ++i2)
            h2[i2] = 0;
          dyn_len_1 = build_tree(h1, dyn_lmap, 286);
          dyn_len_2 = build_tree(h2, dyn_dmap, 30);
          return boff;
        }
        function inflate(data, usz) {
          if (data[0] == 3 && !(data[1] & 3)) {
            return [new_raw_buf(usz), 2];
          }
          var boff = 0;
          var header = 0;
          var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
          var woff = 0;
          var OL = outbuf.length >>> 0;
          var max_len_1 = 0, max_len_2 = 0;
          while ((header & 1) == 0) {
            header = read_bits_3(data, boff);
            boff += 3;
            if (header >>> 1 == 0) {
              if (boff & 7)
                boff += 8 - (boff & 7);
              var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
              boff += 32;
              if (sz > 0) {
                if (!usz && OL < woff + sz) {
                  outbuf = realloc(outbuf, woff + sz);
                  OL = outbuf.length;
                }
                while (sz-- > 0) {
                  outbuf[woff++] = data[boff >>> 3];
                  boff += 8;
                }
              }
              continue;
            } else if (header >> 1 == 1) {
              max_len_1 = 9;
              max_len_2 = 5;
            } else {
              boff = dyn(data, boff);
              max_len_1 = dyn_len_1;
              max_len_2 = dyn_len_2;
            }
            for (; ; ) {
              if (!usz && OL < woff + 32767) {
                outbuf = realloc(outbuf, woff + 32767);
                OL = outbuf.length;
              }
              var bits = read_bits_n(data, boff, max_len_1);
              var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
              boff += code & 15;
              code >>>= 4;
              if ((code >>> 8 & 255) === 0)
                outbuf[woff++] = code;
              else if (code == 256)
                break;
              else {
                code -= 257;
                var len_eb = code < 8 ? 0 : code - 4 >> 2;
                if (len_eb > 5)
                  len_eb = 0;
                var tgt = woff + LEN_LN[code];
                if (len_eb > 0) {
                  tgt += read_bits_n(data, boff, len_eb);
                  boff += len_eb;
                }
                bits = read_bits_n(data, boff, max_len_2);
                code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
                boff += code & 15;
                code >>>= 4;
                var dst_eb = code < 4 ? 0 : code - 2 >> 1;
                var dst = DST_LN[code];
                if (dst_eb > 0) {
                  dst += read_bits_n(data, boff, dst_eb);
                  boff += dst_eb;
                }
                if (!usz && OL < tgt) {
                  outbuf = realloc(outbuf, tgt + 100);
                  OL = outbuf.length;
                }
                while (woff < tgt) {
                  outbuf[woff] = outbuf[woff - dst];
                  ++woff;
                }
              }
            }
          }
          if (usz)
            return [outbuf, boff + 7 >>> 3];
          return [outbuf.slice(0, woff), boff + 7 >>> 3];
        }
        function _inflate(payload, usz) {
          var data = payload.slice(payload.l || 0);
          var out = inflate(data, usz);
          payload.l += out[1];
          return out[0];
        }
        function warn_or_throw(wrn, msg2) {
          if (wrn) {
            if (typeof console !== "undefined")
              console.error(msg2);
          } else
            throw new Error(msg2);
        }
        function parse_zip2(file, options) {
          var blob = (
            /*::(*/
            file
          );
          prep_blob(blob, 0);
          var FileIndex = [], FullPaths = [];
          var o = {
            FileIndex,
            FullPaths
          };
          init_cfb(o, { root: options.root });
          var i2 = blob.length - 4;
          while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0)
            --i2;
          blob.l = i2 + 4;
          blob.l += 4;
          var fcnt = blob.read_shift(2);
          blob.l += 6;
          var start_cd = blob.read_shift(4);
          blob.l = start_cd;
          for (i2 = 0; i2 < fcnt; ++i2) {
            blob.l += 20;
            var csz = blob.read_shift(4);
            var usz = blob.read_shift(4);
            var namelen = blob.read_shift(2);
            var efsz = blob.read_shift(2);
            var fcsz = blob.read_shift(2);
            blob.l += 8;
            var offset = blob.read_shift(4);
            var EF = parse_extra_field(
              /*::(*/
              blob.slice(blob.l + namelen, blob.l + namelen + efsz)
              /*:: :any)*/
            );
            blob.l += namelen + efsz + fcsz;
            var L = blob.l;
            blob.l = offset + 4;
            parse_local_file(blob, csz, usz, o, EF);
            blob.l = L;
          }
          return o;
        }
        function parse_local_file(blob, csz, usz, o, EF) {
          blob.l += 2;
          var flags = blob.read_shift(2);
          var meth = blob.read_shift(2);
          var date2 = parse_dos_date(blob);
          if (flags & 8257)
            throw new Error("Unsupported ZIP encryption");
          var crc32 = blob.read_shift(4);
          var _csz = blob.read_shift(4);
          var _usz = blob.read_shift(4);
          var namelen = blob.read_shift(2);
          var efsz = blob.read_shift(2);
          var name = "";
          for (var i2 = 0; i2 < namelen; ++i2)
            name += String.fromCharCode(blob[blob.l++]);
          if (efsz) {
            var ef = parse_extra_field(
              /*::(*/
              blob.slice(blob.l, blob.l + efsz)
              /*:: :any)*/
            );
            if ((ef[21589] || {}).mt)
              date2 = ef[21589].mt;
            if (((EF || {})[21589] || {}).mt)
              date2 = EF[21589].mt;
          }
          blob.l += efsz;
          var data = blob.slice(blob.l, blob.l + _csz);
          switch (meth) {
            case 8:
              data = _inflateRawSync(blob, _usz);
              break;
            case 0:
              break;
            default:
              throw new Error("Unsupported ZIP Compression method " + meth);
          }
          var wrn = false;
          if (flags & 8) {
            crc32 = blob.read_shift(4);
            if (crc32 == 134695760) {
              crc32 = blob.read_shift(4);
              wrn = true;
            }
            _csz = blob.read_shift(4);
            _usz = blob.read_shift(4);
          }
          if (_csz != csz)
            warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
          if (_usz != usz)
            warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
          cfb_add(o, name, data, { unsafe: true, mt: date2 });
        }
        function write_zip(cfb, options) {
          var _opts = options || {};
          var out = [], cdirs = [];
          var o = new_buf(1);
          var method2 = _opts.compression ? 8 : 0, flags = 0;
          var i2 = 0, j = 0;
          var start_cd = 0, fcnt = 0;
          var root2 = cfb.FullPaths[0], fp = root2, fi = cfb.FileIndex[0];
          var crcs = [];
          var sz_cd = 0;
          for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
            fp = cfb.FullPaths[i2].slice(root2.length);
            fi = cfb.FileIndex[i2];
            if (!fi.size || !fi.content || fp == "Sh33tJ5")
              continue;
            var start = start_cd;
            var namebuf = new_buf(fp.length);
            for (j = 0; j < fp.length; ++j)
              namebuf.write_shift(1, fp.charCodeAt(j) & 127);
            namebuf = namebuf.slice(0, namebuf.l);
            crcs[fcnt] = CRC32.buf(
              /*::((*/
              fi.content,
              0
            );
            var outbuf = fi.content;
            if (method2 == 8)
              outbuf = _deflateRawSync(outbuf);
            o = new_buf(30);
            o.write_shift(4, 67324752);
            o.write_shift(2, 20);
            o.write_shift(2, flags);
            o.write_shift(2, method2);
            if (fi.mt)
              write_dos_date(o, fi.mt);
            else
              o.write_shift(4, 0);
            o.write_shift(-4, crcs[fcnt]);
            o.write_shift(4, outbuf.length);
            o.write_shift(
              4,
              /*::(*/
              fi.content.length
            );
            o.write_shift(2, namebuf.length);
            o.write_shift(2, 0);
            start_cd += o.length;
            out.push(o);
            start_cd += namebuf.length;
            out.push(namebuf);
            start_cd += outbuf.length;
            out.push(outbuf);
            o = new_buf(46);
            o.write_shift(4, 33639248);
            o.write_shift(2, 0);
            o.write_shift(2, 20);
            o.write_shift(2, flags);
            o.write_shift(2, method2);
            o.write_shift(4, 0);
            o.write_shift(-4, crcs[fcnt]);
            o.write_shift(4, outbuf.length);
            o.write_shift(
              4,
              /*::(*/
              fi.content.length
            );
            o.write_shift(2, namebuf.length);
            o.write_shift(2, 0);
            o.write_shift(2, 0);
            o.write_shift(2, 0);
            o.write_shift(2, 0);
            o.write_shift(4, 0);
            o.write_shift(4, start);
            sz_cd += o.l;
            cdirs.push(o);
            sz_cd += namebuf.length;
            cdirs.push(namebuf);
            ++fcnt;
          }
          o = new_buf(22);
          o.write_shift(4, 101010256);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(2, fcnt);
          o.write_shift(2, fcnt);
          o.write_shift(4, sz_cd);
          o.write_shift(4, start_cd);
          o.write_shift(2, 0);
          return bconcat([bconcat(out), bconcat(cdirs), o]);
        }
        var ContentTypeMap = {
          "htm": "text/html",
          "xml": "text/xml",
          "gif": "image/gif",
          "jpg": "image/jpeg",
          "png": "image/png",
          "mso": "application/x-mso",
          "thmx": "application/vnd.ms-officetheme",
          "sh33tj5": "application/octet-stream"
        };
        function get_content_type(fi, fp) {
          if (fi.ctype)
            return fi.ctype;
          var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
          if (m && ContentTypeMap[m[1]])
            return ContentTypeMap[m[1]];
          if (fp) {
            m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
            if (m && ContentTypeMap[m[1]])
              return ContentTypeMap[m[1]];
          }
          return "application/octet-stream";
        }
        function write_base64_76(bstr) {
          var data = Base64_encode(bstr);
          var o = [];
          for (var i2 = 0; i2 < data.length; i2 += 76)
            o.push(data.slice(i2, i2 + 76));
          return o.join("\r\n") + "\r\n";
        }
        function write_quoted_printable(text) {
          var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c2) {
            var w = c2.charCodeAt(0).toString(16).toUpperCase();
            return "=" + (w.length == 1 ? "0" + w : w);
          });
          encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
          if (encoded.charAt(0) == "\n")
            encoded = "=0D" + encoded.slice(1);
          encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
          var o = [], split = encoded.split("\r\n");
          for (var si = 0; si < split.length; ++si) {
            var str = split[si];
            if (str.length == 0) {
              o.push("");
              continue;
            }
            for (var i2 = 0; i2 < str.length; ) {
              var end = 76;
              var tmp = str.slice(i2, i2 + end);
              if (tmp.charAt(end - 1) == "=")
                end--;
              else if (tmp.charAt(end - 2) == "=")
                end -= 2;
              else if (tmp.charAt(end - 3) == "=")
                end -= 3;
              tmp = str.slice(i2, i2 + end);
              i2 += end;
              if (i2 < str.length)
                tmp += "=";
              o.push(tmp);
            }
          }
          return o.join("\r\n");
        }
        function parse_quoted_printable(data) {
          var o = [];
          for (var di = 0; di < data.length; ++di) {
            var line = data[di];
            while (di <= data.length && line.charAt(line.length - 1) == "=")
              line = line.slice(0, line.length - 1) + data[++di];
            o.push(line);
          }
          for (var oi = 0; oi < o.length; ++oi)
            o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
              return String.fromCharCode(parseInt($$.slice(1), 16));
            });
          return s2a(o.join("\r\n"));
        }
        function parse_mime(cfb, data, root2) {
          var fname = "", cte = "", ctype = "", fdata;
          var di = 0;
          for (; di < 10; ++di) {
            var line = data[di];
            if (!line || line.match(/^\s*$/))
              break;
            var m = line.match(/^(.*?):\s*([^\s].*)$/);
            if (m)
              switch (m[1].toLowerCase()) {
                case "content-location":
                  fname = m[2].trim();
                  break;
                case "content-type":
                  ctype = m[2].trim();
                  break;
                case "content-transfer-encoding":
                  cte = m[2].trim();
                  break;
              }
          }
          ++di;
          switch (cte.toLowerCase()) {
            case "base64":
              fdata = s2a(Base64_decode(data.slice(di).join("")));
              break;
            case "quoted-printable":
              fdata = parse_quoted_printable(data.slice(di));
              break;
            default:
              throw new Error("Unsupported Content-Transfer-Encoding " + cte);
          }
          var file = cfb_add(cfb, fname.slice(root2.length), fdata, { unsafe: true });
          if (ctype)
            file.ctype = ctype;
        }
        function parse_mad(file, options) {
          if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:")
            throw new Error("Unsupported MAD header");
          var root2 = options && options.root || "";
          var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
          var di = 0, row = "";
          for (di = 0; di < data.length; ++di) {
            row = data[di];
            if (!/^Content-Location:/i.test(row))
              continue;
            row = row.slice(row.indexOf("file"));
            if (!root2)
              root2 = row.slice(0, row.lastIndexOf("/") + 1);
            if (row.slice(0, root2.length) == root2)
              continue;
            while (root2.length > 0) {
              root2 = root2.slice(0, root2.length - 1);
              root2 = root2.slice(0, root2.lastIndexOf("/") + 1);
              if (row.slice(0, root2.length) == root2)
                break;
            }
          }
          var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
          if (!mboundary)
            throw new Error("MAD cannot find boundary");
          var boundary = "--" + (mboundary[1] || "");
          var FileIndex = [], FullPaths = [];
          var o = {
            FileIndex,
            FullPaths
          };
          init_cfb(o);
          var start_di, fcnt = 0;
          for (di = 0; di < data.length; ++di) {
            var line = data[di];
            if (line !== boundary && line !== boundary + "--")
              continue;
            if (fcnt++)
              parse_mime(o, data.slice(start_di, di), root2);
            start_di = di;
          }
          return o;
        }
        function write_mad(cfb, options) {
          var opts = options || {};
          var boundary = opts.boundary || "SheetJS";
          boundary = "------=" + boundary;
          var out = [
            "MIME-Version: 1.0",
            'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
            "",
            "",
            ""
          ];
          var root2 = cfb.FullPaths[0], fp = root2, fi = cfb.FileIndex[0];
          for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
            fp = cfb.FullPaths[i2].slice(root2.length);
            fi = cfb.FileIndex[i2];
            if (!fi.size || !fi.content || fp == "Sh33tJ5")
              continue;
            fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c2) {
              return "_x" + c2.charCodeAt(0).toString(16) + "_";
            }).replace(/[\u0080-\uFFFF]/g, function(u) {
              return "_u" + u.charCodeAt(0).toString(16) + "_";
            });
            var ca = fi.content;
            var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
            var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
            for (var csl = 0; csl <= L; ++csl)
              if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128)
                ++dispcnt;
            var qp = dispcnt >= L * 4 / 5;
            out.push(boundary);
            out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
            out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
            out.push("Content-Type: " + get_content_type(fi, fp));
            out.push("");
            out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
          }
          out.push(boundary + "--\r\n");
          return out.join("\r\n");
        }
        function cfb_new(opts) {
          var o = {};
          init_cfb(o, opts);
          return o;
        }
        function cfb_add(cfb, name, content, opts) {
          var unsafe = opts && opts.unsafe;
          if (!unsafe)
            init_cfb(cfb);
          var file = !unsafe && CFB.find(cfb, name);
          if (!file) {
            var fpath = cfb.FullPaths[0];
            if (name.slice(0, fpath.length) == fpath)
              fpath = name;
            else {
              if (fpath.slice(-1) != "/")
                fpath += "/";
              fpath = (fpath + name).replace("//", "/");
            }
            file = { name: filename(name), type: 2 };
            cfb.FileIndex.push(file);
            cfb.FullPaths.push(fpath);
            if (!unsafe)
              CFB.utils.cfb_gc(cfb);
          }
          file.content = content;
          file.size = content ? content.length : 0;
          if (opts) {
            if (opts.CLSID)
              file.clsid = opts.CLSID;
            if (opts.mt)
              file.mt = opts.mt;
            if (opts.ct)
              file.ct = opts.ct;
          }
          return file;
        }
        function cfb_del(cfb, name) {
          init_cfb(cfb);
          var file = CFB.find(cfb, name);
          if (file) {
            for (var j = 0; j < cfb.FileIndex.length; ++j)
              if (cfb.FileIndex[j] == file) {
                cfb.FileIndex.splice(j, 1);
                cfb.FullPaths.splice(j, 1);
                return true;
              }
          }
          return false;
        }
        function cfb_mov(cfb, old_name, new_name) {
          init_cfb(cfb);
          var file = CFB.find(cfb, old_name);
          if (file) {
            for (var j = 0; j < cfb.FileIndex.length; ++j)
              if (cfb.FileIndex[j] == file) {
                cfb.FileIndex[j].name = filename(new_name);
                cfb.FullPaths[j] = new_name;
                return true;
              }
          }
          return false;
        }
        function cfb_gc(cfb) {
          rebuild_cfb(cfb, true);
        }
        exports2.find = find2;
        exports2.read = read;
        exports2.parse = parse2;
        exports2.write = write;
        exports2.writeFile = write_file;
        exports2.utils = {
          cfb_new,
          cfb_add,
          cfb_del,
          cfb_mov,
          cfb_gc,
          ReadShift,
          CheckField,
          prep_blob,
          bconcat,
          use_zlib,
          _deflateRaw: _deflate,
          _inflateRaw: _inflate,
          consts
        };
        return exports2;
      }();
      function read_binary(path) {
        if (typeof Deno !== "undefined")
          return Deno.readFileSync(path);
        if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
          try {
            var infile = File(path);
            infile.open("r");
            infile.encoding = "binary";
            var data = infile.read();
            infile.close();
            return data;
          } catch (e) {
            if (!e.message || !e.message.match(/onstruct/))
              throw e;
          }
        throw new Error("Cannot access file " + path);
      }
      function keys(o) {
        var ks = Object.keys(o), o2 = [];
        for (var i = 0; i < ks.length; ++i)
          if (Object.prototype.hasOwnProperty.call(o, ks[i]))
            o2.push(ks[i]);
        return o2;
      }
      function evert(obj) {
        var o = [], K = keys(obj);
        for (var i = 0; i !== K.length; ++i)
          o[obj[K[i]]] = K[i];
        return o;
      }
      var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
      function datenum(v, date1904) {
        var epoch = /* @__PURE__ */ v.getTime();
        if (date1904)
          epoch -= 1462 * 24 * 60 * 60 * 1e3;
        var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
        return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
      }
      var refdate = /* @__PURE__ */ new Date();
      var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
      var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
      function numdate(v) {
        var out = /* @__PURE__ */ new Date();
        out.setTime(v * 24 * 60 * 60 * 1e3 + dnthresh);
        if (out.getTimezoneOffset() !== refoffset) {
          out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
        }
        return out;
      }
      function parse_isodur(s) {
        var sec = 0, mt = 0, time2 = false;
        var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
        if (!m)
          throw new Error("|" + s + "| is not an ISO8601 Duration");
        for (var i = 1; i != m.length; ++i) {
          if (!m[i])
            continue;
          mt = 1;
          if (i > 3)
            time2 = true;
          switch (m[i].slice(m[i].length - 1)) {
            case "Y":
              throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length - 1));
            case "D":
              mt *= 24;
            case "H":
              mt *= 60;
            case "M":
              if (!time2)
                throw new Error("Unsupported ISO Duration Field: M");
              else
                mt *= 60;
          }
          sec += mt * parseInt(m[i], 10);
        }
        return sec;
      }
      var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
      var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
      var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
      function parseDate(str, fixdate) {
        var d = new Date(str);
        if (good_pd) {
          if (fixdate > 0)
            d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1e3);
          else if (fixdate < 0)
            d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
          return d;
        }
        if (str instanceof Date)
          return str;
        if (good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
          var s = d.getFullYear();
          if (str.indexOf("" + s) > -1)
            return d;
          d.setFullYear(d.getFullYear() + 100);
          return d;
        }
        var n = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
        var out = new Date(+n[0], +n[1] - 1, +n[2], +n[3] || 0, +n[4] || 0, +n[5] || 0);
        if (str.indexOf("Z") > -1)
          out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
        return out;
      }
      function cc2str(arr, debomit) {
        if (has_buf && Buffer.isBuffer(arr)) {
          if (debomit) {
            if (arr[0] == 255 && arr[1] == 254)
              return utf8write(arr.slice(2).toString("utf16le"));
            if (arr[1] == 254 && arr[2] == 255)
              return utf8write(utf16beread(arr.slice(2).toString("binary")));
          }
          return arr.toString("binary");
        }
        if (typeof TextDecoder !== "undefined")
          try {
            if (debomit) {
              if (arr[0] == 255 && arr[1] == 254)
                return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
              if (arr[0] == 254 && arr[1] == 255)
                return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
            }
            var rev = {
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": ""
            };
            if (Array.isArray(arr))
              arr = new Uint8Array(arr);
            return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c2) {
              return rev[c2] || c2;
            });
          } catch (e) {
          }
        var o = [];
        for (var i = 0; i != arr.length; ++i)
          o.push(String.fromCharCode(arr[i]));
        return o.join("");
      }
      function dup(o) {
        if (typeof JSON != "undefined" && !Array.isArray(o))
          return JSON.parse(JSON.stringify(o));
        if (typeof o != "object" || o == null)
          return o;
        if (o instanceof Date)
          return new Date(o.getTime());
        var out = {};
        for (var k in o)
          if (Object.prototype.hasOwnProperty.call(o, k))
            out[k] = dup(o[k]);
        return out;
      }
      function fill(c2, l) {
        var o = "";
        while (o.length < l)
          o += c2;
        return o;
      }
      function fuzzynum(s) {
        var v = Number(s);
        if (!isNaN(v))
          return isFinite(v) ? v : NaN;
        if (!/\d/.test(s))
          return v;
        var wt = 1;
        var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
          wt *= 100;
          return "";
        });
        if (!isNaN(v = Number(ss)))
          return v / wt;
        ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
          wt = -wt;
          return $1;
        });
        if (!isNaN(v = Number(ss)))
          return v / wt;
        return v;
      }
      var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
      function fuzzydate(s) {
        var o = new Date(s), n = /* @__PURE__ */ new Date(NaN);
        var y = o.getYear(), m = o.getMonth(), d = o.getDate();
        if (isNaN(d))
          return n;
        var lower = s.toLowerCase();
        if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
          lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
          if (lower.length > 3 && lower_months.indexOf(lower) == -1)
            return n;
        } else if (lower.match(/[a-z]/))
          return n;
        if (y < 0 || y > 8099)
          return n;
        if ((m > 0 || d > 1) && y != 101)
          return o;
        if (s.match(/[^-0-9:,\/\\]/))
          return n;
        return o;
      }
      var split_regex = /* @__PURE__ */ function() {
        var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
        return function split_regex2(str, re, def) {
          if (safe_split_regex || typeof re == "string")
            return str.split(re);
          var p2 = str.split(re), o = [p2[0]];
          for (var i = 1; i < p2.length; ++i) {
            o.push(def);
            o.push(p2[i]);
          }
          return o;
        };
      }();
      function getdatastr(data) {
        if (!data)
          return null;
        if (data.content && data.type)
          return cc2str(data.content, true);
        if (data.data)
          return debom(data.data);
        if (data.asNodeBuffer && has_buf)
          return debom(data.asNodeBuffer().toString("binary"));
        if (data.asBinary)
          return debom(data.asBinary());
        if (data._data && data._data.getContent)
          return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
        return null;
      }
      function getdatabin(data) {
        if (!data)
          return null;
        if (data.data)
          return char_codes(data.data);
        if (data.asNodeBuffer && has_buf)
          return data.asNodeBuffer();
        if (data._data && data._data.getContent) {
          var o = data._data.getContent();
          if (typeof o == "string")
            return char_codes(o);
          return Array.prototype.slice.call(o);
        }
        if (data.content && data.type)
          return data.content;
        return null;
      }
      function getdata(data) {
        return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
      }
      function safegetzipfile(zip, file) {
        var k = zip.FullPaths || keys(zip.files);
        var f = file.toLowerCase().replace(/[\/]/g, "\\"), g = f.replace(/\\/g, "/");
        for (var i = 0; i < k.length; ++i) {
          var n = k[i].replace(/^Root Entry[\/]/, "").toLowerCase();
          if (f == n || g == n)
            return zip.files ? zip.files[k[i]] : zip.FileIndex[i];
        }
        return null;
      }
      function getzipfile(zip, file) {
        var o = safegetzipfile(zip, file);
        if (o == null)
          throw new Error("Cannot find file " + file + " in zip");
        return o;
      }
      function getzipdata(zip, file, safe) {
        if (!safe)
          return getdata(getzipfile(zip, file));
        if (!file)
          return null;
        try {
          return getzipdata(zip, file);
        } catch (e) {
          return null;
        }
      }
      function getzipstr(zip, file, safe) {
        if (!safe)
          return getdatastr(getzipfile(zip, file));
        if (!file)
          return null;
        try {
          return getzipstr(zip, file);
        } catch (e) {
          return null;
        }
      }
      function getzipbin(zip, file, safe) {
        if (!safe)
          return getdatabin(getzipfile(zip, file));
        if (!file)
          return null;
        try {
          return getzipbin(zip, file);
        } catch (e) {
          return null;
        }
      }
      function zipentries(zip) {
        var k = zip.FullPaths || keys(zip.files), o = [];
        for (var i = 0; i < k.length; ++i)
          if (k[i].slice(-1) != "/")
            o.push(k[i].replace(/^Root Entry[\/]/, ""));
        return o.sort();
      }
      function zip_add_file(zip, path, content) {
        if (zip.FullPaths) {
          if (typeof content == "string") {
            var res;
            if (has_buf)
              res = Buffer_from(content);
            else
              res = utf8decode(content);
            return CFB.utils.cfb_add(zip, path, res);
          }
          CFB.utils.cfb_add(zip, path, content);
        } else
          zip.file(path, content);
      }
      function zip_read(d, o) {
        switch (o.type) {
          case "base64":
            return CFB.read(d, { type: "base64" });
          case "binary":
            return CFB.read(d, { type: "binary" });
          case "buffer":
          case "array":
            return CFB.read(d, { type: "buffer" });
        }
        throw new Error("Unrecognized type " + o.type);
      }
      function resolve_path(path, base2) {
        if (path.charAt(0) == "/")
          return path.slice(1);
        var result = base2.split("/");
        if (base2.slice(-1) != "/")
          result.pop();
        var target = path.split("/");
        while (target.length !== 0) {
          var step = target.shift();
          if (step === "..")
            result.pop();
          else if (step !== ".")
            result.push(step);
        }
        return result.join("/");
      }
      var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
      var attregexg = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
      var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^>]*>/g;
      var tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
      var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
      function parsexmltag(tag, skip_root, skip_LC) {
        var z = {};
        var eq2 = 0, c2 = 0;
        for (; eq2 !== tag.length; ++eq2)
          if ((c2 = tag.charCodeAt(eq2)) === 32 || c2 === 10 || c2 === 13)
            break;
        if (!skip_root)
          z[0] = tag.slice(0, eq2);
        if (eq2 === tag.length)
          return z;
        var m = tag.match(attregexg), j = 0, v = "", i = 0, q = "", cc = "", quot = 1;
        if (m)
          for (i = 0; i != m.length; ++i) {
            cc = m[i];
            for (c2 = 0; c2 != cc.length; ++c2)
              if (cc.charCodeAt(c2) === 61)
                break;
            q = cc.slice(0, c2).trim();
            while (cc.charCodeAt(c2 + 1) == 32)
              ++c2;
            quot = (eq2 = cc.charCodeAt(c2 + 1)) == 34 || eq2 == 39 ? 1 : 0;
            v = cc.slice(c2 + 1 + quot, cc.length - quot);
            for (j = 0; j != q.length; ++j)
              if (q.charCodeAt(j) === 58)
                break;
            if (j === q.length) {
              if (q.indexOf("_") > 0)
                q = q.slice(0, q.indexOf("_"));
              z[q] = v;
              if (!skip_LC)
                z[q.toLowerCase()] = v;
            } else {
              var k = (j === 5 && q.slice(0, 5) === "xmlns" ? "xmlns" : "") + q.slice(j + 1);
              if (z[k] && q.slice(j - 3, j) == "ext")
                continue;
              z[k] = v;
              if (!skip_LC)
                z[k.toLowerCase()] = v;
            }
          }
        return z;
      }
      function strip_ns(x) {
        return x.replace(nsregex2, "<$1");
      }
      var encodings = {
        "&quot;": '"',
        "&apos;": "'",
        "&gt;": ">",
        "&lt;": "<",
        "&amp;": "&"
      };
      var rencoding = /* @__PURE__ */ evert(encodings);
      var unescapexml = /* @__PURE__ */ function() {
        var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
        return function unescapexml2(text) {
          var s = text + "", i = s.indexOf("<![CDATA[");
          if (i == -1)
            return s.replace(encregex, function($$, $1) {
              return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
            }).replace(coderegex, function(m, c2) {
              return String.fromCharCode(parseInt(c2, 16));
            });
          var j = s.indexOf("]]>");
          return unescapexml2(s.slice(0, i)) + s.slice(i + 9, j) + unescapexml2(s.slice(j + 3));
        };
      }();
      var decregex = /[&<>'"]/g;
      var htmlcharegex = /[\u0000-\u001f]/g;
      function escapehtml(text) {
        var s = text + "";
        return s.replace(decregex, function(y) {
          return rencoding[y];
        }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
          return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
        });
      }
      var xlml_fixstr = /* @__PURE__ */ function() {
        var entregex = /&#(\d+);/g;
        function entrepl($$, $1) {
          return String.fromCharCode(parseInt($1, 10));
        }
        return function xlml_fixstr2(str) {
          return str.replace(entregex, entrepl);
        };
      }();
      function parsexmlbool(value) {
        switch (value) {
          case 1:
          case true:
          case "1":
          case "true":
          case "TRUE":
            return true;
          default:
            return false;
        }
      }
      function utf8reada(orig) {
        var out = "", i = 0, c2 = 0, d = 0, e = 0, f = 0, w = 0;
        while (i < orig.length) {
          c2 = orig.charCodeAt(i++);
          if (c2 < 128) {
            out += String.fromCharCode(c2);
            continue;
          }
          d = orig.charCodeAt(i++);
          if (c2 > 191 && c2 < 224) {
            f = (c2 & 31) << 6;
            f |= d & 63;
            out += String.fromCharCode(f);
            continue;
          }
          e = orig.charCodeAt(i++);
          if (c2 < 240) {
            out += String.fromCharCode((c2 & 15) << 12 | (d & 63) << 6 | e & 63);
            continue;
          }
          f = orig.charCodeAt(i++);
          w = ((c2 & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
          out += String.fromCharCode(55296 + (w >>> 10 & 1023));
          out += String.fromCharCode(56320 + (w & 1023));
        }
        return out;
      }
      function utf8readb(data) {
        var out = new_raw_buf(2 * data.length), w, i, j = 1, k = 0, ww = 0, c2;
        for (i = 0; i < data.length; i += j) {
          j = 1;
          if ((c2 = data.charCodeAt(i)) < 128)
            w = c2;
          else if (c2 < 224) {
            w = (c2 & 31) * 64 + (data.charCodeAt(i + 1) & 63);
            j = 2;
          } else if (c2 < 240) {
            w = (c2 & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
            j = 3;
          } else {
            j = 4;
            w = (c2 & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
            w -= 65536;
            ww = 55296 + (w >>> 10 & 1023);
            w = 56320 + (w & 1023);
          }
          if (ww !== 0) {
            out[k++] = ww & 255;
            out[k++] = ww >>> 8;
            ww = 0;
          }
          out[k++] = w % 256;
          out[k++] = w >>> 8;
        }
        return out.slice(0, k).toString("ucs2");
      }
      function utf8readc(data) {
        return Buffer_from(data, "binary").toString("utf8");
      }
      var utf8corpus = "foo bar baz";
      var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
      var utf8write = has_buf ? function(data) {
        return Buffer_from(data, "utf8").toString("binary");
      } : function(orig) {
        var out = [], i = 0, c2 = 0, d = 0;
        while (i < orig.length) {
          c2 = orig.charCodeAt(i++);
          switch (true) {
            case c2 < 128:
              out.push(String.fromCharCode(c2));
              break;
            case c2 < 2048:
              out.push(String.fromCharCode(192 + (c2 >> 6)));
              out.push(String.fromCharCode(128 + (c2 & 63)));
              break;
            case (c2 >= 55296 && c2 < 57344):
              c2 -= 55296;
              d = orig.charCodeAt(i++) - 56320 + (c2 << 10);
              out.push(String.fromCharCode(240 + (d >> 18 & 7)));
              out.push(String.fromCharCode(144 + (d >> 12 & 63)));
              out.push(String.fromCharCode(128 + (d >> 6 & 63)));
              out.push(String.fromCharCode(128 + (d & 63)));
              break;
            default:
              out.push(String.fromCharCode(224 + (c2 >> 12)));
              out.push(String.fromCharCode(128 + (c2 >> 6 & 63)));
              out.push(String.fromCharCode(128 + (c2 & 63)));
          }
        }
        return out.join("");
      };
      var matchtag = /* @__PURE__ */ function() {
        var mtcache = {};
        return function matchtag2(f, g) {
          var t = f + "|" + (g || "");
          if (mtcache[t])
            return mtcache[t];
          return mtcache[t] = new RegExp("<(?:\\w+:)?" + f + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + f + ">", g || "");
        };
      }();
      var htmldecode = /* @__PURE__ */ function() {
        var entities = [
          ["nbsp", " "],
          ["middot", ""],
          ["quot", '"'],
          ["apos", "'"],
          ["gt", ">"],
          ["lt", "<"],
          ["amp", "&"]
        ].map(function(x) {
          return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
        });
        return function htmldecode2(str) {
          var o = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
          for (var i = 0; i < entities.length; ++i)
            o = o.replace(entities[i][0], entities[i][1]);
          return o;
        };
      }();
      var vtregex = /* @__PURE__ */ function() {
        var vt_cache = {};
        return function vt_regex(bt) {
          if (vt_cache[bt] !== void 0)
            return vt_cache[bt];
          return vt_cache[bt] = new RegExp("<(?:vt:)?" + bt + ">([\\s\\S]*?)</(?:vt:)?" + bt + ">", "g");
        };
      }();
      var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^>]*)>([\s\S]*)</;
      function parseVector(data, opts) {
        var h2 = parsexmltag(data);
        var matches = data.match(vtregex(h2.baseType)) || [];
        var res = [];
        if (matches.length != h2.size) {
          if (opts.WTF)
            throw new Error("unexpected vector length " + matches.length + " != " + h2.size);
          return res;
        }
        matches.forEach(function(x) {
          var v = x.replace(vtvregex, "").match(vtmregex);
          if (v)
            res.push({ v: utf8read(v[2]), t: v[1] });
        });
        return res;
      }
      var wtregex = /(^\s|\s$|\n)/;
      function wxt_helper(h2) {
        return keys(h2).map(function(k) {
          return " " + k + '="' + h2[k] + '"';
        }).join("");
      }
      function writextag(f, g, h2) {
        return "<" + f + (h2 != null ? wxt_helper(h2) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
      }
      function xlml_normalize(d) {
        if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
        Buffer.isBuffer(d))
          return d.toString("utf8");
        if (typeof d === "string")
          return d;
        if (typeof Uint8Array !== "undefined" && d instanceof Uint8Array)
          return utf8read(a2s(ab2a(d)));
        throw new Error("Bad input format: expected Buffer or string");
      }
      var xlmlregex = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/mg;
      var XMLNS = {
        CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
        CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
        CT: "http://schemas.openxmlformats.org/package/2006/content-types",
        RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
        TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
        "dc": "http://purl.org/dc/elements/1.1/",
        "dcterms": "http://purl.org/dc/terms/",
        "dcmitype": "http://purl.org/dc/dcmitype/",
        "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
        "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
        "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
        "xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xsd": "http://www.w3.org/2001/XMLSchema"
      };
      var XMLNS_main = [
        "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        "http://purl.oclc.org/ooxml/spreadsheetml/main",
        "http://schemas.microsoft.com/office/excel/2006/main",
        "http://schemas.microsoft.com/office/excel/2006/2"
      ];
      function read_double_le(b, idx) {
        var s = 1 - 2 * (b[idx + 7] >>> 7);
        var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
        var m = b[idx + 6] & 15;
        for (var i = 5; i >= 0; --i)
          m = m * 256 + b[idx + i];
        if (e == 2047)
          return m == 0 ? s * Infinity : NaN;
        if (e == 0)
          e = -1022;
        else {
          e -= 1023;
          m += Math.pow(2, 52);
        }
        return s * Math.pow(2, e - 52) * m;
      }
      function write_double_le(b, v, idx) {
        var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
        var av = bs ? -v : v;
        if (!isFinite(av)) {
          e = 2047;
          m = isNaN(v) ? 26985 : 0;
        } else if (av == 0)
          e = m = 0;
        else {
          e = Math.floor(Math.log(av) / Math.LN2);
          m = av * Math.pow(2, 52 - e);
          if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
            e = -1022;
          } else {
            m -= Math.pow(2, 52);
            e += 1023;
          }
        }
        for (var i = 0; i <= 5; ++i, m /= 256)
          b[idx + i] = m & 255;
        b[idx + 6] = (e & 15) << 4 | m & 15;
        b[idx + 7] = e >> 4 | bs;
      }
      var ___toBuffer = function(bufs) {
        var x = [], w = 10240;
        for (var i = 0; i < bufs[0].length; ++i)
          if (bufs[0][i])
            for (var j = 0, L = bufs[0][i].length; j < L; j += w)
              x.push.apply(x, bufs[0][i].slice(j, j + w));
        return x;
      };
      var __toBuffer = has_buf ? function(bufs) {
        return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
          return Buffer.isBuffer(x) ? x : Buffer_from(x);
        })) : ___toBuffer(bufs);
      } : ___toBuffer;
      var ___utf16le = function(b, s, e) {
        var ss = [];
        for (var i = s; i < e; i += 2)
          ss.push(String.fromCharCode(__readUInt16LE(b, i)));
        return ss.join("").replace(chr0, "");
      };
      var __utf16le = has_buf ? function(b, s, e) {
        if (!Buffer.isBuffer(b))
          return ___utf16le(b, s, e);
        return b.toString("utf16le", s, e).replace(chr0, "");
      } : ___utf16le;
      var ___hexlify = function(b, s, l) {
        var ss = [];
        for (var i = s; i < s + l; ++i)
          ss.push(("0" + b[i].toString(16)).slice(-2));
        return ss.join("");
      };
      var __hexlify = has_buf ? function(b, s, l) {
        return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
      } : ___hexlify;
      var ___utf8 = function(b, s, e) {
        var ss = [];
        for (var i = s; i < e; i++)
          ss.push(String.fromCharCode(__readUInt8(b, i)));
        return ss.join("");
      };
      var __utf8 = has_buf ? function utf8_b(b, s, e) {
        return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
      } : ___utf8;
      var ___lpstr = function(b, i) {
        var len2 = __readUInt32LE(b, i);
        return len2 > 0 ? __utf8(b, i + 4, i + 4 + len2 - 1) : "";
      };
      var __lpstr = ___lpstr;
      var ___cpstr = function(b, i) {
        var len2 = __readUInt32LE(b, i);
        return len2 > 0 ? __utf8(b, i + 4, i + 4 + len2 - 1) : "";
      };
      var __cpstr = ___cpstr;
      var ___lpwstr = function(b, i) {
        var len2 = 2 * __readUInt32LE(b, i);
        return len2 > 0 ? __utf8(b, i + 4, i + 4 + len2 - 1) : "";
      };
      var __lpwstr = ___lpwstr;
      var ___lpp4 = function lpp4_(b, i) {
        var len2 = __readUInt32LE(b, i);
        return len2 > 0 ? __utf16le(b, i + 4, i + 4 + len2) : "";
      };
      var __lpp4 = ___lpp4;
      var ___8lpp4 = function(b, i) {
        var len2 = __readUInt32LE(b, i);
        return len2 > 0 ? __utf8(b, i + 4, i + 4 + len2) : "";
      };
      var __8lpp4 = ___8lpp4;
      var ___double = function(b, idx) {
        return read_double_le(b, idx);
      };
      var __double = ___double;
      var is_buf = function is_buf_a(a2) {
        return Array.isArray(a2) || typeof Uint8Array !== "undefined" && a2 instanceof Uint8Array;
      };
      if (has_buf) {
        __lpstr = function lpstr_b(b, i) {
          if (!Buffer.isBuffer(b))
            return ___lpstr(b, i);
          var len2 = b.readUInt32LE(i);
          return len2 > 0 ? b.toString("utf8", i + 4, i + 4 + len2 - 1) : "";
        };
        __cpstr = function cpstr_b(b, i) {
          if (!Buffer.isBuffer(b))
            return ___cpstr(b, i);
          var len2 = b.readUInt32LE(i);
          return len2 > 0 ? b.toString("utf8", i + 4, i + 4 + len2 - 1) : "";
        };
        __lpwstr = function lpwstr_b(b, i) {
          if (!Buffer.isBuffer(b))
            return ___lpwstr(b, i);
          var len2 = 2 * b.readUInt32LE(i);
          return b.toString("utf16le", i + 4, i + 4 + len2 - 1);
        };
        __lpp4 = function lpp4_b(b, i) {
          if (!Buffer.isBuffer(b))
            return ___lpp4(b, i);
          var len2 = b.readUInt32LE(i);
          return b.toString("utf16le", i + 4, i + 4 + len2);
        };
        __8lpp4 = function lpp4_8b(b, i) {
          if (!Buffer.isBuffer(b))
            return ___8lpp4(b, i);
          var len2 = b.readUInt32LE(i);
          return b.toString("utf8", i + 4, i + 4 + len2);
        };
        __double = function double_(b, i) {
          if (Buffer.isBuffer(b))
            return b.readDoubleLE(i);
          return ___double(b, i);
        };
        is_buf = function is_buf_b(a2) {
          return Buffer.isBuffer(a2) || Array.isArray(a2) || typeof Uint8Array !== "undefined" && a2 instanceof Uint8Array;
        };
      }
      var __readUInt8 = function(b, idx) {
        return b[idx];
      };
      var __readUInt16LE = function(b, idx) {
        return b[idx + 1] * (1 << 8) + b[idx];
      };
      var __readInt16LE = function(b, idx) {
        var u = b[idx + 1] * (1 << 8) + b[idx];
        return u < 32768 ? u : (65535 - u + 1) * -1;
      };
      var __readUInt32LE = function(b, idx) {
        return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
      };
      var __readInt32LE = function(b, idx) {
        return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
      };
      var __readInt32BE = function(b, idx) {
        return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
      };
      function ReadShift(size2, t) {
        var o = "", oI, oR, oo = [], w, vv, i, loc;
        switch (t) {
          case "dbcs":
            loc = this.l;
            if (has_buf && Buffer.isBuffer(this))
              o = this.slice(this.l, this.l + 2 * size2).toString("utf16le");
            else
              for (i = 0; i < size2; ++i) {
                o += String.fromCharCode(__readUInt16LE(this, loc));
                loc += 2;
              }
            size2 *= 2;
            break;
          case "utf8":
            o = __utf8(this, this.l, this.l + size2);
            break;
          case "utf16le":
            size2 *= 2;
            o = __utf16le(this, this.l, this.l + size2);
            break;
          case "wstr":
            return ReadShift.call(this, size2, "dbcs");
          case "lpstr-ansi":
            o = __lpstr(this, this.l);
            size2 = 4 + __readUInt32LE(this, this.l);
            break;
          case "lpstr-cp":
            o = __cpstr(this, this.l);
            size2 = 4 + __readUInt32LE(this, this.l);
            break;
          case "lpwstr":
            o = __lpwstr(this, this.l);
            size2 = 4 + 2 * __readUInt32LE(this, this.l);
            break;
          case "lpp4":
            size2 = 4 + __readUInt32LE(this, this.l);
            o = __lpp4(this, this.l);
            if (size2 & 2)
              size2 += 2;
            break;
          case "8lpp4":
            size2 = 4 + __readUInt32LE(this, this.l);
            o = __8lpp4(this, this.l);
            if (size2 & 3)
              size2 += 4 - (size2 & 3);
            break;
          case "cstr":
            size2 = 0;
            o = "";
            while ((w = __readUInt8(this, this.l + size2++)) !== 0)
              oo.push(_getchar(w));
            o = oo.join("");
            break;
          case "_wstr":
            size2 = 0;
            o = "";
            while ((w = __readUInt16LE(this, this.l + size2)) !== 0) {
              oo.push(_getchar(w));
              size2 += 2;
            }
            size2 += 2;
            o = oo.join("");
            break;
          case "dbcs-cont":
            o = "";
            loc = this.l;
            for (i = 0; i < size2; ++i) {
              if (this.lens && this.lens.indexOf(loc) !== -1) {
                w = __readUInt8(this, loc);
                this.l = loc + 1;
                vv = ReadShift.call(this, size2 - i, w ? "dbcs-cont" : "sbcs-cont");
                return oo.join("") + vv;
              }
              oo.push(_getchar(__readUInt16LE(this, loc)));
              loc += 2;
            }
            o = oo.join("");
            size2 *= 2;
            break;
          case "cpstr":
          case "sbcs-cont":
            o = "";
            loc = this.l;
            for (i = 0; i != size2; ++i) {
              if (this.lens && this.lens.indexOf(loc) !== -1) {
                w = __readUInt8(this, loc);
                this.l = loc + 1;
                vv = ReadShift.call(this, size2 - i, w ? "dbcs-cont" : "sbcs-cont");
                return oo.join("") + vv;
              }
              oo.push(_getchar(__readUInt8(this, loc)));
              loc += 1;
            }
            o = oo.join("");
            break;
          default:
            switch (size2) {
              case 1:
                oI = __readUInt8(this, this.l);
                this.l++;
                return oI;
              case 2:
                oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
                this.l += 2;
                return oI;
              case 4:
              case -4:
                if (t === "i" || (this[this.l + 3] & 128) === 0) {
                  oI = (size2 > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
                  this.l += 4;
                  return oI;
                } else {
                  oR = __readUInt32LE(this, this.l);
                  this.l += 4;
                }
                return oR;
              case 8:
              case -8:
                if (t === "f") {
                  if (size2 == 8)
                    oR = __double(this, this.l);
                  else
                    oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
                  this.l += 8;
                  return oR;
                } else
                  size2 = 8;
              case 16:
                o = __hexlify(this, this.l, size2);
                break;
            }
        }
        this.l += size2;
        return o;
      }
      var __writeUInt32LE = function(b, val, idx) {
        b[idx] = val & 255;
        b[idx + 1] = val >>> 8 & 255;
        b[idx + 2] = val >>> 16 & 255;
        b[idx + 3] = val >>> 24 & 255;
      };
      var __writeInt32LE = function(b, val, idx) {
        b[idx] = val & 255;
        b[idx + 1] = val >> 8 & 255;
        b[idx + 2] = val >> 16 & 255;
        b[idx + 3] = val >> 24 & 255;
      };
      var __writeUInt16LE = function(b, val, idx) {
        b[idx] = val & 255;
        b[idx + 1] = val >>> 8 & 255;
      };
      function WriteShift(t, val, f) {
        var size2 = 0, i = 0;
        if (f === "dbcs") {
          for (i = 0; i != val.length; ++i)
            __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
          size2 = 2 * val.length;
        } else if (f === "sbcs") {
          {
            val = val.replace(/[^\x00-\x7F]/g, "_");
            for (i = 0; i != val.length; ++i)
              this[this.l + i] = val.charCodeAt(i) & 255;
          }
          size2 = val.length;
        } else if (f === "hex") {
          for (; i < t; ++i) {
            this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
          }
          return this;
        } else if (f === "utf16le") {
          var end = Math.min(this.l + t, this.length);
          for (i = 0; i < Math.min(val.length, t); ++i) {
            var cc = val.charCodeAt(i);
            this[this.l++] = cc & 255;
            this[this.l++] = cc >> 8;
          }
          while (this.l < end)
            this[this.l++] = 0;
          return this;
        } else
          switch (t) {
            case 1:
              size2 = 1;
              this[this.l] = val & 255;
              break;
            case 2:
              size2 = 2;
              this[this.l] = val & 255;
              val >>>= 8;
              this[this.l + 1] = val & 255;
              break;
            case 3:
              size2 = 3;
              this[this.l] = val & 255;
              val >>>= 8;
              this[this.l + 1] = val & 255;
              val >>>= 8;
              this[this.l + 2] = val & 255;
              break;
            case 4:
              size2 = 4;
              __writeUInt32LE(this, val, this.l);
              break;
            case 8:
              size2 = 8;
              if (f === "f") {
                write_double_le(this, val, this.l);
                break;
              }
            case 16:
              break;
            case -4:
              size2 = 4;
              __writeInt32LE(this, val, this.l);
              break;
          }
        this.l += size2;
        return this;
      }
      function CheckField(hexstr, fld) {
        var m = __hexlify(this, this.l, hexstr.length >> 1);
        if (m !== hexstr)
          throw new Error(fld + "Expected " + hexstr + " saw " + m);
        this.l += hexstr.length >> 1;
      }
      function prep_blob(blob, pos) {
        blob.l = pos;
        blob.read_shift = /*::(*/
        ReadShift;
        blob.chk = CheckField;
        blob.write_shift = WriteShift;
      }
      function parsenoop(blob, length) {
        blob.l += length;
      }
      function new_buf(sz) {
        var o = new_raw_buf(sz);
        prep_blob(o, 0);
        return o;
      }
      function recordhopper(data, cb, opts) {
        if (!data)
          return;
        var tmpbyte, cntbyte, length;
        prep_blob(data, data.l || 0);
        var L = data.length, RT = 0, tgt = 0;
        while (data.l < L) {
          RT = data.read_shift(1);
          if (RT & 128)
            RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
          var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
          tmpbyte = data.read_shift(1);
          length = tmpbyte & 127;
          for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte)
            length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
          tgt = data.l + length;
          var d = R.f && R.f(data, length, opts);
          data.l = tgt;
          if (cb(d, R, RT))
            return;
        }
      }
      function buf_array() {
        var bufs = [], blksz = has_buf ? 256 : 2048;
        var newblk = function ba_newblk(sz) {
          var o = new_buf(sz);
          prep_blob(o, 0);
          return o;
        };
        var curbuf = newblk(blksz);
        var endbuf = function ba_endbuf() {
          if (!curbuf)
            return;
          if (curbuf.length > curbuf.l) {
            curbuf = curbuf.slice(0, curbuf.l);
            curbuf.l = curbuf.length;
          }
          if (curbuf.length > 0)
            bufs.push(curbuf);
          curbuf = null;
        };
        var next = function ba_next(sz) {
          if (curbuf && sz < curbuf.length - curbuf.l)
            return curbuf;
          endbuf();
          return curbuf = newblk(Math.max(sz + 1, blksz));
        };
        var end = function ba_end() {
          endbuf();
          return bconcat(bufs);
        };
        var push = function ba_push(buf) {
          endbuf();
          curbuf = buf;
          if (curbuf.l == null)
            curbuf.l = curbuf.length;
          next(blksz);
        };
        return { next, push, end, _bufs: bufs };
      }
      function shift_cell_xls(cell, tgt, opts) {
        var out = dup(cell);
        if (tgt.s) {
          if (out.cRel)
            out.c += tgt.s.c;
          if (out.rRel)
            out.r += tgt.s.r;
        } else {
          if (out.cRel)
            out.c += tgt.c;
          if (out.rRel)
            out.r += tgt.r;
        }
        if (!opts || opts.biff < 12) {
          while (out.c >= 256)
            out.c -= 256;
          while (out.r >= 65536)
            out.r -= 65536;
        }
        return out;
      }
      function shift_range_xls(cell, range2, opts) {
        var out = dup(cell);
        out.s = shift_cell_xls(out.s, range2.s, opts);
        out.e = shift_cell_xls(out.e, range2.s, opts);
        return out;
      }
      function encode_cell_xls(c2, biff) {
        if (c2.cRel && c2.c < 0) {
          c2 = dup(c2);
          while (c2.c < 0)
            c2.c += biff > 8 ? 16384 : 256;
        }
        if (c2.rRel && c2.r < 0) {
          c2 = dup(c2);
          while (c2.r < 0)
            c2.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
        }
        var s = encode_cell(c2);
        if (!c2.cRel && c2.cRel != null)
          s = fix_col(s);
        if (!c2.rRel && c2.rRel != null)
          s = fix_row(s);
        return s;
      }
      function encode_range_xls(r, opts) {
        if (r.s.r == 0 && !r.s.rRel) {
          if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
            return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
          }
        }
        if (r.s.c == 0 && !r.s.cRel) {
          if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
            return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
          }
        }
        return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
      }
      function decode_row(rowstr) {
        return parseInt(unfix_row(rowstr), 10) - 1;
      }
      function encode_row(row) {
        return "" + (row + 1);
      }
      function fix_row(cstr) {
        return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
      }
      function unfix_row(cstr) {
        return cstr.replace(/\$(\d+)$/, "$1");
      }
      function decode_col(colstr) {
        var c2 = unfix_col(colstr), d = 0, i = 0;
        for (; i !== c2.length; ++i)
          d = 26 * d + c2.charCodeAt(i) - 64;
        return d - 1;
      }
      function encode_col(col) {
        if (col < 0)
          throw new Error("invalid column " + col);
        var s = "";
        for (++col; col; col = Math.floor((col - 1) / 26))
          s = String.fromCharCode((col - 1) % 26 + 65) + s;
        return s;
      }
      function fix_col(cstr) {
        return cstr.replace(/^([A-Z])/, "$$$1");
      }
      function unfix_col(cstr) {
        return cstr.replace(/^\$([A-Z])/, "$1");
      }
      function split_cell(cstr) {
        return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
      }
      function decode_cell(cstr) {
        var R = 0, C = 0;
        for (var i = 0; i < cstr.length; ++i) {
          var cc = cstr.charCodeAt(i);
          if (cc >= 48 && cc <= 57)
            R = 10 * R + (cc - 48);
          else if (cc >= 65 && cc <= 90)
            C = 26 * C + (cc - 64);
        }
        return { c: C - 1, r: R - 1 };
      }
      function encode_cell(cell) {
        var col = cell.c + 1;
        var s = "";
        for (; col; col = (col - 1) / 26 | 0)
          s = String.fromCharCode((col - 1) % 26 + 65) + s;
        return s + (cell.r + 1);
      }
      function decode_range(range2) {
        var idx = range2.indexOf(":");
        if (idx == -1)
          return { s: decode_cell(range2), e: decode_cell(range2) };
        return { s: decode_cell(range2.slice(0, idx)), e: decode_cell(range2.slice(idx + 1)) };
      }
      function encode_range(cs, ce) {
        if (typeof ce === "undefined" || typeof ce === "number") {
          return encode_range(cs.s, cs.e);
        }
        if (typeof cs !== "string")
          cs = encode_cell(cs);
        if (typeof ce !== "string")
          ce = encode_cell(ce);
        return cs == ce ? cs : cs + ":" + ce;
      }
      function safe_decode_range(range2) {
        var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
        var idx = 0, i = 0, cc = 0;
        var len2 = range2.length;
        for (idx = 0; i < len2; ++i) {
          if ((cc = range2.charCodeAt(i) - 64) < 1 || cc > 26)
            break;
          idx = 26 * idx + cc;
        }
        o.s.c = --idx;
        for (idx = 0; i < len2; ++i) {
          if ((cc = range2.charCodeAt(i) - 48) < 0 || cc > 9)
            break;
          idx = 10 * idx + cc;
        }
        o.s.r = --idx;
        if (i === len2 || cc != 10) {
          o.e.c = o.s.c;
          o.e.r = o.s.r;
          return o;
        }
        ++i;
        for (idx = 0; i != len2; ++i) {
          if ((cc = range2.charCodeAt(i) - 64) < 1 || cc > 26)
            break;
          idx = 26 * idx + cc;
        }
        o.e.c = --idx;
        for (idx = 0; i != len2; ++i) {
          if ((cc = range2.charCodeAt(i) - 48) < 0 || cc > 9)
            break;
          idx = 10 * idx + cc;
        }
        o.e.r = --idx;
        return o;
      }
      function safe_format_cell(cell, v) {
        var q = cell.t == "d" && v instanceof Date;
        if (cell.z != null)
          try {
            return cell.w = SSF_format(cell.z, q ? datenum(v) : v);
          } catch (e) {
          }
        try {
          return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
        } catch (e) {
          return "" + v;
        }
      }
      function format_cell(cell, v, o) {
        if (cell == null || cell.t == null || cell.t == "z")
          return "";
        if (cell.w !== void 0)
          return cell.w;
        if (cell.t == "d" && !cell.z && o && o.dateNF)
          cell.z = o.dateNF;
        if (cell.t == "e")
          return BErr[cell.v] || cell.v;
        if (v == void 0)
          return safe_format_cell(cell, cell.v);
        return safe_format_cell(cell, v);
      }
      function sheet_to_workbook(sheet, opts) {
        var n = opts && opts.sheet ? opts.sheet : "Sheet1";
        var sheets = {};
        sheets[n] = sheet;
        return { SheetNames: [n], Sheets: sheets };
      }
      function sheet_add_aoa(_ws, data, opts) {
        var o = opts || {};
        var dense = _ws ? Array.isArray(_ws) : o.dense;
        var ws = _ws || (dense ? [] : {});
        var _R = 0, _C = 0;
        if (ws && o.origin != null) {
          if (typeof o.origin == "number")
            _R = o.origin;
          else {
            var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
            _R = _origin.r;
            _C = _origin.c;
          }
          if (!ws["!ref"])
            ws["!ref"] = "A1:A1";
        }
        var range2 = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
        if (ws["!ref"]) {
          var _range = safe_decode_range(ws["!ref"]);
          range2.s.c = _range.s.c;
          range2.s.r = _range.s.r;
          range2.e.c = Math.max(range2.e.c, _range.e.c);
          range2.e.r = Math.max(range2.e.r, _range.e.r);
          if (_R == -1)
            range2.e.r = _R = _range.e.r + 1;
        }
        for (var R = 0; R != data.length; ++R) {
          if (!data[R])
            continue;
          if (!Array.isArray(data[R]))
            throw new Error("aoa_to_sheet expects an array of arrays");
          for (var C = 0; C != data[R].length; ++C) {
            if (typeof data[R][C] === "undefined")
              continue;
            var cell = { v: data[R][C] };
            var __R = _R + R, __C = _C + C;
            if (range2.s.r > __R)
              range2.s.r = __R;
            if (range2.s.c > __C)
              range2.s.c = __C;
            if (range2.e.r < __R)
              range2.e.r = __R;
            if (range2.e.c < __C)
              range2.e.c = __C;
            if (data[R][C] && typeof data[R][C] === "object" && !Array.isArray(data[R][C]) && !(data[R][C] instanceof Date))
              cell = data[R][C];
            else {
              if (Array.isArray(cell.v)) {
                cell.f = data[R][C][1];
                cell.v = cell.v[0];
              }
              if (cell.v === null) {
                if (cell.f)
                  cell.t = "n";
                else if (o.nullError) {
                  cell.t = "e";
                  cell.v = 0;
                } else if (!o.sheetStubs)
                  continue;
                else
                  cell.t = "z";
              } else if (typeof cell.v === "number")
                cell.t = "n";
              else if (typeof cell.v === "boolean")
                cell.t = "b";
              else if (cell.v instanceof Date) {
                cell.z = o.dateNF || table_fmt[14];
                if (o.cellDates) {
                  cell.t = "d";
                  cell.w = SSF_format(cell.z, datenum(cell.v));
                } else {
                  cell.t = "n";
                  cell.v = datenum(cell.v);
                  cell.w = SSF_format(cell.z, cell.v);
                }
              } else
                cell.t = "s";
            }
            if (dense) {
              if (!ws[__R])
                ws[__R] = [];
              if (ws[__R][__C] && ws[__R][__C].z)
                cell.z = ws[__R][__C].z;
              ws[__R][__C] = cell;
            } else {
              var cell_ref = encode_cell({ c: __C, r: __R });
              if (ws[cell_ref] && ws[cell_ref].z)
                cell.z = ws[cell_ref].z;
              ws[cell_ref] = cell;
            }
          }
        }
        if (range2.s.c < 1e7)
          ws["!ref"] = encode_range(range2);
        return ws;
      }
      function aoa_to_sheet(data, opts) {
        return sheet_add_aoa(null, data, opts);
      }
      function parse_Int32LE(data) {
        return data.read_shift(4, "i");
      }
      function parse_XLWideString(data) {
        var cchCharacters = data.read_shift(4);
        return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
      }
      function parse_StrRun(data) {
        return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
      }
      function parse_RichStr(data, length) {
        var start = data.l;
        var flags = data.read_shift(1);
        var str = parse_XLWideString(data);
        var rgsStrRun = [];
        var z = { t: str, h: str };
        if ((flags & 1) !== 0) {
          var dwSizeStrRun = data.read_shift(4);
          for (var i = 0; i != dwSizeStrRun; ++i)
            rgsStrRun.push(parse_StrRun(data));
          z.r = rgsStrRun;
        } else
          z.r = [{ ich: 0, ifnt: 0 }];
        data.l = start + length;
        return z;
      }
      var parse_BrtCommentText = parse_RichStr;
      function parse_XLSBCell(data) {
        var col = data.read_shift(4);
        var iStyleRef = data.read_shift(2);
        iStyleRef += data.read_shift(1) << 16;
        data.l++;
        return { c: col, iStyleRef };
      }
      function parse_XLSBShortCell(data) {
        var iStyleRef = data.read_shift(2);
        iStyleRef += data.read_shift(1) << 16;
        data.l++;
        return { c: -1, iStyleRef };
      }
      var parse_XLSBCodeName = parse_XLWideString;
      function parse_XLNullableWideString(data) {
        var cchCharacters = data.read_shift(4);
        return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
      }
      var parse_XLNameWideString = parse_XLWideString;
      var parse_RelID = parse_XLNullableWideString;
      function parse_RkNumber(data) {
        var b = data.slice(data.l, data.l + 4);
        var fX100 = b[0] & 1, fInt = b[0] & 2;
        data.l += 4;
        var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
        return fX100 ? RK / 100 : RK;
      }
      function parse_RfX(data) {
        var cell = { s: {}, e: {} };
        cell.s.r = data.read_shift(4);
        cell.e.r = data.read_shift(4);
        cell.s.c = data.read_shift(4);
        cell.e.c = data.read_shift(4);
        return cell;
      }
      var parse_UncheckedRfX = parse_RfX;
      function parse_Xnum(data) {
        if (data.length - data.l < 8)
          throw "XLS Xnum Buffer underflow";
        return data.read_shift(8, "f");
      }
      function parse_BrtColor(data) {
        var out = {};
        var d = data.read_shift(1);
        var xColorType = d >>> 1;
        var index = data.read_shift(1);
        var nTS = data.read_shift(2, "i");
        var bR = data.read_shift(1);
        var bG = data.read_shift(1);
        var bB = data.read_shift(1);
        data.l++;
        switch (xColorType) {
          case 0:
            out.auto = 1;
            break;
          case 1:
            out.index = index;
            var icv = XLSIcv[index];
            if (icv)
              out.rgb = rgb2Hex(icv);
            break;
          case 2:
            out.rgb = rgb2Hex([bR, bG, bB]);
            break;
          case 3:
            out.theme = index;
            break;
        }
        if (nTS != 0)
          out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
        return out;
      }
      function parse_FontFlags(data) {
        var d = data.read_shift(1);
        data.l++;
        var out = {
          fBold: d & 1,
          fItalic: d & 2,
          fUnderline: d & 4,
          fStrikeout: d & 8,
          fOutline: d & 16,
          fShadow: d & 32,
          fCondense: d & 64,
          fExtend: d & 128
        };
        return out;
      }
      function parse_ClipboardFormatOrString(o, w) {
        var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
        var m = o.read_shift(4);
        switch (m) {
          case 0:
            return "";
          case 4294967295:
          case 4294967294:
            return ClipFmt[o.read_shift(4)] || "";
        }
        if (m > 400)
          throw new Error("Unsupported Clipboard: " + m.toString(16));
        o.l -= 4;
        return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");
      }
      function parse_ClipboardFormatOrAnsiString(o) {
        return parse_ClipboardFormatOrString(o, 1);
      }
      function parse_ClipboardFormatOrUnicodeString(o) {
        return parse_ClipboardFormatOrString(o, 2);
      }
      var VT_I2 = 2;
      var VT_I4 = 3;
      var VT_BOOL = 11;
      var VT_VARIANT = 12;
      var VT_UI4 = 19;
      var VT_FILETIME = 64;
      var VT_BLOB = 65;
      var VT_CF = 71;
      var VT_VECTOR_VARIANT = 4108;
      var VT_VECTOR_LPSTR = 4126;
      var VT_STRING = 80;
      var VT_USTR = 81;
      var VT_CUSTOM = [VT_STRING, VT_USTR];
      var DocSummaryPIDDSI = {
        /*::[*/
        1: { n: "CodePage", t: VT_I2 },
        /*::[*/
        2: { n: "Category", t: VT_STRING },
        /*::[*/
        3: { n: "PresentationFormat", t: VT_STRING },
        /*::[*/
        4: { n: "ByteCount", t: VT_I4 },
        /*::[*/
        5: { n: "LineCount", t: VT_I4 },
        /*::[*/
        6: { n: "ParagraphCount", t: VT_I4 },
        /*::[*/
        7: { n: "SlideCount", t: VT_I4 },
        /*::[*/
        8: { n: "NoteCount", t: VT_I4 },
        /*::[*/
        9: { n: "HiddenCount", t: VT_I4 },
        /*::[*/
        10: { n: "MultimediaClipCount", t: VT_I4 },
        /*::[*/
        11: { n: "ScaleCrop", t: VT_BOOL },
        /*::[*/
        12: {
          n: "HeadingPairs",
          t: VT_VECTOR_VARIANT
          /* VT_VECTOR | VT_VARIANT */
        },
        /*::[*/
        13: {
          n: "TitlesOfParts",
          t: VT_VECTOR_LPSTR
          /* VT_VECTOR | VT_LPSTR */
        },
        /*::[*/
        14: { n: "Manager", t: VT_STRING },
        /*::[*/
        15: { n: "Company", t: VT_STRING },
        /*::[*/
        16: { n: "LinksUpToDate", t: VT_BOOL },
        /*::[*/
        17: { n: "CharacterCount", t: VT_I4 },
        /*::[*/
        19: { n: "SharedDoc", t: VT_BOOL },
        /*::[*/
        22: { n: "HyperlinksChanged", t: VT_BOOL },
        /*::[*/
        23: { n: "AppVersion", t: VT_I4, p: "version" },
        /*::[*/
        24: { n: "DigSig", t: VT_BLOB },
        /*::[*/
        26: { n: "ContentType", t: VT_STRING },
        /*::[*/
        27: { n: "ContentStatus", t: VT_STRING },
        /*::[*/
        28: { n: "Language", t: VT_STRING },
        /*::[*/
        29: { n: "Version", t: VT_STRING },
        /*::[*/
        255: {},
        /* [MS-OLEPS] 2.18 */
        /*::[*/
        2147483648: { n: "Locale", t: VT_UI4 },
        /*::[*/
        2147483651: { n: "Behavior", t: VT_UI4 },
        /*::[*/
        1919054434: {}
      };
      var SummaryPIDSI = {
        /*::[*/
        1: { n: "CodePage", t: VT_I2 },
        /*::[*/
        2: { n: "Title", t: VT_STRING },
        /*::[*/
        3: { n: "Subject", t: VT_STRING },
        /*::[*/
        4: { n: "Author", t: VT_STRING },
        /*::[*/
        5: { n: "Keywords", t: VT_STRING },
        /*::[*/
        6: { n: "Comments", t: VT_STRING },
        /*::[*/
        7: { n: "Template", t: VT_STRING },
        /*::[*/
        8: { n: "LastAuthor", t: VT_STRING },
        /*::[*/
        9: { n: "RevNumber", t: VT_STRING },
        /*::[*/
        10: { n: "EditTime", t: VT_FILETIME },
        /*::[*/
        11: { n: "LastPrinted", t: VT_FILETIME },
        /*::[*/
        12: { n: "CreatedDate", t: VT_FILETIME },
        /*::[*/
        13: { n: "ModifiedDate", t: VT_FILETIME },
        /*::[*/
        14: { n: "PageCount", t: VT_I4 },
        /*::[*/
        15: { n: "WordCount", t: VT_I4 },
        /*::[*/
        16: { n: "CharCount", t: VT_I4 },
        /*::[*/
        17: { n: "Thumbnail", t: VT_CF },
        /*::[*/
        18: { n: "Application", t: VT_STRING },
        /*::[*/
        19: { n: "DocSecurity", t: VT_I4 },
        /*::[*/
        255: {},
        /* [MS-OLEPS] 2.18 */
        /*::[*/
        2147483648: { n: "Locale", t: VT_UI4 },
        /*::[*/
        2147483651: { n: "Behavior", t: VT_UI4 },
        /*::[*/
        1919054434: {}
      };
      var CountryEnum = {
        /*::[*/
        1: "US",
        // United States
        /*::[*/
        2: "CA",
        // Canada
        /*::[*/
        3: "",
        // Latin America (except Brazil)
        /*::[*/
        7: "RU",
        // Russia
        /*::[*/
        20: "EG",
        // Egypt
        /*::[*/
        30: "GR",
        // Greece
        /*::[*/
        31: "NL",
        // Netherlands
        /*::[*/
        32: "BE",
        // Belgium
        /*::[*/
        33: "FR",
        // France
        /*::[*/
        34: "ES",
        // Spain
        /*::[*/
        36: "HU",
        // Hungary
        /*::[*/
        39: "IT",
        // Italy
        /*::[*/
        41: "CH",
        // Switzerland
        /*::[*/
        43: "AT",
        // Austria
        /*::[*/
        44: "GB",
        // United Kingdom
        /*::[*/
        45: "DK",
        // Denmark
        /*::[*/
        46: "SE",
        // Sweden
        /*::[*/
        47: "NO",
        // Norway
        /*::[*/
        48: "PL",
        // Poland
        /*::[*/
        49: "DE",
        // Germany
        /*::[*/
        52: "MX",
        // Mexico
        /*::[*/
        55: "BR",
        // Brazil
        /*::[*/
        61: "AU",
        // Australia
        /*::[*/
        64: "NZ",
        // New Zealand
        /*::[*/
        66: "TH",
        // Thailand
        /*::[*/
        81: "JP",
        // Japan
        /*::[*/
        82: "KR",
        // Korea
        /*::[*/
        84: "VN",
        // Viet Nam
        /*::[*/
        86: "CN",
        // China
        /*::[*/
        90: "TR",
        // Turkey
        /*::[*/
        105: "JS",
        // Ramastan
        /*::[*/
        213: "DZ",
        // Algeria
        /*::[*/
        216: "MA",
        // Morocco
        /*::[*/
        218: "LY",
        // Libya
        /*::[*/
        351: "PT",
        // Portugal
        /*::[*/
        354: "IS",
        // Iceland
        /*::[*/
        358: "FI",
        // Finland
        /*::[*/
        420: "CZ",
        // Czech Republic
        /*::[*/
        886: "TW",
        // Taiwan
        /*::[*/
        961: "LB",
        // Lebanon
        /*::[*/
        962: "JO",
        // Jordan
        /*::[*/
        963: "SY",
        // Syria
        /*::[*/
        964: "IQ",
        // Iraq
        /*::[*/
        965: "KW",
        // Kuwait
        /*::[*/
        966: "SA",
        // Saudi Arabia
        /*::[*/
        971: "AE",
        // United Arab Emirates
        /*::[*/
        972: "IL",
        // Israel
        /*::[*/
        974: "QA",
        // Qatar
        /*::[*/
        981: "IR",
        // Iran
        /*::[*/
        65535: "US"
        // United States
      };
      var XLSFillPattern = [
        null,
        "solid",
        "mediumGray",
        "darkGray",
        "lightGray",
        "darkHorizontal",
        "darkVertical",
        "darkDown",
        "darkUp",
        "darkGrid",
        "darkTrellis",
        "lightHorizontal",
        "lightVertical",
        "lightDown",
        "lightUp",
        "lightGrid",
        "lightTrellis",
        "gray125",
        "gray0625"
      ];
      function rgbify(arr) {
        return arr.map(function(x) {
          return [x >> 16 & 255, x >> 8 & 255, x & 255];
        });
      }
      var _XLSIcv = /* @__PURE__ */ rgbify([
        /* Color Constants */
        0,
        16777215,
        16711680,
        65280,
        255,
        16776960,
        16711935,
        65535,
        /* Overridable Defaults */
        0,
        16777215,
        16711680,
        65280,
        255,
        16776960,
        16711935,
        65535,
        8388608,
        32768,
        128,
        8421376,
        8388736,
        32896,
        12632256,
        8421504,
        10066431,
        10040166,
        16777164,
        13434879,
        6684774,
        16744576,
        26316,
        13421823,
        128,
        16711935,
        16776960,
        65535,
        8388736,
        8388608,
        32896,
        255,
        52479,
        13434879,
        13434828,
        16777113,
        10079487,
        16751052,
        13408767,
        16764057,
        3368703,
        3394764,
        10079232,
        16763904,
        16750848,
        16737792,
        6710937,
        9868950,
        13158,
        3381606,
        13056,
        3355392,
        10040064,
        10040166,
        3355545,
        3355443,
        /* Other entries to appease BIFF8/12 */
        16777215,
        /* 0x40 icvForeground ?? */
        0,
        /* 0x41 icvBackground ?? */
        0,
        /* 0x42 icvFrame ?? */
        0,
        /* 0x43 icv3D ?? */
        0,
        /* 0x44 icv3DText ?? */
        0,
        /* 0x45 icv3DHilite ?? */
        0,
        /* 0x46 icv3DShadow ?? */
        0,
        /* 0x47 icvHilite ?? */
        0,
        /* 0x48 icvCtlText ?? */
        0,
        /* 0x49 icvCtlScrl ?? */
        0,
        /* 0x4A icvCtlInv ?? */
        0,
        /* 0x4B icvCtlBody ?? */
        0,
        /* 0x4C icvCtlFrame ?? */
        0,
        /* 0x4D icvCtlFore ?? */
        0,
        /* 0x4E icvCtlBack ?? */
        0,
        /* 0x4F icvCtlNeutral */
        0,
        /* 0x50 icvInfoBk ?? */
        0
        /* 0x51 icvInfoText ?? */
      ]);
      var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
      var BErr = {
        /*::[*/
        0: "#NULL!",
        /*::[*/
        7: "#DIV/0!",
        /*::[*/
        15: "#VALUE!",
        /*::[*/
        23: "#REF!",
        /*::[*/
        29: "#NAME?",
        /*::[*/
        36: "#NUM!",
        /*::[*/
        42: "#N/A",
        /*::[*/
        43: "#GETTING_DATA",
        /*::[*/
        255: "#WTF?"
      };
      var RBErr = {
        "#NULL!": 0,
        "#DIV/0!": 7,
        "#VALUE!": 15,
        "#REF!": 23,
        "#NAME?": 29,
        "#NUM!": 36,
        "#N/A": 42,
        "#GETTING_DATA": 43,
        "#WTF?": 255
      };
      var ct2type = {
        /* Workbook */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
        "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
        "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
        "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
        /* Worksheet */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
        "application/vnd.ms-excel.worksheet": "sheets",
        "application/vnd.ms-excel.binIndexWs": "TODO",
        /* Binary Index */
        /* Chartsheet */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
        "application/vnd.ms-excel.chartsheet": "charts",
        /* Macrosheet */
        "application/vnd.ms-excel.macrosheet+xml": "macros",
        "application/vnd.ms-excel.macrosheet": "macros",
        "application/vnd.ms-excel.intlmacrosheet": "TODO",
        "application/vnd.ms-excel.binIndexMs": "TODO",
        /* Binary Index */
        /* Dialogsheet */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
        "application/vnd.ms-excel.dialogsheet": "dialogs",
        /* Shared Strings */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
        "application/vnd.ms-excel.sharedStrings": "strs",
        /* Styles */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
        "application/vnd.ms-excel.styles": "styles",
        /* File Properties */
        "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
        /* Custom Data Properties */
        "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
        /* Comments */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
        "application/vnd.ms-excel.comments": "comments",
        "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
        "application/vnd.ms-excel.person+xml": "people",
        /* Metadata (Stock/Geography and Dynamic Array) */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
        "application/vnd.ms-excel.sheetMetadata": "metadata",
        /* PivotTable */
        "application/vnd.ms-excel.pivotTable": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
        /* Chart Objects */
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
        /* Chart Colors */
        "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
        /* Chart Style */
        "application/vnd.ms-office.chartstyle+xml": "TODO",
        /* Chart Advanced */
        "application/vnd.ms-office.chartex+xml": "TODO",
        /* Calculation Chain */
        "application/vnd.ms-excel.calcChain": "calcchains",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
        /* Printer Settings */
        "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
        /* ActiveX */
        "application/vnd.ms-office.activeX": "TODO",
        "application/vnd.ms-office.activeX+xml": "TODO",
        /* Custom Toolbars */
        "application/vnd.ms-excel.attachedToolbars": "TODO",
        /* External Data Connections */
        "application/vnd.ms-excel.connections": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
        /* External Links */
        "application/vnd.ms-excel.externalLink": "links",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
        /* PivotCache */
        "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
        "application/vnd.ms-excel.pivotCacheRecords": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
        /* Query Table */
        "application/vnd.ms-excel.queryTable": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
        /* Shared Workbook */
        "application/vnd.ms-excel.userNames": "TODO",
        "application/vnd.ms-excel.revisionHeaders": "TODO",
        "application/vnd.ms-excel.revisionLog": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
        /* Single Cell Table */
        "application/vnd.ms-excel.tableSingleCells": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
        /* Slicer */
        "application/vnd.ms-excel.slicer": "TODO",
        "application/vnd.ms-excel.slicerCache": "TODO",
        "application/vnd.ms-excel.slicer+xml": "TODO",
        "application/vnd.ms-excel.slicerCache+xml": "TODO",
        /* Sort Map */
        "application/vnd.ms-excel.wsSortMap": "TODO",
        /* Table */
        "application/vnd.ms-excel.table": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
        /* Themes */
        "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
        /* Theme Override */
        "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
        /* Timeline */
        "application/vnd.ms-excel.Timeline+xml": "TODO",
        /* verify */
        "application/vnd.ms-excel.TimelineCache+xml": "TODO",
        /* verify */
        /* VBA */
        "application/vnd.ms-office.vbaProject": "vba",
        "application/vnd.ms-office.vbaProjectSignature": "TODO",
        /* Volatile Dependencies */
        "application/vnd.ms-office.volatileDependencies": "TODO",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
        /* Control Properties */
        "application/vnd.ms-excel.controlproperties+xml": "TODO",
        /* Data Model */
        "application/vnd.openxmlformats-officedocument.model+data": "TODO",
        /* Survey */
        "application/vnd.ms-excel.Survey+xml": "TODO",
        /* Drawing */
        "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
        "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
        /* VML */
        "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
        "application/vnd.openxmlformats-package.relationships+xml": "rels",
        "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
        /* Image */
        "image/png": "TODO",
        "sheet": "js"
      };
      function new_ct() {
        return {
          workbooks: [],
          sheets: [],
          charts: [],
          dialogs: [],
          macros: [],
          rels: [],
          strs: [],
          comments: [],
          threadedcomments: [],
          links: [],
          coreprops: [],
          extprops: [],
          custprops: [],
          themes: [],
          styles: [],
          calcchains: [],
          vba: [],
          drawings: [],
          metadata: [],
          people: [],
          TODO: [],
          xmlns: ""
        };
      }
      function parse_ct(data) {
        var ct = new_ct();
        if (!data || !data.match)
          return ct;
        var ctext = {};
        (data.match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          switch (y[0].replace(nsregex, "<")) {
            case "<?xml":
              break;
            case "<Types":
              ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || ["", ""])[1]];
              break;
            case "<Default":
              ctext[y.Extension] = y.ContentType;
              break;
            case "<Override":
              if (ct[ct2type[y.ContentType]] !== void 0)
                ct[ct2type[y.ContentType]].push(y.PartName);
              break;
          }
        });
        if (ct.xmlns !== XMLNS.CT)
          throw new Error("Unknown Namespace: " + ct.xmlns);
        ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
        ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
        ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
        ct.defaults = ctext;
        delete ct.calcchains;
        return ct;
      }
      var RELS = {
        WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
        VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
        XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
        XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
        XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
        CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
        CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
        CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
        CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
        EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
        CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
        SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
        STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
        THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
        CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
        CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
        CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
        WS: [
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
          "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
        ],
        DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
        MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
        IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
        DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
        XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
        TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
        PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
        VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
      };
      function get_rels_path(file) {
        var n = file.lastIndexOf("/");
        return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
      }
      function parse_rels(data, currentFilePath) {
        var rels = { "!id": {} };
        if (!data)
          return rels;
        if (currentFilePath.charAt(0) !== "/") {
          currentFilePath = "/" + currentFilePath;
        }
        var hash = {};
        (data.match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          if (y[0] === "<Relationship") {
            var rel = {};
            rel.Type = y.Type;
            rel.Target = y.Target;
            rel.Id = y.Id;
            if (y.TargetMode)
              rel.TargetMode = y.TargetMode;
            var canonictarget = y.TargetMode === "External" ? y.Target : resolve_path(y.Target, currentFilePath);
            rels[canonictarget] = rel;
            hash[y.Id] = rel;
          }
        });
        rels["!id"] = hash;
        return rels;
      }
      var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
      function parse_manifest(d, opts) {
        var str = xlml_normalize(d);
        var Rn;
        var FEtag;
        while (Rn = xlmlregex.exec(str))
          switch (Rn[3]) {
            case "manifest":
              break;
            case "file-entry":
              FEtag = parsexmltag(Rn[0], false);
              if (FEtag.path == "/" && FEtag.type !== CT_ODS)
                throw new Error("This OpenDocument is not a spreadsheet");
              break;
            case "encryption-data":
            case "algorithm":
            case "start-key-generation":
            case "key-derivation":
              throw new Error("Unsupported ODS Encryption");
            default:
              if (opts && opts.WTF)
                throw Rn;
          }
      }
      var CORE_PROPS = [
        ["cp:category", "Category"],
        ["cp:contentStatus", "ContentStatus"],
        ["cp:keywords", "Keywords"],
        ["cp:lastModifiedBy", "LastAuthor"],
        ["cp:lastPrinted", "LastPrinted"],
        ["cp:revision", "RevNumber"],
        ["cp:version", "Version"],
        ["dc:creator", "Author"],
        ["dc:description", "Comments"],
        ["dc:identifier", "Identifier"],
        ["dc:language", "Language"],
        ["dc:subject", "Subject"],
        ["dc:title", "Title"],
        ["dcterms:created", "CreatedDate", "date"],
        ["dcterms:modified", "ModifiedDate", "date"]
      ];
      var CORE_PROPS_REGEX = /* @__PURE__ */ function() {
        var r = new Array(CORE_PROPS.length);
        for (var i = 0; i < CORE_PROPS.length; ++i) {
          var f = CORE_PROPS[i];
          var g = "(?:" + f[0].slice(0, f[0].indexOf(":")) + ":)" + f[0].slice(f[0].indexOf(":") + 1);
          r[i] = new RegExp("<" + g + "[^>]*>([\\s\\S]*?)</" + g + ">");
        }
        return r;
      }();
      function parse_core_props(data) {
        var p2 = {};
        data = utf8read(data);
        for (var i = 0; i < CORE_PROPS.length; ++i) {
          var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);
          if (cur != null && cur.length > 0)
            p2[f[1]] = unescapexml(cur[1]);
          if (f[2] === "date" && p2[f[1]])
            p2[f[1]] = parseDate(p2[f[1]]);
        }
        return p2;
      }
      var EXT_PROPS = [
        ["Application", "Application", "string"],
        ["AppVersion", "AppVersion", "string"],
        ["Company", "Company", "string"],
        ["DocSecurity", "DocSecurity", "string"],
        ["Manager", "Manager", "string"],
        ["HyperlinksChanged", "HyperlinksChanged", "bool"],
        ["SharedDoc", "SharedDoc", "bool"],
        ["LinksUpToDate", "LinksUpToDate", "bool"],
        ["ScaleCrop", "ScaleCrop", "bool"],
        ["HeadingPairs", "HeadingPairs", "raw"],
        ["TitlesOfParts", "TitlesOfParts", "raw"]
      ];
      function load_props_pairs(HP, TOP, props, opts) {
        var v = [];
        if (typeof HP == "string")
          v = parseVector(HP, opts);
        else
          for (var j = 0; j < HP.length; ++j)
            v = v.concat(HP[j].map(function(hp) {
              return { v: hp };
            }));
        var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x) {
          return x.v;
        }) : TOP;
        var idx = 0, len2 = 0;
        if (parts.length > 0)
          for (var i = 0; i !== v.length; i += 2) {
            len2 = +v[i + 1].v;
            switch (v[i].v) {
              case "Worksheets":
              case "":
              case "":
              case " ":
              case "":
              case " ":
              case "Arbeitsbltter":
              case "alma Sayfalar":
              case "Feuilles de calcul":
              case "Fogli di lavoro":
              case "Folhas de clculo":
              case "Planilhas":
              case "Regneark":
              case "Hojas de clculo":
              case "Werkbladen":
                props.Worksheets = len2;
                props.SheetNames = parts.slice(idx, idx + len2);
                break;
              case "Named Ranges":
              case "Rangos con nombre":
              case "":
              case "Benannte Bereiche":
              case "Navngivne omrder":
                props.NamedRanges = len2;
                props.DefinedNames = parts.slice(idx, idx + len2);
                break;
              case "Charts":
              case "Diagramme":
                props.Chartsheets = len2;
                props.ChartNames = parts.slice(idx, idx + len2);
                break;
            }
            idx += len2;
          }
      }
      function parse_ext_props(data, p2, opts) {
        var q = {};
        if (!p2)
          p2 = {};
        data = utf8read(data);
        EXT_PROPS.forEach(function(f) {
          var xml = (data.match(matchtag(f[0])) || [])[1];
          switch (f[2]) {
            case "string":
              if (xml)
                p2[f[1]] = unescapexml(xml);
              break;
            case "bool":
              p2[f[1]] = xml === "true";
              break;
            case "raw":
              var cur = data.match(new RegExp("<" + f[0] + "[^>]*>([\\s\\S]*?)</" + f[0] + ">"));
              if (cur && cur.length > 0)
                q[f[1]] = cur[1];
              break;
          }
        });
        if (q.HeadingPairs && q.TitlesOfParts)
          load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p2, opts);
        return p2;
      }
      var custregex = /<[^>]+>[^<]*/g;
      function parse_cust_props(data, opts) {
        var p2 = {}, name = "";
        var m = data.match(custregex);
        if (m)
          for (var i = 0; i != m.length; ++i) {
            var x = m[i], y = parsexmltag(x);
            switch (y[0]) {
              case "<?xml":
                break;
              case "<Properties":
                break;
              case "<property":
                name = unescapexml(y.name);
                break;
              case "</property>":
                name = null;
                break;
              default:
                if (x.indexOf("<vt:") === 0) {
                  var toks = x.split(">");
                  var type2 = toks[0].slice(4), text = toks[1];
                  switch (type2) {
                    case "lpstr":
                    case "bstr":
                    case "lpwstr":
                      p2[name] = unescapexml(text);
                      break;
                    case "bool":
                      p2[name] = parsexmlbool(text);
                      break;
                    case "i1":
                    case "i2":
                    case "i4":
                    case "i8":
                    case "int":
                    case "uint":
                      p2[name] = parseInt(text, 10);
                      break;
                    case "r4":
                    case "r8":
                    case "decimal":
                      p2[name] = parseFloat(text);
                      break;
                    case "filetime":
                    case "date":
                      p2[name] = parseDate(text);
                      break;
                    case "cy":
                    case "error":
                      p2[name] = unescapexml(text);
                      break;
                    default:
                      if (type2.slice(-1) == "/")
                        break;
                      if (opts.WTF && typeof console !== "undefined")
                        console.warn("Unexpected", x, type2, toks);
                  }
                } else if (x.slice(0, 2) === "</")
                  ;
                else if (opts.WTF)
                  throw new Error(x);
            }
          }
        return p2;
      }
      var XLMLDocPropsMap = {
        Title: "Title",
        Subject: "Subject",
        Author: "Author",
        Keywords: "Keywords",
        Comments: "Description",
        LastAuthor: "LastAuthor",
        RevNumber: "Revision",
        Application: "AppName",
        /* TotalTime: 'TotalTime', */
        LastPrinted: "LastPrinted",
        CreatedDate: "Created",
        ModifiedDate: "LastSaved",
        /* Pages */
        /* Words */
        /* Characters */
        Category: "Category",
        /* PresentationFormat */
        Manager: "Manager",
        Company: "Company",
        /* Guid */
        /* HyperlinkBase */
        /* Bytes */
        /* Lines */
        /* Paragraphs */
        /* CharactersWithSpaces */
        AppVersion: "Version",
        ContentStatus: "ContentStatus",
        /* NOTE: missing from schema */
        Identifier: "Identifier",
        /* NOTE: missing from schema */
        Language: "Language"
        /* NOTE: missing from schema */
      };
      var evert_XLMLDPM;
      function xlml_set_prop(Props, tag, val) {
        if (!evert_XLMLDPM)
          evert_XLMLDPM = evert(XLMLDocPropsMap);
        tag = evert_XLMLDPM[tag] || tag;
        Props[tag] = val;
      }
      function parse_FILETIME(blob) {
        var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
        return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
      }
      function parse_lpstr(blob, type2, pad) {
        var start = blob.l;
        var str = blob.read_shift(0, "lpstr-cp");
        if (pad)
          while (blob.l - start & 3)
            ++blob.l;
        return str;
      }
      function parse_lpwstr(blob, type2, pad) {
        var str = blob.read_shift(0, "lpwstr");
        if (pad)
          blob.l += 4 - (str.length + 1 & 3) & 3;
        return str;
      }
      function parse_VtStringBase(blob, stringType, pad) {
        if (stringType === 31)
          return parse_lpwstr(blob);
        return parse_lpstr(blob, stringType, pad);
      }
      function parse_VtString(blob, t, pad) {
        return parse_VtStringBase(blob, t, pad === false ? 0 : 4);
      }
      function parse_VtUnalignedString(blob, t) {
        if (!t)
          throw new Error("VtUnalignedString must have positive length");
        return parse_VtStringBase(blob, t, 0);
      }
      function parse_VtVecLpwstrValue(blob) {
        var length = blob.read_shift(4);
        var ret = [];
        for (var i = 0; i != length; ++i) {
          var start = blob.l;
          ret[i] = blob.read_shift(0, "lpwstr").replace(chr0, "");
          if (blob.l - start & 2)
            blob.l += 2;
        }
        return ret;
      }
      function parse_VtVecUnalignedLpstrValue(blob) {
        var length = blob.read_shift(4);
        var ret = [];
        for (var i = 0; i != length; ++i)
          ret[i] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
        return ret;
      }
      function parse_VtHeadingPair(blob) {
        var start = blob.l;
        var headingString = parse_TypedPropertyValue(blob, VT_USTR);
        if (blob[blob.l] == 0 && blob[blob.l + 1] == 0 && blob.l - start & 2)
          blob.l += 2;
        var headerParts = parse_TypedPropertyValue(blob, VT_I4);
        return [headingString, headerParts];
      }
      function parse_VtVecHeadingPairValue(blob) {
        var cElements = blob.read_shift(4);
        var out = [];
        for (var i = 0; i < cElements / 2; ++i)
          out.push(parse_VtHeadingPair(blob));
        return out;
      }
      function parse_dictionary(blob, CodePage) {
        var cnt = blob.read_shift(4);
        var dict = {};
        for (var j = 0; j != cnt; ++j) {
          var pid = blob.read_shift(4);
          var len2 = blob.read_shift(4);
          dict[pid] = blob.read_shift(len2, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
          if (CodePage === 1200 && len2 % 2)
            blob.l += 2;
        }
        if (blob.l & 3)
          blob.l = blob.l >> 2 + 1 << 2;
        return dict;
      }
      function parse_BLOB(blob) {
        var size2 = blob.read_shift(4);
        var bytes = blob.slice(blob.l, blob.l + size2);
        blob.l += size2;
        if ((size2 & 3) > 0)
          blob.l += 4 - (size2 & 3) & 3;
        return bytes;
      }
      function parse_ClipboardData(blob) {
        var o = {};
        o.Size = blob.read_shift(4);
        blob.l += o.Size + 3 - (o.Size - 1) % 4;
        return o;
      }
      function parse_TypedPropertyValue(blob, type2, _opts) {
        var t = blob.read_shift(2), ret, opts = _opts || {};
        blob.l += 2;
        if (type2 !== VT_VARIANT) {
          if (t !== type2 && VT_CUSTOM.indexOf(type2) === -1 && !((type2 & 65534) == 4126 && (t & 65534) == 4126))
            throw new Error("Expected type " + type2 + " saw " + t);
        }
        switch (type2 === VT_VARIANT ? t : type2) {
          case 2:
            ret = blob.read_shift(2, "i");
            if (!opts.raw)
              blob.l += 2;
            return ret;
          case 3:
            ret = blob.read_shift(4, "i");
            return ret;
          case 11:
            return blob.read_shift(4) !== 0;
          case 19:
            ret = blob.read_shift(4);
            return ret;
          case 30:
            return parse_lpstr(blob, t, 4).replace(chr0, "");
          case 31:
            return parse_lpwstr(blob);
          case 64:
            return parse_FILETIME(blob);
          case 65:
            return parse_BLOB(blob);
          case 71:
            return parse_ClipboardData(blob);
          case 80:
            return parse_VtString(blob, t, !opts.raw).replace(chr0, "");
          case 81:
            return parse_VtUnalignedString(
              blob,
              t
              /*, 4*/
            ).replace(chr0, "");
          case 4108:
            return parse_VtVecHeadingPairValue(blob);
          case 4126:
          case 4127:
            return t == 4127 ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);
          default:
            throw new Error("TypedPropertyValue unrecognized type " + type2 + " " + t);
        }
      }
      function parse_PropertySet(blob, PIDSI) {
        var start_addr = blob.l;
        var size2 = blob.read_shift(4);
        var NumProps = blob.read_shift(4);
        var Props = [], i = 0;
        var CodePage = 0;
        var Dictionary = -1, DictObj = {};
        for (i = 0; i != NumProps; ++i) {
          var PropID = blob.read_shift(4);
          var Offset = blob.read_shift(4);
          Props[i] = [PropID, Offset + start_addr];
        }
        Props.sort(function(x, y) {
          return x[1] - y[1];
        });
        var PropH = {};
        for (i = 0; i != NumProps; ++i) {
          if (blob.l !== Props[i][1]) {
            var fail = true;
            if (i > 0 && PIDSI)
              switch (PIDSI[Props[i - 1][0]].t) {
                case 2:
                  if (blob.l + 2 === Props[i][1]) {
                    blob.l += 2;
                    fail = false;
                  }
                  break;
                case 80:
                  if (blob.l <= Props[i][1]) {
                    blob.l = Props[i][1];
                    fail = false;
                  }
                  break;
                case 4108:
                  if (blob.l <= Props[i][1]) {
                    blob.l = Props[i][1];
                    fail = false;
                  }
                  break;
              }
            if ((!PIDSI || i == 0) && blob.l <= Props[i][1]) {
              fail = false;
              blob.l = Props[i][1];
            }
            if (fail)
              throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob.l + " :" + i);
          }
          if (PIDSI) {
            var piddsi = PIDSI[Props[i][0]];
            PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, { raw: true });
            if (piddsi.p === "version")
              PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
            if (piddsi.n == "CodePage")
              switch (PropH[piddsi.n]) {
                case 0:
                  PropH[piddsi.n] = 1252;
                case 874:
                case 932:
                case 936:
                case 949:
                case 950:
                case 1250:
                case 1251:
                case 1253:
                case 1254:
                case 1255:
                case 1256:
                case 1257:
                case 1258:
                case 1e4:
                case 1200:
                case 1201:
                case 1252:
                case 65e3:
                case -536:
                case 65001:
                case -535:
                  set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
                  break;
                default:
                  throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
              }
          } else {
            if (Props[i][0] === 1) {
              CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
              set_cp(CodePage);
              if (Dictionary !== -1) {
                var oldpos = blob.l;
                blob.l = Props[Dictionary][1];
                DictObj = parse_dictionary(blob, CodePage);
                blob.l = oldpos;
              }
            } else if (Props[i][0] === 0) {
              if (CodePage === 0) {
                Dictionary = i;
                blob.l = Props[i + 1][1];
                continue;
              }
              DictObj = parse_dictionary(blob, CodePage);
            } else {
              var name = DictObj[Props[i][0]];
              var val;
              switch (blob[blob.l]) {
                case 65:
                  blob.l += 4;
                  val = parse_BLOB(blob);
                  break;
                case 30:
                  blob.l += 4;
                  val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
                  break;
                case 31:
                  blob.l += 4;
                  val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
                  break;
                case 3:
                  blob.l += 4;
                  val = blob.read_shift(4, "i");
                  break;
                case 19:
                  blob.l += 4;
                  val = blob.read_shift(4);
                  break;
                case 5:
                  blob.l += 4;
                  val = blob.read_shift(8, "f");
                  break;
                case 11:
                  blob.l += 4;
                  val = parsebool(blob, 4);
                  break;
                case 64:
                  blob.l += 4;
                  val = parseDate(parse_FILETIME(blob));
                  break;
                default:
                  throw new Error("unparsed value: " + blob[blob.l]);
              }
              PropH[name] = val;
            }
          }
        }
        blob.l = start_addr + size2;
        return PropH;
      }
      function parse_PropertySetStream(file, PIDSI, clsid) {
        var blob = file.content;
        if (!blob)
          return {};
        prep_blob(blob, 0);
        var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
        blob.chk("feff", "Byte Order: ");
        blob.read_shift(2);
        var SystemIdentifier = blob.read_shift(4);
        var CLSID = blob.read_shift(16);
        if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid)
          throw new Error("Bad PropertySet CLSID " + CLSID);
        NumSets = blob.read_shift(4);
        if (NumSets !== 1 && NumSets !== 2)
          throw new Error("Unrecognized #Sets: " + NumSets);
        FMTID0 = blob.read_shift(16);
        Offset0 = blob.read_shift(4);
        if (NumSets === 1 && Offset0 !== blob.l)
          throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);
        else if (NumSets === 2) {
          FMTID1 = blob.read_shift(16);
          Offset1 = blob.read_shift(4);
        }
        var PSet0 = parse_PropertySet(blob, PIDSI);
        var rval = { SystemIdentifier };
        for (var y in PSet0)
          rval[y] = PSet0[y];
        rval.FMTID = FMTID0;
        if (NumSets === 1)
          return rval;
        if (Offset1 - blob.l == 2)
          blob.l += 2;
        if (blob.l !== Offset1)
          throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
        var PSet1;
        try {
          PSet1 = parse_PropertySet(blob, null);
        } catch (e) {
        }
        for (y in PSet1)
          rval[y] = PSet1[y];
        rval.FMTID = [FMTID0, FMTID1];
        return rval;
      }
      function parsenoop2(blob, length) {
        blob.read_shift(length);
        return null;
      }
      function parslurp(blob, length, cb) {
        var arr = [], target = blob.l + length;
        while (blob.l < target)
          arr.push(cb(blob, target - blob.l));
        if (target !== blob.l)
          throw new Error("Slurp error");
        return arr;
      }
      function parsebool(blob, length) {
        return blob.read_shift(length) === 1;
      }
      function parseuint16(blob) {
        return blob.read_shift(2, "u");
      }
      function parseuint16a(blob, length) {
        return parslurp(blob, length, parseuint16);
      }
      function parse_Bes(blob) {
        var v = blob.read_shift(1), t = blob.read_shift(1);
        return t === 1 ? v : v === 1;
      }
      function parse_ShortXLUnicodeString(blob, length, opts) {
        var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
        var encoding = "sbcs-cont";
        if (opts && opts.biff >= 8)
          ;
        if (!opts || opts.biff == 8) {
          var fHighByte = blob.read_shift(1);
          if (fHighByte) {
            encoding = "dbcs-cont";
          }
        } else if (opts.biff == 12) {
          encoding = "wstr";
        }
        if (opts.biff >= 2 && opts.biff <= 5)
          encoding = "cpstr";
        var o = cch ? blob.read_shift(cch, encoding) : "";
        return o;
      }
      function parse_XLUnicodeRichExtendedString(blob) {
        var cch = blob.read_shift(2), flags = blob.read_shift(1);
        var fExtSt = flags & 4, fRichSt = flags & 8;
        var width = 1 + (flags & 1);
        var cRun = 0, cbExtRst;
        var z = {};
        if (fRichSt)
          cRun = blob.read_shift(2);
        if (fExtSt)
          cbExtRst = blob.read_shift(4);
        var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
        var msg2 = cch === 0 ? "" : blob.read_shift(cch, encoding);
        if (fRichSt)
          blob.l += 4 * cRun;
        if (fExtSt)
          blob.l += cbExtRst;
        z.t = msg2;
        if (!fRichSt) {
          z.raw = "<t>" + z.t + "</t>";
          z.r = z.t;
        }
        return z;
      }
      function parse_XLUnicodeStringNoCch(blob, cch, opts) {
        var retval;
        if (opts) {
          if (opts.biff >= 2 && opts.biff <= 5)
            return blob.read_shift(cch, "cpstr");
          if (opts.biff >= 12)
            return blob.read_shift(cch, "dbcs-cont");
        }
        var fHighByte = blob.read_shift(1);
        if (fHighByte === 0) {
          retval = blob.read_shift(cch, "sbcs-cont");
        } else {
          retval = blob.read_shift(cch, "dbcs-cont");
        }
        return retval;
      }
      function parse_XLUnicodeString(blob, length, opts) {
        var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        if (cch === 0) {
          blob.l++;
          return "";
        }
        return parse_XLUnicodeStringNoCch(blob, cch, opts);
      }
      function parse_XLUnicodeString2(blob, length, opts) {
        if (opts.biff > 5)
          return parse_XLUnicodeString(blob, length, opts);
        var cch = blob.read_shift(1);
        if (cch === 0) {
          blob.l++;
          return "";
        }
        return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
      }
      function parse_ControlInfo(blob) {
        var flags = blob.read_shift(1);
        blob.l++;
        var accel = blob.read_shift(2);
        blob.l += 2;
        return [flags, accel];
      }
      function parse_URLMoniker(blob) {
        var len2 = blob.read_shift(4), start = blob.l;
        var extra = false;
        if (len2 > 24) {
          blob.l += len2 - 24;
          if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763")
            extra = true;
          blob.l = start;
        }
        var url = blob.read_shift((extra ? len2 - 24 : len2) >> 1, "utf16le").replace(chr0, "");
        if (extra)
          blob.l += 24;
        return url;
      }
      function parse_FileMoniker(blob) {
        var cAnti = blob.read_shift(2);
        var preamble = "";
        while (cAnti-- > 0)
          preamble += "../";
        var ansiPath = blob.read_shift(0, "lpstr-ansi");
        blob.l += 2;
        if (blob.read_shift(2) != 57005)
          throw new Error("Bad FileMoniker");
        var sz = blob.read_shift(4);
        if (sz === 0)
          return preamble + ansiPath.replace(/\\/g, "/");
        var bytes = blob.read_shift(4);
        if (blob.read_shift(2) != 3)
          throw new Error("Bad FileMoniker");
        var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
        return preamble + unicodePath;
      }
      function parse_HyperlinkMoniker(blob, length) {
        var clsid = blob.read_shift(16);
        switch (clsid) {
          case "e0c9ea79f9bace118c8200aa004ba90b":
            return parse_URLMoniker(blob);
          case "0303000000000000c000000000000046":
            return parse_FileMoniker(blob);
          default:
            throw new Error("Unsupported Moniker " + clsid);
        }
      }
      function parse_HyperlinkString(blob) {
        var len2 = blob.read_shift(4);
        var o = len2 > 0 ? blob.read_shift(len2, "utf16le").replace(chr0, "") : "";
        return o;
      }
      function parse_Hyperlink(blob, length) {
        var end = blob.l + length;
        var sVer = blob.read_shift(4);
        if (sVer !== 2)
          throw new Error("Unrecognized streamVersion: " + sVer);
        var flags = blob.read_shift(2);
        blob.l += 2;
        var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
        if (flags & 16)
          displayName = parse_HyperlinkString(blob, end - blob.l);
        if (flags & 128)
          targetFrameName = parse_HyperlinkString(blob, end - blob.l);
        if ((flags & 257) === 257)
          moniker = parse_HyperlinkString(blob, end - blob.l);
        if ((flags & 257) === 1)
          oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
        if (flags & 8)
          Loc = parse_HyperlinkString(blob, end - blob.l);
        if (flags & 32)
          guid = blob.read_shift(16);
        if (flags & 64)
          fileTime = parse_FILETIME(
            blob
            /*, 8*/
          );
        blob.l = end;
        var target = targetFrameName || moniker || oleMoniker || "";
        if (target && Loc)
          target += "#" + Loc;
        if (!target)
          target = "#" + Loc;
        if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/")
          target = "file://" + target;
        var out = { Target: target };
        if (guid)
          out.guid = guid;
        if (fileTime)
          out.time = fileTime;
        if (displayName)
          out.Tooltip = displayName;
        return out;
      }
      function parse_LongRGBA(blob) {
        var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a2 = blob.read_shift(1);
        return [r, g, b, a2];
      }
      function parse_LongRGB(blob, length) {
        var x = parse_LongRGBA(blob);
        x[3] = 0;
        return x;
      }
      function parse_XLSCell(blob) {
        var rw = blob.read_shift(2);
        var col = blob.read_shift(2);
        var ixfe = blob.read_shift(2);
        return { r: rw, c: col, ixfe };
      }
      function parse_frtHeader(blob) {
        var rt = blob.read_shift(2);
        var flags = blob.read_shift(2);
        blob.l += 8;
        return { type: rt, flags };
      }
      function parse_OptXLUnicodeString(blob, length, opts) {
        return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
      }
      function parse_XTI(blob, length, opts) {
        var w = opts.biff > 8 ? 4 : 2;
        var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
        return [iSupBook, itabFirst, itabLast];
      }
      function parse_RkRec(blob) {
        var ixfe = blob.read_shift(2);
        var RK = parse_RkNumber(blob);
        return [ixfe, RK];
      }
      function parse_AddinUdf(blob, length, opts) {
        blob.l += 4;
        length -= 4;
        var l = blob.l + length;
        var udfName = parse_ShortXLUnicodeString(blob, length, opts);
        var cb = blob.read_shift(2);
        l -= blob.l;
        if (cb !== l)
          throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);
        blob.l += cb;
        return udfName;
      }
      function parse_Ref8U(blob) {
        var rwFirst = blob.read_shift(2);
        var rwLast = blob.read_shift(2);
        var colFirst = blob.read_shift(2);
        var colLast = blob.read_shift(2);
        return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
      }
      function parse_RefU(blob) {
        var rwFirst = blob.read_shift(2);
        var rwLast = blob.read_shift(2);
        var colFirst = blob.read_shift(1);
        var colLast = blob.read_shift(1);
        return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
      }
      var parse_Ref = parse_RefU;
      function parse_FtCmo(blob) {
        blob.l += 4;
        var ot = blob.read_shift(2);
        var id = blob.read_shift(2);
        var flags = blob.read_shift(2);
        blob.l += 12;
        return [id, ot, flags];
      }
      function parse_FtNts(blob) {
        var out = {};
        blob.l += 4;
        blob.l += 16;
        out.fSharedNote = blob.read_shift(2);
        blob.l += 4;
        return out;
      }
      function parse_FtCf(blob) {
        var out = {};
        blob.l += 4;
        blob.cf = blob.read_shift(2);
        return out;
      }
      function parse_FtSkip(blob) {
        blob.l += 2;
        blob.l += blob.read_shift(2);
      }
      var FtTab = {
        /*::[*/
        0: parse_FtSkip,
        /* FtEnd */
        /*::[*/
        4: parse_FtSkip,
        /* FtMacro */
        /*::[*/
        5: parse_FtSkip,
        /* FtButton */
        /*::[*/
        6: parse_FtSkip,
        /* FtGmo */
        /*::[*/
        7: parse_FtCf,
        /* FtCf */
        /*::[*/
        8: parse_FtSkip,
        /* FtPioGrbit */
        /*::[*/
        9: parse_FtSkip,
        /* FtPictFmla */
        /*::[*/
        10: parse_FtSkip,
        /* FtCbls */
        /*::[*/
        11: parse_FtSkip,
        /* FtRbo */
        /*::[*/
        12: parse_FtSkip,
        /* FtSbs */
        /*::[*/
        13: parse_FtNts,
        /* FtNts */
        /*::[*/
        14: parse_FtSkip,
        /* FtSbsFmla */
        /*::[*/
        15: parse_FtSkip,
        /* FtGboData */
        /*::[*/
        16: parse_FtSkip,
        /* FtEdoData */
        /*::[*/
        17: parse_FtSkip,
        /* FtRboData */
        /*::[*/
        18: parse_FtSkip,
        /* FtCblsData */
        /*::[*/
        19: parse_FtSkip,
        /* FtLbsData */
        /*::[*/
        20: parse_FtSkip,
        /* FtCblsFmla */
        /*::[*/
        21: parse_FtCmo
      };
      function parse_FtArray(blob, length) {
        var tgt = blob.l + length;
        var fts = [];
        while (blob.l < tgt) {
          var ft = blob.read_shift(2);
          blob.l -= 2;
          try {
            fts.push(FtTab[ft](blob, tgt - blob.l));
          } catch (e) {
            blob.l = tgt;
            return fts;
          }
        }
        if (blob.l != tgt)
          blob.l = tgt;
        return fts;
      }
      function parse_BOF(blob, length) {
        var o = { BIFFVer: 0, dt: 0 };
        o.BIFFVer = blob.read_shift(2);
        length -= 2;
        if (length >= 2) {
          o.dt = blob.read_shift(2);
          blob.l -= 2;
        }
        switch (o.BIFFVer) {
          case 1536:
          case 1280:
          case 1024:
          case 768:
          case 512:
          case 2:
          case 7:
            break;
          default:
            if (length > 6)
              throw new Error("Unexpected BIFF Ver " + o.BIFFVer);
        }
        blob.read_shift(length);
        return o;
      }
      function parse_InterfaceHdr(blob, length) {
        if (length === 0)
          return 1200;
        if (blob.read_shift(2) !== 1200)
          ;
        return 1200;
      }
      function parse_WriteAccess(blob, length, opts) {
        if (opts.enc) {
          blob.l += length;
          return "";
        }
        var l = blob.l;
        var UserName = parse_XLUnicodeString2(blob, 0, opts);
        blob.read_shift(length + l - blob.l);
        return UserName;
      }
      function parse_WsBool(blob, length, opts) {
        var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);
        return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
      }
      function parse_BoundSheet8(blob, length, opts) {
        var pos = blob.read_shift(4);
        var hidden = blob.read_shift(1) & 3;
        var dt = blob.read_shift(1);
        switch (dt) {
          case 0:
            dt = "Worksheet";
            break;
          case 1:
            dt = "Macrosheet";
            break;
          case 2:
            dt = "Chartsheet";
            break;
          case 6:
            dt = "VBAModule";
            break;
        }
        var name = parse_ShortXLUnicodeString(blob, 0, opts);
        if (name.length === 0)
          name = "Sheet1";
        return { pos, hs: hidden, dt, name };
      }
      function parse_SST(blob, length) {
        var end = blob.l + length;
        var cnt = blob.read_shift(4);
        var ucnt = blob.read_shift(4);
        var strs2 = [];
        for (var i = 0; i != ucnt && blob.l < end; ++i) {
          strs2.push(parse_XLUnicodeRichExtendedString(blob));
        }
        strs2.Count = cnt;
        strs2.Unique = ucnt;
        return strs2;
      }
      function parse_ExtSST(blob, length) {
        var extsst = {};
        extsst.dsst = blob.read_shift(2);
        blob.l += length - 2;
        return extsst;
      }
      function parse_Row(blob) {
        var z = {};
        z.r = blob.read_shift(2);
        z.c = blob.read_shift(2);
        z.cnt = blob.read_shift(2) - z.c;
        var miyRw = blob.read_shift(2);
        blob.l += 4;
        var flags = blob.read_shift(1);
        blob.l += 3;
        if (flags & 7)
          z.level = flags & 7;
        if (flags & 32)
          z.hidden = true;
        if (flags & 64)
          z.hpt = miyRw / 20;
        return z;
      }
      function parse_ForceFullCalculation(blob) {
        var header = parse_frtHeader(blob);
        if (header.type != 2211)
          throw new Error("Invalid Future Record " + header.type);
        var fullcalc = blob.read_shift(4);
        return fullcalc !== 0;
      }
      function parse_RecalcId(blob) {
        blob.read_shift(2);
        return blob.read_shift(4);
      }
      function parse_DefaultRowHeight(blob, length, opts) {
        var f = 0;
        if (!(opts && opts.biff == 2)) {
          f = blob.read_shift(2);
        }
        var miyRw = blob.read_shift(2);
        if (opts && opts.biff == 2) {
          f = 1 - (miyRw >> 15);
          miyRw &= 32767;
        }
        var fl = { Unsynced: f & 1, DyZero: (f & 2) >> 1, ExAsc: (f & 4) >> 2, ExDsc: (f & 8) >> 3 };
        return [fl, miyRw];
      }
      function parse_Window1(blob) {
        var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
        var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
        var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
        return {
          Pos: [xWn, yWn],
          Dim: [dxWn, dyWn],
          Flags: flags,
          CurTab: iTabCur,
          FirstTab: iTabFirst,
          Selected: ctabSel,
          TabRatio: wTabRatio
        };
      }
      function parse_Window2(blob, length, opts) {
        if (opts && opts.biff >= 2 && opts.biff < 5)
          return {};
        var f = blob.read_shift(2);
        return { RTL: f & 64 };
      }
      function parse_Pane() {
      }
      function parse_Font(blob, length, opts) {
        var o = {
          dyHeight: blob.read_shift(2),
          fl: blob.read_shift(2)
        };
        switch (opts && opts.biff || 8) {
          case 2:
            break;
          case 3:
          case 4:
            blob.l += 2;
            break;
          default:
            blob.l += 10;
            break;
        }
        o.name = parse_ShortXLUnicodeString(blob, 0, opts);
        return o;
      }
      function parse_LabelSst(blob) {
        var cell = parse_XLSCell(blob);
        cell.isst = blob.read_shift(4);
        return cell;
      }
      function parse_Label(blob, length, opts) {
        if (opts.biffguess && opts.biff == 2)
          opts.biff = 5;
        var target = blob.l + length;
        var cell = parse_XLSCell(blob);
        if (opts.biff == 2)
          blob.l++;
        var str = parse_XLUnicodeString(blob, target - blob.l, opts);
        cell.val = str;
        return cell;
      }
      function parse_Format(blob, length, opts) {
        var numFmtId = blob.read_shift(2);
        var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
        return [numFmtId, fmtstr];
      }
      var parse_BIFF2Format = parse_XLUnicodeString2;
      function parse_Dimensions(blob, length, opts) {
        var end = blob.l + length;
        var w = opts.biff == 8 || !opts.biff ? 4 : 2;
        var r = blob.read_shift(w), R = blob.read_shift(w);
        var c2 = blob.read_shift(2), C = blob.read_shift(2);
        blob.l = end;
        return { s: { r, c: c2 }, e: { r: R, c: C } };
      }
      function parse_RK(blob) {
        var rw = blob.read_shift(2), col = blob.read_shift(2);
        var rkrec = parse_RkRec(blob);
        return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
      }
      function parse_MulRk(blob, length) {
        var target = blob.l + length - 2;
        var rw = blob.read_shift(2), col = blob.read_shift(2);
        var rkrecs = [];
        while (blob.l < target)
          rkrecs.push(parse_RkRec(blob));
        if (blob.l !== target)
          throw new Error("MulRK read error");
        var lastcol = blob.read_shift(2);
        if (rkrecs.length != lastcol - col + 1)
          throw new Error("MulRK length mismatch");
        return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
      }
      function parse_MulBlank(blob, length) {
        var target = blob.l + length - 2;
        var rw = blob.read_shift(2), col = blob.read_shift(2);
        var ixfes = [];
        while (blob.l < target)
          ixfes.push(blob.read_shift(2));
        if (blob.l !== target)
          throw new Error("MulBlank read error");
        var lastcol = blob.read_shift(2);
        if (ixfes.length != lastcol - col + 1)
          throw new Error("MulBlank length mismatch");
        return { r: rw, c: col, C: lastcol, ixfe: ixfes };
      }
      function parse_CellStyleXF(blob, length, style2, opts) {
        var o = {};
        var a2 = blob.read_shift(4), b = blob.read_shift(4);
        var c2 = blob.read_shift(4), d = blob.read_shift(2);
        o.patternType = XLSFillPattern[c2 >> 26];
        if (!opts.cellStyles)
          return o;
        o.alc = a2 & 7;
        o.fWrap = a2 >> 3 & 1;
        o.alcV = a2 >> 4 & 7;
        o.fJustLast = a2 >> 7 & 1;
        o.trot = a2 >> 8 & 255;
        o.cIndent = a2 >> 16 & 15;
        o.fShrinkToFit = a2 >> 20 & 1;
        o.iReadOrder = a2 >> 22 & 2;
        o.fAtrNum = a2 >> 26 & 1;
        o.fAtrFnt = a2 >> 27 & 1;
        o.fAtrAlc = a2 >> 28 & 1;
        o.fAtrBdr = a2 >> 29 & 1;
        o.fAtrPat = a2 >> 30 & 1;
        o.fAtrProt = a2 >> 31 & 1;
        o.dgLeft = b & 15;
        o.dgRight = b >> 4 & 15;
        o.dgTop = b >> 8 & 15;
        o.dgBottom = b >> 12 & 15;
        o.icvLeft = b >> 16 & 127;
        o.icvRight = b >> 23 & 127;
        o.grbitDiag = b >> 30 & 3;
        o.icvTop = c2 & 127;
        o.icvBottom = c2 >> 7 & 127;
        o.icvDiag = c2 >> 14 & 127;
        o.dgDiag = c2 >> 21 & 15;
        o.icvFore = d & 127;
        o.icvBack = d >> 7 & 127;
        o.fsxButton = d >> 14 & 1;
        return o;
      }
      function parse_XF(blob, length, opts) {
        var o = {};
        o.ifnt = blob.read_shift(2);
        o.numFmtId = blob.read_shift(2);
        o.flags = blob.read_shift(2);
        o.fStyle = o.flags >> 2 & 1;
        length -= 6;
        o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);
        return o;
      }
      function parse_Guts(blob) {
        blob.l += 4;
        var out = [blob.read_shift(2), blob.read_shift(2)];
        if (out[0] !== 0)
          out[0]--;
        if (out[1] !== 0)
          out[1]--;
        if (out[0] > 7 || out[1] > 7)
          throw new Error("Bad Gutters: " + out.join("|"));
        return out;
      }
      function parse_BoolErr(blob, length, opts) {
        var cell = parse_XLSCell(blob);
        if (opts.biff == 2 || length == 9)
          ++blob.l;
        var val = parse_Bes(blob);
        cell.val = val;
        cell.t = val === true || val === false ? "b" : "e";
        return cell;
      }
      function parse_Number(blob, length, opts) {
        if (opts.biffguess && opts.biff == 2)
          opts.biff = 5;
        var cell = parse_XLSCell(blob);
        var xnum = parse_Xnum(blob);
        cell.val = xnum;
        return cell;
      }
      var parse_XLHeaderFooter = parse_OptXLUnicodeString;
      function parse_SupBook(blob, length, opts) {
        var end = blob.l + length;
        var ctab = blob.read_shift(2);
        var cch = blob.read_shift(2);
        opts.sbcch = cch;
        if (cch == 1025 || cch == 14849)
          return [cch, ctab];
        if (cch < 1 || cch > 255)
          throw new Error("Unexpected SupBook type: " + cch);
        var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
        var rgst = [];
        while (end > blob.l)
          rgst.push(parse_XLUnicodeString(blob));
        return [cch, ctab, virtPath, rgst];
      }
      function parse_ExternName(blob, length, opts) {
        var flags = blob.read_shift(2);
        var body;
        var o = {
          fBuiltIn: flags & 1,
          fWantAdvise: flags >>> 1 & 1,
          fWantPict: flags >>> 2 & 1,
          fOle: flags >>> 3 & 1,
          fOleLink: flags >>> 4 & 1,
          cf: flags >>> 5 & 1023,
          fIcon: flags >>> 15 & 1
        };
        if (opts.sbcch === 14849)
          body = parse_AddinUdf(blob, length - 2, opts);
        o.body = body || blob.read_shift(length - 2);
        if (typeof body === "string")
          o.Name = body;
        return o;
      }
      var XLSLblBuiltIn = [
        "_xlnm.Consolidate_Area",
        "_xlnm.Auto_Open",
        "_xlnm.Auto_Close",
        "_xlnm.Extract",
        "_xlnm.Database",
        "_xlnm.Criteria",
        "_xlnm.Print_Area",
        "_xlnm.Print_Titles",
        "_xlnm.Recorder",
        "_xlnm.Data_Form",
        "_xlnm.Auto_Activate",
        "_xlnm.Auto_Deactivate",
        "_xlnm.Sheet_Title",
        "_xlnm._FilterDatabase"
      ];
      function parse_Lbl(blob, length, opts) {
        var target = blob.l + length;
        var flags = blob.read_shift(2);
        var chKey = blob.read_shift(1);
        var cch = blob.read_shift(1);
        var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        var itab = 0;
        if (!opts || opts.biff >= 5) {
          if (opts.biff != 5)
            blob.l += 2;
          itab = blob.read_shift(2);
          if (opts.biff == 5)
            blob.l += 2;
          blob.l += 4;
        }
        var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
        if (flags & 32)
          name = XLSLblBuiltIn[name.charCodeAt(0)];
        var npflen = target - blob.l;
        if (opts && opts.biff == 2)
          --npflen;
        var rgce = target == blob.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
        return {
          chKey,
          Name: name,
          itab,
          rgce
        };
      }
      function parse_ExternSheet(blob, length, opts) {
        if (opts.biff < 8)
          return parse_BIFF5ExternSheet(blob, length, opts);
        var o = [], target = blob.l + length, len2 = blob.read_shift(opts.biff > 8 ? 4 : 2);
        while (len2-- !== 0)
          o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
        if (blob.l != target)
          throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
        return o;
      }
      function parse_BIFF5ExternSheet(blob, length, opts) {
        if (blob[blob.l + 1] == 3)
          blob[blob.l]++;
        var o = parse_ShortXLUnicodeString(blob, length, opts);
        return o.charCodeAt(0) == 3 ? o.slice(1) : o;
      }
      function parse_NameCmt(blob, length, opts) {
        if (opts.biff < 8) {
          blob.l += length;
          return;
        }
        var cchName = blob.read_shift(2);
        var cchComment = blob.read_shift(2);
        var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
        var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
        return [name, comment];
      }
      function parse_ShrFmla(blob, length, opts) {
        var ref2 = parse_RefU(blob);
        blob.l++;
        var cUse = blob.read_shift(1);
        length -= 8;
        return [parse_SharedParsedFormula(blob, length, opts), cUse, ref2];
      }
      function parse_Array(blob, length, opts) {
        var ref2 = parse_Ref(blob);
        switch (opts.biff) {
          case 2:
            blob.l++;
            length -= 7;
            break;
          case 3:
          case 4:
            blob.l += 2;
            length -= 8;
            break;
          default:
            blob.l += 6;
            length -= 12;
        }
        return [ref2, parse_ArrayParsedFormula(blob, length, opts)];
      }
      function parse_MTRSettings(blob) {
        var fMTREnabled = blob.read_shift(4) !== 0;
        var fUserSetThreadCount = blob.read_shift(4) !== 0;
        var cUserThreadCount = blob.read_shift(4);
        return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
      }
      function parse_NoteSh(blob, length, opts) {
        if (opts.biff < 8)
          return;
        var row = blob.read_shift(2), col = blob.read_shift(2);
        var flags = blob.read_shift(2), idObj = blob.read_shift(2);
        var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
        if (opts.biff < 8)
          blob.read_shift(1);
        return [{ r: row, c: col }, stAuthor, idObj, flags];
      }
      function parse_Note(blob, length, opts) {
        return parse_NoteSh(blob, length, opts);
      }
      function parse_MergeCells(blob, length) {
        var merges = [];
        var cmcs = blob.read_shift(2);
        while (cmcs--)
          merges.push(parse_Ref8U(blob));
        return merges;
      }
      function parse_Obj(blob, length, opts) {
        if (opts && opts.biff < 8)
          return parse_BIFF5Obj(blob, length, opts);
        var cmo = parse_FtCmo(blob);
        var fts = parse_FtArray(blob, length - 22, cmo[1]);
        return { cmo, ft: fts };
      }
      var parse_BIFF5OT = {
        8: function(blob, length) {
          var tgt = blob.l + length;
          blob.l += 10;
          var cf = blob.read_shift(2);
          blob.l += 4;
          blob.l += 2;
          blob.l += 2;
          blob.l += 2;
          blob.l += 4;
          var cchName = blob.read_shift(1);
          blob.l += cchName;
          blob.l = tgt;
          return { fmt: cf };
        }
      };
      function parse_BIFF5Obj(blob, length, opts) {
        blob.l += 4;
        var ot = blob.read_shift(2);
        var id = blob.read_shift(2);
        var grbit = blob.read_shift(2);
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 2;
        blob.l += 6;
        length -= 36;
        var fts = [];
        fts.push((parse_BIFF5OT[ot] || parsenoop)(blob, length, opts));
        return { cmo: [id, ot, grbit], ft: fts };
      }
      function parse_TxO(blob, length, opts) {
        var s = blob.l;
        var texts = "";
        try {
          blob.l += 4;
          var ot = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
          var controlInfo;
          if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1)
            blob.l += 6;
          else
            controlInfo = parse_ControlInfo(blob, 6, opts);
          var cchText = blob.read_shift(2);
          blob.read_shift(2);
          parseuint16(blob, 2);
          var len2 = blob.read_shift(2);
          blob.l += len2;
          for (var i = 1; i < blob.lens.length - 1; ++i) {
            if (blob.l - s != blob.lens[i])
              throw new Error("TxO: bad continue record");
            var hdr = blob[blob.l];
            var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i + 1] - blob.lens[i] - 1);
            texts += t;
            if (texts.length >= (hdr ? cchText : 2 * cchText))
              break;
          }
          if (texts.length !== cchText && texts.length !== cchText * 2) {
            throw new Error("cchText: " + cchText + " != " + texts.length);
          }
          blob.l = s + length;
          return { t: texts };
        } catch (e) {
          blob.l = s + length;
          return { t: texts };
        }
      }
      function parse_HLink(blob, length) {
        var ref2 = parse_Ref8U(blob);
        blob.l += 16;
        var hlink = parse_Hyperlink(blob, length - 24);
        return [ref2, hlink];
      }
      function parse_HLinkTooltip(blob, length) {
        blob.read_shift(2);
        var ref2 = parse_Ref8U(blob);
        var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
        wzTooltip = wzTooltip.replace(chr0, "");
        return [ref2, wzTooltip];
      }
      function parse_Country(blob) {
        var o = [0, 0], d;
        d = blob.read_shift(2);
        o[0] = CountryEnum[d] || d;
        d = blob.read_shift(2);
        o[1] = CountryEnum[d] || d;
        return o;
      }
      function parse_ClrtClient(blob) {
        var ccv = blob.read_shift(2);
        var o = [];
        while (ccv-- > 0)
          o.push(parse_LongRGB(blob));
        return o;
      }
      function parse_Palette(blob) {
        var ccv = blob.read_shift(2);
        var o = [];
        while (ccv-- > 0)
          o.push(parse_LongRGB(blob));
        return o;
      }
      function parse_XFCRC(blob) {
        blob.l += 2;
        var o = { cxfs: 0, crc: 0 };
        o.cxfs = blob.read_shift(2);
        o.crc = blob.read_shift(4);
        return o;
      }
      function parse_ColInfo(blob, length, opts) {
        if (!opts.cellStyles)
          return parsenoop(blob, length);
        var w = opts && opts.biff >= 12 ? 4 : 2;
        var colFirst = blob.read_shift(w);
        var colLast = blob.read_shift(w);
        var coldx = blob.read_shift(w);
        var ixfe = blob.read_shift(w);
        var flags = blob.read_shift(2);
        if (w == 2)
          blob.l += 2;
        var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
        if (opts.biff >= 5 || !opts.biff)
          o.level = flags >> 8 & 7;
        return o;
      }
      function parse_Setup(blob, length) {
        var o = {};
        if (length < 32)
          return o;
        blob.l += 16;
        o.header = parse_Xnum(blob);
        o.footer = parse_Xnum(blob);
        blob.l += 2;
        return o;
      }
      function parse_ShtProps(blob, length, opts) {
        var def = { area: false };
        if (opts.biff != 5) {
          blob.l += length;
          return def;
        }
        var d = blob.read_shift(1);
        blob.l += 3;
        if (d & 16)
          def.area = true;
        return def;
      }
      var parse_Blank = parse_XLSCell;
      var parse_Scl = parseuint16a;
      var parse_String = parse_XLUnicodeString;
      function parse_ImData(blob) {
        var cf = blob.read_shift(2);
        var env = blob.read_shift(2);
        var lcb = blob.read_shift(4);
        var o = { fmt: cf, env, len: lcb, data: blob.slice(blob.l, blob.l + lcb) };
        blob.l += lcb;
        return o;
      }
      function parse_BIFF2STR(blob, length, opts) {
        if (opts.biffguess && opts.biff == 5)
          opts.biff = 2;
        var cell = parse_XLSCell(blob);
        ++blob.l;
        var str = parse_XLUnicodeString2(blob, length - 7, opts);
        cell.t = "str";
        cell.val = str;
        return cell;
      }
      function parse_BIFF2NUM(blob) {
        var cell = parse_XLSCell(blob);
        ++blob.l;
        var num = parse_Xnum(blob);
        cell.t = "n";
        cell.val = num;
        return cell;
      }
      function parse_BIFF2INT(blob) {
        var cell = parse_XLSCell(blob);
        ++blob.l;
        var num = blob.read_shift(2);
        cell.t = "n";
        cell.val = num;
        return cell;
      }
      function parse_BIFF2STRING(blob) {
        var cch = blob.read_shift(1);
        if (cch === 0) {
          blob.l++;
          return "";
        }
        return blob.read_shift(cch, "sbcs-cont");
      }
      function parse_BIFF2FONTXTRA(blob, length) {
        blob.l += 6;
        blob.l += 2;
        blob.l += 1;
        blob.l += 3;
        blob.l += 1;
        blob.l += length - 13;
      }
      function parse_RString(blob, length, opts) {
        var end = blob.l + length;
        var cell = parse_XLSCell(blob);
        var cch = blob.read_shift(2);
        var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
        blob.l = end;
        cell.t = "str";
        cell.val = str;
        return cell;
      }
      var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
      var DBF = /* @__PURE__ */ function() {
        var dbf_codepage_map = {
          /* Code Pages Supported by Visual FoxPro */
          /*::[*/
          1: 437,
          /*::[*/
          2: 850,
          /*::[*/
          3: 1252,
          /*::[*/
          4: 1e4,
          /*::[*/
          100: 852,
          /*::[*/
          101: 866,
          /*::[*/
          102: 865,
          /*::[*/
          103: 861,
          /*::[*/
          104: 895,
          /*::[*/
          105: 620,
          /*::[*/
          106: 737,
          /*::[*/
          107: 857,
          /*::[*/
          120: 950,
          /*::[*/
          121: 949,
          /*::[*/
          122: 936,
          /*::[*/
          123: 932,
          /*::[*/
          124: 874,
          /*::[*/
          125: 1255,
          /*::[*/
          126: 1256,
          /*::[*/
          150: 10007,
          /*::[*/
          151: 10029,
          /*::[*/
          152: 10006,
          /*::[*/
          200: 1250,
          /*::[*/
          201: 1251,
          /*::[*/
          202: 1254,
          /*::[*/
          203: 1253,
          /* shapefile DBF extension */
          /*::[*/
          0: 20127,
          /*::[*/
          8: 865,
          /*::[*/
          9: 437,
          /*::[*/
          10: 850,
          /*::[*/
          11: 437,
          /*::[*/
          13: 437,
          /*::[*/
          14: 850,
          /*::[*/
          15: 437,
          /*::[*/
          16: 850,
          /*::[*/
          17: 437,
          /*::[*/
          18: 850,
          /*::[*/
          19: 932,
          /*::[*/
          20: 850,
          /*::[*/
          21: 437,
          /*::[*/
          22: 850,
          /*::[*/
          23: 865,
          /*::[*/
          24: 437,
          /*::[*/
          25: 437,
          /*::[*/
          26: 850,
          /*::[*/
          27: 437,
          /*::[*/
          28: 863,
          /*::[*/
          29: 850,
          /*::[*/
          31: 852,
          /*::[*/
          34: 852,
          /*::[*/
          35: 852,
          /*::[*/
          36: 860,
          /*::[*/
          37: 850,
          /*::[*/
          38: 866,
          /*::[*/
          55: 850,
          /*::[*/
          64: 852,
          /*::[*/
          77: 936,
          /*::[*/
          78: 949,
          /*::[*/
          79: 950,
          /*::[*/
          80: 874,
          /*::[*/
          87: 1252,
          /*::[*/
          88: 1252,
          /*::[*/
          89: 1252,
          /*::[*/
          108: 863,
          /*::[*/
          134: 737,
          /*::[*/
          135: 852,
          /*::[*/
          136: 857,
          /*::[*/
          204: 1257,
          /*::[*/
          255: 16969
        };
        var dbf_reverse_map = evert({
          /*::[*/
          1: 437,
          /*::[*/
          2: 850,
          /*::[*/
          3: 1252,
          /*::[*/
          4: 1e4,
          /*::[*/
          100: 852,
          /*::[*/
          101: 866,
          /*::[*/
          102: 865,
          /*::[*/
          103: 861,
          /*::[*/
          104: 895,
          /*::[*/
          105: 620,
          /*::[*/
          106: 737,
          /*::[*/
          107: 857,
          /*::[*/
          120: 950,
          /*::[*/
          121: 949,
          /*::[*/
          122: 936,
          /*::[*/
          123: 932,
          /*::[*/
          124: 874,
          /*::[*/
          125: 1255,
          /*::[*/
          126: 1256,
          /*::[*/
          150: 10007,
          /*::[*/
          151: 10029,
          /*::[*/
          152: 10006,
          /*::[*/
          200: 1250,
          /*::[*/
          201: 1251,
          /*::[*/
          202: 1254,
          /*::[*/
          203: 1253,
          /*::[*/
          0: 20127
        });
        function dbf_to_aoa(buf, opts) {
          var out = [];
          var d = new_raw_buf(1);
          switch (opts.type) {
            case "base64":
              d = s2a(Base64_decode(buf));
              break;
            case "binary":
              d = s2a(buf);
              break;
            case "buffer":
            case "array":
              d = buf;
              break;
          }
          prep_blob(d, 0);
          var ft = d.read_shift(1);
          var memo = !!(ft & 136);
          var vfp = false, l7 = false;
          switch (ft) {
            case 2:
              break;
            case 3:
              break;
            case 48:
              vfp = true;
              memo = true;
              break;
            case 49:
              vfp = true;
              memo = true;
              break;
            case 131:
              break;
            case 139:
              break;
            case 140:
              l7 = true;
              break;
            case 245:
              break;
            default:
              throw new Error("DBF Unsupported Version: " + ft.toString(16));
          }
          var nrow = 0, fpos = 521;
          if (ft == 2)
            nrow = d.read_shift(2);
          d.l += 3;
          if (ft != 2)
            nrow = d.read_shift(4);
          if (nrow > 1048576)
            nrow = 1e6;
          if (ft != 2)
            fpos = d.read_shift(2);
          var rlen = d.read_shift(2);
          var current_cp = opts.codepage || 1252;
          if (ft != 2) {
            d.l += 16;
            d.read_shift(1);
            if (d[d.l] !== 0)
              current_cp = dbf_codepage_map[d[d.l]];
            d.l += 1;
            d.l += 2;
          }
          if (l7)
            d.l += 36;
          var fields = [], field = {};
          var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
          var ww = l7 ? 32 : 11;
          while (d.l < hend && d[d.l] != 13) {
            field = {};
            field.name = $cptable.utils.decode(current_cp, d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n].*$/g, "");
            d.l += ww;
            field.type = String.fromCharCode(d.read_shift(1));
            if (ft != 2 && !l7)
              field.offset = d.read_shift(4);
            field.len = d.read_shift(1);
            if (ft == 2)
              field.offset = d.read_shift(2);
            field.dec = d.read_shift(1);
            if (field.name.length)
              fields.push(field);
            if (ft != 2)
              d.l += l7 ? 13 : 14;
            switch (field.type) {
              case "B":
                if ((!vfp || field.len != 8) && opts.WTF)
                  console.log("Skipping " + field.name + ":" + field.type);
                break;
              case "G":
              case "P":
                if (opts.WTF)
                  console.log("Skipping " + field.name + ":" + field.type);
                break;
              case "+":
              case "0":
              case "@":
              case "C":
              case "D":
              case "F":
              case "I":
              case "L":
              case "M":
              case "N":
              case "O":
              case "T":
              case "Y":
                break;
              default:
                throw new Error("Unknown Field Type: " + field.type);
            }
          }
          if (d[d.l] !== 13)
            d.l = fpos - 1;
          if (d.read_shift(1) !== 13)
            throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
          d.l = fpos;
          var R = 0, C = 0;
          out[0] = [];
          for (C = 0; C != fields.length; ++C)
            out[0][C] = fields[C].name;
          while (nrow-- > 0) {
            if (d[d.l] === 42) {
              d.l += rlen;
              continue;
            }
            ++d.l;
            out[++R] = [];
            C = 0;
            for (C = 0; C != fields.length; ++C) {
              var dd = d.slice(d.l, d.l + fields[C].len);
              d.l += fields[C].len;
              prep_blob(dd, 0);
              var s = $cptable.utils.decode(current_cp, dd);
              switch (fields[C].type) {
                case "C":
                  if (s.trim().length)
                    out[R][C] = s.replace(/\s+$/, "");
                  break;
                case "D":
                  if (s.length === 8)
                    out[R][C] = new Date(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8));
                  else
                    out[R][C] = s;
                  break;
                case "F":
                  out[R][C] = parseFloat(s.trim());
                  break;
                case "+":
                case "I":
                  out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
                  break;
                case "L":
                  switch (s.trim().toUpperCase()) {
                    case "Y":
                    case "T":
                      out[R][C] = true;
                      break;
                    case "N":
                    case "F":
                      out[R][C] = false;
                      break;
                    case "":
                    case "?":
                      break;
                    default:
                      throw new Error("DBF Unrecognized L:|" + s + "|");
                  }
                  break;
                case "M":
                  if (!memo)
                    throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
                  out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
                  break;
                case "N":
                  s = s.replace(/\u0000/g, "").trim();
                  if (s && s != ".")
                    out[R][C] = +s || 0;
                  break;
                case "@":
                  out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
                  break;
                case "T":
                  out[R][C] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
                  break;
                case "Y":
                  out[R][C] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
                  break;
                case "O":
                  out[R][C] = -dd.read_shift(-8, "f");
                  break;
                case "B":
                  if (vfp && fields[C].len == 8) {
                    out[R][C] = dd.read_shift(8, "f");
                    break;
                  }
                case "G":
                case "P":
                  dd.l += fields[C].len;
                  break;
                case "0":
                  if (fields[C].name === "_NullFlags")
                    break;
                default:
                  throw new Error("DBF Unsupported data type " + fields[C].type);
              }
            }
          }
          if (ft != 2) {
            if (d.l < d.length && d[d.l++] != 26)
              throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
          }
          if (opts && opts.sheetRows)
            out = out.slice(0, opts.sheetRows);
          opts.DBF = fields;
          return out;
        }
        function dbf_to_sheet(buf, opts) {
          var o = opts || {};
          if (!o.dateNF)
            o.dateNF = "yyyymmdd";
          var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
          ws["!cols"] = o.DBF.map(function(field) {
            return {
              wch: field.len,
              DBF: field
            };
          });
          delete o.DBF;
          return ws;
        }
        function dbf_to_workbook(buf, opts) {
          try {
            return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
          } catch (e) {
            if (opts && opts.WTF)
              throw e;
          }
          return { SheetNames: [], Sheets: {} };
        }
        var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
        function sheet_to_dbf(ws, opts) {
          var o = opts || {};
          if (+o.codepage >= 0)
            set_cp(+o.codepage);
          if (o.type == "string")
            throw new Error("Cannot write DBF to JS string");
          var ba = buf_array();
          var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
          var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
          var i = 0, j = 0, hcnt = 0, rlen = 1;
          for (i = 0; i < headers.length; ++i) {
            if (((cols[i] || {}).DBF || {}).name) {
              headers[i] = cols[i].DBF.name;
              ++hcnt;
              continue;
            }
            if (headers[i] == null)
              continue;
            ++hcnt;
            if (typeof headers[i] === "number")
              headers[i] = headers[i].toString(10);
            if (typeof headers[i] !== "string")
              throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
            if (headers.indexOf(headers[i]) !== i) {
              for (j = 0; j < 1024; ++j)
                if (headers.indexOf(headers[i] + "_" + j) == -1) {
                  headers[i] += "_" + j;
                  break;
                }
            }
          }
          var range2 = safe_decode_range(ws["!ref"]);
          var coltypes = [];
          var colwidths = [];
          var coldecimals = [];
          for (i = 0; i <= range2.e.c - range2.s.c; ++i) {
            var guess = "", _guess = "", maxlen = 0;
            var col = [];
            for (j = 0; j < data.length; ++j) {
              if (data[j][i] != null)
                col.push(data[j][i]);
            }
            if (col.length == 0 || headers[i] == null) {
              coltypes[i] = "?";
              continue;
            }
            for (j = 0; j < col.length; ++j) {
              switch (typeof col[j]) {
                case "number":
                  _guess = "B";
                  break;
                case "string":
                  _guess = "C";
                  break;
                case "boolean":
                  _guess = "L";
                  break;
                case "object":
                  _guess = col[j] instanceof Date ? "D" : "C";
                  break;
                default:
                  _guess = "C";
              }
              maxlen = Math.max(maxlen, String(col[j]).length);
              guess = guess && guess != _guess ? "C" : _guess;
            }
            if (maxlen > 250)
              maxlen = 250;
            _guess = ((cols[i] || {}).DBF || {}).type;
            if (_guess == "C") {
              if (cols[i].DBF.len > maxlen)
                maxlen = cols[i].DBF.len;
            }
            if (guess == "B" && _guess == "N") {
              guess = "N";
              coldecimals[i] = cols[i].DBF.dec;
              maxlen = cols[i].DBF.len;
            }
            colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
            rlen += colwidths[i];
            coltypes[i] = guess;
          }
          var h2 = ba.next(32);
          h2.write_shift(4, 318902576);
          h2.write_shift(4, data.length);
          h2.write_shift(2, 296 + 32 * hcnt);
          h2.write_shift(2, rlen);
          for (i = 0; i < 4; ++i)
            h2.write_shift(4, 0);
          h2.write_shift(4, 0 | (+dbf_reverse_map[
            /*::String(*/
            current_ansi
            /*::)*/
          ] || 3) << 8);
          for (i = 0, j = 0; i < headers.length; ++i) {
            if (headers[i] == null)
              continue;
            var hf = ba.next(32);
            var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
            hf.write_shift(1, _f, "sbcs");
            hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
            hf.write_shift(4, j);
            hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
            hf.write_shift(1, coldecimals[i] || 0);
            hf.write_shift(1, 2);
            hf.write_shift(4, 0);
            hf.write_shift(1, 0);
            hf.write_shift(4, 0);
            hf.write_shift(4, 0);
            j += colwidths[i] || _RLEN[coltypes[i]] || 0;
          }
          var hb = ba.next(264);
          hb.write_shift(4, 13);
          for (i = 0; i < 65; ++i)
            hb.write_shift(4, 0);
          for (i = 0; i < data.length; ++i) {
            var rout = ba.next(rlen);
            rout.write_shift(1, 0);
            for (j = 0; j < headers.length; ++j) {
              if (headers[j] == null)
                continue;
              switch (coltypes[j]) {
                case "L":
                  rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
                  break;
                case "B":
                  rout.write_shift(8, data[i][j] || 0, "f");
                  break;
                case "N":
                  var _n = "0";
                  if (typeof data[i][j] == "number")
                    _n = data[i][j].toFixed(coldecimals[j] || 0);
                  for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt)
                    rout.write_shift(1, 32);
                  rout.write_shift(1, _n, "sbcs");
                  break;
                case "D":
                  if (!data[i][j])
                    rout.write_shift(8, "00000000", "sbcs");
                  else {
                    rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
                    rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
                    rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
                  }
                  break;
                case "C":
                  var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
                  rout.write_shift(1, _s, "sbcs");
                  for (hcnt = 0; hcnt < colwidths[j] - _s.length; ++hcnt)
                    rout.write_shift(1, 32);
                  break;
              }
            }
          }
          ba.next(1).write_shift(1, 26);
          return ba.end();
        }
        return {
          to_workbook: dbf_to_workbook,
          to_sheet: dbf_to_sheet,
          from_sheet: sheet_to_dbf
        };
      }();
      var SYLK = /* @__PURE__ */ function() {
        var sylk_escapes = {
          AA: "",
          BA: "",
          CA: "",
          DA: 195,
          HA: "",
          JA: 197,
          AE: "",
          BE: "",
          CE: "",
          HE: "",
          AI: "",
          BI: "",
          CI: "",
          HI: "",
          AO: "",
          BO: "",
          CO: "",
          DO: 213,
          HO: "",
          AU: "",
          BU: "",
          CU: "",
          HU: "",
          Aa: "",
          Ba: "",
          Ca: "",
          Da: 227,
          Ha: "",
          Ja: 229,
          Ae: "",
          Be: "",
          Ce: "",
          He: "",
          Ai: "",
          Bi: "",
          Ci: "",
          Hi: "",
          Ao: "",
          Bo: "",
          Co: "",
          Do: 245,
          Ho: "",
          Au: "",
          Bu: "",
          Cu: "",
          Hu: "",
          KC: "",
          Kc: "",
          q: "",
          z: "",
          a: "",
          j: "",
          DN: 209,
          Dn: 241,
          Hy: 255,
          S: 169,
          c: 170,
          R: 174,
          "B ": 180,
          /*::[*/
          0: 176,
          /*::[*/
          1: 177,
          /*::[*/
          2: 178,
          /*::[*/
          3: 179,
          /*::[*/
          5: 181,
          /*::[*/
          6: 182,
          /*::[*/
          7: 183,
          Q: 185,
          k: 186,
          b: 208,
          i: 216,
          l: 222,
          s: 240,
          y: 248,
          "!": 161,
          '"': 162,
          "#": 163,
          "(": 164,
          "%": 165,
          "'": 167,
          "H ": 168,
          "+": 171,
          ";": 187,
          "<": 188,
          "=": 189,
          ">": 190,
          "?": 191,
          "{": 223
        };
        var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
        var sylk_char_fn = function(_, $1) {
          var o = sylk_escapes[$1];
          return typeof o == "number" ? _getansi(o) : o;
        };
        var decode_sylk_char = function($$, $1, $2) {
          var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
          return newcc == 59 ? $$ : _getansi(newcc);
        };
        sylk_escapes["|"] = 254;
        function sylk_to_aoa(d, opts) {
          switch (opts.type) {
            case "base64":
              return sylk_to_aoa_str(Base64_decode(d), opts);
            case "binary":
              return sylk_to_aoa_str(d, opts);
            case "buffer":
              return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
            case "array":
              return sylk_to_aoa_str(cc2str(d), opts);
          }
          throw new Error("Unrecognized type " + opts.type);
        }
        function sylk_to_aoa_str(str, opts) {
          var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
          var formats = [];
          var next_cell_format = null;
          var sht = {}, rowinfo = [], colinfo = [], cw = [];
          var Mval = 0, j;
          if (+opts.codepage >= 0)
            set_cp(+opts.codepage);
          for (; ri !== records.length; ++ri) {
            Mval = 0;
            var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
            var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
              return x.replace(/\u0000/g, ";");
            });
            var RT = record[0], val;
            if (rstr.length > 0)
              switch (RT) {
                case "ID":
                  break;
                case "E":
                  break;
                case "B":
                  break;
                case "O":
                  break;
                case "W":
                  break;
                case "P":
                  if (record[1].charAt(0) == "P")
                    formats.push(rstr.slice(3).replace(/;;/g, ";"));
                  break;
                case "C":
                  var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
                  for (rj = 1; rj < record.length; ++rj)
                    switch (record[rj].charAt(0)) {
                      case "A":
                        break;
                      case "X":
                        C = parseInt(record[rj].slice(1)) - 1;
                        C_seen_X = true;
                        break;
                      case "Y":
                        R = parseInt(record[rj].slice(1)) - 1;
                        if (!C_seen_X)
                          C = 0;
                        for (j = arr.length; j <= R; ++j)
                          arr[j] = [];
                        break;
                      case "K":
                        val = record[rj].slice(1);
                        if (val.charAt(0) === '"')
                          val = val.slice(1, val.length - 1);
                        else if (val === "TRUE")
                          val = true;
                        else if (val === "FALSE")
                          val = false;
                        else if (!isNaN(fuzzynum(val))) {
                          val = fuzzynum(val);
                          if (next_cell_format !== null && fmt_is_date(next_cell_format))
                            val = numdate(val);
                        } else if (!isNaN(fuzzydate(val).getDate())) {
                          val = parseDate(val);
                        }
                        C_seen_K = true;
                        break;
                      case "E":
                        C_seen_E = true;
                        var formula = rc_to_a1(record[rj].slice(1), { r: R, c: C });
                        arr[R][C] = [arr[R][C], formula];
                        break;
                      case "S":
                        C_seen_S = true;
                        arr[R][C] = [arr[R][C], "S5S"];
                        break;
                      case "G":
                        break;
                      case "R":
                        _R = parseInt(record[rj].slice(1)) - 1;
                        break;
                      case "C":
                        _C = parseInt(record[rj].slice(1)) - 1;
                        break;
                      default:
                        if (opts && opts.WTF)
                          throw new Error("SYLK bad record " + rstr);
                    }
                  if (C_seen_K) {
                    if (arr[R][C] && arr[R][C].length == 2)
                      arr[R][C][0] = val;
                    else
                      arr[R][C] = val;
                    next_cell_format = null;
                  }
                  if (C_seen_S) {
                    if (C_seen_E)
                      throw new Error("SYLK shared formula cannot have own formula");
                    var shrbase = _R > -1 && arr[_R][_C];
                    if (!shrbase || !shrbase[1])
                      throw new Error("SYLK shared formula cannot find base");
                    arr[R][C][1] = shift_formula_str(shrbase[1], { r: R - _R, c: C - _C });
                  }
                  break;
                case "F":
                  var F_seen = 0;
                  for (rj = 1; rj < record.length; ++rj)
                    switch (record[rj].charAt(0)) {
                      case "X":
                        C = parseInt(record[rj].slice(1)) - 1;
                        ++F_seen;
                        break;
                      case "Y":
                        R = parseInt(record[rj].slice(1)) - 1;
                        for (j = arr.length; j <= R; ++j)
                          arr[j] = [];
                        break;
                      case "M":
                        Mval = parseInt(record[rj].slice(1)) / 20;
                        break;
                      case "F":
                        break;
                      case "G":
                        break;
                      case "P":
                        next_cell_format = formats[parseInt(record[rj].slice(1))];
                        break;
                      case "S":
                        break;
                      case "D":
                        break;
                      case "N":
                        break;
                      case "W":
                        cw = record[rj].slice(1).split(" ");
                        for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                          Mval = parseInt(cw[2], 10);
                          colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                          process_col(colinfo[j - 1]);
                        }
                        break;
                      case "C":
                        C = parseInt(record[rj].slice(1)) - 1;
                        if (!colinfo[C])
                          colinfo[C] = {};
                        break;
                      case "R":
                        R = parseInt(record[rj].slice(1)) - 1;
                        if (!rowinfo[R])
                          rowinfo[R] = {};
                        if (Mval > 0) {
                          rowinfo[R].hpt = Mval;
                          rowinfo[R].hpx = pt2px(Mval);
                        } else if (Mval === 0)
                          rowinfo[R].hidden = true;
                        break;
                      default:
                        if (opts && opts.WTF)
                          throw new Error("SYLK bad record " + rstr);
                    }
                  if (F_seen < 1)
                    next_cell_format = null;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
          }
          if (rowinfo.length > 0)
            sht["!rows"] = rowinfo;
          if (colinfo.length > 0)
            sht["!cols"] = colinfo;
          if (opts && opts.sheetRows)
            arr = arr.slice(0, opts.sheetRows);
          return [arr, sht];
        }
        function sylk_to_sheet(d, opts) {
          var aoasht = sylk_to_aoa(d, opts);
          var aoa = aoasht[0], ws = aoasht[1];
          var o = aoa_to_sheet(aoa, opts);
          keys(ws).forEach(function(k) {
            o[k] = ws[k];
          });
          return o;
        }
        function sylk_to_workbook(d, opts) {
          return sheet_to_workbook(sylk_to_sheet(d, opts), opts);
        }
        function write_ws_cell_sylk(cell, ws, R, C) {
          var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
          switch (cell.t) {
            case "n":
              o += cell.v || 0;
              if (cell.f && !cell.F)
                o += ";E" + a1_to_rc(cell.f, { r: R, c: C });
              break;
            case "b":
              o += cell.v ? "TRUE" : "FALSE";
              break;
            case "e":
              o += cell.w || cell.v;
              break;
            case "d":
              o += '"' + (cell.w || cell.v) + '"';
              break;
            case "s":
              o += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
              break;
          }
          return o;
        }
        function write_ws_cols_sylk(out, cols) {
          cols.forEach(function(col, i) {
            var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
            if (col.hidden)
              rec += "0";
            else {
              if (typeof col.width == "number" && !col.wpx)
                col.wpx = width2px(col.width);
              if (typeof col.wpx == "number" && !col.wch)
                col.wch = px2char(col.wpx);
              if (typeof col.wch == "number")
                rec += Math.round(col.wch);
            }
            if (rec.charAt(rec.length - 1) != " ")
              out.push(rec);
          });
        }
        function write_ws_rows_sylk(out, rows) {
          rows.forEach(function(row, i) {
            var rec = "F;";
            if (row.hidden)
              rec += "M0;";
            else if (row.hpt)
              rec += "M" + 20 * row.hpt + ";";
            else if (row.hpx)
              rec += "M" + 20 * px2pt(row.hpx) + ";";
            if (rec.length > 2)
              out.push(rec + "R" + (i + 1));
          });
        }
        function sheet_to_sylk(ws, opts) {
          var preamble = ["ID;PWXL;N;E"], o = [];
          var r = safe_decode_range(ws["!ref"]), cell;
          var dense = Array.isArray(ws);
          var RS = "\r\n";
          preamble.push("P;PGeneral");
          preamble.push("F;P0;DG0G8;M255");
          if (ws["!cols"])
            write_ws_cols_sylk(preamble, ws["!cols"]);
          if (ws["!rows"])
            write_ws_rows_sylk(preamble, ws["!rows"]);
          preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
          for (var R = r.s.r; R <= r.e.r; ++R) {
            for (var C = r.s.c; C <= r.e.c; ++C) {
              var coord = encode_cell({ r: R, c: C });
              cell = dense ? (ws[R] || [])[C] : ws[coord];
              if (!cell || cell.v == null && (!cell.f || cell.F))
                continue;
              o.push(write_ws_cell_sylk(cell, ws, R, C));
            }
          }
          return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
        }
        return {
          to_workbook: sylk_to_workbook,
          to_sheet: sylk_to_sheet,
          from_sheet: sheet_to_sylk
        };
      }();
      var DIF = /* @__PURE__ */ function() {
        function dif_to_aoa(d, opts) {
          switch (opts.type) {
            case "base64":
              return dif_to_aoa_str(Base64_decode(d), opts);
            case "binary":
              return dif_to_aoa_str(d, opts);
            case "buffer":
              return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
            case "array":
              return dif_to_aoa_str(cc2str(d), opts);
          }
          throw new Error("Unrecognized type " + opts.type);
        }
        function dif_to_aoa_str(str, opts) {
          var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
          for (; ri !== records.length; ++ri) {
            if (records[ri].trim() === "BOT") {
              arr[++R] = [];
              C = 0;
              continue;
            }
            if (R < 0)
              continue;
            var metadata = records[ri].trim().split(",");
            var type2 = metadata[0], value = metadata[1];
            ++ri;
            var data = records[ri] || "";
            while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1)
              data += "\n" + records[++ri];
            data = data.trim();
            switch (+type2) {
              case -1:
                if (data === "BOT") {
                  arr[++R] = [];
                  C = 0;
                  continue;
                } else if (data !== "EOD")
                  throw new Error("Unrecognized DIF special command " + data);
                break;
              case 0:
                if (data === "TRUE")
                  arr[R][C] = true;
                else if (data === "FALSE")
                  arr[R][C] = false;
                else if (!isNaN(fuzzynum(value)))
                  arr[R][C] = fuzzynum(value);
                else if (!isNaN(fuzzydate(value).getDate()))
                  arr[R][C] = parseDate(value);
                else
                  arr[R][C] = value;
                ++C;
                break;
              case 1:
                data = data.slice(1, data.length - 1);
                data = data.replace(/""/g, '"');
                if (data && data.match(/^=".*"$/))
                  data = data.slice(2, -1);
                arr[R][C++] = data !== "" ? data : null;
                break;
            }
            if (data === "EOD")
              break;
          }
          if (opts && opts.sheetRows)
            arr = arr.slice(0, opts.sheetRows);
          return arr;
        }
        function dif_to_sheet(str, opts) {
          return aoa_to_sheet(dif_to_aoa(str, opts), opts);
        }
        function dif_to_workbook(str, opts) {
          return sheet_to_workbook(dif_to_sheet(str, opts), opts);
        }
        var sheet_to_dif = /* @__PURE__ */ function() {
          var push_field = function pf(o, topic, v, n, s) {
            o.push(topic);
            o.push(v + "," + n);
            o.push('"' + s.replace(/"/g, '""') + '"');
          };
          var push_value = function po(o, type2, v, s) {
            o.push(type2 + "," + v);
            o.push(type2 == 1 ? '"' + s.replace(/"/g, '""') + '"' : s);
          };
          return function sheet_to_dif2(ws) {
            var o = [];
            var r = safe_decode_range(ws["!ref"]), cell;
            var dense = Array.isArray(ws);
            push_field(o, "TABLE", 0, 1, "sheetjs");
            push_field(o, "VECTORS", 0, r.e.r - r.s.r + 1, "");
            push_field(o, "TUPLES", 0, r.e.c - r.s.c + 1, "");
            push_field(o, "DATA", 0, 0, "");
            for (var R = r.s.r; R <= r.e.r; ++R) {
              push_value(o, -1, 0, "BOT");
              for (var C = r.s.c; C <= r.e.c; ++C) {
                var coord = encode_cell({ r: R, c: C });
                cell = dense ? (ws[R] || [])[C] : ws[coord];
                if (!cell) {
                  push_value(o, 1, 0, "");
                  continue;
                }
                switch (cell.t) {
                  case "n":
                    var val = cell.w;
                    if (!val && cell.v != null)
                      val = cell.v;
                    if (val == null) {
                      if (cell.f && !cell.F)
                        push_value(o, 1, 0, "=" + cell.f);
                      else
                        push_value(o, 1, 0, "");
                    } else
                      push_value(o, 0, val, "V");
                    break;
                  case "b":
                    push_value(o, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
                    break;
                  case "s":
                    push_value(o, 1, 0, isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
                    break;
                  case "d":
                    if (!cell.w)
                      cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
                    push_value(o, 0, cell.w, "V");
                    break;
                  default:
                    push_value(o, 1, 0, "");
                }
              }
            }
            push_value(o, -1, 0, "EOD");
            var RS = "\r\n";
            var oo = o.join(RS);
            return oo;
          };
        }();
        return {
          to_workbook: dif_to_workbook,
          to_sheet: dif_to_sheet,
          from_sheet: sheet_to_dif
        };
      }();
      var ETH = /* @__PURE__ */ function() {
        function decode(s) {
          return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
        }
        function encode2(s) {
          return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
        }
        function eth_to_aoa(str, opts) {
          var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
          for (; ri !== records.length; ++ri) {
            var record = records[ri].trim().split(":");
            if (record[0] !== "cell")
              continue;
            var addr = decode_cell(record[1]);
            if (arr.length <= addr.r) {
              for (R = arr.length; R <= addr.r; ++R)
                if (!arr[R])
                  arr[R] = [];
            }
            R = addr.r;
            C = addr.c;
            switch (record[2]) {
              case "t":
                arr[R][C] = decode(record[3]);
                break;
              case "v":
                arr[R][C] = +record[3];
                break;
              case "vtf":
                var _f = record[record.length - 1];
              case "vtc":
                switch (record[3]) {
                  case "nl":
                    arr[R][C] = +record[4] ? true : false;
                    break;
                  default:
                    arr[R][C] = +record[4];
                    break;
                }
                if (record[2] == "vtf")
                  arr[R][C] = [arr[R][C], _f];
            }
          }
          if (opts && opts.sheetRows)
            arr = arr.slice(0, opts.sheetRows);
          return arr;
        }
        function eth_to_sheet(d, opts) {
          return aoa_to_sheet(eth_to_aoa(d, opts), opts);
        }
        function eth_to_workbook(d, opts) {
          return sheet_to_workbook(eth_to_sheet(d, opts), opts);
        }
        var header = [
          "socialcalc:version:1.5",
          "MIME-Version: 1.0",
          "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
        ].join("\n");
        var sep = [
          "--SocialCalcSpreadsheetControlSave",
          "Content-type: text/plain; charset=UTF-8"
        ].join("\n") + "\n";
        var meta = [
          "# SocialCalc Spreadsheet Control Save",
          "part:sheet"
        ].join("\n");
        var end = "--SocialCalcSpreadsheetControlSave--";
        function sheet_to_eth_data(ws) {
          if (!ws || !ws["!ref"])
            return "";
          var o = [], oo = [], cell, coord = "";
          var r = decode_range(ws["!ref"]);
          var dense = Array.isArray(ws);
          for (var R = r.s.r; R <= r.e.r; ++R) {
            for (var C = r.s.c; C <= r.e.c; ++C) {
              coord = encode_cell({ r: R, c: C });
              cell = dense ? (ws[R] || [])[C] : ws[coord];
              if (!cell || cell.v == null || cell.t === "z")
                continue;
              oo = ["cell", coord, "t"];
              switch (cell.t) {
                case "s":
                case "str":
                  oo.push(encode2(cell.v));
                  break;
                case "n":
                  if (!cell.f) {
                    oo[2] = "v";
                    oo[3] = cell.v;
                  } else {
                    oo[2] = "vtf";
                    oo[3] = "n";
                    oo[4] = cell.v;
                    oo[5] = encode2(cell.f);
                  }
                  break;
                case "b":
                  oo[2] = "vt" + (cell.f ? "f" : "c");
                  oo[3] = "nl";
                  oo[4] = cell.v ? "1" : "0";
                  oo[5] = encode2(cell.f || (cell.v ? "TRUE" : "FALSE"));
                  break;
                case "d":
                  var t = datenum(parseDate(cell.v));
                  oo[2] = "vtc";
                  oo[3] = "nd";
                  oo[4] = "" + t;
                  oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
                  break;
                case "e":
                  continue;
              }
              o.push(oo.join(":"));
            }
          }
          o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
          o.push("valueformat:1:text-wiki");
          return o.join("\n");
        }
        function sheet_to_eth(ws) {
          return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
        }
        return {
          to_workbook: eth_to_workbook,
          to_sheet: eth_to_sheet,
          from_sheet: sheet_to_eth
        };
      }();
      var PRN = /* @__PURE__ */ function() {
        function set_text_arr(data, arr, R, C, o) {
          if (o.raw)
            arr[R][C] = data;
          else if (data === "")
            ;
          else if (data === "TRUE")
            arr[R][C] = true;
          else if (data === "FALSE")
            arr[R][C] = false;
          else if (!isNaN(fuzzynum(data)))
            arr[R][C] = fuzzynum(data);
          else if (!isNaN(fuzzydate(data).getDate()))
            arr[R][C] = parseDate(data);
          else
            arr[R][C] = data;
        }
        function prn_to_aoa_str(f, opts) {
          var o = opts || {};
          var arr = [];
          if (!f || f.length === 0)
            return arr;
          var lines = f.split(/[\r\n]/);
          var L = lines.length - 1;
          while (L >= 0 && lines[L].length === 0)
            --L;
          var start = 10, idx = 0;
          var R = 0;
          for (; R <= L; ++R) {
            idx = lines[R].indexOf(" ");
            if (idx == -1)
              idx = lines[R].length;
            else
              idx++;
            start = Math.max(start, idx);
          }
          for (R = 0; R <= L; ++R) {
            arr[R] = [];
            var C = 0;
            set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
            for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C)
              set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
          }
          if (o.sheetRows)
            arr = arr.slice(0, o.sheetRows);
          return arr;
        }
        var guess_seps = {
          /*::[*/
          44: ",",
          /*::[*/
          9: "	",
          /*::[*/
          59: ";",
          /*::[*/
          124: "|"
        };
        var guess_sep_weights = {
          /*::[*/
          44: 3,
          /*::[*/
          9: 2,
          /*::[*/
          59: 1,
          /*::[*/
          124: 0
        };
        function guess_sep(str) {
          var cnt = {}, instr = false, end = 0, cc = 0;
          for (; end < str.length; ++end) {
            if ((cc = str.charCodeAt(end)) == 34)
              instr = !instr;
            else if (!instr && cc in guess_seps)
              cnt[cc] = (cnt[cc] || 0) + 1;
          }
          cc = [];
          for (end in cnt)
            if (Object.prototype.hasOwnProperty.call(cnt, end)) {
              cc.push([cnt[end], end]);
            }
          if (!cc.length) {
            cnt = guess_sep_weights;
            for (end in cnt)
              if (Object.prototype.hasOwnProperty.call(cnt, end)) {
                cc.push([cnt[end], end]);
              }
          }
          cc.sort(function(a2, b) {
            return a2[0] - b[0] || guess_sep_weights[a2[1]] - guess_sep_weights[b[1]];
          });
          return guess_seps[cc.pop()[1]] || 44;
        }
        function dsv_to_sheet_str(str, opts) {
          var o = opts || {};
          var sep = "";
          var ws = o.dense ? [] : {};
          var range2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
          if (str.slice(0, 4) == "sep=") {
            if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
              sep = str.charAt(4);
              str = str.slice(7);
            } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
              sep = str.charAt(4);
              str = str.slice(6);
            } else
              sep = guess_sep(str.slice(0, 1024));
          } else if (o && o.FS)
            sep = o.FS;
          else
            sep = guess_sep(str.slice(0, 1024));
          var R = 0, C = 0, v = 0;
          var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
          str = str.replace(/\r\n/mg, "\n");
          var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
          function finish_cell() {
            var s = str.slice(start, end);
            var cell = {};
            if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"')
              s = s.slice(1, -1).replace(/""/g, '"');
            if (s.length === 0)
              cell.t = "z";
            else if (o.raw) {
              cell.t = "s";
              cell.v = s;
            } else if (s.trim().length === 0) {
              cell.t = "s";
              cell.v = s;
            } else if (s.charCodeAt(0) == 61) {
              if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
                cell.t = "s";
                cell.v = s.slice(2, -1).replace(/""/g, '"');
              } else if (fuzzyfmla(s)) {
                cell.t = "n";
                cell.f = s.slice(1);
              } else {
                cell.t = "s";
                cell.v = s;
              }
            } else if (s == "TRUE") {
              cell.t = "b";
              cell.v = true;
            } else if (s == "FALSE") {
              cell.t = "b";
              cell.v = false;
            } else if (!isNaN(v = fuzzynum(s))) {
              cell.t = "n";
              if (o.cellText !== false)
                cell.w = s;
              cell.v = v;
            } else if (!isNaN(fuzzydate(s).getDate()) || _re && s.match(_re)) {
              cell.z = o.dateNF || table_fmt[14];
              var k = 0;
              if (_re && s.match(_re)) {
                s = dateNF_fix(s, o.dateNF, s.match(_re) || []);
                k = 1;
              }
              if (o.cellDates) {
                cell.t = "d";
                cell.v = parseDate(s, k);
              } else {
                cell.t = "n";
                cell.v = datenum(parseDate(s, k));
              }
              if (o.cellText !== false)
                cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
              if (!o.cellNF)
                delete cell.z;
            } else {
              cell.t = "s";
              cell.v = s;
            }
            if (cell.t == "z")
              ;
            else if (o.dense) {
              if (!ws[R])
                ws[R] = [];
              ws[R][C] = cell;
            } else
              ws[encode_cell({ c: C, r: R })] = cell;
            start = end + 1;
            startcc = str.charCodeAt(start);
            if (range2.e.c < C)
              range2.e.c = C;
            if (range2.e.r < R)
              range2.e.r = R;
            if (cc == sepcc)
              ++C;
            else {
              C = 0;
              ++R;
              if (o.sheetRows && o.sheetRows <= R)
                return true;
            }
          }
          outer:
            for (; end < str.length; ++end)
              switch (cc = str.charCodeAt(end)) {
                case 34:
                  if (startcc === 34)
                    instr = !instr;
                  break;
                case sepcc:
                case 10:
                case 13:
                  if (!instr && finish_cell())
                    break outer;
                  break;
              }
          if (end - start > 0)
            finish_cell();
          ws["!ref"] = encode_range(range2);
          return ws;
        }
        function prn_to_sheet_str(str, opts) {
          if (!(opts && opts.PRN))
            return dsv_to_sheet_str(str, opts);
          if (opts.FS)
            return dsv_to_sheet_str(str, opts);
          if (str.slice(0, 4) == "sep=")
            return dsv_to_sheet_str(str, opts);
          if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0)
            return dsv_to_sheet_str(str, opts);
          return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
        }
        function prn_to_sheet(d, opts) {
          var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
          switch (opts.type) {
            case "base64":
              str = Base64_decode(d);
              break;
            case "binary":
              str = d;
              break;
            case "buffer":
              if (opts.codepage == 65001)
                str = d.toString("utf8");
              else if (opts.codepage && typeof $cptable !== "undefined")
                str = $cptable.utils.decode(opts.codepage, d);
              else
                str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
              break;
            case "array":
              str = cc2str(d);
              break;
            case "string":
              str = d;
              break;
            default:
              throw new Error("Unrecognized type " + opts.type);
          }
          if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
            str = utf8read(str.slice(3));
          else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001)
            str = utf8read(str);
          else if (opts.type == "binary" && typeof $cptable !== "undefined" && opts.codepage)
            str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591, str));
          if (str.slice(0, 19) == "socialcalc:version:")
            return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
          return prn_to_sheet_str(str, opts);
        }
        function prn_to_workbook(d, opts) {
          return sheet_to_workbook(prn_to_sheet(d, opts), opts);
        }
        function sheet_to_prn(ws) {
          var o = [];
          var r = safe_decode_range(ws["!ref"]), cell;
          var dense = Array.isArray(ws);
          for (var R = r.s.r; R <= r.e.r; ++R) {
            var oo = [];
            for (var C = r.s.c; C <= r.e.c; ++C) {
              var coord = encode_cell({ r: R, c: C });
              cell = dense ? (ws[R] || [])[C] : ws[coord];
              if (!cell || cell.v == null) {
                oo.push("          ");
                continue;
              }
              var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
              while (w.length < 10)
                w += " ";
              oo.push(w + (C === 0 ? " " : ""));
            }
            o.push(oo.join(""));
          }
          return o.join("\n");
        }
        return {
          to_workbook: prn_to_workbook,
          to_sheet: prn_to_sheet,
          from_sheet: sheet_to_prn
        };
      }();
      function read_wb_ID(d, opts) {
        var o = opts || {}, OLD_WTF = !!o.WTF;
        o.WTF = true;
        try {
          var out = SYLK.to_workbook(d, o);
          o.WTF = OLD_WTF;
          return out;
        } catch (e) {
          o.WTF = OLD_WTF;
          if (!e.message.match(/SYLK bad record ID/) && OLD_WTF)
            throw e;
          return PRN.to_workbook(d, opts);
        }
      }
      var WK_ = /* @__PURE__ */ function() {
        function lotushopper(data, cb, opts) {
          if (!data)
            return;
          prep_blob(data, data.l || 0);
          var Enum = opts.Enum || WK1Enum;
          while (data.l < data.length) {
            var RT = data.read_shift(2);
            var R = Enum[RT] || Enum[65535];
            var length = data.read_shift(2);
            var tgt = data.l + length;
            var d = R.f && R.f(data, length, opts);
            data.l = tgt;
            if (cb(d, R, RT))
              return;
          }
        }
        function lotus_to_workbook(d, opts) {
          switch (opts.type) {
            case "base64":
              return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
            case "binary":
              return lotus_to_workbook_buf(s2a(d), opts);
            case "buffer":
            case "array":
              return lotus_to_workbook_buf(d, opts);
          }
          throw "Unsupported type " + opts.type;
        }
        function lotus_to_workbook_buf(d, opts) {
          if (!d)
            return d;
          var o = opts || {};
          var s = o.dense ? [] : {}, n = "Sheet1", next_n = "", sidx = 0;
          var sheets = {}, snames = [], realnames = [];
          var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
          var sheetRows = o.sheetRows || 0;
          if (d[2] == 0) {
            if (d[3] == 8 || d[3] == 9) {
              if (d.length >= 16 && d[14] == 5 && d[15] === 108)
                throw new Error("Unsupported Works 3 for Mac file");
            }
          }
          if (d[2] == 2) {
            o.Enum = WK1Enum;
            lotushopper(d, function(val, R, RT) {
              switch (RT) {
                case 0:
                  o.vers = val;
                  if (val >= 4096)
                    o.qpro = true;
                  break;
                case 6:
                  refguess = val;
                  break;
                case 204:
                  if (val)
                    next_n = val;
                  break;
                case 222:
                  next_n = val;
                  break;
                case 15:
                case 51:
                  if (!o.qpro)
                    val[1].v = val[1].v.slice(1);
                case 13:
                case 14:
                case 16:
                  if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
                    val[1].z = o.dateNF || table_fmt[14];
                    if (o.cellDates) {
                      val[1].t = "d";
                      val[1].v = numdate(val[1].v);
                    }
                  }
                  if (o.qpro) {
                    if (val[3] > sidx) {
                      s["!ref"] = encode_range(refguess);
                      sheets[n] = s;
                      snames.push(n);
                      s = o.dense ? [] : {};
                      refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                      sidx = val[3];
                      n = next_n || "Sheet" + (sidx + 1);
                      next_n = "";
                    }
                  }
                  var tmpcell = o.dense ? (s[val[0].r] || [])[val[0].c] : s[encode_cell(val[0])];
                  if (tmpcell) {
                    tmpcell.t = val[1].t;
                    tmpcell.v = val[1].v;
                    if (val[1].z != null)
                      tmpcell.z = val[1].z;
                    if (val[1].f != null)
                      tmpcell.f = val[1].f;
                    break;
                  }
                  if (o.dense) {
                    if (!s[val[0].r])
                      s[val[0].r] = [];
                    s[val[0].r][val[0].c] = val[1];
                  } else
                    s[encode_cell(val[0])] = val[1];
                  break;
              }
            }, o);
          } else if (d[2] == 26 || d[2] == 14) {
            o.Enum = WK3Enum;
            if (d[2] == 14) {
              o.qpro = true;
              d.l = 0;
            }
            lotushopper(d, function(val, R, RT) {
              switch (RT) {
                case 204:
                  n = val;
                  break;
                case 22:
                  val[1].v = val[1].v.slice(1);
                case 23:
                case 24:
                case 25:
                case 37:
                case 39:
                case 40:
                  if (val[3] > sidx) {
                    s["!ref"] = encode_range(refguess);
                    sheets[n] = s;
                    snames.push(n);
                    s = o.dense ? [] : {};
                    refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                    sidx = val[3];
                    n = "Sheet" + (sidx + 1);
                  }
                  if (sheetRows > 0 && val[0].r >= sheetRows)
                    break;
                  if (o.dense) {
                    if (!s[val[0].r])
                      s[val[0].r] = [];
                    s[val[0].r][val[0].c] = val[1];
                  } else
                    s[encode_cell(val[0])] = val[1];
                  if (refguess.e.c < val[0].c)
                    refguess.e.c = val[0].c;
                  if (refguess.e.r < val[0].r)
                    refguess.e.r = val[0].r;
                  break;
                case 27:
                  if (val[14e3])
                    realnames[val[14e3][0]] = val[14e3][1];
                  break;
                case 1537:
                  realnames[val[0]] = val[1];
                  if (val[0] == sidx)
                    n = val[1];
                  break;
              }
            }, o);
          } else
            throw new Error("Unrecognized LOTUS BOF " + d[2]);
          s["!ref"] = encode_range(refguess);
          sheets[next_n || n] = s;
          snames.push(next_n || n);
          if (!realnames.length)
            return { SheetNames: snames, Sheets: sheets };
          var osheets = {}, rnames = [];
          for (var i = 0; i < realnames.length; ++i)
            if (sheets[snames[i]]) {
              rnames.push(realnames[i] || snames[i]);
              osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
            } else {
              rnames.push(realnames[i]);
              osheets[realnames[i]] = { "!ref": "A1" };
            }
          return { SheetNames: rnames, Sheets: osheets };
        }
        function sheet_to_wk1(ws, opts) {
          var o = opts || {};
          if (+o.codepage >= 0)
            set_cp(+o.codepage);
          if (o.type == "string")
            throw new Error("Cannot write WK1 to JS string");
          var ba = buf_array();
          var range2 = safe_decode_range(ws["!ref"]);
          var dense = Array.isArray(ws);
          var cols = [];
          write_biff_rec(ba, 0, write_BOF_WK1(1030));
          write_biff_rec(ba, 6, write_RANGE(range2));
          var max_R = Math.min(range2.e.r, 8191);
          for (var R = range2.s.r; R <= max_R; ++R) {
            var rr = encode_row(R);
            for (var C = range2.s.c; C <= range2.e.c; ++C) {
              if (R === range2.s.r)
                cols[C] = encode_col(C);
              var ref2 = cols[C] + rr;
              var cell = dense ? (ws[R] || [])[C] : ws[ref2];
              if (!cell || cell.t == "z")
                continue;
              if (cell.t == "n") {
                if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767)
                  write_biff_rec(ba, 13, write_INTEGER(R, C, cell.v));
                else
                  write_biff_rec(ba, 14, write_NUMBER(R, C, cell.v));
              } else {
                var str = format_cell(cell);
                write_biff_rec(ba, 15, write_LABEL(R, C, str.slice(0, 239)));
              }
            }
          }
          write_biff_rec(ba, 1);
          return ba.end();
        }
        function book_to_wk3(wb, opts) {
          var o = opts || {};
          if (+o.codepage >= 0)
            set_cp(+o.codepage);
          if (o.type == "string")
            throw new Error("Cannot write WK3 to JS string");
          var ba = buf_array();
          write_biff_rec(ba, 0, write_BOF_WK3(wb));
          for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i)
            if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"])
              write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
          var wsidx = 0;
          for (i = 0; i < wb.SheetNames.length; ++i) {
            var ws = wb.Sheets[wb.SheetNames[i]];
            if (!ws || !ws["!ref"])
              continue;
            var range2 = safe_decode_range(ws["!ref"]);
            var dense = Array.isArray(ws);
            var cols = [];
            var max_R = Math.min(range2.e.r, 8191);
            for (var R = range2.s.r; R <= max_R; ++R) {
              var rr = encode_row(R);
              for (var C = range2.s.c; C <= range2.e.c; ++C) {
                if (R === range2.s.r)
                  cols[C] = encode_col(C);
                var ref2 = cols[C] + rr;
                var cell = dense ? (ws[R] || [])[C] : ws[ref2];
                if (!cell || cell.t == "z")
                  continue;
                if (cell.t == "n") {
                  write_biff_rec(ba, 23, write_NUMBER_17(R, C, wsidx, cell.v));
                } else {
                  var str = format_cell(cell);
                  write_biff_rec(ba, 22, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
                }
              }
            }
            ++wsidx;
          }
          write_biff_rec(ba, 1);
          return ba.end();
        }
        function write_BOF_WK1(v) {
          var out = new_buf(2);
          out.write_shift(2, v);
          return out;
        }
        function write_BOF_WK3(wb) {
          var out = new_buf(26);
          out.write_shift(2, 4096);
          out.write_shift(2, 4);
          out.write_shift(4, 0);
          var rows = 0, cols = 0, wscnt = 0;
          for (var i = 0; i < wb.SheetNames.length; ++i) {
            var name = wb.SheetNames[i];
            var ws = wb.Sheets[name];
            if (!ws || !ws["!ref"])
              continue;
            ++wscnt;
            var range2 = decode_range(ws["!ref"]);
            if (rows < range2.e.r)
              rows = range2.e.r;
            if (cols < range2.e.c)
              cols = range2.e.c;
          }
          if (rows > 8191)
            rows = 8191;
          out.write_shift(2, rows);
          out.write_shift(1, wscnt);
          out.write_shift(1, cols);
          out.write_shift(2, 0);
          out.write_shift(2, 0);
          out.write_shift(1, 1);
          out.write_shift(1, 2);
          out.write_shift(4, 0);
          out.write_shift(4, 0);
          return out;
        }
        function parse_RANGE(blob, length, opts) {
          var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
          if (length == 8 && opts.qpro) {
            o.s.c = blob.read_shift(1);
            blob.l++;
            o.s.r = blob.read_shift(2);
            o.e.c = blob.read_shift(1);
            blob.l++;
            o.e.r = blob.read_shift(2);
            return o;
          }
          o.s.c = blob.read_shift(2);
          o.s.r = blob.read_shift(2);
          if (length == 12 && opts.qpro)
            blob.l += 2;
          o.e.c = blob.read_shift(2);
          o.e.r = blob.read_shift(2);
          if (length == 12 && opts.qpro)
            blob.l += 2;
          if (o.s.c == 65535)
            o.s.c = o.e.c = o.s.r = o.e.r = 0;
          return o;
        }
        function write_RANGE(range2) {
          var out = new_buf(8);
          out.write_shift(2, range2.s.c);
          out.write_shift(2, range2.s.r);
          out.write_shift(2, range2.e.c);
          out.write_shift(2, range2.e.r);
          return out;
        }
        function parse_cell(blob, length, opts) {
          var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
          if (opts.qpro && opts.vers != 20768) {
            o[0].c = blob.read_shift(1);
            o[3] = blob.read_shift(1);
            o[0].r = blob.read_shift(2);
            blob.l += 2;
          } else {
            o[2] = blob.read_shift(1);
            o[0].c = blob.read_shift(2);
            o[0].r = blob.read_shift(2);
          }
          return o;
        }
        function parse_LABEL(blob, length, opts) {
          var tgt = blob.l + length;
          var o = parse_cell(blob, length, opts);
          o[1].t = "s";
          if (opts.vers == 20768) {
            blob.l++;
            var len2 = blob.read_shift(1);
            o[1].v = blob.read_shift(len2, "utf8");
            return o;
          }
          if (opts.qpro)
            blob.l++;
          o[1].v = blob.read_shift(tgt - blob.l, "cstr");
          return o;
        }
        function write_LABEL(R, C, s) {
          var o = new_buf(7 + s.length);
          o.write_shift(1, 255);
          o.write_shift(2, C);
          o.write_shift(2, R);
          o.write_shift(1, 39);
          for (var i = 0; i < o.length; ++i) {
            var cc = s.charCodeAt(i);
            o.write_shift(1, cc >= 128 ? 95 : cc);
          }
          o.write_shift(1, 0);
          return o;
        }
        function parse_INTEGER(blob, length, opts) {
          var o = parse_cell(blob, length, opts);
          o[1].v = blob.read_shift(2, "i");
          return o;
        }
        function write_INTEGER(R, C, v) {
          var o = new_buf(7);
          o.write_shift(1, 255);
          o.write_shift(2, C);
          o.write_shift(2, R);
          o.write_shift(2, v, "i");
          return o;
        }
        function parse_NUMBER(blob, length, opts) {
          var o = parse_cell(blob, length, opts);
          o[1].v = blob.read_shift(8, "f");
          return o;
        }
        function write_NUMBER(R, C, v) {
          var o = new_buf(13);
          o.write_shift(1, 255);
          o.write_shift(2, C);
          o.write_shift(2, R);
          o.write_shift(8, v, "f");
          return o;
        }
        function parse_FORMULA(blob, length, opts) {
          var tgt = blob.l + length;
          var o = parse_cell(blob, length, opts);
          o[1].v = blob.read_shift(8, "f");
          if (opts.qpro)
            blob.l = tgt;
          else {
            var flen = blob.read_shift(2);
            wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
            blob.l += flen;
          }
          return o;
        }
        function wk1_parse_rc(B, V, col) {
          var rel = V & 32768;
          V &= ~32768;
          V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
          return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
        }
        var FuncTab = {
          51: ["FALSE", 0],
          52: ["TRUE", 0],
          70: ["LEN", 1],
          80: ["SUM", 69],
          81: ["AVERAGEA", 69],
          82: ["COUNTA", 69],
          83: ["MINA", 69],
          84: ["MAXA", 69],
          111: ["T", 1]
        };
        var BinOpTab = [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          // eslint-disable-line no-mixed-spaces-and-tabs
          "",
          "+",
          "-",
          "*",
          "/",
          "^",
          "=",
          "<>",
          // eslint-disable-line no-mixed-spaces-and-tabs
          "<=",
          ">=",
          "<",
          ">",
          "",
          "",
          "",
          "",
          // eslint-disable-line no-mixed-spaces-and-tabs
          "&",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
          // eslint-disable-line no-mixed-spaces-and-tabs
        ];
        function wk1_fmla_to_csf(blob, o) {
          prep_blob(blob, 0);
          var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
          while (blob.l < blob.length) {
            var cc = blob[blob.l++];
            switch (cc) {
              case 0:
                out.push(blob.read_shift(8, "f"));
                break;
              case 1:
                {
                  C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
                  R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
                  out.push(C + R);
                }
                break;
              case 2:
                {
                  var c2 = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
                  var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
                  C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
                  R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
                  out.push(c2 + r + ":" + C + R);
                }
                break;
              case 3:
                if (blob.l < blob.length) {
                  console.error("WK1 premature formula end");
                  return;
                }
                break;
              case 4:
                out.push("(" + out.pop() + ")");
                break;
              case 5:
                out.push(blob.read_shift(2));
                break;
              case 6:
                {
                  var Z = "";
                  while (cc = blob[blob.l++])
                    Z += String.fromCharCode(cc);
                  out.push('"' + Z.replace(/"/g, '""') + '"');
                }
                break;
              case 8:
                out.push("-" + out.pop());
                break;
              case 23:
                out.push("+" + out.pop());
                break;
              case 22:
                out.push("NOT(" + out.pop() + ")");
                break;
              case 20:
              case 21:
                {
                  argR = out.pop();
                  argL = out.pop();
                  out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
                }
                break;
              default:
                if (cc < 32 && BinOpTab[cc]) {
                  argR = out.pop();
                  argL = out.pop();
                  out.push(argL + BinOpTab[cc] + argR);
                } else if (FuncTab[cc]) {
                  argc = FuncTab[cc][1];
                  if (argc == 69)
                    argc = blob[blob.l++];
                  if (argc > out.length) {
                    console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
                    return;
                  }
                  var args = out.slice(-argc);
                  out.length -= argc;
                  out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
                } else if (cc <= 7)
                  return console.error("WK1 invalid opcode " + cc.toString(16));
                else if (cc <= 24)
                  return console.error("WK1 unsupported op " + cc.toString(16));
                else if (cc <= 30)
                  return console.error("WK1 invalid opcode " + cc.toString(16));
                else if (cc <= 115)
                  return console.error("WK1 unsupported function opcode " + cc.toString(16));
                else
                  return console.error("WK1 unrecognized opcode " + cc.toString(16));
            }
          }
          if (out.length == 1)
            o[1].f = "" + out[0];
          else
            console.error("WK1 bad formula parse |" + out.join("|") + "|");
        }
        function parse_cell_3(blob) {
          var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
          o[0].r = blob.read_shift(2);
          o[3] = blob[blob.l++];
          o[0].c = blob[blob.l++];
          return o;
        }
        function parse_LABEL_16(blob, length) {
          var o = parse_cell_3(blob);
          o[1].t = "s";
          o[1].v = blob.read_shift(length - 4, "cstr");
          return o;
        }
        function write_LABEL_16(R, C, wsidx, s) {
          var o = new_buf(6 + s.length);
          o.write_shift(2, R);
          o.write_shift(1, wsidx);
          o.write_shift(1, C);
          o.write_shift(1, 39);
          for (var i = 0; i < s.length; ++i) {
            var cc = s.charCodeAt(i);
            o.write_shift(1, cc >= 128 ? 95 : cc);
          }
          o.write_shift(1, 0);
          return o;
        }
        function parse_NUMBER_18(blob, length) {
          var o = parse_cell_3(blob);
          o[1].v = blob.read_shift(2);
          var v = o[1].v >> 1;
          if (o[1].v & 1) {
            switch (v & 7) {
              case 0:
                v = (v >> 3) * 5e3;
                break;
              case 1:
                v = (v >> 3) * 500;
                break;
              case 2:
                v = (v >> 3) / 20;
                break;
              case 3:
                v = (v >> 3) / 200;
                break;
              case 4:
                v = (v >> 3) / 2e3;
                break;
              case 5:
                v = (v >> 3) / 2e4;
                break;
              case 6:
                v = (v >> 3) / 16;
                break;
              case 7:
                v = (v >> 3) / 64;
                break;
            }
          }
          o[1].v = v;
          return o;
        }
        function parse_NUMBER_17(blob, length) {
          var o = parse_cell_3(blob);
          var v1 = blob.read_shift(4);
          var v2 = blob.read_shift(4);
          var e = blob.read_shift(2);
          if (e == 65535) {
            if (v1 === 0 && v2 === 3221225472) {
              o[1].t = "e";
              o[1].v = 15;
            } else if (v1 === 0 && v2 === 3489660928) {
              o[1].t = "e";
              o[1].v = 42;
            } else
              o[1].v = 0;
            return o;
          }
          var s = e & 32768;
          e = (e & 32767) - 16446;
          o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
          return o;
        }
        function write_NUMBER_17(R, C, wsidx, v) {
          var o = new_buf(14);
          o.write_shift(2, R);
          o.write_shift(1, wsidx);
          o.write_shift(1, C);
          if (v == 0) {
            o.write_shift(4, 0);
            o.write_shift(4, 0);
            o.write_shift(2, 65535);
            return o;
          }
          var s = 0, e = 0, v1 = 0, v2 = 0;
          if (v < 0) {
            s = 1;
            v = -v;
          }
          e = Math.log2(v) | 0;
          v /= Math.pow(2, e - 31);
          v2 = v >>> 0;
          if ((v2 & 2147483648) == 0) {
            v /= 2;
            ++e;
            v2 = v >>> 0;
          }
          v -= v2;
          v2 |= 2147483648;
          v2 >>>= 0;
          v *= Math.pow(2, 32);
          v1 = v >>> 0;
          o.write_shift(4, v1);
          o.write_shift(4, v2);
          e += 16383 + (s ? 32768 : 0);
          o.write_shift(2, e);
          return o;
        }
        function parse_FORMULA_19(blob, length) {
          var o = parse_NUMBER_17(blob);
          blob.l += length - 14;
          return o;
        }
        function parse_NUMBER_25(blob, length) {
          var o = parse_cell_3(blob);
          var v1 = blob.read_shift(4);
          o[1].v = v1 >> 6;
          return o;
        }
        function parse_NUMBER_27(blob, length) {
          var o = parse_cell_3(blob);
          var v1 = blob.read_shift(8, "f");
          o[1].v = v1;
          return o;
        }
        function parse_FORMULA_28(blob, length) {
          var o = parse_NUMBER_27(blob);
          blob.l += length - 10;
          return o;
        }
        function parse_SHEETNAMECS(blob, length) {
          return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
        }
        function parse_SHEETNAMELP(blob, length) {
          var len2 = blob[blob.l++];
          if (len2 > length - 1)
            len2 = length - 1;
          var o = "";
          while (o.length < len2)
            o += String.fromCharCode(blob[blob.l++]);
          return o;
        }
        function parse_SHEETINFOQP(blob, length, opts) {
          if (!opts.qpro || length < 21)
            return;
          var id = blob.read_shift(1);
          blob.l += 17;
          blob.l += 1;
          blob.l += 2;
          var nm = blob.read_shift(length - 21, "cstr");
          return [id, nm];
        }
        function parse_XFORMAT(blob, length) {
          var o = {}, tgt = blob.l + length;
          while (blob.l < tgt) {
            var dt = blob.read_shift(2);
            if (dt == 14e3) {
              o[dt] = [0, ""];
              o[dt][0] = blob.read_shift(2);
              while (blob[blob.l]) {
                o[dt][1] += String.fromCharCode(blob[blob.l]);
                blob.l++;
              }
              blob.l++;
            }
          }
          return o;
        }
        function write_XFORMAT_SHEETNAME(name, wsidx) {
          var out = new_buf(5 + name.length);
          out.write_shift(2, 14e3);
          out.write_shift(2, wsidx);
          for (var i = 0; i < name.length; ++i) {
            var cc = name.charCodeAt(i);
            out[out.l++] = cc > 127 ? 95 : cc;
          }
          out[out.l++] = 0;
          return out;
        }
        var WK1Enum = {
          /*::[*/
          0: { n: "BOF", f: parseuint16 },
          /*::[*/
          1: { n: "EOF" },
          /*::[*/
          2: { n: "CALCMODE" },
          /*::[*/
          3: { n: "CALCORDER" },
          /*::[*/
          4: { n: "SPLIT" },
          /*::[*/
          5: { n: "SYNC" },
          /*::[*/
          6: { n: "RANGE", f: parse_RANGE },
          /*::[*/
          7: { n: "WINDOW1" },
          /*::[*/
          8: { n: "COLW1" },
          /*::[*/
          9: { n: "WINTWO" },
          /*::[*/
          10: { n: "COLW2" },
          /*::[*/
          11: { n: "NAME" },
          /*::[*/
          12: { n: "BLANK" },
          /*::[*/
          13: { n: "INTEGER", f: parse_INTEGER },
          /*::[*/
          14: { n: "NUMBER", f: parse_NUMBER },
          /*::[*/
          15: { n: "LABEL", f: parse_LABEL },
          /*::[*/
          16: { n: "FORMULA", f: parse_FORMULA },
          /*::[*/
          24: { n: "TABLE" },
          /*::[*/
          25: { n: "ORANGE" },
          /*::[*/
          26: { n: "PRANGE" },
          /*::[*/
          27: { n: "SRANGE" },
          /*::[*/
          28: { n: "FRANGE" },
          /*::[*/
          29: { n: "KRANGE1" },
          /*::[*/
          32: { n: "HRANGE" },
          /*::[*/
          35: { n: "KRANGE2" },
          /*::[*/
          36: { n: "PROTEC" },
          /*::[*/
          37: { n: "FOOTER" },
          /*::[*/
          38: { n: "HEADER" },
          /*::[*/
          39: { n: "SETUP" },
          /*::[*/
          40: { n: "MARGINS" },
          /*::[*/
          41: { n: "LABELFMT" },
          /*::[*/
          42: { n: "TITLES" },
          /*::[*/
          43: { n: "SHEETJS" },
          /*::[*/
          45: { n: "GRAPH" },
          /*::[*/
          46: { n: "NGRAPH" },
          /*::[*/
          47: { n: "CALCCOUNT" },
          /*::[*/
          48: { n: "UNFORMATTED" },
          /*::[*/
          49: { n: "CURSORW12" },
          /*::[*/
          50: { n: "WINDOW" },
          /*::[*/
          51: { n: "STRING", f: parse_LABEL },
          /*::[*/
          55: { n: "PASSWORD" },
          /*::[*/
          56: { n: "LOCKED" },
          /*::[*/
          60: { n: "QUERY" },
          /*::[*/
          61: { n: "QUERYNAME" },
          /*::[*/
          62: { n: "PRINT" },
          /*::[*/
          63: { n: "PRINTNAME" },
          /*::[*/
          64: { n: "GRAPH2" },
          /*::[*/
          65: { n: "GRAPHNAME" },
          /*::[*/
          66: { n: "ZOOM" },
          /*::[*/
          67: { n: "SYMSPLIT" },
          /*::[*/
          68: { n: "NSROWS" },
          /*::[*/
          69: { n: "NSCOLS" },
          /*::[*/
          70: { n: "RULER" },
          /*::[*/
          71: { n: "NNAME" },
          /*::[*/
          72: { n: "ACOMM" },
          /*::[*/
          73: { n: "AMACRO" },
          /*::[*/
          74: { n: "PARSE" },
          /*::[*/
          102: { n: "PRANGES??" },
          /*::[*/
          103: { n: "RRANGES??" },
          /*::[*/
          104: { n: "FNAME??" },
          /*::[*/
          105: { n: "MRANGES??" },
          /*::[*/
          204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
          /*::[*/
          222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
          /*::[*/
          65535: { n: "" }
        };
        var WK3Enum = {
          /*::[*/
          0: { n: "BOF" },
          /*::[*/
          1: { n: "EOF" },
          /*::[*/
          2: { n: "PASSWORD" },
          /*::[*/
          3: { n: "CALCSET" },
          /*::[*/
          4: { n: "WINDOWSET" },
          /*::[*/
          5: { n: "SHEETCELLPTR" },
          /*::[*/
          6: { n: "SHEETLAYOUT" },
          /*::[*/
          7: { n: "COLUMNWIDTH" },
          /*::[*/
          8: { n: "HIDDENCOLUMN" },
          /*::[*/
          9: { n: "USERRANGE" },
          /*::[*/
          10: { n: "SYSTEMRANGE" },
          /*::[*/
          11: { n: "ZEROFORCE" },
          /*::[*/
          12: { n: "SORTKEYDIR" },
          /*::[*/
          13: { n: "FILESEAL" },
          /*::[*/
          14: { n: "DATAFILLNUMS" },
          /*::[*/
          15: { n: "PRINTMAIN" },
          /*::[*/
          16: { n: "PRINTSTRING" },
          /*::[*/
          17: { n: "GRAPHMAIN" },
          /*::[*/
          18: { n: "GRAPHSTRING" },
          /*::[*/
          19: { n: "??" },
          /*::[*/
          20: { n: "ERRCELL" },
          /*::[*/
          21: { n: "NACELL" },
          /*::[*/
          22: { n: "LABEL16", f: parse_LABEL_16 },
          /*::[*/
          23: { n: "NUMBER17", f: parse_NUMBER_17 },
          /*::[*/
          24: { n: "NUMBER18", f: parse_NUMBER_18 },
          /*::[*/
          25: { n: "FORMULA19", f: parse_FORMULA_19 },
          /*::[*/
          26: { n: "FORMULA1A" },
          /*::[*/
          27: { n: "XFORMAT", f: parse_XFORMAT },
          /*::[*/
          28: { n: "DTLABELMISC" },
          /*::[*/
          29: { n: "DTLABELCELL" },
          /*::[*/
          30: { n: "GRAPHWINDOW" },
          /*::[*/
          31: { n: "CPA" },
          /*::[*/
          32: { n: "LPLAUTO" },
          /*::[*/
          33: { n: "QUERY" },
          /*::[*/
          34: { n: "HIDDENSHEET" },
          /*::[*/
          35: { n: "??" },
          /*::[*/
          37: { n: "NUMBER25", f: parse_NUMBER_25 },
          /*::[*/
          38: { n: "??" },
          /*::[*/
          39: { n: "NUMBER27", f: parse_NUMBER_27 },
          /*::[*/
          40: { n: "FORMULA28", f: parse_FORMULA_28 },
          /*::[*/
          142: { n: "??" },
          /*::[*/
          147: { n: "??" },
          /*::[*/
          150: { n: "??" },
          /*::[*/
          151: { n: "??" },
          /*::[*/
          152: { n: "??" },
          /*::[*/
          153: { n: "??" },
          /*::[*/
          154: { n: "??" },
          /*::[*/
          155: { n: "??" },
          /*::[*/
          156: { n: "??" },
          /*::[*/
          163: { n: "??" },
          /*::[*/
          174: { n: "??" },
          /*::[*/
          175: { n: "??" },
          /*::[*/
          176: { n: "??" },
          /*::[*/
          177: { n: "??" },
          /*::[*/
          184: { n: "??" },
          /*::[*/
          185: { n: "??" },
          /*::[*/
          186: { n: "??" },
          /*::[*/
          187: { n: "??" },
          /*::[*/
          188: { n: "??" },
          /*::[*/
          195: { n: "??" },
          /*::[*/
          201: { n: "??" },
          /*::[*/
          204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
          /*::[*/
          205: { n: "??" },
          /*::[*/
          206: { n: "??" },
          /*::[*/
          207: { n: "??" },
          /*::[*/
          208: { n: "??" },
          /*::[*/
          256: { n: "??" },
          /*::[*/
          259: { n: "??" },
          /*::[*/
          260: { n: "??" },
          /*::[*/
          261: { n: "??" },
          /*::[*/
          262: { n: "??" },
          /*::[*/
          263: { n: "??" },
          /*::[*/
          265: { n: "??" },
          /*::[*/
          266: { n: "??" },
          /*::[*/
          267: { n: "??" },
          /*::[*/
          268: { n: "??" },
          /*::[*/
          270: { n: "??" },
          /*::[*/
          271: { n: "??" },
          /*::[*/
          384: { n: "??" },
          /*::[*/
          389: { n: "??" },
          /*::[*/
          390: { n: "??" },
          /*::[*/
          393: { n: "??" },
          /*::[*/
          396: { n: "??" },
          /*::[*/
          512: { n: "??" },
          /*::[*/
          514: { n: "??" },
          /*::[*/
          513: { n: "??" },
          /*::[*/
          516: { n: "??" },
          /*::[*/
          517: { n: "??" },
          /*::[*/
          640: { n: "??" },
          /*::[*/
          641: { n: "??" },
          /*::[*/
          642: { n: "??" },
          /*::[*/
          643: { n: "??" },
          /*::[*/
          644: { n: "??" },
          /*::[*/
          645: { n: "??" },
          /*::[*/
          646: { n: "??" },
          /*::[*/
          647: { n: "??" },
          /*::[*/
          648: { n: "??" },
          /*::[*/
          658: { n: "??" },
          /*::[*/
          659: { n: "??" },
          /*::[*/
          660: { n: "??" },
          /*::[*/
          661: { n: "??" },
          /*::[*/
          662: { n: "??" },
          /*::[*/
          665: { n: "??" },
          /*::[*/
          666: { n: "??" },
          /*::[*/
          768: { n: "??" },
          /*::[*/
          772: { n: "??" },
          /*::[*/
          1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
          /*::[*/
          1600: { n: "??" },
          /*::[*/
          1602: { n: "??" },
          /*::[*/
          1793: { n: "??" },
          /*::[*/
          1794: { n: "??" },
          /*::[*/
          1795: { n: "??" },
          /*::[*/
          1796: { n: "??" },
          /*::[*/
          1920: { n: "??" },
          /*::[*/
          2048: { n: "??" },
          /*::[*/
          2049: { n: "??" },
          /*::[*/
          2052: { n: "??" },
          /*::[*/
          2688: { n: "??" },
          /*::[*/
          10998: { n: "??" },
          /*::[*/
          12849: { n: "??" },
          /*::[*/
          28233: { n: "??" },
          /*::[*/
          28484: { n: "??" },
          /*::[*/
          65535: { n: "" }
        };
        return {
          sheet_to_wk1,
          book_to_wk3,
          to_workbook: lotus_to_workbook
        };
      }();
      function parse_rpr(rpr) {
        var font = {}, m = rpr.match(tagregex), i = 0;
        var pass = false;
        if (m)
          for (; i != m.length; ++i) {
            var y = parsexmltag(m[i]);
            switch (y[0].replace(/\w*:/g, "")) {
              case "<condense":
                break;
              case "<extend":
                break;
              case "<shadow":
                if (!y.val)
                  break;
              case "<shadow>":
              case "<shadow/>":
                font.shadow = 1;
                break;
              case "</shadow>":
                break;
              case "<charset":
                if (y.val == "1")
                  break;
                font.cp = CS2CP[parseInt(y.val, 10)];
                break;
              case "<outline":
                if (!y.val)
                  break;
              case "<outline>":
              case "<outline/>":
                font.outline = 1;
                break;
              case "</outline>":
                break;
              case "<rFont":
                font.name = y.val;
                break;
              case "<sz":
                font.sz = y.val;
                break;
              case "<strike":
                if (!y.val)
                  break;
              case "<strike>":
              case "<strike/>":
                font.strike = 1;
                break;
              case "</strike>":
                break;
              case "<u":
                if (!y.val)
                  break;
                switch (y.val) {
                  case "double":
                    font.uval = "double";
                    break;
                  case "singleAccounting":
                    font.uval = "single-accounting";
                    break;
                  case "doubleAccounting":
                    font.uval = "double-accounting";
                    break;
                }
              case "<u>":
              case "<u/>":
                font.u = 1;
                break;
              case "</u>":
                break;
              case "<b":
                if (y.val == "0")
                  break;
              case "<b>":
              case "<b/>":
                font.b = 1;
                break;
              case "</b>":
                break;
              case "<i":
                if (y.val == "0")
                  break;
              case "<i>":
              case "<i/>":
                font.i = 1;
                break;
              case "</i>":
                break;
              case "<color":
                if (y.rgb)
                  font.color = y.rgb.slice(2, 8);
                break;
              case "<color>":
              case "<color/>":
              case "</color>":
                break;
              case "<family":
                font.family = y.val;
                break;
              case "<family>":
              case "<family/>":
              case "</family>":
                break;
              case "<vertAlign":
                font.valign = y.val;
                break;
              case "<vertAlign>":
              case "<vertAlign/>":
              case "</vertAlign>":
                break;
              case "<scheme":
                break;
              case "<scheme>":
              case "<scheme/>":
              case "</scheme>":
                break;
              case "<extLst":
              case "<extLst>":
              case "</extLst>":
                break;
              case "<ext":
                pass = true;
                break;
              case "</ext>":
                pass = false;
                break;
              default:
                if (y[0].charCodeAt(1) !== 47 && !pass)
                  throw new Error("Unrecognized rich format " + y[0]);
            }
          }
        return font;
      }
      var parse_rs = /* @__PURE__ */ function() {
        var tregex = matchtag("t"), rpregex = matchtag("rPr");
        function parse_r(r) {
          var t = r.match(tregex);
          if (!t)
            return { t: "s", v: "" };
          var o = { t: "s", v: unescapexml(t[1]) };
          var rpr = r.match(rpregex);
          if (rpr)
            o.s = parse_rpr(rpr[1]);
          return o;
        }
        var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
        return function parse_rs2(rs) {
          return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r) {
            return r.v;
          });
        };
      }();
      var rs_to_html = /* @__PURE__ */ function parse_rs_factory() {
        var nlregex = /(\r\n|\n)/g;
        function parse_rpr2(font, intro, outro) {
          var style2 = [];
          if (font.u)
            style2.push("text-decoration: underline;");
          if (font.uval)
            style2.push("text-underline-style:" + font.uval + ";");
          if (font.sz)
            style2.push("font-size:" + font.sz + "pt;");
          if (font.outline)
            style2.push("text-effect: outline;");
          if (font.shadow)
            style2.push("text-shadow: auto;");
          intro.push('<span style="' + style2.join("") + '">');
          if (font.b) {
            intro.push("<b>");
            outro.push("</b>");
          }
          if (font.i) {
            intro.push("<i>");
            outro.push("</i>");
          }
          if (font.strike) {
            intro.push("<s>");
            outro.push("</s>");
          }
          var align = font.valign || "";
          if (align == "superscript" || align == "super")
            align = "sup";
          else if (align == "subscript")
            align = "sub";
          if (align != "") {
            intro.push("<" + align + ">");
            outro.push("</" + align + ">");
          }
          outro.push("</span>");
          return font;
        }
        function r_to_html(r) {
          var terms = [[], r.v, []];
          if (!r.v)
            return "";
          if (r.s)
            parse_rpr2(r.s, terms[0], terms[2]);
          return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
        }
        return function parse_rs2(rs) {
          return rs.map(r_to_html).join("");
        };
      }();
      var sitregex = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r>/;
      var sirphregex = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
      function parse_si(x, opts) {
        var html = opts ? opts.cellHTML : true;
        var z = {};
        if (!x)
          return { t: "" };
        if (x.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
          z.t = unescapexml(utf8read(x.slice(x.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""));
          z.r = utf8read(x);
          if (html)
            z.h = escapehtml(z.t);
        } else if (
          /*y = */
          x.match(sirregex)
        ) {
          z.r = utf8read(x);
          z.t = unescapexml(utf8read((x.replace(sirphregex, "").match(sitregex) || []).join("").replace(tagregex, "")));
          if (html)
            z.h = rs_to_html(parse_rs(z.r));
        }
        return z;
      }
      var sstr0 = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;
      var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
      var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
      function parse_sst_xml(data, opts) {
        var s = [], ss = "";
        if (!data)
          return s;
        var sst = data.match(sstr0);
        if (sst) {
          ss = sst[2].replace(sstr1, "").split(sstr2);
          for (var i = 0; i != ss.length; ++i) {
            var o = parse_si(ss[i].trim(), opts);
            if (o != null)
              s[s.length] = o;
          }
          sst = parsexmltag(sst[1]);
          s.Count = sst.count;
          s.Unique = sst.uniqueCount;
        }
        return s;
      }
      function parse_BrtBeginSst(data) {
        return [data.read_shift(4), data.read_shift(4)];
      }
      function parse_sst_bin(data, opts) {
        var s = [];
        var pass = false;
        recordhopper(data, function hopper_sst(val, R, RT) {
          switch (RT) {
            case 159:
              s.Count = val[0];
              s.Unique = val[1];
              break;
            case 19:
              s.push(val);
              break;
            case 160:
              return true;
            case 35:
              pass = true;
              break;
            case 36:
              pass = false;
              break;
            default:
              if (R.T)
                ;
              if (!pass || opts.WTF)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        });
        return s;
      }
      function _JS2ANSI(str) {
        var o = [], oo = str.split("");
        for (var i = 0; i < oo.length; ++i)
          o[i] = oo[i].charCodeAt(0);
        return o;
      }
      function parse_CRYPTOVersion(blob, length) {
        var o = {};
        o.Major = blob.read_shift(2);
        o.Minor = blob.read_shift(2);
        if (length >= 4)
          blob.l += length - 4;
        return o;
      }
      function parse_DataSpaceVersionInfo(blob) {
        var o = {};
        o.id = blob.read_shift(0, "lpp4");
        o.R = parse_CRYPTOVersion(blob, 4);
        o.U = parse_CRYPTOVersion(blob, 4);
        o.W = parse_CRYPTOVersion(blob, 4);
        return o;
      }
      function parse_DataSpaceMapEntry(blob) {
        var len2 = blob.read_shift(4);
        var end = blob.l + len2 - 4;
        var o = {};
        var cnt = blob.read_shift(4);
        var comps = [];
        while (cnt-- > 0)
          comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, "lpp4") });
        o.name = blob.read_shift(0, "lpp4");
        o.comps = comps;
        if (blob.l != end)
          throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
        return o;
      }
      function parse_DataSpaceMap(blob) {
        var o = [];
        blob.l += 4;
        var cnt = blob.read_shift(4);
        while (cnt-- > 0)
          o.push(parse_DataSpaceMapEntry(blob));
        return o;
      }
      function parse_DataSpaceDefinition(blob) {
        var o = [];
        blob.l += 4;
        var cnt = blob.read_shift(4);
        while (cnt-- > 0)
          o.push(blob.read_shift(0, "lpp4"));
        return o;
      }
      function parse_TransformInfoHeader(blob) {
        var o = {};
        blob.read_shift(4);
        blob.l += 4;
        o.id = blob.read_shift(0, "lpp4");
        o.name = blob.read_shift(0, "lpp4");
        o.R = parse_CRYPTOVersion(blob, 4);
        o.U = parse_CRYPTOVersion(blob, 4);
        o.W = parse_CRYPTOVersion(blob, 4);
        return o;
      }
      function parse_Primary(blob) {
        var hdr = parse_TransformInfoHeader(blob);
        hdr.ename = blob.read_shift(0, "8lpp4");
        hdr.blksz = blob.read_shift(4);
        hdr.cmode = blob.read_shift(4);
        if (blob.read_shift(4) != 4)
          throw new Error("Bad !Primary record");
        return hdr;
      }
      function parse_EncryptionHeader(blob, length) {
        var tgt = blob.l + length;
        var o = {};
        o.Flags = blob.read_shift(4) & 63;
        blob.l += 4;
        o.AlgID = blob.read_shift(4);
        var valid = false;
        switch (o.AlgID) {
          case 26126:
          case 26127:
          case 26128:
            valid = o.Flags == 36;
            break;
          case 26625:
            valid = o.Flags == 4;
            break;
          case 0:
            valid = o.Flags == 16 || o.Flags == 4 || o.Flags == 36;
            break;
          default:
            throw "Unrecognized encryption algorithm: " + o.AlgID;
        }
        if (!valid)
          throw new Error("Encryption Flags/AlgID mismatch");
        o.AlgIDHash = blob.read_shift(4);
        o.KeySize = blob.read_shift(4);
        o.ProviderType = blob.read_shift(4);
        blob.l += 8;
        o.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
        blob.l = tgt;
        return o;
      }
      function parse_EncryptionVerifier(blob, length) {
        var o = {}, tgt = blob.l + length;
        blob.l += 4;
        o.Salt = blob.slice(blob.l, blob.l + 16);
        blob.l += 16;
        o.Verifier = blob.slice(blob.l, blob.l + 16);
        blob.l += 16;
        blob.read_shift(4);
        o.VerifierHash = blob.slice(blob.l, tgt);
        blob.l = tgt;
        return o;
      }
      function parse_EncryptionInfo(blob) {
        var vers = parse_CRYPTOVersion(blob);
        switch (vers.Minor) {
          case 2:
            return [vers.Minor, parse_EncInfoStd(blob)];
          case 3:
            return [vers.Minor, parse_EncInfoExt()];
          case 4:
            return [vers.Minor, parse_EncInfoAgl(blob)];
        }
        throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
      }
      function parse_EncInfoStd(blob) {
        var flags = blob.read_shift(4);
        if ((flags & 63) != 36)
          throw new Error("EncryptionInfo mismatch");
        var sz = blob.read_shift(4);
        var hdr = parse_EncryptionHeader(blob, sz);
        var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
        return { t: "Std", h: hdr, v: verifier };
      }
      function parse_EncInfoExt() {
        throw new Error("File is password-protected: ECMA-376 Extensible");
      }
      function parse_EncInfoAgl(blob) {
        var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
        blob.l += 4;
        var xml = blob.read_shift(blob.length - blob.l, "utf8");
        var o = {};
        xml.replace(tagregex, function xml_agile(x) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<?xml":
              break;
            case "<encryption":
            case "</encryption>":
              break;
            case "<keyData":
              KeyData.forEach(function(k) {
                o[k] = y[k];
              });
              break;
            case "<dataIntegrity":
              o.encryptedHmacKey = y.encryptedHmacKey;
              o.encryptedHmacValue = y.encryptedHmacValue;
              break;
            case "<keyEncryptors>":
            case "<keyEncryptors":
              o.encs = [];
              break;
            case "</keyEncryptors>":
              break;
            case "<keyEncryptor":
              o.uri = y.uri;
              break;
            case "</keyEncryptor>":
              break;
            case "<encryptedKey":
              o.encs.push(y);
              break;
            default:
              throw y[0];
          }
        });
        return o;
      }
      function parse_RC4CryptoHeader(blob, length) {
        var o = {};
        var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
        length -= 4;
        if (vers.Minor != 2)
          throw new Error("unrecognized minor version code: " + vers.Minor);
        if (vers.Major > 4 || vers.Major < 2)
          throw new Error("unrecognized major version code: " + vers.Major);
        o.Flags = blob.read_shift(4);
        length -= 4;
        var sz = blob.read_shift(4);
        length -= 4;
        o.EncryptionHeader = parse_EncryptionHeader(blob, sz);
        length -= sz;
        o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
        return o;
      }
      function parse_RC4Header(blob) {
        var o = {};
        var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
        if (vers.Major != 1 || vers.Minor != 1)
          throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
        o.Salt = blob.read_shift(16);
        o.EncryptedVerifier = blob.read_shift(16);
        o.EncryptedVerifierHash = blob.read_shift(16);
        return o;
      }
      function crypto_CreatePasswordVerifier_Method1(Password) {
        var Verifier = 0, PasswordArray;
        var PasswordDecoded = _JS2ANSI(Password);
        var len2 = PasswordDecoded.length + 1, i, PasswordByte;
        var Intermediate1, Intermediate2, Intermediate3;
        PasswordArray = new_raw_buf(len2);
        PasswordArray[0] = PasswordDecoded.length;
        for (i = 1; i != len2; ++i)
          PasswordArray[i] = PasswordDecoded[i - 1];
        for (i = len2 - 1; i >= 0; --i) {
          PasswordByte = PasswordArray[i];
          Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
          Intermediate2 = Verifier << 1 & 32767;
          Intermediate3 = Intermediate1 | Intermediate2;
          Verifier = Intermediate3 ^ PasswordByte;
        }
        return Verifier ^ 52811;
      }
      var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
        var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
        var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
        var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
        var Ror = function(Byte) {
          return (Byte / 2 | Byte * 128) & 255;
        };
        var XorRor = function(byte1, byte2) {
          return Ror(byte1 ^ byte2);
        };
        var CreateXorKey_Method1 = function(Password) {
          var XorKey = InitialCode[Password.length - 1];
          var CurrentElement = 104;
          for (var i = Password.length - 1; i >= 0; --i) {
            var Char = Password[i];
            for (var j = 0; j != 7; ++j) {
              if (Char & 64)
                XorKey ^= XorMatrix[CurrentElement];
              Char *= 2;
              --CurrentElement;
            }
          }
          return XorKey;
        };
        return function(password) {
          var Password = _JS2ANSI(password);
          var XorKey = CreateXorKey_Method1(Password);
          var Index = Password.length;
          var ObfuscationArray = new_raw_buf(16);
          for (var i = 0; i != 16; ++i)
            ObfuscationArray[i] = 0;
          var Temp, PasswordLastChar, PadIndex;
          if ((Index & 1) === 1) {
            Temp = XorKey >> 8;
            ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
            --Index;
            Temp = XorKey & 255;
            PasswordLastChar = Password[Password.length - 1];
            ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
          }
          while (Index > 0) {
            --Index;
            Temp = XorKey >> 8;
            ObfuscationArray[Index] = XorRor(Password[Index], Temp);
            --Index;
            Temp = XorKey & 255;
            ObfuscationArray[Index] = XorRor(Password[Index], Temp);
          }
          Index = 15;
          PadIndex = 15 - Password.length;
          while (PadIndex > 0) {
            Temp = XorKey >> 8;
            ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
            --Index;
            --PadIndex;
            Temp = XorKey & 255;
            ObfuscationArray[Index] = XorRor(Password[Index], Temp);
            --Index;
            --PadIndex;
          }
          return ObfuscationArray;
        };
      }();
      var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
        if (!O)
          O = Data;
        if (!XorArray)
          XorArray = crypto_CreateXorArray_Method1(password);
        var Index, Value;
        for (Index = 0; Index != Data.length; ++Index) {
          Value = Data[Index];
          Value ^= XorArray[XorArrayIndex];
          Value = (Value >> 5 | Value << 3) & 255;
          O[Index] = Value;
          ++XorArrayIndex;
        }
        return [O, XorArrayIndex, XorArray];
      };
      var crypto_MakeXorDecryptor = function(password) {
        var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
        return function(Data) {
          var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
          XorArrayIndex = O[1];
          return O[0];
        };
      };
      function parse_XORObfuscation(blob, length, opts, out) {
        var o = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
        if (opts.password)
          o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
        out.valid = o.verificationBytes === o.verifier;
        if (out.valid)
          out.insitu = crypto_MakeXorDecryptor(opts.password);
        return o;
      }
      function parse_FilePassHeader(blob, length, oo) {
        var o = oo || {};
        o.Info = blob.read_shift(2);
        blob.l -= 2;
        if (o.Info === 1)
          o.Data = parse_RC4Header(blob);
        else
          o.Data = parse_RC4CryptoHeader(blob, length);
        return o;
      }
      function parse_FilePass(blob, length, opts) {
        var o = { Type: opts.biff >= 8 ? blob.read_shift(2) : 0 };
        if (o.Type)
          parse_FilePassHeader(blob, length - 2, o);
        else
          parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o);
        return o;
      }
      var RTF = /* @__PURE__ */ function() {
        function rtf_to_sheet(d, opts) {
          switch (opts.type) {
            case "base64":
              return rtf_to_sheet_str(Base64_decode(d), opts);
            case "binary":
              return rtf_to_sheet_str(d, opts);
            case "buffer":
              return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
            case "array":
              return rtf_to_sheet_str(cc2str(d), opts);
          }
          throw new Error("Unrecognized type " + opts.type);
        }
        function rtf_to_sheet_str(str, opts) {
          var o = opts || {};
          var ws = o.dense ? [] : {};
          var rows = str.match(/\\trowd.*?\\row\b/g);
          if (!rows.length)
            throw new Error("RTF missing table");
          var range2 = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
          rows.forEach(function(rowtf, R) {
            if (Array.isArray(ws))
              ws[R] = [];
            var rtfre = /\\\w+\b/g;
            var last_index = 0;
            var res;
            var C = -1;
            while (res = rtfre.exec(rowtf)) {
              switch (res[0]) {
                case "\\cell":
                  var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
                  if (data[0] == " ")
                    data = data.slice(1);
                  ++C;
                  if (data.length) {
                    var cell = { v: data, t: "s" };
                    if (Array.isArray(ws))
                      ws[R][C] = cell;
                    else
                      ws[encode_cell({ r: R, c: C })] = cell;
                  }
                  break;
              }
              last_index = rtfre.lastIndex;
            }
            if (C > range2.e.c)
              range2.e.c = C;
          });
          ws["!ref"] = encode_range(range2);
          return ws;
        }
        function rtf_to_workbook(d, opts) {
          return sheet_to_workbook(rtf_to_sheet(d, opts), opts);
        }
        function sheet_to_rtf(ws) {
          var o = ["{\\rtf1\\ansi"];
          var r = safe_decode_range(ws["!ref"]), cell;
          var dense = Array.isArray(ws);
          for (var R = r.s.r; R <= r.e.r; ++R) {
            o.push("\\trowd\\trautofit1");
            for (var C = r.s.c; C <= r.e.c; ++C)
              o.push("\\cellx" + (C + 1));
            o.push("\\pard\\intbl");
            for (C = r.s.c; C <= r.e.c; ++C) {
              var coord = encode_cell({ r: R, c: C });
              cell = dense ? (ws[R] || [])[C] : ws[coord];
              if (!cell || cell.v == null && (!cell.f || cell.F))
                continue;
              o.push(" " + (cell.w || (format_cell(cell), cell.w)));
              o.push("\\cell");
            }
            o.push("\\pard\\intbl\\row");
          }
          return o.join("") + "}";
        }
        return {
          to_workbook: rtf_to_workbook,
          to_sheet: rtf_to_sheet,
          from_sheet: sheet_to_rtf
        };
      }();
      function hex2RGB(h2) {
        var o = h2.slice(h2[0] === "#" ? 1 : 0).slice(0, 6);
        return [parseInt(o.slice(0, 2), 16), parseInt(o.slice(2, 4), 16), parseInt(o.slice(4, 6), 16)];
      }
      function rgb2Hex(rgb) {
        for (var i = 0, o = 1; i != 3; ++i)
          o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
        return o.toString(16).toUpperCase().slice(1);
      }
      function rgb2HSL(rgb) {
        var R = rgb[0] / 255, G = rgb[1] / 255, B = rgb[2] / 255;
        var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;
        if (C === 0)
          return [0, 0, R];
        var H6 = 0, S = 0, L2 = M + m;
        S = C / (L2 > 1 ? 2 - L2 : L2);
        switch (M) {
          case R:
            H6 = ((G - B) / C + 6) % 6;
            break;
          case G:
            H6 = (B - R) / C + 2;
            break;
          case B:
            H6 = (R - G) / C + 4;
            break;
        }
        return [H6 / 6, S, L2 / 2];
      }
      function hsl2RGB(hsl) {
        var H = hsl[0], S = hsl[1], L = hsl[2];
        var C = S * 2 * (L < 0.5 ? L : 1 - L), m = L - C / 2;
        var rgb = [m, m, m], h6 = 6 * H;
        var X;
        if (S !== 0)
          switch (h6 | 0) {
            case 0:
            case 6:
              X = C * h6;
              rgb[0] += C;
              rgb[1] += X;
              break;
            case 1:
              X = C * (2 - h6);
              rgb[0] += X;
              rgb[1] += C;
              break;
            case 2:
              X = C * (h6 - 2);
              rgb[1] += C;
              rgb[2] += X;
              break;
            case 3:
              X = C * (4 - h6);
              rgb[1] += X;
              rgb[2] += C;
              break;
            case 4:
              X = C * (h6 - 4);
              rgb[2] += C;
              rgb[0] += X;
              break;
            case 5:
              X = C * (6 - h6);
              rgb[2] += X;
              rgb[0] += C;
              break;
          }
        for (var i = 0; i != 3; ++i)
          rgb[i] = Math.round(rgb[i] * 255);
        return rgb;
      }
      function rgb_tint(hex2, tint) {
        if (tint === 0)
          return hex2;
        var hsl = rgb2HSL(hex2RGB(hex2));
        if (tint < 0)
          hsl[2] = hsl[2] * (1 + tint);
        else
          hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
        return rgb2Hex(hsl2RGB(hsl));
      }
      var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
      function width2px(width) {
        return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
      }
      function px2char(px) {
        return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
      }
      function char2width(chr) {
        return Math.round((chr * MDW + 5) / MDW * 256) / 256;
      }
      function cycle_width(collw) {
        return char2width(px2char(width2px(collw)));
      }
      function find_mdw_colw(collw) {
        var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
        if (delta > 5e-3) {
          for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW)
            if (Math.abs(collw - cycle_width(collw)) <= delta) {
              delta = Math.abs(collw - cycle_width(collw));
              _MDW = MDW;
            }
        }
        MDW = _MDW;
      }
      function process_col(coll) {
        if (coll.width) {
          coll.wpx = width2px(coll.width);
          coll.wch = px2char(coll.wpx);
          coll.MDW = MDW;
        } else if (coll.wpx) {
          coll.wch = px2char(coll.wpx);
          coll.width = char2width(coll.wch);
          coll.MDW = MDW;
        } else if (typeof coll.wch == "number") {
          coll.width = char2width(coll.wch);
          coll.wpx = width2px(coll.width);
          coll.MDW = MDW;
        }
        if (coll.customWidth)
          delete coll.customWidth;
      }
      var DEF_PPI = 96, PPI = DEF_PPI;
      function px2pt(px) {
        return px * 96 / PPI;
      }
      function pt2px(pt) {
        return pt * PPI / 96;
      }
      var XLMLPatternTypeMap = {
        "None": "none",
        "Solid": "solid",
        "Gray50": "mediumGray",
        "Gray75": "darkGray",
        "Gray25": "lightGray",
        "HorzStripe": "darkHorizontal",
        "VertStripe": "darkVertical",
        "ReverseDiagStripe": "darkDown",
        "DiagStripe": "darkUp",
        "DiagCross": "darkGrid",
        "ThickDiagCross": "darkTrellis",
        "ThinHorzStripe": "lightHorizontal",
        "ThinVertStripe": "lightVertical",
        "ThinReverseDiagStripe": "lightDown",
        "ThinHorzCross": "lightGrid"
      };
      function parse_borders(t, styles2, themes, opts) {
        styles2.Borders = [];
        var border = {};
        var pass = false;
        (t[0].match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<borders":
            case "<borders>":
            case "</borders>":
              break;
            case "<border":
            case "<border>":
            case "<border/>":
              border = /*::(*/
              {};
              if (y.diagonalUp)
                border.diagonalUp = parsexmlbool(y.diagonalUp);
              if (y.diagonalDown)
                border.diagonalDown = parsexmlbool(y.diagonalDown);
              styles2.Borders.push(border);
              break;
            case "</border>":
              break;
            case "<left/>":
              break;
            case "<left":
            case "<left>":
              break;
            case "</left>":
              break;
            case "<right/>":
              break;
            case "<right":
            case "<right>":
              break;
            case "</right>":
              break;
            case "<top/>":
              break;
            case "<top":
            case "<top>":
              break;
            case "</top>":
              break;
            case "<bottom/>":
              break;
            case "<bottom":
            case "<bottom>":
              break;
            case "</bottom>":
              break;
            case "<diagonal":
            case "<diagonal>":
            case "<diagonal/>":
              break;
            case "</diagonal>":
              break;
            case "<horizontal":
            case "<horizontal>":
            case "<horizontal/>":
              break;
            case "</horizontal>":
              break;
            case "<vertical":
            case "<vertical>":
            case "<vertical/>":
              break;
            case "</vertical>":
              break;
            case "<start":
            case "<start>":
            case "<start/>":
              break;
            case "</start>":
              break;
            case "<end":
            case "<end>":
            case "<end/>":
              break;
            case "</end>":
              break;
            case "<color":
            case "<color>":
              break;
            case "<color/>":
            case "</color>":
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            default:
              if (opts && opts.WTF) {
                if (!pass)
                  throw new Error("unrecognized " + y[0] + " in borders");
              }
          }
        });
      }
      function parse_fills(t, styles2, themes, opts) {
        styles2.Fills = [];
        var fill2 = {};
        var pass = false;
        (t[0].match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<fills":
            case "<fills>":
            case "</fills>":
              break;
            case "<fill>":
            case "<fill":
            case "<fill/>":
              fill2 = {};
              styles2.Fills.push(fill2);
              break;
            case "</fill>":
              break;
            case "<gradientFill>":
              break;
            case "<gradientFill":
            case "</gradientFill>":
              styles2.Fills.push(fill2);
              fill2 = {};
              break;
            case "<patternFill":
            case "<patternFill>":
              if (y.patternType)
                fill2.patternType = y.patternType;
              break;
            case "<patternFill/>":
            case "</patternFill>":
              break;
            case "<bgColor":
              if (!fill2.bgColor)
                fill2.bgColor = {};
              if (y.indexed)
                fill2.bgColor.indexed = parseInt(y.indexed, 10);
              if (y.theme)
                fill2.bgColor.theme = parseInt(y.theme, 10);
              if (y.tint)
                fill2.bgColor.tint = parseFloat(y.tint);
              if (y.rgb)
                fill2.bgColor.rgb = y.rgb.slice(-6);
              break;
            case "<bgColor/>":
            case "</bgColor>":
              break;
            case "<fgColor":
              if (!fill2.fgColor)
                fill2.fgColor = {};
              if (y.theme)
                fill2.fgColor.theme = parseInt(y.theme, 10);
              if (y.tint)
                fill2.fgColor.tint = parseFloat(y.tint);
              if (y.rgb != null)
                fill2.fgColor.rgb = y.rgb.slice(-6);
              break;
            case "<fgColor/>":
            case "</fgColor>":
              break;
            case "<stop":
            case "<stop/>":
              break;
            case "</stop>":
              break;
            case "<color":
            case "<color/>":
              break;
            case "</color>":
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            default:
              if (opts && opts.WTF) {
                if (!pass)
                  throw new Error("unrecognized " + y[0] + " in fills");
              }
          }
        });
      }
      function parse_fonts(t, styles2, themes, opts) {
        styles2.Fonts = [];
        var font = {};
        var pass = false;
        (t[0].match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<fonts":
            case "<fonts>":
            case "</fonts>":
              break;
            case "<font":
            case "<font>":
              break;
            case "</font>":
            case "<font/>":
              styles2.Fonts.push(font);
              font = {};
              break;
            case "<name":
              if (y.val)
                font.name = utf8read(y.val);
              break;
            case "<name/>":
            case "</name>":
              break;
            case "<b":
              font.bold = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<b/>":
              font.bold = 1;
              break;
            case "<i":
              font.italic = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<i/>":
              font.italic = 1;
              break;
            case "<u":
              switch (y.val) {
                case "none":
                  font.underline = 0;
                  break;
                case "single":
                  font.underline = 1;
                  break;
                case "double":
                  font.underline = 2;
                  break;
                case "singleAccounting":
                  font.underline = 33;
                  break;
                case "doubleAccounting":
                  font.underline = 34;
                  break;
              }
              break;
            case "<u/>":
              font.underline = 1;
              break;
            case "<strike":
              font.strike = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<strike/>":
              font.strike = 1;
              break;
            case "<outline":
              font.outline = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<outline/>":
              font.outline = 1;
              break;
            case "<shadow":
              font.shadow = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<shadow/>":
              font.shadow = 1;
              break;
            case "<condense":
              font.condense = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<condense/>":
              font.condense = 1;
              break;
            case "<extend":
              font.extend = y.val ? parsexmlbool(y.val) : 1;
              break;
            case "<extend/>":
              font.extend = 1;
              break;
            case "<sz":
              if (y.val)
                font.sz = +y.val;
              break;
            case "<sz/>":
            case "</sz>":
              break;
            case "<vertAlign":
              if (y.val)
                font.vertAlign = y.val;
              break;
            case "<vertAlign/>":
            case "</vertAlign>":
              break;
            case "<family":
              if (y.val)
                font.family = parseInt(y.val, 10);
              break;
            case "<family/>":
            case "</family>":
              break;
            case "<scheme":
              if (y.val)
                font.scheme = y.val;
              break;
            case "<scheme/>":
            case "</scheme>":
              break;
            case "<charset":
              if (y.val == "1")
                break;
              y.codepage = CS2CP[parseInt(y.val, 10)];
              break;
            case "<color":
              if (!font.color)
                font.color = {};
              if (y.auto)
                font.color.auto = parsexmlbool(y.auto);
              if (y.rgb)
                font.color.rgb = y.rgb.slice(-6);
              else if (y.indexed) {
                font.color.index = parseInt(y.indexed, 10);
                var icv = XLSIcv[font.color.index];
                if (font.color.index == 81)
                  icv = XLSIcv[1];
                if (!icv)
                  icv = XLSIcv[1];
                font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
              } else if (y.theme) {
                font.color.theme = parseInt(y.theme, 10);
                if (y.tint)
                  font.color.tint = parseFloat(y.tint);
                if (y.theme && themes.themeElements && themes.themeElements.clrScheme) {
                  font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
                }
              }
              break;
            case "<color/>":
            case "</color>":
              break;
            case "<AlternateContent":
              pass = true;
              break;
            case "</AlternateContent>":
              pass = false;
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            default:
              if (opts && opts.WTF) {
                if (!pass)
                  throw new Error("unrecognized " + y[0] + " in fonts");
              }
          }
        });
      }
      function parse_numFmts(t, styles2, opts) {
        styles2.NumberFmt = [];
        var k = keys(table_fmt);
        for (var i = 0; i < k.length; ++i)
          styles2.NumberFmt[k[i]] = table_fmt[k[i]];
        var m = t[0].match(tagregex);
        if (!m)
          return;
        for (i = 0; i < m.length; ++i) {
          var y = parsexmltag(m[i]);
          switch (strip_ns(y[0])) {
            case "<numFmts":
            case "</numFmts>":
            case "<numFmts/>":
            case "<numFmts>":
              break;
            case "<numFmt":
              {
                var f = unescapexml(utf8read(y.formatCode)), j = parseInt(y.numFmtId, 10);
                styles2.NumberFmt[j] = f;
                if (j > 0) {
                  if (j > 392) {
                    for (j = 392; j > 60; --j)
                      if (styles2.NumberFmt[j] == null)
                        break;
                    styles2.NumberFmt[j] = f;
                  }
                  SSF_load(f, j);
                }
              }
              break;
            case "</numFmt>":
              break;
            default:
              if (opts.WTF)
                throw new Error("unrecognized " + y[0] + " in numFmts");
          }
        }
      }
      var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
      var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
      function parse_cellXfs(t, styles2, opts) {
        styles2.CellXf = [];
        var xf;
        var pass = false;
        (t[0].match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x), i = 0;
          switch (strip_ns(y[0])) {
            case "<cellXfs":
            case "<cellXfs>":
            case "<cellXfs/>":
            case "</cellXfs>":
              break;
            case "<xf":
            case "<xf/>":
              xf = y;
              delete xf[0];
              for (i = 0; i < cellXF_uint.length; ++i)
                if (xf[cellXF_uint[i]])
                  xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);
              for (i = 0; i < cellXF_bool.length; ++i)
                if (xf[cellXF_bool[i]])
                  xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);
              if (styles2.NumberFmt && xf.numFmtId > 392) {
                for (i = 392; i > 60; --i)
                  if (styles2.NumberFmt[xf.numFmtId] == styles2.NumberFmt[i]) {
                    xf.numFmtId = i;
                    break;
                  }
              }
              styles2.CellXf.push(xf);
              break;
            case "</xf>":
              break;
            case "<alignment":
            case "<alignment/>":
              var alignment = {};
              if (y.vertical)
                alignment.vertical = y.vertical;
              if (y.horizontal)
                alignment.horizontal = y.horizontal;
              if (y.textRotation != null)
                alignment.textRotation = y.textRotation;
              if (y.indent)
                alignment.indent = y.indent;
              if (y.wrapText)
                alignment.wrapText = parsexmlbool(y.wrapText);
              xf.alignment = alignment;
              break;
            case "</alignment>":
              break;
            case "<protection":
              break;
            case "</protection>":
            case "<protection/>":
              break;
            case "<AlternateContent":
              pass = true;
              break;
            case "</AlternateContent>":
              pass = false;
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            default:
              if (opts && opts.WTF) {
                if (!pass)
                  throw new Error("unrecognized " + y[0] + " in cellXfs");
              }
          }
        });
      }
      var parse_sty_xml = /* @__PURE__ */ function make_pstyx() {
        var numFmtRegex = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;
        var cellXfRegex = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;
        var fillsRegex = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;
        var fontsRegex = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;
        var bordersRegex = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
        return function parse_sty_xml2(data, themes, opts) {
          var styles2 = {};
          if (!data)
            return styles2;
          data = data.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
          var t;
          if (t = data.match(numFmtRegex))
            parse_numFmts(t, styles2, opts);
          if (t = data.match(fontsRegex))
            parse_fonts(t, styles2, themes, opts);
          if (t = data.match(fillsRegex))
            parse_fills(t, styles2, themes, opts);
          if (t = data.match(bordersRegex))
            parse_borders(t, styles2, themes, opts);
          if (t = data.match(cellXfRegex))
            parse_cellXfs(t, styles2, opts);
          return styles2;
        };
      }();
      function parse_BrtFmt(data, length) {
        var numFmtId = data.read_shift(2);
        var stFmtCode = parse_XLWideString(data);
        return [numFmtId, stFmtCode];
      }
      function parse_BrtFont(data, length, opts) {
        var out = {};
        out.sz = data.read_shift(2) / 20;
        var grbit = parse_FontFlags(data);
        if (grbit.fItalic)
          out.italic = 1;
        if (grbit.fCondense)
          out.condense = 1;
        if (grbit.fExtend)
          out.extend = 1;
        if (grbit.fShadow)
          out.shadow = 1;
        if (grbit.fOutline)
          out.outline = 1;
        if (grbit.fStrikeout)
          out.strike = 1;
        var bls = data.read_shift(2);
        if (bls === 700)
          out.bold = 1;
        switch (data.read_shift(2)) {
          case 1:
            out.vertAlign = "superscript";
            break;
          case 2:
            out.vertAlign = "subscript";
            break;
        }
        var underline = data.read_shift(1);
        if (underline != 0)
          out.underline = underline;
        var family = data.read_shift(1);
        if (family > 0)
          out.family = family;
        var bCharSet = data.read_shift(1);
        if (bCharSet > 0)
          out.charset = bCharSet;
        data.l++;
        out.color = parse_BrtColor(data);
        switch (data.read_shift(1)) {
          case 1:
            out.scheme = "major";
            break;
          case 2:
            out.scheme = "minor";
            break;
        }
        out.name = parse_XLWideString(data);
        return out;
      }
      var parse_BrtFill = parsenoop;
      function parse_BrtXF(data, length) {
        var tgt = data.l + length;
        var ixfeParent = data.read_shift(2);
        var ifmt = data.read_shift(2);
        data.l = tgt;
        return { ixfe: ixfeParent, numFmtId: ifmt };
      }
      var parse_BrtBorder = parsenoop;
      function parse_sty_bin(data, themes, opts) {
        var styles2 = {};
        styles2.NumberFmt = [];
        for (var y in table_fmt)
          styles2.NumberFmt[y] = table_fmt[y];
        styles2.CellXf = [];
        styles2.Fonts = [];
        var state = [];
        var pass = false;
        recordhopper(data, function hopper_sty(val, R, RT) {
          switch (RT) {
            case 44:
              styles2.NumberFmt[val[0]] = val[1];
              SSF_load(val[1], val[0]);
              break;
            case 43:
              styles2.Fonts.push(val);
              if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
                val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
              }
              break;
            case 1025:
              break;
            case 45:
              break;
            case 46:
              break;
            case 47:
              if (state[state.length - 1] == 617) {
                styles2.CellXf.push(val);
              }
              break;
            case 48:
            case 507:
            case 572:
            case 475:
              break;
            case 1171:
            case 2102:
            case 1130:
            case 512:
            case 2095:
            case 3072:
              break;
            case 35:
              pass = true;
              break;
            case 36:
              pass = false;
              break;
            case 37:
              state.push(RT);
              pass = true;
              break;
            case 38:
              state.pop();
              pass = false;
              break;
            default:
              if (R.T > 0)
                state.push(RT);
              else if (R.T < 0)
                state.pop();
              else if (!pass || opts.WTF && state[state.length - 1] != 37)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        });
        return styles2;
      }
      var XLSXThemeClrScheme = [
        "</a:lt1>",
        "</a:dk1>",
        "</a:lt2>",
        "</a:dk2>",
        "</a:accent1>",
        "</a:accent2>",
        "</a:accent3>",
        "</a:accent4>",
        "</a:accent5>",
        "</a:accent6>",
        "</a:hlink>",
        "</a:folHlink>"
      ];
      function parse_clrScheme(t, themes, opts) {
        themes.themeElements.clrScheme = [];
        var color = {};
        (t[0].match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          switch (y[0]) {
            case "<a:clrScheme":
            case "</a:clrScheme>":
              break;
            case "<a:srgbClr":
              color.rgb = y.val;
              break;
            case "<a:sysClr":
              color.rgb = y.lastClr;
              break;
            case "<a:dk1>":
            case "</a:dk1>":
            case "<a:lt1>":
            case "</a:lt1>":
            case "<a:dk2>":
            case "</a:dk2>":
            case "<a:lt2>":
            case "</a:lt2>":
            case "<a:accent1>":
            case "</a:accent1>":
            case "<a:accent2>":
            case "</a:accent2>":
            case "<a:accent3>":
            case "</a:accent3>":
            case "<a:accent4>":
            case "</a:accent4>":
            case "<a:accent5>":
            case "</a:accent5>":
            case "<a:accent6>":
            case "</a:accent6>":
            case "<a:hlink>":
            case "</a:hlink>":
            case "<a:folHlink>":
            case "</a:folHlink>":
              if (y[0].charAt(1) === "/") {
                themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;
                color = {};
              } else {
                color.name = y[0].slice(3, y[0].length - 1);
              }
              break;
            default:
              if (opts && opts.WTF)
                throw new Error("Unrecognized " + y[0] + " in clrScheme");
          }
        });
      }
      function parse_fontScheme() {
      }
      function parse_fmtScheme() {
      }
      var clrsregex = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;
      var fntsregex = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;
      var fmtsregex = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
      function parse_themeElements(data, themes, opts) {
        themes.themeElements = {};
        var t;
        [
          /* clrScheme CT_ColorScheme */
          ["clrScheme", clrsregex, parse_clrScheme],
          /* fontScheme CT_FontScheme */
          ["fontScheme", fntsregex, parse_fontScheme],
          /* fmtScheme CT_StyleMatrix */
          ["fmtScheme", fmtsregex, parse_fmtScheme]
        ].forEach(function(m) {
          if (!(t = data.match(m[1])))
            throw new Error(m[0] + " not found in themeElements");
          m[2](t, themes, opts);
        });
      }
      var themeltregex = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
      function parse_theme_xml(data, opts) {
        if (!data || data.length === 0)
          data = write_theme();
        var t;
        var themes = {};
        if (!(t = data.match(themeltregex)))
          throw new Error("themeElements not found in theme");
        parse_themeElements(t[0], themes, opts);
        themes.raw = data;
        return themes;
      }
      function write_theme(Themes, opts) {
        if (opts && opts.themeXLSX)
          return opts.themeXLSX;
        if (Themes && typeof Themes.raw == "string")
          return Themes.raw;
        var o = [XML_HEADER];
        o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
        o[o.length] = "<a:themeElements>";
        o[o.length] = '<a:clrScheme name="Office">';
        o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
        o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
        o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
        o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
        o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
        o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
        o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
        o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
        o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
        o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
        o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
        o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
        o[o.length] = "</a:clrScheme>";
        o[o.length] = '<a:fontScheme name="Office">';
        o[o.length] = "<a:majorFont>";
        o[o.length] = '<a:latin typeface="Cambria"/>';
        o[o.length] = '<a:ea typeface=""/>';
        o[o.length] = '<a:cs typeface=""/>';
        o[o.length] = '<a:font script="Jpan" typeface=" "/>';
        o[o.length] = '<a:font script="Hang" typeface=" "/>';
        o[o.length] = '<a:font script="Hans" typeface=""/>';
        o[o.length] = '<a:font script="Hant" typeface=""/>';
        o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
        o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
        o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
        o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
        o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
        o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
        o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
        o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
        o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
        o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
        o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
        o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
        o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
        o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
        o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
        o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
        o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
        o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
        o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
        o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
        o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
        o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
        o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
        o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
        o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
        o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
        o[o.length] = "</a:majorFont>";
        o[o.length] = "<a:minorFont>";
        o[o.length] = '<a:latin typeface="Calibri"/>';
        o[o.length] = '<a:ea typeface=""/>';
        o[o.length] = '<a:cs typeface=""/>';
        o[o.length] = '<a:font script="Jpan" typeface=" "/>';
        o[o.length] = '<a:font script="Hang" typeface=" "/>';
        o[o.length] = '<a:font script="Hans" typeface=""/>';
        o[o.length] = '<a:font script="Hant" typeface=""/>';
        o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
        o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
        o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
        o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
        o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
        o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
        o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
        o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
        o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
        o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
        o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
        o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
        o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
        o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
        o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
        o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
        o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
        o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
        o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
        o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
        o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
        o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
        o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
        o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
        o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
        o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
        o[o.length] = "</a:minorFont>";
        o[o.length] = "</a:fontScheme>";
        o[o.length] = '<a:fmtScheme name="Office">';
        o[o.length] = "<a:fillStyleLst>";
        o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = "</a:fillStyleLst>";
        o[o.length] = "<a:lnStyleLst>";
        o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
        o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
        o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
        o[o.length] = "</a:lnStyleLst>";
        o[o.length] = "<a:effectStyleLst>";
        o[o.length] = "<a:effectStyle>";
        o[o.length] = "<a:effectLst>";
        o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
        o[o.length] = "</a:effectLst>";
        o[o.length] = "</a:effectStyle>";
        o[o.length] = "<a:effectStyle>";
        o[o.length] = "<a:effectLst>";
        o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
        o[o.length] = "</a:effectLst>";
        o[o.length] = "</a:effectStyle>";
        o[o.length] = "<a:effectStyle>";
        o[o.length] = "<a:effectLst>";
        o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
        o[o.length] = "</a:effectLst>";
        o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
        o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
        o[o.length] = "</a:effectStyle>";
        o[o.length] = "</a:effectStyleLst>";
        o[o.length] = "<a:bgFillStyleLst>";
        o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = '<a:gradFill rotWithShape="1">';
        o[o.length] = "<a:gsLst>";
        o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
        o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
        o[o.length] = "</a:gsLst>";
        o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
        o[o.length] = "</a:gradFill>";
        o[o.length] = "</a:bgFillStyleLst>";
        o[o.length] = "</a:fmtScheme>";
        o[o.length] = "</a:themeElements>";
        o[o.length] = "<a:objectDefaults>";
        o[o.length] = "<a:spDef>";
        o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
        o[o.length] = "</a:spDef>";
        o[o.length] = "<a:lnDef>";
        o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
        o[o.length] = "</a:lnDef>";
        o[o.length] = "</a:objectDefaults>";
        o[o.length] = "<a:extraClrSchemeLst/>";
        o[o.length] = "</a:theme>";
        return o.join("");
      }
      function parse_Theme(blob, length, opts) {
        var end = blob.l + length;
        var dwThemeVersion = blob.read_shift(4);
        if (dwThemeVersion === 124226)
          return;
        if (!opts.cellStyles) {
          blob.l = end;
          return;
        }
        var data = blob.slice(blob.l);
        blob.l = end;
        var zip;
        try {
          zip = zip_read(data, { type: "array" });
        } catch (e) {
          return;
        }
        var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
        if (!themeXML)
          return;
        return parse_theme_xml(themeXML, opts);
      }
      function parse_ColorTheme(blob) {
        return blob.read_shift(4);
      }
      function parse_FullColorExt(blob) {
        var o = {};
        o.xclrType = blob.read_shift(2);
        o.nTintShade = blob.read_shift(2);
        switch (o.xclrType) {
          case 0:
            blob.l += 4;
            break;
          case 1:
            o.xclrValue = parse_IcvXF(blob, 4);
            break;
          case 2:
            o.xclrValue = parse_LongRGBA(blob);
            break;
          case 3:
            o.xclrValue = parse_ColorTheme(blob);
            break;
          case 4:
            blob.l += 4;
            break;
        }
        blob.l += 8;
        return o;
      }
      function parse_IcvXF(blob, length) {
        return parsenoop(blob, length);
      }
      function parse_XFExtGradient(blob, length) {
        return parsenoop(blob, length);
      }
      function parse_ExtProp(blob) {
        var extType = blob.read_shift(2);
        var cb = blob.read_shift(2) - 4;
        var o = [extType];
        switch (extType) {
          case 4:
          case 5:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 13:
            o[1] = parse_FullColorExt(blob);
            break;
          case 6:
            o[1] = parse_XFExtGradient(blob, cb);
            break;
          case 14:
          case 15:
            o[1] = blob.read_shift(cb === 1 ? 1 : 2);
            break;
          default:
            throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
        }
        return o;
      }
      function parse_XFExt(blob, length) {
        var end = blob.l + length;
        blob.l += 2;
        var ixfe = blob.read_shift(2);
        blob.l += 2;
        var cexts = blob.read_shift(2);
        var ext = [];
        while (cexts-- > 0)
          ext.push(parse_ExtProp(blob, end - blob.l));
        return { ixfe, ext };
      }
      function update_xfext(xf, xfext) {
        xfext.forEach(function(xfe) {
          switch (xfe[0]) {
          }
        });
      }
      function parse_BrtMdtinfo(data, length) {
        return {
          flags: data.read_shift(4),
          version: data.read_shift(4),
          name: parse_XLWideString(data)
        };
      }
      function parse_BrtMdb(data) {
        var out = [];
        var cnt = data.read_shift(4);
        while (cnt-- > 0)
          out.push([data.read_shift(4), data.read_shift(4)]);
        return out;
      }
      function parse_BrtBeginEsmdb(data) {
        data.l += 4;
        return data.read_shift(4) != 0;
      }
      function parse_xlmeta_bin(data, name, _opts) {
        var out = { Types: [], Cell: [], Value: [] };
        var opts = _opts || {};
        var state = [];
        var pass = false;
        var metatype = 2;
        recordhopper(data, function(val, R, RT) {
          switch (RT) {
            case 335:
              out.Types.push({ name: val.name });
              break;
            case 51:
              val.forEach(function(r) {
                if (metatype == 1)
                  out.Cell.push({ type: out.Types[r[0] - 1].name, index: r[1] });
                else if (metatype == 0)
                  out.Value.push({ type: out.Types[r[0] - 1].name, index: r[1] });
              });
              break;
            case 337:
              metatype = val ? 1 : 0;
              break;
            case 338:
              metatype = 2;
              break;
            case 35:
              state.push(RT);
              pass = true;
              break;
            case 36:
              state.pop();
              pass = false;
              break;
            default:
              if (R.T)
                ;
              else if (!pass || opts.WTF && state[state.length - 1] != 35)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        });
        return out;
      }
      function parse_xlmeta_xml(data, name, opts) {
        var out = { Types: [], Cell: [], Value: [] };
        if (!data)
          return out;
        var pass = false;
        var metatype = 2;
        var lastmeta;
        data.replace(tagregex, function(x) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<?xml":
              break;
            case "<metadata":
            case "</metadata>":
              break;
            case "<metadataTypes":
            case "</metadataTypes>":
              break;
            case "<metadataType":
              out.Types.push({ name: y.name });
              break;
            case "</metadataType>":
              break;
            case "<futureMetadata":
              for (var j = 0; j < out.Types.length; ++j)
                if (out.Types[j].name == y.name)
                  lastmeta = out.Types[j];
              break;
            case "</futureMetadata>":
              break;
            case "<bk>":
              break;
            case "</bk>":
              break;
            case "<rc":
              if (metatype == 1)
                out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });
              else if (metatype == 0)
                out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });
              break;
            case "</rc>":
              break;
            case "<cellMetadata":
              metatype = 1;
              break;
            case "</cellMetadata>":
              metatype = 2;
              break;
            case "<valueMetadata":
              metatype = 0;
              break;
            case "</valueMetadata>":
              metatype = 2;
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
            case "<extLst/>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            case "<rvb":
              if (!lastmeta)
                break;
              if (!lastmeta.offsets)
                lastmeta.offsets = [];
              lastmeta.offsets.push(+y.i);
              break;
            default:
              if (!pass && opts.WTF)
                throw new Error("unrecognized " + y[0] + " in metadata");
          }
          return x;
        });
        return out;
      }
      function parse_cc_xml(data) {
        var d = [];
        if (!data)
          return d;
        var i = 1;
        (data.match(tagregex) || []).forEach(function(x) {
          var y = parsexmltag(x);
          switch (y[0]) {
            case "<?xml":
              break;
            case "<calcChain":
            case "<calcChain>":
            case "</calcChain>":
              break;
            case "<c":
              delete y[0];
              if (y.i)
                i = y.i;
              else
                y.i = i;
              d.push(y);
              break;
          }
        });
        return d;
      }
      function parse_BrtCalcChainItem$(data) {
        var out = {};
        out.i = data.read_shift(4);
        var cell = {};
        cell.r = data.read_shift(4);
        cell.c = data.read_shift(4);
        out.r = encode_cell(cell);
        var flags = data.read_shift(1);
        if (flags & 2)
          out.l = "1";
        if (flags & 8)
          out.a = "1";
        return out;
      }
      function parse_cc_bin(data, name, opts) {
        var out = [];
        recordhopper(data, function hopper_cc(val, R, RT) {
          switch (RT) {
            case 63:
              out.push(val);
              break;
            default:
              if (R.T)
                ;
              else
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        });
        return out;
      }
      function parse_xlink_xml() {
      }
      function parse_xlink_bin(data, rel, name, _opts) {
        if (!data)
          return data;
        var opts = _opts || {};
        var pass = false;
        recordhopper(data, function xlink_parse(val, R, RT) {
          switch (RT) {
            case 359:
            case 363:
            case 364:
            case 366:
            case 367:
            case 368:
            case 369:
            case 370:
            case 371:
            case 472:
            case 577:
            case 578:
            case 579:
            case 580:
            case 581:
            case 582:
            case 583:
            case 584:
            case 585:
            case 586:
            case 587:
              break;
            case 35:
              pass = true;
              break;
            case 36:
              pass = false;
              break;
            default:
              if (R.T)
                ;
              else if (!pass || opts.WTF)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        }, opts);
      }
      function parse_drawing(data, rels) {
        if (!data)
          return "??";
        var id = (data.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
        return rels["!id"][id].Target;
      }
      function sheet_insert_comments(sheet, comments, threaded, people) {
        var dense = Array.isArray(sheet);
        var cell;
        comments.forEach(function(comment) {
          var r = decode_cell(comment.ref);
          if (dense) {
            if (!sheet[r.r])
              sheet[r.r] = [];
            cell = sheet[r.r][r.c];
          } else
            cell = sheet[comment.ref];
          if (!cell) {
            cell = { t: "z" };
            if (dense)
              sheet[r.r][r.c] = cell;
            else
              sheet[comment.ref] = cell;
            var range2 = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
            if (range2.s.r > r.r)
              range2.s.r = r.r;
            if (range2.e.r < r.r)
              range2.e.r = r.r;
            if (range2.s.c > r.c)
              range2.s.c = r.c;
            if (range2.e.c < r.c)
              range2.e.c = r.c;
            var encoded = encode_range(range2);
            if (encoded !== sheet["!ref"])
              sheet["!ref"] = encoded;
          }
          if (!cell.c)
            cell.c = [];
          var o = { a: comment.author, t: comment.t, r: comment.r, T: threaded };
          if (comment.h)
            o.h = comment.h;
          for (var i = cell.c.length - 1; i >= 0; --i) {
            if (!threaded && cell.c[i].T)
              return;
            if (threaded && !cell.c[i].T)
              cell.c.splice(i, 1);
          }
          if (threaded && people)
            for (i = 0; i < people.length; ++i) {
              if (o.a == people[i].id) {
                o.a = people[i].name || o.a;
                break;
              }
            }
          cell.c.push(o);
        });
      }
      function parse_comments_xml(data, opts) {
        if (data.match(/<(?:\w+:)?comments *\/>/))
          return [];
        var authors = [];
        var commentList = [];
        var authtag = data.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
        if (authtag && authtag[1])
          authtag[1].split(/<\/\w*:?author>/).forEach(function(x) {
            if (x === "" || x.trim() === "")
              return;
            var a2 = x.match(/<(?:\w+:)?author[^>]*>(.*)/);
            if (a2)
              authors.push(a2[1]);
          });
        var cmnttag = data.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
        if (cmnttag && cmnttag[1])
          cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x) {
            if (x === "" || x.trim() === "")
              return;
            var cm = x.match(/<(?:\w+:)?comment[^>]*>/);
            if (!cm)
              return;
            var y = parsexmltag(cm[0]);
            var comment = { author: y.authorId && authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid };
            var cell = decode_cell(y.ref);
            if (opts.sheetRows && opts.sheetRows <= cell.r)
              return;
            var textMatch = x.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);
            var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
            comment.r = rt.r;
            if (rt.r == "<t></t>")
              rt.t = rt.h = "";
            comment.t = (rt.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            if (opts.cellHTML)
              comment.h = rt.h;
            commentList.push(comment);
          });
        return commentList;
      }
      function parse_tcmnt_xml(data, opts) {
        var out = [];
        var pass = false, comment = {}, tidx = 0;
        data.replace(tagregex, function xml_tcmnt(x, idx) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<?xml":
              break;
            case "<ThreadedComments":
              break;
            case "</ThreadedComments>":
              break;
            case "<threadedComment":
              comment = { author: y.personId, guid: y.id, ref: y.ref, T: 1 };
              break;
            case "</threadedComment>":
              if (comment.t != null)
                out.push(comment);
              break;
            case "<text>":
            case "<text":
              tidx = idx + x.length;
              break;
            case "</text>":
              comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
              break;
            case "<mentions":
            case "<mentions>":
              pass = true;
              break;
            case "</mentions>":
              pass = false;
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
            case "<extLst/>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            default:
              if (!pass && opts.WTF)
                throw new Error("unrecognized " + y[0] + " in threaded comments");
          }
          return x;
        });
        return out;
      }
      function parse_people_xml(data, opts) {
        var out = [];
        var pass = false;
        data.replace(tagregex, function xml_tcmnt(x) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<?xml":
              break;
            case "<personList":
              break;
            case "</personList>":
              break;
            case "<person":
              out.push({ name: y.displayname, id: y.id });
              break;
            case "</person>":
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
            case "<extLst/>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            default:
              if (!pass && opts.WTF)
                throw new Error("unrecognized " + y[0] + " in threaded comments");
          }
          return x;
        });
        return out;
      }
      function parse_BrtBeginComment(data) {
        var out = {};
        out.iauthor = data.read_shift(4);
        var rfx = parse_UncheckedRfX(data);
        out.rfx = rfx.s;
        out.ref = encode_cell(rfx.s);
        data.l += 16;
        return out;
      }
      var parse_BrtCommentAuthor = parse_XLWideString;
      function parse_comments_bin(data, opts) {
        var out = [];
        var authors = [];
        var c2 = {};
        var pass = false;
        recordhopper(data, function hopper_cmnt(val, R, RT) {
          switch (RT) {
            case 632:
              authors.push(val);
              break;
            case 635:
              c2 = val;
              break;
            case 637:
              c2.t = val.t;
              c2.h = val.h;
              c2.r = val.r;
              break;
            case 636:
              c2.author = authors[c2.iauthor];
              delete c2.iauthor;
              if (opts.sheetRows && c2.rfx && opts.sheetRows <= c2.rfx.r)
                break;
              if (!c2.t)
                c2.t = "";
              delete c2.rfx;
              out.push(c2);
              break;
            case 3072:
              break;
            case 35:
              pass = true;
              break;
            case 36:
              pass = false;
              break;
            case 37:
              break;
            case 38:
              break;
            default:
              if (R.T)
                ;
              else if (!pass || opts.WTF)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        });
        return out;
      }
      var CT_VBA = "application/vnd.ms-office.vbaProject";
      function make_vba_xls(cfb) {
        var newcfb = CFB.utils.cfb_new({ root: "R" });
        cfb.FullPaths.forEach(function(p2, i) {
          if (p2.slice(-1) === "/" || !p2.match(/_VBA_PROJECT_CUR/))
            return;
          var newpath = p2.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
          CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);
        });
        return CFB.write(newcfb);
      }
      function parse_ds_bin() {
        return { "!type": "dialog" };
      }
      function parse_ds_xml() {
        return { "!type": "dialog" };
      }
      function parse_ms_bin() {
        return { "!type": "macro" };
      }
      function parse_ms_xml() {
        return { "!type": "macro" };
      }
      var rc_to_a1 = /* @__PURE__ */ function() {
        var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
        var rcbase = { r: 0, c: 0 };
        function rcfunc($$, $1, $2, $3) {
          var cRel = false, rRel = false;
          if ($2.length == 0)
            rRel = true;
          else if ($2.charAt(0) == "[") {
            rRel = true;
            $2 = $2.slice(1, -1);
          }
          if ($3.length == 0)
            cRel = true;
          else if ($3.charAt(0) == "[") {
            cRel = true;
            $3 = $3.slice(1, -1);
          }
          var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
          if (cRel)
            C += rcbase.c;
          else
            --C;
          if (rRel)
            R += rcbase.r;
          else
            --R;
          return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
        }
        return function rc_to_a12(fstr, base2) {
          rcbase = base2;
          return fstr.replace(rcregex, rcfunc);
        };
      }();
      var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
      var a1_to_rc = /* @__PURE__ */ function() {
        return function a1_to_rc2(fstr, base2) {
          return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
            var c2 = decode_col($3) - ($2 ? 0 : base2.c);
            var r = decode_row($5) - ($4 ? 0 : base2.r);
            var R = r == 0 ? "" : !$4 ? "[" + r + "]" : r + 1;
            var C = c2 == 0 ? "" : !$2 ? "[" + c2 + "]" : c2 + 1;
            return $1 + "R" + R + "C" + C;
          });
        };
      }();
      function shift_formula_str(f, delta) {
        return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
          return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
        });
      }
      function shift_formula_xlsx(f, range2, cell) {
        var r = decode_range(range2), s = r.s, c2 = decode_cell(cell);
        var delta = { r: c2.r - s.r, c: c2.c - s.c };
        return shift_formula_str(f, delta);
      }
      function fuzzyfmla(f) {
        if (f.length == 1)
          return false;
        return true;
      }
      function _xlfn(f) {
        return f.replace(/_xlfn\./g, "");
      }
      function parseread1(blob) {
        blob.l += 1;
        return;
      }
      function parse_ColRelU(blob, length) {
        var c2 = blob.read_shift(length == 1 ? 1 : 2);
        return [c2 & 16383, c2 >> 14 & 1, c2 >> 15 & 1];
      }
      function parse_RgceArea(blob, length, opts) {
        var w = 2;
        if (opts) {
          if (opts.biff >= 2 && opts.biff <= 5)
            return parse_RgceArea_BIFF2(blob);
          else if (opts.biff == 12)
            w = 4;
        }
        var r = blob.read_shift(w), R = blob.read_shift(w);
        var c2 = parse_ColRelU(blob, 2);
        var C = parse_ColRelU(blob, 2);
        return { s: { r, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
      }
      function parse_RgceArea_BIFF2(blob) {
        var r = parse_ColRelU(blob, 2), R = parse_ColRelU(blob, 2);
        var c2 = blob.read_shift(1);
        var C = blob.read_shift(1);
        return { s: { r: r[0], c: c2, cRel: r[1], rRel: r[2] }, e: { r: R[0], c: C, cRel: R[1], rRel: R[2] } };
      }
      function parse_RgceAreaRel(blob, length, opts) {
        if (opts.biff < 8)
          return parse_RgceArea_BIFF2(blob);
        var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
        var c2 = parse_ColRelU(blob, 2);
        var C = parse_ColRelU(blob, 2);
        return { s: { r, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
      }
      function parse_RgceLoc(blob, length, opts) {
        if (opts && opts.biff >= 2 && opts.biff <= 5)
          return parse_RgceLoc_BIFF2(blob);
        var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
        var c2 = parse_ColRelU(blob, 2);
        return { r, c: c2[0], cRel: c2[1], rRel: c2[2] };
      }
      function parse_RgceLoc_BIFF2(blob) {
        var r = parse_ColRelU(blob, 2);
        var c2 = blob.read_shift(1);
        return { r: r[0], c: c2, cRel: r[1], rRel: r[2] };
      }
      function parse_RgceElfLoc(blob) {
        var r = blob.read_shift(2);
        var c2 = blob.read_shift(2);
        return { r, c: c2 & 255, fQuoted: !!(c2 & 16384), cRel: c2 >> 15, rRel: c2 >> 15 };
      }
      function parse_RgceLocRel(blob, length, opts) {
        var biff = opts && opts.biff ? opts.biff : 8;
        if (biff >= 2 && biff <= 5)
          return parse_RgceLocRel_BIFF2(blob);
        var r = blob.read_shift(biff >= 12 ? 4 : 2);
        var cl = blob.read_shift(2);
        var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
        cl &= 16383;
        if (rRel == 1)
          while (r > 524287)
            r -= 1048576;
        if (cRel == 1)
          while (cl > 8191)
            cl = cl - 16384;
        return { r, c: cl, cRel, rRel };
      }
      function parse_RgceLocRel_BIFF2(blob) {
        var rl = blob.read_shift(2);
        var c2 = blob.read_shift(1);
        var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
        rl &= 16383;
        if (rRel == 1 && rl >= 8192)
          rl = rl - 16384;
        if (cRel == 1 && c2 >= 128)
          c2 = c2 - 256;
        return { r: rl, c: c2, cRel, rRel };
      }
      function parse_PtgArea(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
        return [type2, area];
      }
      function parse_PtgArea3d(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        var ixti = blob.read_shift(2, "i");
        var w = 8;
        if (opts)
          switch (opts.biff) {
            case 5:
              blob.l += 12;
              w = 6;
              break;
            case 12:
              w = 12;
              break;
          }
        var area = parse_RgceArea(blob, w, opts);
        return [type2, ixti, area];
      }
      function parse_PtgAreaErr(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
        return [type2];
      }
      function parse_PtgAreaErr3d(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        var ixti = blob.read_shift(2);
        var w = 8;
        if (opts)
          switch (opts.biff) {
            case 5:
              blob.l += 12;
              w = 6;
              break;
            case 12:
              w = 12;
              break;
          }
        blob.l += w;
        return [type2, ixti];
      }
      function parse_PtgAreaN(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        var area = parse_RgceAreaRel(blob, length - 1, opts);
        return [type2, area];
      }
      function parse_PtgArray(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
        return [type2];
      }
      function parse_PtgAttrBaxcel(blob) {
        var bitSemi = blob[blob.l + 1] & 1;
        var bitBaxcel = 1;
        blob.l += 4;
        return [bitSemi, bitBaxcel];
      }
      function parse_PtgAttrChoose(blob, length, opts) {
        blob.l += 2;
        var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        var o = [];
        for (var i = 0; i <= offset; ++i)
          o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
        return o;
      }
      function parse_PtgAttrGoto(blob, length, opts) {
        var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += 2;
        return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
      }
      function parse_PtgAttrIf(blob, length, opts) {
        var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += 2;
        return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
      }
      function parse_PtgAttrIfError(blob) {
        var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += 2;
        return [bitIf, blob.read_shift(2)];
      }
      function parse_PtgAttrSemi(blob, length, opts) {
        var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
        blob.l += opts && opts.biff == 2 ? 3 : 4;
        return [bitSemi];
      }
      function parse_PtgAttrSpaceType(blob) {
        var type2 = blob.read_shift(1), cch = blob.read_shift(1);
        return [type2, cch];
      }
      function parse_PtgAttrSpace(blob) {
        blob.read_shift(2);
        return parse_PtgAttrSpaceType(blob);
      }
      function parse_PtgAttrSpaceSemi(blob) {
        blob.read_shift(2);
        return parse_PtgAttrSpaceType(blob);
      }
      function parse_PtgRef(blob, length, opts) {
        var type2 = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var loc = parse_RgceLoc(blob, 0, opts);
        return [type2, loc];
      }
      function parse_PtgRefN(blob, length, opts) {
        var type2 = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var loc = parse_RgceLocRel(blob, 0, opts);
        return [type2, loc];
      }
      function parse_PtgRef3d(blob, length, opts) {
        var type2 = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var ixti = blob.read_shift(2);
        if (opts && opts.biff == 5)
          blob.l += 12;
        var loc = parse_RgceLoc(blob, 0, opts);
        return [type2, ixti, loc];
      }
      function parse_PtgFunc(blob, length, opts) {
        var type2 = (blob[blob.l] & 96) >> 5;
        blob.l += 1;
        var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
        return [FtabArgc[iftab], Ftab[iftab], type2];
      }
      function parse_PtgFuncVar(blob, length, opts) {
        var type2 = blob[blob.l++];
        var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type2 == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
        return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
      }
      function parsetab(blob) {
        return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
      }
      function parse_PtgAttrSum(blob, length, opts) {
        blob.l += opts && opts.biff == 2 ? 3 : 4;
        return;
      }
      function parse_PtgExp(blob, length, opts) {
        blob.l++;
        if (opts && opts.biff == 12)
          return [blob.read_shift(4, "i"), 0];
        var row = blob.read_shift(2);
        var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        return [row, col];
      }
      function parse_PtgErr(blob) {
        blob.l++;
        return BErr[blob.read_shift(1)];
      }
      function parse_PtgInt(blob) {
        blob.l++;
        return blob.read_shift(2);
      }
      function parse_PtgBool(blob) {
        blob.l++;
        return blob.read_shift(1) !== 0;
      }
      function parse_PtgNum(blob) {
        blob.l++;
        return parse_Xnum(blob);
      }
      function parse_PtgStr(blob, length, opts) {
        blob.l++;
        return parse_ShortXLUnicodeString(blob, length - 1, opts);
      }
      function parse_SerAr(blob, biff) {
        var val = [blob.read_shift(1)];
        if (biff == 12)
          switch (val[0]) {
            case 2:
              val[0] = 4;
              break;
            case 4:
              val[0] = 16;
              break;
            case 0:
              val[0] = 1;
              break;
            case 1:
              val[0] = 2;
              break;
          }
        switch (val[0]) {
          case 4:
            val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
            if (biff != 12)
              blob.l += 7;
            break;
          case 37:
          case 16:
            val[1] = BErr[blob[blob.l]];
            blob.l += biff == 12 ? 4 : 8;
            break;
          case 0:
            blob.l += 8;
            break;
          case 1:
            val[1] = parse_Xnum(blob);
            break;
          case 2:
            val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
            break;
          default:
            throw new Error("Bad SerAr: " + val[0]);
        }
        return val;
      }
      function parse_PtgExtraMem(blob, cce, opts) {
        var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
        var out = [];
        for (var i = 0; i != count; ++i)
          out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
        return out;
      }
      function parse_PtgExtraArray(blob, length, opts) {
        var rows = 0, cols = 0;
        if (opts.biff == 12) {
          rows = blob.read_shift(4);
          cols = blob.read_shift(4);
        } else {
          cols = 1 + blob.read_shift(1);
          rows = 1 + blob.read_shift(2);
        }
        if (opts.biff >= 2 && opts.biff < 8) {
          --rows;
          if (--cols == 0)
            cols = 256;
        }
        for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
          for (var j = 0; j != cols; ++j)
            o[i][j] = parse_SerAr(blob, opts.biff);
        return o;
      }
      function parse_PtgName(blob, length, opts) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        var w = !opts || opts.biff >= 8 ? 4 : 2;
        var nameindex = blob.read_shift(w);
        switch (opts.biff) {
          case 2:
            blob.l += 5;
            break;
          case 3:
          case 4:
            blob.l += 8;
            break;
          case 5:
            blob.l += 12;
            break;
        }
        return [type2, 0, nameindex];
      }
      function parse_PtgNameX(blob, length, opts) {
        if (opts.biff == 5)
          return parse_PtgNameX_BIFF5(blob);
        var type2 = blob.read_shift(1) >>> 5 & 3;
        var ixti = blob.read_shift(2);
        var nameindex = blob.read_shift(4);
        return [type2, ixti, nameindex];
      }
      function parse_PtgNameX_BIFF5(blob) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        var ixti = blob.read_shift(2, "i");
        blob.l += 8;
        var nameindex = blob.read_shift(2);
        blob.l += 12;
        return [type2, ixti, nameindex];
      }
      function parse_PtgMemArea(blob, length, opts) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        blob.l += opts && opts.biff == 2 ? 3 : 4;
        var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        return [type2, cce];
      }
      function parse_PtgMemFunc(blob, length, opts) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
        return [type2, cce];
      }
      function parse_PtgRefErr(blob, length, opts) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        blob.l += 4;
        if (opts.biff < 8)
          blob.l--;
        if (opts.biff == 12)
          blob.l += 2;
        return [type2];
      }
      function parse_PtgRefErr3d(blob, length, opts) {
        var type2 = (blob[blob.l++] & 96) >> 5;
        var ixti = blob.read_shift(2);
        var w = 4;
        if (opts)
          switch (opts.biff) {
            case 5:
              w = 15;
              break;
            case 12:
              w = 6;
              break;
          }
        blob.l += w;
        return [type2, ixti];
      }
      var parse_PtgMemErr = parsenoop;
      var parse_PtgMemNoMem = parsenoop;
      var parse_PtgTbl = parsenoop;
      function parse_PtgElfLoc(blob, length, opts) {
        blob.l += 2;
        return [parse_RgceElfLoc(blob)];
      }
      function parse_PtgElfNoop(blob) {
        blob.l += 6;
        return [];
      }
      var parse_PtgElfCol = parse_PtgElfLoc;
      var parse_PtgElfColS = parse_PtgElfNoop;
      var parse_PtgElfColSV = parse_PtgElfNoop;
      var parse_PtgElfColV = parse_PtgElfLoc;
      function parse_PtgElfLel(blob) {
        blob.l += 2;
        return [parseuint16(blob), blob.read_shift(2) & 1];
      }
      var parse_PtgElfRadical = parse_PtgElfLoc;
      var parse_PtgElfRadicalLel = parse_PtgElfLel;
      var parse_PtgElfRadicalS = parse_PtgElfNoop;
      var parse_PtgElfRw = parse_PtgElfLoc;
      var parse_PtgElfRwV = parse_PtgElfLoc;
      var PtgListRT = [
        "Data",
        "All",
        "Headers",
        "??",
        "?Data2",
        "??",
        "?DataHeaders",
        "??",
        "Totals",
        "??",
        "??",
        "??",
        "?DataTotals",
        "??",
        "??",
        "??",
        "?Current"
      ];
      function parse_PtgList(blob) {
        blob.l += 2;
        var ixti = blob.read_shift(2);
        var flags = blob.read_shift(2);
        var idx = blob.read_shift(4);
        var c2 = blob.read_shift(2);
        var C = blob.read_shift(2);
        var rt = PtgListRT[flags >> 2 & 31];
        return { ixti, coltype: flags & 3, rt, idx, c: c2, C };
      }
      function parse_PtgSxName(blob) {
        blob.l += 2;
        return [blob.read_shift(4)];
      }
      function parse_PtgSheet(blob, length, opts) {
        blob.l += 5;
        blob.l += 2;
        blob.l += opts.biff == 2 ? 1 : 4;
        return ["PTGSHEET"];
      }
      function parse_PtgEndSheet(blob, length, opts) {
        blob.l += opts.biff == 2 ? 4 : 5;
        return ["PTGENDSHEET"];
      }
      function parse_PtgMemAreaN(blob) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        var cce = blob.read_shift(2);
        return [type2, cce];
      }
      function parse_PtgMemNoMemN(blob) {
        var type2 = blob.read_shift(1) >>> 5 & 3;
        var cce = blob.read_shift(2);
        return [type2, cce];
      }
      function parse_PtgAttrNoop(blob) {
        blob.l += 4;
        return [0, 0];
      }
      var PtgTypes = {
        /*::[*/
        1: { n: "PtgExp", f: parse_PtgExp },
        /*::[*/
        2: { n: "PtgTbl", f: parse_PtgTbl },
        /*::[*/
        3: { n: "PtgAdd", f: parseread1 },
        /*::[*/
        4: { n: "PtgSub", f: parseread1 },
        /*::[*/
        5: { n: "PtgMul", f: parseread1 },
        /*::[*/
        6: { n: "PtgDiv", f: parseread1 },
        /*::[*/
        7: { n: "PtgPower", f: parseread1 },
        /*::[*/
        8: { n: "PtgConcat", f: parseread1 },
        /*::[*/
        9: { n: "PtgLt", f: parseread1 },
        /*::[*/
        10: { n: "PtgLe", f: parseread1 },
        /*::[*/
        11: { n: "PtgEq", f: parseread1 },
        /*::[*/
        12: { n: "PtgGe", f: parseread1 },
        /*::[*/
        13: { n: "PtgGt", f: parseread1 },
        /*::[*/
        14: { n: "PtgNe", f: parseread1 },
        /*::[*/
        15: { n: "PtgIsect", f: parseread1 },
        /*::[*/
        16: { n: "PtgUnion", f: parseread1 },
        /*::[*/
        17: { n: "PtgRange", f: parseread1 },
        /*::[*/
        18: { n: "PtgUplus", f: parseread1 },
        /*::[*/
        19: { n: "PtgUminus", f: parseread1 },
        /*::[*/
        20: { n: "PtgPercent", f: parseread1 },
        /*::[*/
        21: { n: "PtgParen", f: parseread1 },
        /*::[*/
        22: { n: "PtgMissArg", f: parseread1 },
        /*::[*/
        23: { n: "PtgStr", f: parse_PtgStr },
        /*::[*/
        26: { n: "PtgSheet", f: parse_PtgSheet },
        /*::[*/
        27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
        /*::[*/
        28: { n: "PtgErr", f: parse_PtgErr },
        /*::[*/
        29: { n: "PtgBool", f: parse_PtgBool },
        /*::[*/
        30: { n: "PtgInt", f: parse_PtgInt },
        /*::[*/
        31: { n: "PtgNum", f: parse_PtgNum },
        /*::[*/
        32: { n: "PtgArray", f: parse_PtgArray },
        /*::[*/
        33: { n: "PtgFunc", f: parse_PtgFunc },
        /*::[*/
        34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
        /*::[*/
        35: { n: "PtgName", f: parse_PtgName },
        /*::[*/
        36: { n: "PtgRef", f: parse_PtgRef },
        /*::[*/
        37: { n: "PtgArea", f: parse_PtgArea },
        /*::[*/
        38: { n: "PtgMemArea", f: parse_PtgMemArea },
        /*::[*/
        39: { n: "PtgMemErr", f: parse_PtgMemErr },
        /*::[*/
        40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
        /*::[*/
        41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
        /*::[*/
        42: { n: "PtgRefErr", f: parse_PtgRefErr },
        /*::[*/
        43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
        /*::[*/
        44: { n: "PtgRefN", f: parse_PtgRefN },
        /*::[*/
        45: { n: "PtgAreaN", f: parse_PtgAreaN },
        /*::[*/
        46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
        /*::[*/
        47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
        /*::[*/
        57: { n: "PtgNameX", f: parse_PtgNameX },
        /*::[*/
        58: { n: "PtgRef3d", f: parse_PtgRef3d },
        /*::[*/
        59: { n: "PtgArea3d", f: parse_PtgArea3d },
        /*::[*/
        60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
        /*::[*/
        61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
        /*::[*/
        255: {}
      };
      var PtgDupes = {
        /*::[*/
        64: 32,
        /*::[*/
        96: 32,
        /*::[*/
        65: 33,
        /*::[*/
        97: 33,
        /*::[*/
        66: 34,
        /*::[*/
        98: 34,
        /*::[*/
        67: 35,
        /*::[*/
        99: 35,
        /*::[*/
        68: 36,
        /*::[*/
        100: 36,
        /*::[*/
        69: 37,
        /*::[*/
        101: 37,
        /*::[*/
        70: 38,
        /*::[*/
        102: 38,
        /*::[*/
        71: 39,
        /*::[*/
        103: 39,
        /*::[*/
        72: 40,
        /*::[*/
        104: 40,
        /*::[*/
        73: 41,
        /*::[*/
        105: 41,
        /*::[*/
        74: 42,
        /*::[*/
        106: 42,
        /*::[*/
        75: 43,
        /*::[*/
        107: 43,
        /*::[*/
        76: 44,
        /*::[*/
        108: 44,
        /*::[*/
        77: 45,
        /*::[*/
        109: 45,
        /*::[*/
        78: 46,
        /*::[*/
        110: 46,
        /*::[*/
        79: 47,
        /*::[*/
        111: 47,
        /*::[*/
        88: 34,
        /*::[*/
        120: 34,
        /*::[*/
        89: 57,
        /*::[*/
        121: 57,
        /*::[*/
        90: 58,
        /*::[*/
        122: 58,
        /*::[*/
        91: 59,
        /*::[*/
        123: 59,
        /*::[*/
        92: 60,
        /*::[*/
        124: 60,
        /*::[*/
        93: 61,
        /*::[*/
        125: 61
      };
      var Ptg18 = {
        /*::[*/
        1: { n: "PtgElfLel", f: parse_PtgElfLel },
        /*::[*/
        2: { n: "PtgElfRw", f: parse_PtgElfRw },
        /*::[*/
        3: { n: "PtgElfCol", f: parse_PtgElfCol },
        /*::[*/
        6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
        /*::[*/
        7: { n: "PtgElfColV", f: parse_PtgElfColV },
        /*::[*/
        10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
        /*::[*/
        11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
        /*::[*/
        13: { n: "PtgElfColS", f: parse_PtgElfColS },
        /*::[*/
        15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
        /*::[*/
        16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
        /*::[*/
        25: { n: "PtgList", f: parse_PtgList },
        /*::[*/
        29: { n: "PtgSxName", f: parse_PtgSxName },
        /*::[*/
        255: {}
      };
      var Ptg19 = {
        /*::[*/
        0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
        /*::[*/
        1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
        /*::[*/
        2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
        /*::[*/
        4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
        /*::[*/
        8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
        /*::[*/
        16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
        /*::[*/
        32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
        /*::[*/
        33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
        /*::[*/
        64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
        /*::[*/
        65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
        /*::[*/
        128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
        /*::[*/
        255: {}
      };
      function parse_RgbExtra(blob, length, rgce, opts) {
        if (opts.biff < 8)
          return parsenoop(blob, length);
        var target = blob.l + length;
        var o = [];
        for (var i = 0; i !== rgce.length; ++i) {
          switch (rgce[i][0]) {
            case "PtgArray":
              rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
              o.push(rgce[i][1]);
              break;
            case "PtgMemArea":
              rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
              o.push(rgce[i][2]);
              break;
            case "PtgExp":
              if (opts && opts.biff == 12) {
                rgce[i][1][1] = blob.read_shift(4);
                o.push(rgce[i][1]);
              }
              break;
            case "PtgList":
            case "PtgElfRadicalS":
            case "PtgElfColS":
            case "PtgElfColSV":
              throw "Unsupported " + rgce[i][0];
          }
        }
        length = target - blob.l;
        if (length !== 0)
          o.push(parsenoop(blob, length));
        return o;
      }
      function parse_Rgce(blob, length, opts) {
        var target = blob.l + length;
        var R, id, ptgs = [];
        while (target != blob.l) {
          length = target - blob.l;
          id = blob[blob.l];
          R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
          if (id === 24 || id === 25)
            R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
          if (!R || !R.f) {
            parsenoop(blob, length);
          } else {
            ptgs.push([R.n, R.f(blob, length, opts)]);
          }
        }
        return ptgs;
      }
      function stringify_array(f) {
        var o = [];
        for (var i = 0; i < f.length; ++i) {
          var x = f[i], r = [];
          for (var j = 0; j < x.length; ++j) {
            var y = x[j];
            if (y)
              switch (y[0]) {
                case 2:
                  r.push('"' + y[1].replace(/"/g, '""') + '"');
                  break;
                default:
                  r.push(y[1]);
              }
            else
              r.push("");
          }
          o.push(r.join(","));
        }
        return o.join(";");
      }
      var PtgBinOp = {
        PtgAdd: "+",
        PtgConcat: "&",
        PtgDiv: "/",
        PtgEq: "=",
        PtgGe: ">=",
        PtgGt: ">",
        PtgLe: "<=",
        PtgLt: "<",
        PtgMul: "*",
        PtgNe: "<>",
        PtgPower: "^",
        PtgSub: "-"
      };
      function formula_quote_sheet_name(sname, opts) {
        if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2))
          throw new Error("empty sheet name");
        if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname))
          return "'" + sname + "'";
        return sname;
      }
      function get_ixti_raw(supbooks, ixti, opts) {
        if (!supbooks)
          return "SH33TJSERR0";
        if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti]))
          return supbooks.SheetNames[ixti];
        if (!supbooks.XTI)
          return "SH33TJSERR6";
        var XTI = supbooks.XTI[ixti];
        if (opts.biff < 8) {
          if (ixti > 1e4)
            ixti -= 65536;
          if (ixti < 0)
            ixti = -ixti;
          return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
        }
        if (!XTI)
          return "SH33TJSERR1";
        var o = "";
        if (opts.biff > 8)
          switch (supbooks[XTI[0]][0]) {
            case 357:
              o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
              return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
            case 358:
              if (opts.SID != null)
                return supbooks.SheetNames[opts.SID];
              return "SH33TJSSAME" + supbooks[XTI[0]][0];
            case 355:
            default:
              return "SH33TJSSRC" + supbooks[XTI[0]][0];
          }
        switch (supbooks[XTI[0]][0][0]) {
          case 1025:
            o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
            return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
          case 14849:
            return supbooks[XTI[0]].slice(1).map(function(name) {
              return name.Name;
            }).join(";;");
          default:
            if (!supbooks[XTI[0]][0][3])
              return "SH33TJSERR2";
            o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
            return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
        }
      }
      function get_ixti(supbooks, ixti, opts) {
        var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
        return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
      }
      function stringify_formula(formula, range2, cell, supbooks, opts) {
        var biff = opts && opts.biff || 8;
        var _range = (
          /*range != null ? range :*/
          { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
        );
        var stack2 = [], e1, e2, c2, ixti = 0, nameidx = 0, r, sname = "";
        if (!formula[0] || !formula[0][0])
          return "";
        var last_sp = -1, sp = "";
        for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
          var f = formula[0][ff];
          switch (f[0]) {
            case "PtgUminus":
              stack2.push("-" + stack2.pop());
              break;
            case "PtgUplus":
              stack2.push("+" + stack2.pop());
              break;
            case "PtgPercent":
              stack2.push(stack2.pop() + "%");
              break;
            case "PtgAdd":
            case "PtgConcat":
            case "PtgDiv":
            case "PtgEq":
            case "PtgGe":
            case "PtgGt":
            case "PtgLe":
            case "PtgLt":
            case "PtgMul":
            case "PtgNe":
            case "PtgPower":
            case "PtgSub":
              e1 = stack2.pop();
              e2 = stack2.pop();
              if (last_sp >= 0) {
                switch (formula[0][last_sp][1][0]) {
                  case 0:
                    sp = fill(" ", formula[0][last_sp][1][1]);
                    break;
                  case 1:
                    sp = fill("\r", formula[0][last_sp][1][1]);
                    break;
                  default:
                    sp = "";
                    if (opts.WTF)
                      throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
                }
                e2 = e2 + sp;
                last_sp = -1;
              }
              stack2.push(e2 + PtgBinOp[f[0]] + e1);
              break;
            case "PtgIsect":
              e1 = stack2.pop();
              e2 = stack2.pop();
              stack2.push(e2 + " " + e1);
              break;
            case "PtgUnion":
              e1 = stack2.pop();
              e2 = stack2.pop();
              stack2.push(e2 + "," + e1);
              break;
            case "PtgRange":
              e1 = stack2.pop();
              e2 = stack2.pop();
              stack2.push(e2 + ":" + e1);
              break;
            case "PtgAttrChoose":
              break;
            case "PtgAttrGoto":
              break;
            case "PtgAttrIf":
              break;
            case "PtgAttrIfError":
              break;
            case "PtgRef":
              c2 = shift_cell_xls(f[1][1], _range, opts);
              stack2.push(encode_cell_xls(c2, biff));
              break;
            case "PtgRefN":
              c2 = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
              stack2.push(encode_cell_xls(c2, biff));
              break;
            case "PtgRef3d":
              ixti = /*::Number(*/
              f[1][1];
              c2 = shift_cell_xls(f[1][2], _range, opts);
              sname = get_ixti(supbooks, ixti, opts);
              stack2.push(sname + "!" + encode_cell_xls(c2, biff));
              break;
            case "PtgFunc":
            case "PtgFuncVar":
              var argc = f[1][0], func = f[1][1];
              if (!argc)
                argc = 0;
              argc &= 127;
              var args = argc == 0 ? [] : stack2.slice(-argc);
              stack2.length -= argc;
              if (func === "User")
                func = args.shift();
              stack2.push(func + "(" + args.join(",") + ")");
              break;
            case "PtgBool":
              stack2.push(f[1] ? "TRUE" : "FALSE");
              break;
            case "PtgInt":
              stack2.push(
                /*::String(*/
                f[1]
                /*::)*/
              );
              break;
            case "PtgNum":
              stack2.push(String(f[1]));
              break;
            case "PtgStr":
              stack2.push('"' + f[1].replace(/"/g, '""') + '"');
              break;
            case "PtgErr":
              stack2.push(
                /*::String(*/
                f[1]
                /*::)*/
              );
              break;
            case "PtgAreaN":
              r = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
              stack2.push(encode_range_xls(r, opts));
              break;
            case "PtgArea":
              r = shift_range_xls(f[1][1], _range, opts);
              stack2.push(encode_range_xls(r, opts));
              break;
            case "PtgArea3d":
              ixti = /*::Number(*/
              f[1][1];
              r = f[1][2];
              sname = get_ixti(supbooks, ixti, opts);
              stack2.push(sname + "!" + encode_range_xls(r, opts));
              break;
            case "PtgAttrSum":
              stack2.push("SUM(" + stack2.pop() + ")");
              break;
            case "PtgAttrBaxcel":
            case "PtgAttrSemi":
              break;
            case "PtgName":
              nameidx = f[1][2];
              var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
              var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
              if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn)
                name = name.slice(6);
              stack2.push(name);
              break;
            case "PtgNameX":
              var bookidx = f[1][1];
              nameidx = f[1][2];
              var externbook;
              if (opts.biff <= 5) {
                if (bookidx < 0)
                  bookidx = -bookidx;
                if (supbooks[bookidx])
                  externbook = supbooks[bookidx][nameidx];
              } else {
                var o = "";
                if (((supbooks[bookidx] || [])[0] || [])[0] == 14849)
                  ;
                else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
                  if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
                    o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
                  }
                } else
                  o = supbooks.SheetNames[nameidx - 1] + "!";
                if (supbooks[bookidx] && supbooks[bookidx][nameidx])
                  o += supbooks[bookidx][nameidx].Name;
                else if (supbooks[0] && supbooks[0][nameidx])
                  o += supbooks[0][nameidx].Name;
                else {
                  var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
                  if (ixtidata[nameidx - 1])
                    o = ixtidata[nameidx - 1];
                  else
                    o += "SH33TJSERRX";
                }
                stack2.push(o);
                break;
              }
              if (!externbook)
                externbook = { Name: "SH33TJSERRY" };
              stack2.push(externbook.Name);
              break;
            case "PtgParen":
              var lp = "(", rp = ")";
              if (last_sp >= 0) {
                sp = "";
                switch (formula[0][last_sp][1][0]) {
                  case 2:
                    lp = fill(" ", formula[0][last_sp][1][1]) + lp;
                    break;
                  case 3:
                    lp = fill("\r", formula[0][last_sp][1][1]) + lp;
                    break;
                  case 4:
                    rp = fill(" ", formula[0][last_sp][1][1]) + rp;
                    break;
                  case 5:
                    rp = fill("\r", formula[0][last_sp][1][1]) + rp;
                    break;
                  default:
                    if (opts.WTF)
                      throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
                }
                last_sp = -1;
              }
              stack2.push(lp + stack2.pop() + rp);
              break;
            case "PtgRefErr":
              stack2.push("#REF!");
              break;
            case "PtgRefErr3d":
              stack2.push("#REF!");
              break;
            case "PtgExp":
              c2 = { c: f[1][1], r: f[1][0] };
              var q = { c: cell.c, r: cell.r };
              if (supbooks.sharedf[encode_cell(c2)]) {
                var parsedf = supbooks.sharedf[encode_cell(c2)];
                stack2.push(stringify_formula(parsedf, _range, q, supbooks, opts));
              } else {
                var fnd = false;
                for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
                  e2 = supbooks.arrayf[e1];
                  if (c2.c < e2[0].s.c || c2.c > e2[0].e.c)
                    continue;
                  if (c2.r < e2[0].s.r || c2.r > e2[0].e.r)
                    continue;
                  stack2.push(stringify_formula(e2[1], _range, q, supbooks, opts));
                  fnd = true;
                  break;
                }
                if (!fnd)
                  stack2.push(
                    /*::String(*/
                    f[1]
                    /*::)*/
                  );
              }
              break;
            case "PtgArray":
              stack2.push("{" + stringify_array(
                /*::(*/
                f[1]
                /*:: :any)*/
              ) + "}");
              break;
            case "PtgMemArea":
              break;
            case "PtgAttrSpace":
            case "PtgAttrSpaceSemi":
              last_sp = ff;
              break;
            case "PtgTbl":
              break;
            case "PtgMemErr":
              break;
            case "PtgMissArg":
              stack2.push("");
              break;
            case "PtgAreaErr":
              stack2.push("#REF!");
              break;
            case "PtgAreaErr3d":
              stack2.push("#REF!");
              break;
            case "PtgList":
              stack2.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
              break;
            case "PtgMemAreaN":
            case "PtgMemNoMemN":
            case "PtgAttrNoop":
            case "PtgSheet":
            case "PtgEndSheet":
              break;
            case "PtgMemFunc":
              break;
            case "PtgMemNoMem":
              break;
            case "PtgElfCol":
            case "PtgElfColS":
            case "PtgElfColSV":
            case "PtgElfColV":
            case "PtgElfLel":
            case "PtgElfRadical":
            case "PtgElfRadicalLel":
            case "PtgElfRadicalS":
            case "PtgElfRw":
            case "PtgElfRwV":
              throw new Error("Unsupported ELFs");
            case "PtgSxName":
              throw new Error("Unrecognized Formula Token: " + String(f));
            default:
              throw new Error("Unrecognized Formula Token: " + String(f));
          }
          var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
          if (opts.biff != 3) {
            if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
              f = formula[0][last_sp];
              var _left = true;
              switch (f[1][0]) {
                case 4:
                  _left = false;
                case 0:
                  sp = fill(" ", f[1][1]);
                  break;
                case 5:
                  _left = false;
                case 1:
                  sp = fill("\r", f[1][1]);
                  break;
                default:
                  sp = "";
                  if (opts.WTF)
                    throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
              }
              stack2.push((_left ? sp : "") + stack2.pop() + (_left ? "" : sp));
              last_sp = -1;
            }
          }
        }
        if (stack2.length > 1 && opts.WTF)
          throw new Error("bad formula stack");
        return stack2[0];
      }
      function parse_ArrayParsedFormula(blob, length, opts) {
        var target = blob.l + length, len2 = opts.biff == 2 ? 1 : 2;
        var rgcb, cce = blob.read_shift(len2);
        if (cce == 65535)
          return [[], parsenoop(blob, length - 2)];
        var rgce = parse_Rgce(blob, cce, opts);
        if (length !== cce + len2)
          rgcb = parse_RgbExtra(blob, length - cce - len2, rgce, opts);
        blob.l = target;
        return [rgce, rgcb];
      }
      function parse_XLSCellParsedFormula(blob, length, opts) {
        var target = blob.l + length, len2 = opts.biff == 2 ? 1 : 2;
        var rgcb, cce = blob.read_shift(len2);
        if (cce == 65535)
          return [[], parsenoop(blob, length - 2)];
        var rgce = parse_Rgce(blob, cce, opts);
        if (length !== cce + len2)
          rgcb = parse_RgbExtra(blob, length - cce - len2, rgce, opts);
        blob.l = target;
        return [rgce, rgcb];
      }
      function parse_NameParsedFormula(blob, length, opts, cce) {
        var target = blob.l + length;
        var rgce = parse_Rgce(blob, cce, opts);
        var rgcb;
        if (target !== blob.l)
          rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
        return [rgce, rgcb];
      }
      function parse_SharedParsedFormula(blob, length, opts) {
        var target = blob.l + length;
        var rgcb, cce = blob.read_shift(2);
        var rgce = parse_Rgce(blob, cce, opts);
        if (cce == 65535)
          return [[], parsenoop(blob, length - 2)];
        if (length !== cce + 2)
          rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
        return [rgce, rgcb];
      }
      function parse_FormulaValue(blob) {
        var b;
        if (__readUInt16LE(blob, blob.l + 6) !== 65535)
          return [parse_Xnum(blob), "n"];
        switch (blob[blob.l]) {
          case 0:
            blob.l += 8;
            return ["String", "s"];
          case 1:
            b = blob[blob.l + 2] === 1;
            blob.l += 8;
            return [b, "b"];
          case 2:
            b = blob[blob.l + 2];
            blob.l += 8;
            return [b, "e"];
          case 3:
            blob.l += 8;
            return ["", "s"];
        }
        return [];
      }
      function parse_Formula(blob, length, opts) {
        var end = blob.l + length;
        var cell = parse_XLSCell(blob);
        if (opts.biff == 2)
          ++blob.l;
        var val = parse_FormulaValue(blob);
        var flags = blob.read_shift(1);
        if (opts.biff != 2) {
          blob.read_shift(1);
          if (opts.biff >= 5) {
            blob.read_shift(4);
          }
        }
        var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
        return { cell, val: val[0], formula: cbf, shared: flags >> 3 & 1, tt: val[1] };
      }
      function parse_XLSBParsedFormula(data, length, opts) {
        var cce = data.read_shift(4);
        var rgce = parse_Rgce(data, cce, opts);
        var cb = data.read_shift(4);
        var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
        return [rgce, rgcb];
      }
      var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
      var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
      var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
      var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
      var Cetab = {
        0: "BEEP",
        1: "OPEN",
        2: "OPEN.LINKS",
        3: "CLOSE.ALL",
        4: "SAVE",
        5: "SAVE.AS",
        6: "FILE.DELETE",
        7: "PAGE.SETUP",
        8: "PRINT",
        9: "PRINTER.SETUP",
        10: "QUIT",
        11: "NEW.WINDOW",
        12: "ARRANGE.ALL",
        13: "WINDOW.SIZE",
        14: "WINDOW.MOVE",
        15: "FULL",
        16: "CLOSE",
        17: "RUN",
        22: "SET.PRINT.AREA",
        23: "SET.PRINT.TITLES",
        24: "SET.PAGE.BREAK",
        25: "REMOVE.PAGE.BREAK",
        26: "FONT",
        27: "DISPLAY",
        28: "PROTECT.DOCUMENT",
        29: "PRECISION",
        30: "A1.R1C1",
        31: "CALCULATE.NOW",
        32: "CALCULATION",
        34: "DATA.FIND",
        35: "EXTRACT",
        36: "DATA.DELETE",
        37: "SET.DATABASE",
        38: "SET.CRITERIA",
        39: "SORT",
        40: "DATA.SERIES",
        41: "TABLE",
        42: "FORMAT.NUMBER",
        43: "ALIGNMENT",
        44: "STYLE",
        45: "BORDER",
        46: "CELL.PROTECTION",
        47: "COLUMN.WIDTH",
        48: "UNDO",
        49: "CUT",
        50: "COPY",
        51: "PASTE",
        52: "CLEAR",
        53: "PASTE.SPECIAL",
        54: "EDIT.DELETE",
        55: "INSERT",
        56: "FILL.RIGHT",
        57: "FILL.DOWN",
        61: "DEFINE.NAME",
        62: "CREATE.NAMES",
        63: "FORMULA.GOTO",
        64: "FORMULA.FIND",
        65: "SELECT.LAST.CELL",
        66: "SHOW.ACTIVE.CELL",
        67: "GALLERY.AREA",
        68: "GALLERY.BAR",
        69: "GALLERY.COLUMN",
        70: "GALLERY.LINE",
        71: "GALLERY.PIE",
        72: "GALLERY.SCATTER",
        73: "COMBINATION",
        74: "PREFERRED",
        75: "ADD.OVERLAY",
        76: "GRIDLINES",
        77: "SET.PREFERRED",
        78: "AXES",
        79: "LEGEND",
        80: "ATTACH.TEXT",
        81: "ADD.ARROW",
        82: "SELECT.CHART",
        83: "SELECT.PLOT.AREA",
        84: "PATTERNS",
        85: "MAIN.CHART",
        86: "OVERLAY",
        87: "SCALE",
        88: "FORMAT.LEGEND",
        89: "FORMAT.TEXT",
        90: "EDIT.REPEAT",
        91: "PARSE",
        92: "JUSTIFY",
        93: "HIDE",
        94: "UNHIDE",
        95: "WORKSPACE",
        96: "FORMULA",
        97: "FORMULA.FILL",
        98: "FORMULA.ARRAY",
        99: "DATA.FIND.NEXT",
        100: "DATA.FIND.PREV",
        101: "FORMULA.FIND.NEXT",
        102: "FORMULA.FIND.PREV",
        103: "ACTIVATE",
        104: "ACTIVATE.NEXT",
        105: "ACTIVATE.PREV",
        106: "UNLOCKED.NEXT",
        107: "UNLOCKED.PREV",
        108: "COPY.PICTURE",
        109: "SELECT",
        110: "DELETE.NAME",
        111: "DELETE.FORMAT",
        112: "VLINE",
        113: "HLINE",
        114: "VPAGE",
        115: "HPAGE",
        116: "VSCROLL",
        117: "HSCROLL",
        118: "ALERT",
        119: "NEW",
        120: "CANCEL.COPY",
        121: "SHOW.CLIPBOARD",
        122: "MESSAGE",
        124: "PASTE.LINK",
        125: "APP.ACTIVATE",
        126: "DELETE.ARROW",
        127: "ROW.HEIGHT",
        128: "FORMAT.MOVE",
        129: "FORMAT.SIZE",
        130: "FORMULA.REPLACE",
        131: "SEND.KEYS",
        132: "SELECT.SPECIAL",
        133: "APPLY.NAMES",
        134: "REPLACE.FONT",
        135: "FREEZE.PANES",
        136: "SHOW.INFO",
        137: "SPLIT",
        138: "ON.WINDOW",
        139: "ON.DATA",
        140: "DISABLE.INPUT",
        142: "OUTLINE",
        143: "LIST.NAMES",
        144: "FILE.CLOSE",
        145: "SAVE.WORKBOOK",
        146: "DATA.FORM",
        147: "COPY.CHART",
        148: "ON.TIME",
        149: "WAIT",
        150: "FORMAT.FONT",
        151: "FILL.UP",
        152: "FILL.LEFT",
        153: "DELETE.OVERLAY",
        155: "SHORT.MENUS",
        159: "SET.UPDATE.STATUS",
        161: "COLOR.PALETTE",
        162: "DELETE.STYLE",
        163: "WINDOW.RESTORE",
        164: "WINDOW.MAXIMIZE",
        166: "CHANGE.LINK",
        167: "CALCULATE.DOCUMENT",
        168: "ON.KEY",
        169: "APP.RESTORE",
        170: "APP.MOVE",
        171: "APP.SIZE",
        172: "APP.MINIMIZE",
        173: "APP.MAXIMIZE",
        174: "BRING.TO.FRONT",
        175: "SEND.TO.BACK",
        185: "MAIN.CHART.TYPE",
        186: "OVERLAY.CHART.TYPE",
        187: "SELECT.END",
        188: "OPEN.MAIL",
        189: "SEND.MAIL",
        190: "STANDARD.FONT",
        191: "CONSOLIDATE",
        192: "SORT.SPECIAL",
        193: "GALLERY.3D.AREA",
        194: "GALLERY.3D.COLUMN",
        195: "GALLERY.3D.LINE",
        196: "GALLERY.3D.PIE",
        197: "VIEW.3D",
        198: "GOAL.SEEK",
        199: "WORKGROUP",
        200: "FILL.GROUP",
        201: "UPDATE.LINK",
        202: "PROMOTE",
        203: "DEMOTE",
        204: "SHOW.DETAIL",
        206: "UNGROUP",
        207: "OBJECT.PROPERTIES",
        208: "SAVE.NEW.OBJECT",
        209: "SHARE",
        210: "SHARE.NAME",
        211: "DUPLICATE",
        212: "APPLY.STYLE",
        213: "ASSIGN.TO.OBJECT",
        214: "OBJECT.PROTECTION",
        215: "HIDE.OBJECT",
        216: "SET.EXTRACT",
        217: "CREATE.PUBLISHER",
        218: "SUBSCRIBE.TO",
        219: "ATTRIBUTES",
        220: "SHOW.TOOLBAR",
        222: "PRINT.PREVIEW",
        223: "EDIT.COLOR",
        224: "SHOW.LEVELS",
        225: "FORMAT.MAIN",
        226: "FORMAT.OVERLAY",
        227: "ON.RECALC",
        228: "EDIT.SERIES",
        229: "DEFINE.STYLE",
        240: "LINE.PRINT",
        243: "ENTER.DATA",
        249: "GALLERY.RADAR",
        250: "MERGE.STYLES",
        251: "EDITION.OPTIONS",
        252: "PASTE.PICTURE",
        253: "PASTE.PICTURE.LINK",
        254: "SPELLING",
        256: "ZOOM",
        259: "INSERT.OBJECT",
        260: "WINDOW.MINIMIZE",
        265: "SOUND.NOTE",
        266: "SOUND.PLAY",
        267: "FORMAT.SHAPE",
        268: "EXTEND.POLYGON",
        269: "FORMAT.AUTO",
        272: "GALLERY.3D.BAR",
        273: "GALLERY.3D.SURFACE",
        274: "FILL.AUTO",
        276: "CUSTOMIZE.TOOLBAR",
        277: "ADD.TOOL",
        278: "EDIT.OBJECT",
        279: "ON.DOUBLECLICK",
        280: "ON.ENTRY",
        281: "WORKBOOK.ADD",
        282: "WORKBOOK.MOVE",
        283: "WORKBOOK.COPY",
        284: "WORKBOOK.OPTIONS",
        285: "SAVE.WORKSPACE",
        288: "CHART.WIZARD",
        289: "DELETE.TOOL",
        290: "MOVE.TOOL",
        291: "WORKBOOK.SELECT",
        292: "WORKBOOK.ACTIVATE",
        293: "ASSIGN.TO.TOOL",
        295: "COPY.TOOL",
        296: "RESET.TOOL",
        297: "CONSTRAIN.NUMERIC",
        298: "PASTE.TOOL",
        302: "WORKBOOK.NEW",
        305: "SCENARIO.CELLS",
        306: "SCENARIO.DELETE",
        307: "SCENARIO.ADD",
        308: "SCENARIO.EDIT",
        309: "SCENARIO.SHOW",
        310: "SCENARIO.SHOW.NEXT",
        311: "SCENARIO.SUMMARY",
        312: "PIVOT.TABLE.WIZARD",
        313: "PIVOT.FIELD.PROPERTIES",
        314: "PIVOT.FIELD",
        315: "PIVOT.ITEM",
        316: "PIVOT.ADD.FIELDS",
        318: "OPTIONS.CALCULATION",
        319: "OPTIONS.EDIT",
        320: "OPTIONS.VIEW",
        321: "ADDIN.MANAGER",
        322: "MENU.EDITOR",
        323: "ATTACH.TOOLBARS",
        324: "VBAActivate",
        325: "OPTIONS.CHART",
        328: "VBA.INSERT.FILE",
        330: "VBA.PROCEDURE.DEFINITION",
        336: "ROUTING.SLIP",
        338: "ROUTE.DOCUMENT",
        339: "MAIL.LOGON",
        342: "INSERT.PICTURE",
        343: "EDIT.TOOL",
        344: "GALLERY.DOUGHNUT",
        350: "CHART.TREND",
        352: "PIVOT.ITEM.PROPERTIES",
        354: "WORKBOOK.INSERT",
        355: "OPTIONS.TRANSITION",
        356: "OPTIONS.GENERAL",
        370: "FILTER.ADVANCED",
        373: "MAIL.ADD.MAILER",
        374: "MAIL.DELETE.MAILER",
        375: "MAIL.REPLY",
        376: "MAIL.REPLY.ALL",
        377: "MAIL.FORWARD",
        378: "MAIL.NEXT.LETTER",
        379: "DATA.LABEL",
        380: "INSERT.TITLE",
        381: "FONT.PROPERTIES",
        382: "MACRO.OPTIONS",
        383: "WORKBOOK.HIDE",
        384: "WORKBOOK.UNHIDE",
        385: "WORKBOOK.DELETE",
        386: "WORKBOOK.NAME",
        388: "GALLERY.CUSTOM",
        390: "ADD.CHART.AUTOFORMAT",
        391: "DELETE.CHART.AUTOFORMAT",
        392: "CHART.ADD.DATA",
        393: "AUTO.OUTLINE",
        394: "TAB.ORDER",
        395: "SHOW.DIALOG",
        396: "SELECT.ALL",
        397: "UNGROUP.SHEETS",
        398: "SUBTOTAL.CREATE",
        399: "SUBTOTAL.REMOVE",
        400: "RENAME.OBJECT",
        412: "WORKBOOK.SCROLL",
        413: "WORKBOOK.NEXT",
        414: "WORKBOOK.PREV",
        415: "WORKBOOK.TAB.SPLIT",
        416: "FULL.SCREEN",
        417: "WORKBOOK.PROTECT",
        420: "SCROLLBAR.PROPERTIES",
        421: "PIVOT.SHOW.PAGES",
        422: "TEXT.TO.COLUMNS",
        423: "FORMAT.CHARTTYPE",
        424: "LINK.FORMAT",
        425: "TRACER.DISPLAY",
        430: "TRACER.NAVIGATE",
        431: "TRACER.CLEAR",
        432: "TRACER.ERROR",
        433: "PIVOT.FIELD.GROUP",
        434: "PIVOT.FIELD.UNGROUP",
        435: "CHECKBOX.PROPERTIES",
        436: "LABEL.PROPERTIES",
        437: "LISTBOX.PROPERTIES",
        438: "EDITBOX.PROPERTIES",
        439: "PIVOT.REFRESH",
        440: "LINK.COMBO",
        441: "OPEN.TEXT",
        442: "HIDE.DIALOG",
        443: "SET.DIALOG.FOCUS",
        444: "ENABLE.OBJECT",
        445: "PUSHBUTTON.PROPERTIES",
        446: "SET.DIALOG.DEFAULT",
        447: "FILTER",
        448: "FILTER.SHOW.ALL",
        449: "CLEAR.OUTLINE",
        450: "FUNCTION.WIZARD",
        451: "ADD.LIST.ITEM",
        452: "SET.LIST.ITEM",
        453: "REMOVE.LIST.ITEM",
        454: "SELECT.LIST.ITEM",
        455: "SET.CONTROL.VALUE",
        456: "SAVE.COPY.AS",
        458: "OPTIONS.LISTS.ADD",
        459: "OPTIONS.LISTS.DELETE",
        460: "SERIES.AXES",
        461: "SERIES.X",
        462: "SERIES.Y",
        463: "ERRORBAR.X",
        464: "ERRORBAR.Y",
        465: "FORMAT.CHART",
        466: "SERIES.ORDER",
        467: "MAIL.LOGOFF",
        468: "CLEAR.ROUTING.SLIP",
        469: "APP.ACTIVATE.MICROSOFT",
        470: "MAIL.EDIT.MAILER",
        471: "ON.SHEET",
        472: "STANDARD.WIDTH",
        473: "SCENARIO.MERGE",
        474: "SUMMARY.INFO",
        475: "FIND.FILE",
        476: "ACTIVE.CELL.FONT",
        477: "ENABLE.TIPWIZARD",
        478: "VBA.MAKE.ADDIN",
        480: "INSERTDATATABLE",
        481: "WORKGROUP.OPTIONS",
        482: "MAIL.SEND.MAILER",
        485: "AUTOCORRECT",
        489: "POST.DOCUMENT",
        491: "PICKLIST",
        493: "VIEW.SHOW",
        494: "VIEW.DEFINE",
        495: "VIEW.DELETE",
        509: "SHEET.BACKGROUND",
        510: "INSERT.MAP.OBJECT",
        511: "OPTIONS.MENONO",
        517: "MSOCHECKS",
        518: "NORMAL",
        519: "LAYOUT",
        520: "RM.PRINT.AREA",
        521: "CLEAR.PRINT.AREA",
        522: "ADD.PRINT.AREA",
        523: "MOVE.BRK",
        545: "HIDECURR.NOTE",
        546: "HIDEALL.NOTES",
        547: "DELETE.NOTE",
        548: "TRAVERSE.NOTES",
        549: "ACTIVATE.NOTES",
        620: "PROTECT.REVISIONS",
        621: "UNPROTECT.REVISIONS",
        647: "OPTIONS.ME",
        653: "WEB.PUBLISH",
        667: "NEWWEBQUERY",
        673: "PIVOT.TABLE.CHART",
        753: "OPTIONS.SAVE",
        755: "OPTIONS.SPELL",
        808: "HIDEALL.INKANNOTS"
      };
      var Ftab = {
        0: "COUNT",
        1: "IF",
        2: "ISNA",
        3: "ISERROR",
        4: "SUM",
        5: "AVERAGE",
        6: "MIN",
        7: "MAX",
        8: "ROW",
        9: "COLUMN",
        10: "NA",
        11: "NPV",
        12: "STDEV",
        13: "DOLLAR",
        14: "FIXED",
        15: "SIN",
        16: "COS",
        17: "TAN",
        18: "ATAN",
        19: "PI",
        20: "SQRT",
        21: "EXP",
        22: "LN",
        23: "LOG10",
        24: "ABS",
        25: "INT",
        26: "SIGN",
        27: "ROUND",
        28: "LOOKUP",
        29: "INDEX",
        30: "REPT",
        31: "MID",
        32: "LEN",
        33: "VALUE",
        34: "TRUE",
        35: "FALSE",
        36: "AND",
        37: "OR",
        38: "NOT",
        39: "MOD",
        40: "DCOUNT",
        41: "DSUM",
        42: "DAVERAGE",
        43: "DMIN",
        44: "DMAX",
        45: "DSTDEV",
        46: "VAR",
        47: "DVAR",
        48: "TEXT",
        49: "LINEST",
        50: "TREND",
        51: "LOGEST",
        52: "GROWTH",
        53: "GOTO",
        54: "HALT",
        55: "RETURN",
        56: "PV",
        57: "FV",
        58: "NPER",
        59: "PMT",
        60: "RATE",
        61: "MIRR",
        62: "IRR",
        63: "RAND",
        64: "MATCH",
        65: "DATE",
        66: "TIME",
        67: "DAY",
        68: "MONTH",
        69: "YEAR",
        70: "WEEKDAY",
        71: "HOUR",
        72: "MINUTE",
        73: "SECOND",
        74: "NOW",
        75: "AREAS",
        76: "ROWS",
        77: "COLUMNS",
        78: "OFFSET",
        79: "ABSREF",
        80: "RELREF",
        81: "ARGUMENT",
        82: "SEARCH",
        83: "TRANSPOSE",
        84: "ERROR",
        85: "STEP",
        86: "TYPE",
        87: "ECHO",
        88: "SET.NAME",
        89: "CALLER",
        90: "DEREF",
        91: "WINDOWS",
        92: "SERIES",
        93: "DOCUMENTS",
        94: "ACTIVE.CELL",
        95: "SELECTION",
        96: "RESULT",
        97: "ATAN2",
        98: "ASIN",
        99: "ACOS",
        100: "CHOOSE",
        101: "HLOOKUP",
        102: "VLOOKUP",
        103: "LINKS",
        104: "INPUT",
        105: "ISREF",
        106: "GET.FORMULA",
        107: "GET.NAME",
        108: "SET.VALUE",
        109: "LOG",
        110: "EXEC",
        111: "CHAR",
        112: "LOWER",
        113: "UPPER",
        114: "PROPER",
        115: "LEFT",
        116: "RIGHT",
        117: "EXACT",
        118: "TRIM",
        119: "REPLACE",
        120: "SUBSTITUTE",
        121: "CODE",
        122: "NAMES",
        123: "DIRECTORY",
        124: "FIND",
        125: "CELL",
        126: "ISERR",
        127: "ISTEXT",
        128: "ISNUMBER",
        129: "ISBLANK",
        130: "T",
        131: "N",
        132: "FOPEN",
        133: "FCLOSE",
        134: "FSIZE",
        135: "FREADLN",
        136: "FREAD",
        137: "FWRITELN",
        138: "FWRITE",
        139: "FPOS",
        140: "DATEVALUE",
        141: "TIMEVALUE",
        142: "SLN",
        143: "SYD",
        144: "DDB",
        145: "GET.DEF",
        146: "REFTEXT",
        147: "TEXTREF",
        148: "INDIRECT",
        149: "REGISTER",
        150: "CALL",
        151: "ADD.BAR",
        152: "ADD.MENU",
        153: "ADD.COMMAND",
        154: "ENABLE.COMMAND",
        155: "CHECK.COMMAND",
        156: "RENAME.COMMAND",
        157: "SHOW.BAR",
        158: "DELETE.MENU",
        159: "DELETE.COMMAND",
        160: "GET.CHART.ITEM",
        161: "DIALOG.BOX",
        162: "CLEAN",
        163: "MDETERM",
        164: "MINVERSE",
        165: "MMULT",
        166: "FILES",
        167: "IPMT",
        168: "PPMT",
        169: "COUNTA",
        170: "CANCEL.KEY",
        171: "FOR",
        172: "WHILE",
        173: "BREAK",
        174: "NEXT",
        175: "INITIATE",
        176: "REQUEST",
        177: "POKE",
        178: "EXECUTE",
        179: "TERMINATE",
        180: "RESTART",
        181: "HELP",
        182: "GET.BAR",
        183: "PRODUCT",
        184: "FACT",
        185: "GET.CELL",
        186: "GET.WORKSPACE",
        187: "GET.WINDOW",
        188: "GET.DOCUMENT",
        189: "DPRODUCT",
        190: "ISNONTEXT",
        191: "GET.NOTE",
        192: "NOTE",
        193: "STDEVP",
        194: "VARP",
        195: "DSTDEVP",
        196: "DVARP",
        197: "TRUNC",
        198: "ISLOGICAL",
        199: "DCOUNTA",
        200: "DELETE.BAR",
        201: "UNREGISTER",
        204: "USDOLLAR",
        205: "FINDB",
        206: "SEARCHB",
        207: "REPLACEB",
        208: "LEFTB",
        209: "RIGHTB",
        210: "MIDB",
        211: "LENB",
        212: "ROUNDUP",
        213: "ROUNDDOWN",
        214: "ASC",
        215: "DBCS",
        216: "RANK",
        219: "ADDRESS",
        220: "DAYS360",
        221: "TODAY",
        222: "VDB",
        223: "ELSE",
        224: "ELSE.IF",
        225: "END.IF",
        226: "FOR.CELL",
        227: "MEDIAN",
        228: "SUMPRODUCT",
        229: "SINH",
        230: "COSH",
        231: "TANH",
        232: "ASINH",
        233: "ACOSH",
        234: "ATANH",
        235: "DGET",
        236: "CREATE.OBJECT",
        237: "VOLATILE",
        238: "LAST.ERROR",
        239: "CUSTOM.UNDO",
        240: "CUSTOM.REPEAT",
        241: "FORMULA.CONVERT",
        242: "GET.LINK.INFO",
        243: "TEXT.BOX",
        244: "INFO",
        245: "GROUP",
        246: "GET.OBJECT",
        247: "DB",
        248: "PAUSE",
        251: "RESUME",
        252: "FREQUENCY",
        253: "ADD.TOOLBAR",
        254: "DELETE.TOOLBAR",
        255: "User",
        256: "RESET.TOOLBAR",
        257: "EVALUATE",
        258: "GET.TOOLBAR",
        259: "GET.TOOL",
        260: "SPELLING.CHECK",
        261: "ERROR.TYPE",
        262: "APP.TITLE",
        263: "WINDOW.TITLE",
        264: "SAVE.TOOLBAR",
        265: "ENABLE.TOOL",
        266: "PRESS.TOOL",
        267: "REGISTER.ID",
        268: "GET.WORKBOOK",
        269: "AVEDEV",
        270: "BETADIST",
        271: "GAMMALN",
        272: "BETAINV",
        273: "BINOMDIST",
        274: "CHIDIST",
        275: "CHIINV",
        276: "COMBIN",
        277: "CONFIDENCE",
        278: "CRITBINOM",
        279: "EVEN",
        280: "EXPONDIST",
        281: "FDIST",
        282: "FINV",
        283: "FISHER",
        284: "FISHERINV",
        285: "FLOOR",
        286: "GAMMADIST",
        287: "GAMMAINV",
        288: "CEILING",
        289: "HYPGEOMDIST",
        290: "LOGNORMDIST",
        291: "LOGINV",
        292: "NEGBINOMDIST",
        293: "NORMDIST",
        294: "NORMSDIST",
        295: "NORMINV",
        296: "NORMSINV",
        297: "STANDARDIZE",
        298: "ODD",
        299: "PERMUT",
        300: "POISSON",
        301: "TDIST",
        302: "WEIBULL",
        303: "SUMXMY2",
        304: "SUMX2MY2",
        305: "SUMX2PY2",
        306: "CHITEST",
        307: "CORREL",
        308: "COVAR",
        309: "FORECAST",
        310: "FTEST",
        311: "INTERCEPT",
        312: "PEARSON",
        313: "RSQ",
        314: "STEYX",
        315: "SLOPE",
        316: "TTEST",
        317: "PROB",
        318: "DEVSQ",
        319: "GEOMEAN",
        320: "HARMEAN",
        321: "SUMSQ",
        322: "KURT",
        323: "SKEW",
        324: "ZTEST",
        325: "LARGE",
        326: "SMALL",
        327: "QUARTILE",
        328: "PERCENTILE",
        329: "PERCENTRANK",
        330: "MODE",
        331: "TRIMMEAN",
        332: "TINV",
        334: "MOVIE.COMMAND",
        335: "GET.MOVIE",
        336: "CONCATENATE",
        337: "POWER",
        338: "PIVOT.ADD.DATA",
        339: "GET.PIVOT.TABLE",
        340: "GET.PIVOT.FIELD",
        341: "GET.PIVOT.ITEM",
        342: "RADIANS",
        343: "DEGREES",
        344: "SUBTOTAL",
        345: "SUMIF",
        346: "COUNTIF",
        347: "COUNTBLANK",
        348: "SCENARIO.GET",
        349: "OPTIONS.LISTS.GET",
        350: "ISPMT",
        351: "DATEDIF",
        352: "DATESTRING",
        353: "NUMBERSTRING",
        354: "ROMAN",
        355: "OPEN.DIALOG",
        356: "SAVE.DIALOG",
        357: "VIEW.GET",
        358: "GETPIVOTDATA",
        359: "HYPERLINK",
        360: "PHONETIC",
        361: "AVERAGEA",
        362: "MAXA",
        363: "MINA",
        364: "STDEVPA",
        365: "VARPA",
        366: "STDEVA",
        367: "VARA",
        368: "BAHTTEXT",
        369: "THAIDAYOFWEEK",
        370: "THAIDIGIT",
        371: "THAIMONTHOFYEAR",
        372: "THAINUMSOUND",
        373: "THAINUMSTRING",
        374: "THAISTRINGLENGTH",
        375: "ISTHAIDIGIT",
        376: "ROUNDBAHTDOWN",
        377: "ROUNDBAHTUP",
        378: "THAIYEAR",
        379: "RTD",
        380: "CUBEVALUE",
        381: "CUBEMEMBER",
        382: "CUBEMEMBERPROPERTY",
        383: "CUBERANKEDMEMBER",
        384: "HEX2BIN",
        385: "HEX2DEC",
        386: "HEX2OCT",
        387: "DEC2BIN",
        388: "DEC2HEX",
        389: "DEC2OCT",
        390: "OCT2BIN",
        391: "OCT2HEX",
        392: "OCT2DEC",
        393: "BIN2DEC",
        394: "BIN2OCT",
        395: "BIN2HEX",
        396: "IMSUB",
        397: "IMDIV",
        398: "IMPOWER",
        399: "IMABS",
        400: "IMSQRT",
        401: "IMLN",
        402: "IMLOG2",
        403: "IMLOG10",
        404: "IMSIN",
        405: "IMCOS",
        406: "IMEXP",
        407: "IMARGUMENT",
        408: "IMCONJUGATE",
        409: "IMAGINARY",
        410: "IMREAL",
        411: "COMPLEX",
        412: "IMSUM",
        413: "IMPRODUCT",
        414: "SERIESSUM",
        415: "FACTDOUBLE",
        416: "SQRTPI",
        417: "QUOTIENT",
        418: "DELTA",
        419: "GESTEP",
        420: "ISEVEN",
        421: "ISODD",
        422: "MROUND",
        423: "ERF",
        424: "ERFC",
        425: "BESSELJ",
        426: "BESSELK",
        427: "BESSELY",
        428: "BESSELI",
        429: "XIRR",
        430: "XNPV",
        431: "PRICEMAT",
        432: "YIELDMAT",
        433: "INTRATE",
        434: "RECEIVED",
        435: "DISC",
        436: "PRICEDISC",
        437: "YIELDDISC",
        438: "TBILLEQ",
        439: "TBILLPRICE",
        440: "TBILLYIELD",
        441: "PRICE",
        442: "YIELD",
        443: "DOLLARDE",
        444: "DOLLARFR",
        445: "NOMINAL",
        446: "EFFECT",
        447: "CUMPRINC",
        448: "CUMIPMT",
        449: "EDATE",
        450: "EOMONTH",
        451: "YEARFRAC",
        452: "COUPDAYBS",
        453: "COUPDAYS",
        454: "COUPDAYSNC",
        455: "COUPNCD",
        456: "COUPNUM",
        457: "COUPPCD",
        458: "DURATION",
        459: "MDURATION",
        460: "ODDLPRICE",
        461: "ODDLYIELD",
        462: "ODDFPRICE",
        463: "ODDFYIELD",
        464: "RANDBETWEEN",
        465: "WEEKNUM",
        466: "AMORDEGRC",
        467: "AMORLINC",
        468: "CONVERT",
        724: "SHEETJS",
        469: "ACCRINT",
        470: "ACCRINTM",
        471: "WORKDAY",
        472: "NETWORKDAYS",
        473: "GCD",
        474: "MULTINOMIAL",
        475: "LCM",
        476: "FVSCHEDULE",
        477: "CUBEKPIMEMBER",
        478: "CUBESET",
        479: "CUBESETCOUNT",
        480: "IFERROR",
        481: "COUNTIFS",
        482: "SUMIFS",
        483: "AVERAGEIF",
        484: "AVERAGEIFS"
      };
      var FtabArgc = {
        2: 1,
        3: 1,
        10: 0,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 0,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 2,
        30: 2,
        31: 3,
        32: 1,
        33: 1,
        34: 0,
        35: 0,
        38: 1,
        39: 2,
        40: 3,
        41: 3,
        42: 3,
        43: 3,
        44: 3,
        45: 3,
        47: 3,
        48: 2,
        53: 1,
        61: 3,
        63: 0,
        65: 3,
        66: 3,
        67: 1,
        68: 1,
        69: 1,
        70: 1,
        71: 1,
        72: 1,
        73: 1,
        74: 0,
        75: 1,
        76: 1,
        77: 1,
        79: 2,
        80: 2,
        83: 1,
        85: 0,
        86: 1,
        89: 0,
        90: 1,
        94: 0,
        95: 0,
        97: 2,
        98: 1,
        99: 1,
        101: 3,
        102: 3,
        105: 1,
        106: 1,
        108: 2,
        111: 1,
        112: 1,
        113: 1,
        114: 1,
        117: 2,
        118: 1,
        119: 4,
        121: 1,
        126: 1,
        127: 1,
        128: 1,
        129: 1,
        130: 1,
        131: 1,
        133: 1,
        134: 1,
        135: 1,
        136: 2,
        137: 2,
        138: 2,
        140: 1,
        141: 1,
        142: 3,
        143: 4,
        144: 4,
        161: 1,
        162: 1,
        163: 1,
        164: 1,
        165: 2,
        172: 1,
        175: 2,
        176: 2,
        177: 3,
        178: 2,
        179: 1,
        184: 1,
        186: 1,
        189: 3,
        190: 1,
        195: 3,
        196: 3,
        197: 1,
        198: 1,
        199: 3,
        201: 1,
        207: 4,
        210: 3,
        211: 1,
        212: 2,
        213: 2,
        214: 1,
        215: 1,
        225: 0,
        229: 1,
        230: 1,
        231: 1,
        232: 1,
        233: 1,
        234: 1,
        235: 3,
        244: 1,
        247: 4,
        252: 2,
        257: 1,
        261: 1,
        271: 1,
        273: 4,
        274: 2,
        275: 2,
        276: 2,
        277: 3,
        278: 3,
        279: 1,
        280: 3,
        281: 3,
        282: 3,
        283: 1,
        284: 1,
        285: 2,
        286: 4,
        287: 3,
        288: 2,
        289: 4,
        290: 3,
        291: 3,
        292: 3,
        293: 4,
        294: 1,
        295: 3,
        296: 1,
        297: 3,
        298: 1,
        299: 2,
        300: 3,
        301: 3,
        302: 4,
        303: 2,
        304: 2,
        305: 2,
        306: 2,
        307: 2,
        308: 2,
        309: 3,
        310: 2,
        311: 2,
        312: 2,
        313: 2,
        314: 2,
        315: 2,
        316: 4,
        325: 2,
        326: 2,
        327: 2,
        328: 2,
        331: 2,
        332: 2,
        337: 2,
        342: 1,
        343: 1,
        346: 2,
        347: 1,
        350: 4,
        351: 3,
        352: 1,
        353: 2,
        360: 1,
        368: 1,
        369: 1,
        370: 1,
        371: 1,
        372: 1,
        373: 1,
        374: 1,
        375: 1,
        376: 1,
        377: 1,
        378: 1,
        382: 3,
        385: 1,
        392: 1,
        393: 1,
        396: 2,
        397: 2,
        398: 2,
        399: 1,
        400: 1,
        401: 1,
        402: 1,
        403: 1,
        404: 1,
        405: 1,
        406: 1,
        407: 1,
        408: 1,
        409: 1,
        410: 1,
        414: 4,
        415: 1,
        416: 1,
        417: 2,
        420: 1,
        421: 1,
        422: 2,
        424: 1,
        425: 2,
        426: 2,
        427: 2,
        428: 2,
        430: 3,
        438: 3,
        439: 3,
        440: 3,
        443: 2,
        444: 2,
        445: 2,
        446: 2,
        447: 6,
        448: 6,
        449: 2,
        450: 2,
        464: 2,
        468: 3,
        476: 2,
        479: 1,
        480: 2,
        65535: 0
      };
      function ods_to_csf_formula(f) {
        if (f.slice(0, 3) == "of:")
          f = f.slice(3);
        if (f.charCodeAt(0) == 61) {
          f = f.slice(1);
          if (f.charCodeAt(0) == 61)
            f = f.slice(1);
        }
        f = f.replace(/COM\.MICROSOFT\./g, "");
        f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
          return $1.replace(/\./g, "");
        });
        f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
        return f.replace(/[;~]/g, ",").replace(/\|/g, ";");
      }
      function ods_to_csf_3D(r) {
        var a2 = r.split(":");
        var s = a2[0].split(".")[0];
        return [s, a2[0].split(".")[1] + (a2.length > 1 ? ":" + (a2[1].split(".")[1] || a2[1].split(".")[0]) : "")];
      }
      var strs = {};
      var _ssfopts = {};
      function default_margins(margins, mode) {
        if (!margins)
          return;
        var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
        if (mode == "xlml")
          defs = [1, 1, 1, 1, 0.5, 0.5];
        if (margins.left == null)
          margins.left = defs[0];
        if (margins.right == null)
          margins.right = defs[1];
        if (margins.top == null)
          margins.top = defs[2];
        if (margins.bottom == null)
          margins.bottom = defs[3];
        if (margins.header == null)
          margins.header = defs[4];
        if (margins.footer == null)
          margins.footer = defs[5];
      }
      function safe_format(p2, fmtid, fillid, opts, themes, styles2) {
        try {
          if (opts.cellNF)
            p2.z = table_fmt[fmtid];
        } catch (e) {
          if (opts.WTF)
            throw e;
        }
        if (p2.t === "z" && !opts.cellStyles)
          return;
        if (p2.t === "d" && typeof p2.v === "string")
          p2.v = parseDate(p2.v);
        if ((!opts || opts.cellText !== false) && p2.t !== "z")
          try {
            if (table_fmt[fmtid] == null)
              SSF_load(SSFImplicit[fmtid] || "General", fmtid);
            if (p2.t === "e")
              p2.w = p2.w || BErr[p2.v];
            else if (fmtid === 0) {
              if (p2.t === "n") {
                if ((p2.v | 0) === p2.v)
                  p2.w = p2.v.toString(10);
                else
                  p2.w = SSF_general_num(p2.v);
              } else if (p2.t === "d") {
                var dd = datenum(p2.v);
                if ((dd | 0) === dd)
                  p2.w = dd.toString(10);
                else
                  p2.w = SSF_general_num(dd);
              } else if (p2.v === void 0)
                return "";
              else
                p2.w = SSF_general(p2.v, _ssfopts);
            } else if (p2.t === "d")
              p2.w = SSF_format(fmtid, datenum(p2.v), _ssfopts);
            else
              p2.w = SSF_format(fmtid, p2.v, _ssfopts);
          } catch (e) {
            if (opts.WTF)
              throw e;
          }
        if (!opts.cellStyles)
          return;
        if (fillid != null)
          try {
            p2.s = styles2.Fills[fillid];
            if (p2.s.fgColor && p2.s.fgColor.theme && !p2.s.fgColor.rgb) {
              p2.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb, p2.s.fgColor.tint || 0);
              if (opts.WTF)
                p2.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb;
            }
            if (p2.s.bgColor && p2.s.bgColor.theme) {
              p2.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb, p2.s.bgColor.tint || 0);
              if (opts.WTF)
                p2.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb;
            }
          } catch (e) {
            if (opts.WTF && styles2.Fills)
              throw e;
          }
      }
      function parse_ws_xml_dim(ws, s) {
        var d = safe_decode_range(s);
        if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0)
          ws["!ref"] = encode_range(d);
      }
      var mergecregex = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;
      var sheetdataregex = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;
      var hlinkregex = /<(?:\w:)?hyperlink [^>]*>/mg;
      var dimregex = /"(\w*:\w*)"/;
      var colregex = /<(?:\w:)?col\b[^>]*[\/]?>/g;
      var afregex = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;
      var marginregex = /<(?:\w:)?pageMargins[^>]*\/>/g;
      var sheetprregex = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;
      var sheetprregex2 = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/;
      var svsregex = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
      function parse_ws_xml(data, opts, idx, rels, wb, themes, styles2) {
        if (!data)
          return data;
        if (!rels)
          rels = { "!id": {} };
        var s = opts.dense ? [] : {};
        var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        var data1 = "", data2 = "";
        var mtch = data.match(sheetdataregex);
        if (mtch) {
          data1 = data.slice(0, mtch.index);
          data2 = data.slice(mtch.index + mtch[0].length);
        } else
          data1 = data2 = data;
        var sheetPr = data1.match(sheetprregex);
        if (sheetPr)
          parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
        else if (sheetPr = data1.match(sheetprregex2))
          parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s, wb, idx);
        var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
        if (ridx > 0) {
          var ref2 = data1.slice(ridx, ridx + 50).match(dimregex);
          if (ref2)
            parse_ws_xml_dim(s, ref2[1]);
        }
        var svs = data1.match(svsregex);
        if (svs && svs[1])
          parse_ws_xml_sheetviews(svs[1], wb);
        var columns = [];
        if (opts.cellStyles) {
          var cols = data1.match(colregex);
          if (cols)
            parse_ws_xml_cols(columns, cols);
        }
        if (mtch)
          parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles2);
        var afilter = data2.match(afregex);
        if (afilter)
          s["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
        var merges = [];
        var _merge = data2.match(mergecregex);
        if (_merge)
          for (ridx = 0; ridx != _merge.length; ++ridx)
            merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf('"') + 1));
        var hlink = data2.match(hlinkregex);
        if (hlink)
          parse_ws_xml_hlinks(s, hlink, rels);
        var margins = data2.match(marginregex);
        if (margins)
          s["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
        if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r)
          s["!ref"] = encode_range(refguess);
        if (opts.sheetRows > 0 && s["!ref"]) {
          var tmpref = safe_decode_range(s["!ref"]);
          if (opts.sheetRows <= +tmpref.e.r) {
            tmpref.e.r = opts.sheetRows - 1;
            if (tmpref.e.r > refguess.e.r)
              tmpref.e.r = refguess.e.r;
            if (tmpref.e.r < tmpref.s.r)
              tmpref.s.r = tmpref.e.r;
            if (tmpref.e.c > refguess.e.c)
              tmpref.e.c = refguess.e.c;
            if (tmpref.e.c < tmpref.s.c)
              tmpref.s.c = tmpref.e.c;
            s["!fullref"] = s["!ref"];
            s["!ref"] = encode_range(tmpref);
          }
        }
        if (columns.length > 0)
          s["!cols"] = columns;
        if (merges.length > 0)
          s["!merges"] = merges;
        return s;
      }
      function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {
        var data = parsexmltag(sheetPr);
        if (!wb.Sheets[idx])
          wb.Sheets[idx] = {};
        if (data.codeName)
          wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
      }
      function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {
        parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s, wb, idx);
      }
      function parse_ws_xml_hlinks(s, data, rels) {
        var dense = Array.isArray(s);
        for (var i = 0; i != data.length; ++i) {
          var val = parsexmltag(utf8read(data[i]), true);
          if (!val.ref)
            return;
          var rel = ((rels || {})["!id"] || [])[val.id];
          if (rel) {
            val.Target = rel.Target;
            if (val.location)
              val.Target += "#" + unescapexml(val.location);
          } else {
            val.Target = "#" + unescapexml(val.location);
            rel = { Target: val.Target, TargetMode: "Internal" };
          }
          val.Rel = rel;
          if (val.tooltip) {
            val.Tooltip = val.tooltip;
            delete val.tooltip;
          }
          var rng = safe_decode_range(val.ref);
          for (var R = rng.s.r; R <= rng.e.r; ++R)
            for (var C = rng.s.c; C <= rng.e.c; ++C) {
              var addr = encode_cell({ c: C, r: R });
              if (dense) {
                if (!s[R])
                  s[R] = [];
                if (!s[R][C])
                  s[R][C] = { t: "z", v: void 0 };
                s[R][C].l = val;
              } else {
                if (!s[addr])
                  s[addr] = { t: "z", v: void 0 };
                s[addr].l = val;
              }
            }
        }
      }
      function parse_ws_xml_margins(margin) {
        var o = {};
        ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k) {
          if (margin[k])
            o[k] = parseFloat(margin[k]);
        });
        return o;
      }
      function parse_ws_xml_cols(columns, cols) {
        var seencol = false;
        for (var coli = 0; coli != cols.length; ++coli) {
          var coll = parsexmltag(cols[coli], true);
          if (coll.hidden)
            coll.hidden = parsexmlbool(coll.hidden);
          var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
          if (coll.outlineLevel)
            coll.level = +coll.outlineLevel || 0;
          delete coll.min;
          delete coll.max;
          coll.width = +coll.width;
          if (!seencol && coll.width) {
            seencol = true;
            find_mdw_colw(coll.width);
          }
          process_col(coll);
          while (colm <= colM)
            columns[colm++] = dup(coll);
        }
      }
      function parse_ws_xml_autofilter(data) {
        var o = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
        return o;
      }
      var sviewregex = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;
      function parse_ws_xml_sheetviews(data, wb) {
        if (!wb.Views)
          wb.Views = [{}];
        (data.match(sviewregex) || []).forEach(function(r, i) {
          var tag = parsexmltag(r);
          if (!wb.Views[i])
            wb.Views[i] = {};
          if (+tag.zoomScale)
            wb.Views[i].zoom = +tag.zoomScale;
          if (parsexmlbool(tag.rightToLeft))
            wb.Views[i].RTL = true;
        });
      }
      var parse_ws_xml_data = /* @__PURE__ */ function() {
        var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
        var rregex = /r=["']([^"']*)["']/, isregex = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;
        var refregex = /ref=["']([^"']*)["']/;
        var match_v = matchtag("v"), match_f = matchtag("f");
        return function parse_ws_xml_data2(sdata, s, opts, guess, themes, styles2) {
          var ri = 0, x = "", cells = [], cref = [], idx = 0, i = 0, cc = 0, d = "", p2;
          var tag, tagr = 0, tagc = 0;
          var sstr, ftag;
          var fmtid = 0, fillid = 0;
          var do_format = Array.isArray(styles2.CellXf), cf;
          var arrayf = [];
          var sharedf = [];
          var dense = Array.isArray(s);
          var rows = [], rowobj = {}, rowrite = false;
          var sheetStubs = !!opts.sheetStubs;
          for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
            x = marr[mt].trim();
            var xlen = x.length;
            if (xlen === 0)
              continue;
            var rstarti = 0;
            outa:
              for (ri = 0; ri < xlen; ++ri)
                switch (
                  /*x.charCodeAt(ri)*/
                  x[ri]
                ) {
                  case ">":
                    if (
                      /*x.charCodeAt(ri-1) != 47*/
                      x[ri - 1] != "/"
                    ) {
                      ++ri;
                      break outa;
                    }
                    if (opts && opts.cellStyles) {
                      tag = parsexmltag(x.slice(rstarti, ri), true);
                      tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
                      tagc = -1;
                      if (opts.sheetRows && opts.sheetRows < tagr)
                        continue;
                      rowobj = {};
                      rowrite = false;
                      if (tag.ht) {
                        rowrite = true;
                        rowobj.hpt = parseFloat(tag.ht);
                        rowobj.hpx = pt2px(rowobj.hpt);
                      }
                      if (tag.hidden == "1") {
                        rowrite = true;
                        rowobj.hidden = true;
                      }
                      if (tag.outlineLevel != null) {
                        rowrite = true;
                        rowobj.level = +tag.outlineLevel;
                      }
                      if (rowrite)
                        rows[tagr - 1] = rowobj;
                    }
                    break;
                  case "<":
                    rstarti = ri;
                    break;
                }
            if (rstarti >= ri)
              break;
            tag = parsexmltag(x.slice(rstarti, ri), true);
            tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
            tagc = -1;
            if (opts.sheetRows && opts.sheetRows < tagr)
              continue;
            if (guess.s.r > tagr - 1)
              guess.s.r = tagr - 1;
            if (guess.e.r < tagr - 1)
              guess.e.r = tagr - 1;
            if (opts && opts.cellStyles) {
              rowobj = {};
              rowrite = false;
              if (tag.ht) {
                rowrite = true;
                rowobj.hpt = parseFloat(tag.ht);
                rowobj.hpx = pt2px(rowobj.hpt);
              }
              if (tag.hidden == "1") {
                rowrite = true;
                rowobj.hidden = true;
              }
              if (tag.outlineLevel != null) {
                rowrite = true;
                rowobj.level = +tag.outlineLevel;
              }
              if (rowrite)
                rows[tagr - 1] = rowobj;
            }
            cells = x.slice(ri).split(cellregex);
            for (var rslice = 0; rslice != cells.length; ++rslice)
              if (cells[rslice].trim().charAt(0) != "<")
                break;
            cells = cells.slice(rslice);
            for (ri = 0; ri != cells.length; ++ri) {
              x = cells[ri].trim();
              if (x.length === 0)
                continue;
              cref = x.match(rregex);
              idx = ri;
              i = 0;
              cc = 0;
              x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x;
              if (cref != null && cref.length === 2) {
                idx = 0;
                d = cref[1];
                for (i = 0; i != d.length; ++i) {
                  if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26)
                    break;
                  idx = 26 * idx + cc;
                }
                --idx;
                tagc = idx;
              } else
                ++tagc;
              for (i = 0; i != x.length; ++i)
                if (x.charCodeAt(i) === 62)
                  break;
              ++i;
              tag = parsexmltag(x.slice(0, i), true);
              if (!tag.r)
                tag.r = encode_cell({ r: tagr - 1, c: tagc });
              d = x.slice(i);
              p2 = { t: "" };
              if ((cref = d.match(match_v)) != null && /*::cref != null && */
              cref[1] !== "")
                p2.v = unescapexml(cref[1]);
              if (opts.cellFormula) {
                if ((cref = d.match(match_f)) != null && /*::cref != null && */
                cref[1] !== "") {
                  p2.f = unescapexml(utf8read(cref[1])).replace(/\r\n/g, "\n");
                  if (!opts.xlfn)
                    p2.f = _xlfn(p2.f);
                  if (
                    /*::cref != null && cref[0] != null && */
                    cref[0].indexOf('t="array"') > -1
                  ) {
                    p2.F = (d.match(refregex) || [])[1];
                    if (p2.F.indexOf(":") > -1)
                      arrayf.push([safe_decode_range(p2.F), p2.F]);
                  } else if (
                    /*::cref != null && cref[0] != null && */
                    cref[0].indexOf('t="shared"') > -1
                  ) {
                    ftag = parsexmltag(cref[0]);
                    var ___f = unescapexml(utf8read(cref[1]));
                    if (!opts.xlfn)
                      ___f = _xlfn(___f);
                    sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
                  }
                } else if (cref = d.match(/<f[^>]*\/>/)) {
                  ftag = parsexmltag(cref[0]);
                  if (sharedf[ftag.si])
                    p2.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
                }
                var _tag = decode_cell(tag.r);
                for (i = 0; i < arrayf.length; ++i)
                  if (_tag.r >= arrayf[i][0].s.r && _tag.r <= arrayf[i][0].e.r) {
                    if (_tag.c >= arrayf[i][0].s.c && _tag.c <= arrayf[i][0].e.c)
                      p2.F = arrayf[i][1];
                  }
              }
              if (tag.t == null && p2.v === void 0) {
                if (p2.f || p2.F) {
                  p2.v = 0;
                  p2.t = "n";
                } else if (!sheetStubs)
                  continue;
                else
                  p2.t = "z";
              } else
                p2.t = tag.t || "n";
              if (guess.s.c > tagc)
                guess.s.c = tagc;
              if (guess.e.c < tagc)
                guess.e.c = tagc;
              switch (p2.t) {
                case "n":
                  if (p2.v == "" || p2.v == null) {
                    if (!sheetStubs)
                      continue;
                    p2.t = "z";
                  } else
                    p2.v = parseFloat(p2.v);
                  break;
                case "s":
                  if (typeof p2.v == "undefined") {
                    if (!sheetStubs)
                      continue;
                    p2.t = "z";
                  } else {
                    sstr = strs[parseInt(p2.v, 10)];
                    p2.v = sstr.t;
                    p2.r = sstr.r;
                    if (opts.cellHTML)
                      p2.h = sstr.h;
                  }
                  break;
                case "str":
                  p2.t = "s";
                  p2.v = p2.v != null ? utf8read(p2.v) : "";
                  if (opts.cellHTML)
                    p2.h = escapehtml(p2.v);
                  break;
                case "inlineStr":
                  cref = d.match(isregex);
                  p2.t = "s";
                  if (cref != null && (sstr = parse_si(cref[1]))) {
                    p2.v = sstr.t;
                    if (opts.cellHTML)
                      p2.h = sstr.h;
                  } else
                    p2.v = "";
                  break;
                case "b":
                  p2.v = parsexmlbool(p2.v);
                  break;
                case "d":
                  if (opts.cellDates)
                    p2.v = parseDate(p2.v, 1);
                  else {
                    p2.v = datenum(parseDate(p2.v, 1));
                    p2.t = "n";
                  }
                  break;
                case "e":
                  if (!opts || opts.cellText !== false)
                    p2.w = p2.v;
                  p2.v = RBErr[p2.v];
                  break;
              }
              fmtid = fillid = 0;
              cf = null;
              if (do_format && tag.s !== void 0) {
                cf = styles2.CellXf[tag.s];
                if (cf != null) {
                  if (cf.numFmtId != null)
                    fmtid = cf.numFmtId;
                  if (opts.cellStyles) {
                    if (cf.fillId != null)
                      fillid = cf.fillId;
                  }
                }
              }
              safe_format(p2, fmtid, fillid, opts, themes, styles2);
              if (opts.cellDates && do_format && p2.t == "n" && fmt_is_date(table_fmt[fmtid])) {
                p2.t = "d";
                p2.v = numdate(p2.v);
              }
              if (tag.cm && opts.xlmeta) {
                var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
                if (cm && cm.type == "XLDAPR")
                  p2.D = true;
              }
              if (dense) {
                var _r = decode_cell(tag.r);
                if (!s[_r.r])
                  s[_r.r] = [];
                s[_r.r][_r.c] = p2;
              } else
                s[tag.r] = p2;
            }
          }
          if (rows.length > 0)
            s["!rows"] = rows;
        };
      }();
      function parse_BrtRowHdr(data, length) {
        var z = {};
        var tgt = data.l + length;
        z.r = data.read_shift(4);
        data.l += 4;
        var miyRw = data.read_shift(2);
        data.l += 1;
        var flags = data.read_shift(1);
        data.l = tgt;
        if (flags & 7)
          z.level = flags & 7;
        if (flags & 16)
          z.hidden = true;
        if (flags & 32)
          z.hpt = miyRw / 20;
        return z;
      }
      var parse_BrtWsDim = parse_UncheckedRfX;
      function parse_BrtWsFmtInfo() {
      }
      function parse_BrtWsProp(data, length) {
        var z = {};
        var f = data[data.l];
        ++data.l;
        z.above = !(f & 64);
        z.left = !(f & 128);
        data.l += 18;
        z.name = parse_XLSBCodeName(data);
        return z;
      }
      function parse_BrtCellBlank(data) {
        var cell = parse_XLSBCell(data);
        return [cell];
      }
      function parse_BrtShortBlank(data) {
        var cell = parse_XLSBShortCell(data);
        return [cell];
      }
      function parse_BrtCellBool(data) {
        var cell = parse_XLSBCell(data);
        var fBool = data.read_shift(1);
        return [cell, fBool, "b"];
      }
      function parse_BrtShortBool(data) {
        var cell = parse_XLSBShortCell(data);
        var fBool = data.read_shift(1);
        return [cell, fBool, "b"];
      }
      function parse_BrtCellError(data) {
        var cell = parse_XLSBCell(data);
        var bError = data.read_shift(1);
        return [cell, bError, "e"];
      }
      function parse_BrtShortError(data) {
        var cell = parse_XLSBShortCell(data);
        var bError = data.read_shift(1);
        return [cell, bError, "e"];
      }
      function parse_BrtCellIsst(data) {
        var cell = parse_XLSBCell(data);
        var isst = data.read_shift(4);
        return [cell, isst, "s"];
      }
      function parse_BrtShortIsst(data) {
        var cell = parse_XLSBShortCell(data);
        var isst = data.read_shift(4);
        return [cell, isst, "s"];
      }
      function parse_BrtCellReal(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_Xnum(data);
        return [cell, value, "n"];
      }
      function parse_BrtShortReal(data) {
        var cell = parse_XLSBShortCell(data);
        var value = parse_Xnum(data);
        return [cell, value, "n"];
      }
      function parse_BrtCellRk(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_RkNumber(data);
        return [cell, value, "n"];
      }
      function parse_BrtShortRk(data) {
        var cell = parse_XLSBShortCell(data);
        var value = parse_RkNumber(data);
        return [cell, value, "n"];
      }
      function parse_BrtCellRString(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_RichStr(data);
        return [cell, value, "is"];
      }
      function parse_BrtCellSt(data) {
        var cell = parse_XLSBCell(data);
        var value = parse_XLWideString(data);
        return [cell, value, "str"];
      }
      function parse_BrtShortSt(data) {
        var cell = parse_XLSBShortCell(data);
        var value = parse_XLWideString(data);
        return [cell, value, "str"];
      }
      function parse_BrtFmlaBool(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = data.read_shift(1);
        var o = [cell, value, "b"];
        if (opts.cellFormula) {
          data.l += 2;
          var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
          o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else
          data.l = end;
        return o;
      }
      function parse_BrtFmlaError(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = data.read_shift(1);
        var o = [cell, value, "e"];
        if (opts.cellFormula) {
          data.l += 2;
          var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
          o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else
          data.l = end;
        return o;
      }
      function parse_BrtFmlaNum(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = parse_Xnum(data);
        var o = [cell, value, "n"];
        if (opts.cellFormula) {
          data.l += 2;
          var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
          o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else
          data.l = end;
        return o;
      }
      function parse_BrtFmlaString(data, length, opts) {
        var end = data.l + length;
        var cell = parse_XLSBCell(data);
        cell.r = opts["!row"];
        var value = parse_XLWideString(data);
        var o = [cell, value, "str"];
        if (opts.cellFormula) {
          data.l += 2;
          var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
          o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
        } else
          data.l = end;
        return o;
      }
      var parse_BrtMergeCell = parse_UncheckedRfX;
      function parse_BrtHLink(data, length) {
        var end = data.l + length;
        var rfx = parse_UncheckedRfX(data);
        var relId = parse_XLNullableWideString(data);
        var loc = parse_XLWideString(data);
        var tooltip = parse_XLWideString(data);
        var display = parse_XLWideString(data);
        data.l = end;
        var o = { rfx, relId, loc, display };
        if (tooltip)
          o.Tooltip = tooltip;
        return o;
      }
      function parse_BrtPane() {
      }
      function parse_BrtArrFmla(data, length, opts) {
        var end = data.l + length;
        var rfx = parse_RfX(data);
        var fAlwaysCalc = data.read_shift(1);
        var o = [rfx];
        o[2] = fAlwaysCalc;
        if (opts.cellFormula) {
          var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
          o[1] = formula;
        } else
          data.l = end;
        return o;
      }
      function parse_BrtShrFmla(data, length, opts) {
        var end = data.l + length;
        var rfx = parse_UncheckedRfX(data);
        var o = [rfx];
        if (opts.cellFormula) {
          var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
          o[1] = formula;
          data.l = end;
        } else
          data.l = end;
        return o;
      }
      var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
      function parse_BrtMargins(data) {
        var margins = {};
        BrtMarginKeys.forEach(function(k) {
          margins[k] = parse_Xnum(data);
        });
        return margins;
      }
      function parse_BrtBeginWsView(data) {
        var f = data.read_shift(2);
        data.l += 28;
        return { RTL: f & 32 };
      }
      function parse_BrtDVal() {
      }
      function parse_BrtDVal14() {
      }
      function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles2) {
        if (!data)
          return data;
        var opts = _opts || {};
        if (!rels)
          rels = { "!id": {} };
        var s = opts.dense ? [] : {};
        var ref2;
        var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        var pass = false, end = false;
        var row, p2, cf, R, C, addr, sstr, rr, cell;
        var merges = [];
        opts.biff = 12;
        opts["!row"] = 0;
        var ai = 0, af = false;
        var arrayf = [];
        var sharedf = {};
        var supbooks = opts.supbooks || /*::(*/
        wb.supbooks || [[]];
        supbooks.sharedf = sharedf;
        supbooks.arrayf = arrayf;
        supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) {
          return x.name;
        });
        if (!opts.supbooks) {
          opts.supbooks = supbooks;
          if (wb.Names)
            for (var i = 0; i < wb.Names.length; ++i)
              supbooks[0][i + 1] = wb.Names[i];
        }
        var colinfo = [], rowinfo = [];
        var seencol = false;
        XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
        var cm;
        recordhopper(data, function ws_parse(val, RR, RT) {
          if (end)
            return;
          switch (RT) {
            case 148:
              ref2 = val;
              break;
            case 0:
              row = val;
              if (opts.sheetRows && opts.sheetRows <= row.r)
                end = true;
              rr = encode_row(R = row.r);
              opts["!row"] = row.r;
              if (val.hidden || val.hpt || val.level != null) {
                if (val.hpt)
                  val.hpx = pt2px(val.hpt);
                rowinfo[val.r] = val;
              }
              break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 62:
              p2 = { t: val[2] };
              switch (val[2]) {
                case "n":
                  p2.v = val[1];
                  break;
                case "s":
                  sstr = strs[val[1]];
                  p2.v = sstr.t;
                  p2.r = sstr.r;
                  break;
                case "b":
                  p2.v = val[1] ? true : false;
                  break;
                case "e":
                  p2.v = val[1];
                  if (opts.cellText !== false)
                    p2.w = BErr[p2.v];
                  break;
                case "str":
                  p2.t = "s";
                  p2.v = val[1];
                  break;
                case "is":
                  p2.t = "s";
                  p2.v = val[1].t;
                  break;
              }
              if (cf = styles2.CellXf[val[0].iStyleRef])
                safe_format(p2, cf.numFmtId, null, opts, themes, styles2);
              C = val[0].c == -1 ? C + 1 : val[0].c;
              if (opts.dense) {
                if (!s[R])
                  s[R] = [];
                s[R][C] = p2;
              } else
                s[encode_col(C) + rr] = p2;
              if (opts.cellFormula) {
                af = false;
                for (ai = 0; ai < arrayf.length; ++ai) {
                  var aii = arrayf[ai];
                  if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
                    if (C >= aii[0].s.c && C <= aii[0].e.c) {
                      p2.F = encode_range(aii[0]);
                      af = true;
                    }
                  }
                }
                if (!af && val.length > 3)
                  p2.f = val[3];
              }
              if (refguess.s.r > row.r)
                refguess.s.r = row.r;
              if (refguess.s.c > C)
                refguess.s.c = C;
              if (refguess.e.r < row.r)
                refguess.e.r = row.r;
              if (refguess.e.c < C)
                refguess.e.c = C;
              if (opts.cellDates && cf && p2.t == "n" && fmt_is_date(table_fmt[cf.numFmtId])) {
                var _d = SSF_parse_date_code(p2.v);
                if (_d) {
                  p2.t = "d";
                  p2.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
                }
              }
              if (cm) {
                if (cm.type == "XLDAPR")
                  p2.D = true;
                cm = void 0;
              }
              break;
            case 1:
            case 12:
              if (!opts.sheetStubs || pass)
                break;
              p2 = { t: "z", v: void 0 };
              C = val[0].c == -1 ? C + 1 : val[0].c;
              if (opts.dense) {
                if (!s[R])
                  s[R] = [];
                s[R][C] = p2;
              } else
                s[encode_col(C) + rr] = p2;
              if (refguess.s.r > row.r)
                refguess.s.r = row.r;
              if (refguess.s.c > C)
                refguess.s.c = C;
              if (refguess.e.r < row.r)
                refguess.e.r = row.r;
              if (refguess.e.c < C)
                refguess.e.c = C;
              if (cm) {
                if (cm.type == "XLDAPR")
                  p2.D = true;
                cm = void 0;
              }
              break;
            case 176:
              merges.push(val);
              break;
            case 49:
              {
                cm = ((opts.xlmeta || {}).Cell || [])[val - 1];
              }
              break;
            case 494:
              var rel = rels["!id"][val.relId];
              if (rel) {
                val.Target = rel.Target;
                if (val.loc)
                  val.Target += "#" + val.loc;
                val.Rel = rel;
              } else if (val.relId == "") {
                val.Target = "#" + val.loc;
              }
              for (R = val.rfx.s.r; R <= val.rfx.e.r; ++R)
                for (C = val.rfx.s.c; C <= val.rfx.e.c; ++C) {
                  if (opts.dense) {
                    if (!s[R])
                      s[R] = [];
                    if (!s[R][C])
                      s[R][C] = { t: "z", v: void 0 };
                    s[R][C].l = val;
                  } else {
                    addr = encode_cell({ c: C, r: R });
                    if (!s[addr])
                      s[addr] = { t: "z", v: void 0 };
                    s[addr].l = val;
                  }
                }
              break;
            case 426:
              if (!opts.cellFormula)
                break;
              arrayf.push(val);
              cell = opts.dense ? s[R][C] : s[encode_col(C) + rr];
              cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C }, supbooks, opts);
              cell.F = encode_range(val[0]);
              break;
            case 427:
              if (!opts.cellFormula)
                break;
              sharedf[encode_cell(val[0].s)] = val[1];
              cell = opts.dense ? s[R][C] : s[encode_col(C) + rr];
              cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C }, supbooks, opts);
              break;
            case 60:
              if (!opts.cellStyles)
                break;
              while (val.e >= val.s) {
                colinfo[val.e--] = { width: val.w / 256, hidden: !!(val.flags & 1), level: val.level };
                if (!seencol) {
                  seencol = true;
                  find_mdw_colw(val.w / 256);
                }
                process_col(colinfo[val.e + 1]);
              }
              break;
            case 161:
              s["!autofilter"] = { ref: encode_range(val) };
              break;
            case 476:
              s["!margins"] = val;
              break;
            case 147:
              if (!wb.Sheets[idx])
                wb.Sheets[idx] = {};
              if (val.name)
                wb.Sheets[idx].CodeName = val.name;
              if (val.above || val.left)
                s["!outline"] = { above: val.above, left: val.left };
              break;
            case 137:
              if (!wb.Views)
                wb.Views = [{}];
              if (!wb.Views[0])
                wb.Views[0] = {};
              if (val.RTL)
                wb.Views[0].RTL = true;
              break;
            case 485:
              break;
            case 64:
            case 1053:
              break;
            case 151:
              break;
            case 152:
            case 175:
            case 644:
            case 625:
            case 562:
            case 396:
            case 1112:
            case 1146:
            case 471:
            case 1050:
            case 649:
            case 1105:
            case 589:
            case 607:
            case 564:
            case 1055:
            case 168:
            case 174:
            case 1180:
            case 499:
            case 507:
            case 550:
            case 171:
            case 167:
            case 1177:
            case 169:
            case 1181:
            case 551:
            case 552:
            case 661:
            case 639:
            case 478:
            case 537:
            case 477:
            case 536:
            case 1103:
            case 680:
            case 1104:
            case 1024:
            case 663:
            case 535:
            case 678:
            case 504:
            case 1043:
            case 428:
            case 170:
            case 3072:
            case 50:
            case 2070:
            case 1045:
              break;
            case 35:
              pass = true;
              break;
            case 36:
              pass = false;
              break;
            case 37:
              pass = true;
              break;
            case 38:
              pass = false;
              break;
            default:
              if (RR.T)
                ;
              else if (!pass || opts.WTF)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        }, opts);
        delete opts.supbooks;
        delete opts["!row"];
        if (!s["!ref"] && (refguess.s.r < 2e6 || ref2 && (ref2.e.r > 0 || ref2.e.c > 0 || ref2.s.r > 0 || ref2.s.c > 0)))
          s["!ref"] = encode_range(ref2 || refguess);
        if (opts.sheetRows && s["!ref"]) {
          var tmpref = safe_decode_range(s["!ref"]);
          if (opts.sheetRows <= +tmpref.e.r) {
            tmpref.e.r = opts.sheetRows - 1;
            if (tmpref.e.r > refguess.e.r)
              tmpref.e.r = refguess.e.r;
            if (tmpref.e.r < tmpref.s.r)
              tmpref.s.r = tmpref.e.r;
            if (tmpref.e.c > refguess.e.c)
              tmpref.e.c = refguess.e.c;
            if (tmpref.e.c < tmpref.s.c)
              tmpref.s.c = tmpref.e.c;
            s["!fullref"] = s["!ref"];
            s["!ref"] = encode_range(tmpref);
          }
        }
        if (merges.length > 0)
          s["!merges"] = merges;
        if (colinfo.length > 0)
          s["!cols"] = colinfo;
        if (rowinfo.length > 0)
          s["!rows"] = rowinfo;
        return s;
      }
      function parse_Cache(data) {
        var col = [];
        var num = data.match(/^<c:numCache>/);
        var f;
        (data.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(pt) {
          var q = pt.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
          if (!q)
            return;
          col[+q[1]] = num ? +q[2] : q[2];
        });
        var nf = unescapexml((data.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
        (data.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(F) {
          f = F.replace(/<.*?>/g, "");
        });
        return [col, nf, f];
      }
      function parse_chart(data, name, opts, rels, wb, csheet) {
        var cs = csheet || { "!type": "chart" };
        if (!data)
          return csheet;
        var C = 0, R = 0, col = "A";
        var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        (data.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(nc) {
          var cache2 = parse_Cache(nc);
          refguess.s.r = refguess.s.c = 0;
          refguess.e.c = C;
          col = encode_col(C);
          cache2[0].forEach(function(n, i) {
            cs[col + encode_row(i)] = { t: "n", v: n, z: cache2[1] };
            R = i;
          });
          if (refguess.e.r < R)
            refguess.e.r = R;
          ++C;
        });
        if (C > 0)
          cs["!ref"] = encode_range(refguess);
        return cs;
      }
      function parse_cs_xml(data, opts, idx, rels, wb) {
        if (!data)
          return data;
        if (!rels)
          rels = { "!id": {} };
        var s = { "!type": "chart", "!drawel": null, "!rel": "" };
        var m;
        var sheetPr = data.match(sheetprregex);
        if (sheetPr)
          parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
        if (m = data.match(/drawing r:id="(.*?)"/))
          s["!rel"] = m[1];
        if (rels["!id"][s["!rel"]])
          s["!drawel"] = rels["!id"][s["!rel"]];
        return s;
      }
      function parse_BrtCsProp(data, length) {
        data.l += 10;
        var name = parse_XLWideString(data);
        return { name };
      }
      function parse_cs_bin(data, opts, idx, rels, wb) {
        if (!data)
          return data;
        if (!rels)
          rels = { "!id": {} };
        var s = { "!type": "chart", "!drawel": null, "!rel": "" };
        var pass = false;
        recordhopper(data, function cs_parse(val, R, RT) {
          switch (RT) {
            case 550:
              s["!rel"] = val;
              break;
            case 651:
              if (!wb.Sheets[idx])
                wb.Sheets[idx] = {};
              if (val.name)
                wb.Sheets[idx].CodeName = val.name;
              break;
            case 562:
            case 652:
            case 669:
            case 679:
            case 551:
            case 552:
            case 476:
            case 3072:
              break;
            case 35:
              pass = true;
              break;
            case 36:
              pass = false;
              break;
            case 37:
              break;
            case 38:
              break;
            default:
              if (R.T > 0)
                ;
              else if (R.T < 0)
                ;
              else if (!pass || opts.WTF)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        }, opts);
        if (rels["!id"][s["!rel"]])
          s["!drawel"] = rels["!id"][s["!rel"]];
        return s;
      }
      var WBPropsDef = [
        ["allowRefreshQuery", false, "bool"],
        ["autoCompressPictures", true, "bool"],
        ["backupFile", false, "bool"],
        ["checkCompatibility", false, "bool"],
        ["CodeName", ""],
        ["date1904", false, "bool"],
        ["defaultThemeVersion", 0, "int"],
        ["filterPrivacy", false, "bool"],
        ["hidePivotFieldList", false, "bool"],
        ["promptedSolutions", false, "bool"],
        ["publishItems", false, "bool"],
        ["refreshAllConnections", false, "bool"],
        ["saveExternalLinkValues", true, "bool"],
        ["showBorderUnselectedTables", true, "bool"],
        ["showInkAnnotation", true, "bool"],
        ["showObjects", "all"],
        ["showPivotChartFilter", false, "bool"],
        ["updateLinks", "userSet"]
      ];
      var WBViewDef = [
        ["activeTab", 0, "int"],
        ["autoFilterDateGrouping", true, "bool"],
        ["firstSheet", 0, "int"],
        ["minimized", false, "bool"],
        ["showHorizontalScroll", true, "bool"],
        ["showSheetTabs", true, "bool"],
        ["showVerticalScroll", true, "bool"],
        ["tabRatio", 600, "int"],
        ["visibility", "visible"]
        //window{Height,Width}, {x,y}Window
      ];
      var SheetDef = [
        //['state', 'visible']
      ];
      var CalcPrDef = [
        ["calcCompleted", "true"],
        ["calcMode", "auto"],
        ["calcOnSave", "true"],
        ["concurrentCalc", "true"],
        ["fullCalcOnLoad", "false"],
        ["fullPrecision", "true"],
        ["iterate", "false"],
        ["iterateCount", "100"],
        ["iterateDelta", "0.001"],
        ["refMode", "A1"]
      ];
      function push_defaults_array(target, defaults2) {
        for (var j = 0; j != target.length; ++j) {
          var w = target[j];
          for (var i = 0; i != defaults2.length; ++i) {
            var z = defaults2[i];
            if (w[z[0]] == null)
              w[z[0]] = z[1];
            else
              switch (z[2]) {
                case "bool":
                  if (typeof w[z[0]] == "string")
                    w[z[0]] = parsexmlbool(w[z[0]]);
                  break;
                case "int":
                  if (typeof w[z[0]] == "string")
                    w[z[0]] = parseInt(w[z[0]], 10);
                  break;
              }
          }
        }
      }
      function push_defaults(target, defaults2) {
        for (var i = 0; i != defaults2.length; ++i) {
          var z = defaults2[i];
          if (target[z[0]] == null)
            target[z[0]] = z[1];
          else
            switch (z[2]) {
              case "bool":
                if (typeof target[z[0]] == "string")
                  target[z[0]] = parsexmlbool(target[z[0]]);
                break;
              case "int":
                if (typeof target[z[0]] == "string")
                  target[z[0]] = parseInt(target[z[0]], 10);
                break;
            }
        }
      }
      function parse_wb_defaults(wb) {
        push_defaults(wb.WBProps, WBPropsDef);
        push_defaults(wb.CalcPr, CalcPrDef);
        push_defaults_array(wb.WBView, WBViewDef);
        push_defaults_array(wb.Sheets, SheetDef);
        _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
      }
      var badchars = /* @__PURE__ */ "][*?/\\".split("");
      function check_ws_name(n, safe) {
        if (n.length > 31) {
          if (safe)
            return false;
          throw new Error("Sheet names cannot exceed 31 chars");
        }
        var _good = true;
        badchars.forEach(function(c2) {
          if (n.indexOf(c2) == -1)
            return;
          if (!safe)
            throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
          _good = false;
        });
        return _good;
      }
      var wbnsregex = /<\w+:workbook/;
      function parse_wb_xml(data, opts) {
        if (!data)
          throw new Error("Could not find file");
        var wb = (
          /*::(*/
          { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
        );
        var pass = false, xmlns = "xmlns";
        var dname = {}, dnstart = 0;
        data.replace(tagregex, function xml_wb(x, idx) {
          var y = parsexmltag(x);
          switch (strip_ns(y[0])) {
            case "<?xml":
              break;
            case "<workbook":
              if (x.match(wbnsregex))
                xmlns = "xmlns" + x.match(/<(\w+):/)[1];
              wb.xmlns = y[xmlns];
              break;
            case "</workbook>":
              break;
            case "<fileVersion":
              delete y[0];
              wb.AppVersion = y;
              break;
            case "<fileVersion/>":
            case "</fileVersion>":
              break;
            case "<fileSharing":
              break;
            case "<fileSharing/>":
              break;
            case "<workbookPr":
            case "<workbookPr/>":
              WBPropsDef.forEach(function(w) {
                if (y[w[0]] == null)
                  return;
                switch (w[2]) {
                  case "bool":
                    wb.WBProps[w[0]] = parsexmlbool(y[w[0]]);
                    break;
                  case "int":
                    wb.WBProps[w[0]] = parseInt(y[w[0]], 10);
                    break;
                  default:
                    wb.WBProps[w[0]] = y[w[0]];
                }
              });
              if (y.codeName)
                wb.WBProps.CodeName = utf8read(y.codeName);
              break;
            case "</workbookPr>":
              break;
            case "<workbookProtection":
              break;
            case "<workbookProtection/>":
              break;
            case "<bookViews":
            case "<bookViews>":
            case "</bookViews>":
              break;
            case "<workbookView":
            case "<workbookView/>":
              delete y[0];
              wb.WBView.push(y);
              break;
            case "</workbookView>":
              break;
            case "<sheets":
            case "<sheets>":
            case "</sheets>":
              break;
            case "<sheet":
              switch (y.state) {
                case "hidden":
                  y.Hidden = 1;
                  break;
                case "veryHidden":
                  y.Hidden = 2;
                  break;
                default:
                  y.Hidden = 0;
              }
              delete y.state;
              y.name = unescapexml(utf8read(y.name));
              delete y[0];
              wb.Sheets.push(y);
              break;
            case "</sheet>":
              break;
            case "<functionGroups":
            case "<functionGroups/>":
              break;
            case "<functionGroup":
              break;
            case "<externalReferences":
            case "</externalReferences>":
            case "<externalReferences>":
              break;
            case "<externalReference":
              break;
            case "<definedNames/>":
              break;
            case "<definedNames>":
            case "<definedNames":
              pass = true;
              break;
            case "</definedNames>":
              pass = false;
              break;
            case "<definedName":
              {
                dname = {};
                dname.Name = utf8read(y.name);
                if (y.comment)
                  dname.Comment = y.comment;
                if (y.localSheetId)
                  dname.Sheet = +y.localSheetId;
                if (parsexmlbool(y.hidden || "0"))
                  dname.Hidden = true;
                dnstart = idx + x.length;
              }
              break;
            case "</definedName>":
              {
                dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
                wb.Names.push(dname);
              }
              break;
            case "<definedName/>":
              break;
            case "<calcPr":
              delete y[0];
              wb.CalcPr = y;
              break;
            case "<calcPr/>":
              delete y[0];
              wb.CalcPr = y;
              break;
            case "</calcPr>":
              break;
            case "<oleSize":
              break;
            case "<customWorkbookViews>":
            case "</customWorkbookViews>":
            case "<customWorkbookViews":
              break;
            case "<customWorkbookView":
            case "</customWorkbookView>":
              break;
            case "<pivotCaches>":
            case "</pivotCaches>":
            case "<pivotCaches":
              break;
            case "<pivotCache":
              break;
            case "<smartTagPr":
            case "<smartTagPr/>":
              break;
            case "<smartTagTypes":
            case "<smartTagTypes>":
            case "</smartTagTypes>":
              break;
            case "<smartTagType":
              break;
            case "<webPublishing":
            case "<webPublishing/>":
              break;
            case "<fileRecoveryPr":
            case "<fileRecoveryPr/>":
              break;
            case "<webPublishObjects>":
            case "<webPublishObjects":
            case "</webPublishObjects>":
              break;
            case "<webPublishObject":
              break;
            case "<extLst":
            case "<extLst>":
            case "</extLst>":
            case "<extLst/>":
              break;
            case "<ext":
              pass = true;
              break;
            case "</ext>":
              pass = false;
              break;
            case "<ArchID":
              break;
            case "<AlternateContent":
            case "<AlternateContent>":
              pass = true;
              break;
            case "</AlternateContent>":
              pass = false;
              break;
            case "<revisionPtr":
              break;
            default:
              if (!pass && opts.WTF)
                throw new Error("unrecognized " + y[0] + " in workbook");
          }
          return x;
        });
        if (XMLNS_main.indexOf(wb.xmlns) === -1)
          throw new Error("Unknown Namespace: " + wb.xmlns);
        parse_wb_defaults(wb);
        return wb;
      }
      function parse_BrtBundleSh(data, length) {
        var z = {};
        z.Hidden = data.read_shift(4);
        z.iTabID = data.read_shift(4);
        z.strRelID = parse_RelID(data);
        z.name = parse_XLWideString(data);
        return z;
      }
      function parse_BrtWbProp(data, length) {
        var o = {};
        var flags = data.read_shift(4);
        o.defaultThemeVersion = data.read_shift(4);
        var strName = length > 8 ? parse_XLWideString(data) : "";
        if (strName.length > 0)
          o.CodeName = strName;
        o.autoCompressPictures = !!(flags & 65536);
        o.backupFile = !!(flags & 64);
        o.checkCompatibility = !!(flags & 4096);
        o.date1904 = !!(flags & 1);
        o.filterPrivacy = !!(flags & 8);
        o.hidePivotFieldList = !!(flags & 1024);
        o.promptedSolutions = !!(flags & 16);
        o.publishItems = !!(flags & 2048);
        o.refreshAllConnections = !!(flags & 262144);
        o.saveExternalLinkValues = !!(flags & 128);
        o.showBorderUnselectedTables = !!(flags & 4);
        o.showInkAnnotation = !!(flags & 32);
        o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
        o.showPivotChartFilter = !!(flags & 32768);
        o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
        return o;
      }
      function parse_BrtFRTArchID$(data, length) {
        var o = {};
        data.read_shift(4);
        o.ArchID = data.read_shift(4);
        data.l += length - 8;
        return o;
      }
      function parse_BrtName(data, length, opts) {
        var end = data.l + length;
        data.l += 4;
        data.l += 1;
        var itab = data.read_shift(4);
        var name = parse_XLNameWideString(data);
        var formula = parse_XLSBNameParsedFormula(data, 0, opts);
        var comment = parse_XLNullableWideString(data);
        data.l = end;
        var out = { Name: name, Ptg: formula };
        if (itab < 268435455)
          out.Sheet = itab;
        if (comment)
          out.Comment = comment;
        return out;
      }
      function parse_wb_bin(data, opts) {
        var wb = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
        var state = [];
        var pass = false;
        if (!opts)
          opts = {};
        opts.biff = 12;
        var Names = [];
        var supbooks = [[]];
        supbooks.SheetNames = [];
        supbooks.XTI = [];
        XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
        recordhopper(data, function hopper_wb(val, R, RT) {
          switch (RT) {
            case 156:
              supbooks.SheetNames.push(val.name);
              wb.Sheets.push(val);
              break;
            case 153:
              wb.WBProps = val;
              break;
            case 39:
              if (val.Sheet != null)
                opts.SID = val.Sheet;
              val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);
              delete opts.SID;
              delete val.Ptg;
              Names.push(val);
              break;
            case 1036:
              break;
            case 357:
            case 358:
            case 355:
            case 667:
              if (!supbooks[0].length)
                supbooks[0] = [RT, val];
              else
                supbooks.push([RT, val]);
              supbooks[supbooks.length - 1].XTI = [];
              break;
            case 362:
              if (supbooks.length === 0) {
                supbooks[0] = [];
                supbooks[0].XTI = [];
              }
              supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
              supbooks.XTI = supbooks.XTI.concat(val);
              break;
            case 361:
              break;
            case 2071:
            case 158:
            case 143:
            case 664:
            case 353:
              break;
            case 3072:
            case 3073:
            case 534:
            case 677:
            case 157:
            case 610:
            case 2050:
            case 155:
            case 548:
            case 676:
            case 128:
            case 665:
            case 2128:
            case 2125:
            case 549:
            case 2053:
            case 596:
            case 2076:
            case 2075:
            case 2082:
            case 397:
            case 154:
            case 1117:
            case 553:
            case 2091:
              break;
            case 35:
              state.push(RT);
              pass = true;
              break;
            case 36:
              state.pop();
              pass = false;
              break;
            case 37:
              state.push(RT);
              pass = true;
              break;
            case 38:
              state.pop();
              pass = false;
              break;
            case 16:
              break;
            default:
              if (R.T)
                ;
              else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35)
                throw new Error("Unexpected record 0x" + RT.toString(16));
          }
        }, opts);
        parse_wb_defaults(wb);
        wb.Names = Names;
        wb.supbooks = supbooks;
        return wb;
      }
      function parse_wb(data, name, opts) {
        if (name.slice(-4) === ".bin")
          return parse_wb_bin(data, opts);
        return parse_wb_xml(data, opts);
      }
      function parse_ws(data, name, idx, opts, rels, wb, themes, styles2) {
        if (name.slice(-4) === ".bin")
          return parse_ws_bin(data, opts, idx, rels, wb, themes, styles2);
        return parse_ws_xml(data, opts, idx, rels, wb, themes, styles2);
      }
      function parse_cs(data, name, idx, opts, rels, wb, themes, styles2) {
        if (name.slice(-4) === ".bin")
          return parse_cs_bin(data, opts, idx, rels, wb);
        return parse_cs_xml(data, opts, idx, rels, wb);
      }
      function parse_ms(data, name, idx, opts, rels, wb, themes, styles2) {
        if (name.slice(-4) === ".bin")
          return parse_ms_bin();
        return parse_ms_xml();
      }
      function parse_ds(data, name, idx, opts, rels, wb, themes, styles2) {
        if (name.slice(-4) === ".bin")
          return parse_ds_bin();
        return parse_ds_xml();
      }
      function parse_sty(data, name, themes, opts) {
        if (name.slice(-4) === ".bin")
          return parse_sty_bin(data, themes, opts);
        return parse_sty_xml(data, themes, opts);
      }
      function parse_theme(data, name, opts) {
        return parse_theme_xml(data, opts);
      }
      function parse_sst(data, name, opts) {
        if (name.slice(-4) === ".bin")
          return parse_sst_bin(data, opts);
        return parse_sst_xml(data, opts);
      }
      function parse_cmnt(data, name, opts) {
        if (name.slice(-4) === ".bin")
          return parse_comments_bin(data, opts);
        return parse_comments_xml(data, opts);
      }
      function parse_cc(data, name, opts) {
        if (name.slice(-4) === ".bin")
          return parse_cc_bin(data);
        return parse_cc_xml(data);
      }
      function parse_xlink(data, rel, name, opts) {
        if (name.slice(-4) === ".bin")
          return parse_xlink_bin(data, rel, name, opts);
        return parse_xlink_xml();
      }
      function parse_xlmeta(data, name, opts) {
        if (name.slice(-4) === ".bin")
          return parse_xlmeta_bin(data, name, opts);
        return parse_xlmeta_xml(data, name, opts);
      }
      var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
      var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
      function xlml_parsexmltag(tag, skip_root) {
        var words2 = tag.split(/\s+/);
        var z = [];
        if (!skip_root)
          z[0] = words2[0];
        if (words2.length === 1)
          return z;
        var m = tag.match(attregexg2), y, j, w, i;
        if (m)
          for (i = 0; i != m.length; ++i) {
            y = m[i].match(attregex2);
            if ((j = y[1].indexOf(":")) === -1)
              z[y[1]] = y[2].slice(1, y[2].length - 1);
            else {
              if (y[1].slice(0, 6) === "xmlns:")
                w = "xmlns" + y[1].slice(6);
              else
                w = y[1].slice(j + 1);
              z[w] = y[2].slice(1, y[2].length - 1);
            }
          }
        return z;
      }
      function xlml_parsexmltagobj(tag) {
        var words2 = tag.split(/\s+/);
        var z = {};
        if (words2.length === 1)
          return z;
        var m = tag.match(attregexg2), y, j, w, i;
        if (m)
          for (i = 0; i != m.length; ++i) {
            y = m[i].match(attregex2);
            if ((j = y[1].indexOf(":")) === -1)
              z[y[1]] = y[2].slice(1, y[2].length - 1);
            else {
              if (y[1].slice(0, 6) === "xmlns:")
                w = "xmlns" + y[1].slice(6);
              else
                w = y[1].slice(j + 1);
              z[w] = y[2].slice(1, y[2].length - 1);
            }
          }
        return z;
      }
      var XLMLFormatMap;
      function xlml_format(format2, value) {
        var fmt = XLMLFormatMap[format2] || unescapexml(format2);
        if (fmt === "General")
          return SSF_general(value);
        return SSF_format(fmt, value);
      }
      function xlml_set_custprop(Custprops, key, cp, val) {
        var oval = val;
        switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
          case "boolean":
            oval = parsexmlbool(val);
            break;
          case "i2":
          case "int":
            oval = parseInt(val, 10);
            break;
          case "r4":
          case "float":
            oval = parseFloat(val);
            break;
          case "date":
          case "dateTime.tz":
            oval = parseDate(val);
            break;
          case "i8":
          case "string":
          case "fixed":
          case "uuid":
          case "bin.base64":
            break;
          default:
            throw new Error("bad custprop:" + cp[0]);
        }
        Custprops[unescapexml(key)] = oval;
      }
      function safe_format_xlml(cell, nf, o) {
        if (cell.t === "z")
          return;
        if (!o || o.cellText !== false)
          try {
            if (cell.t === "e") {
              cell.w = cell.w || BErr[cell.v];
            } else if (nf === "General") {
              if (cell.t === "n") {
                if ((cell.v | 0) === cell.v)
                  cell.w = cell.v.toString(10);
                else
                  cell.w = SSF_general_num(cell.v);
              } else
                cell.w = SSF_general(cell.v);
            } else
              cell.w = xlml_format(nf || "General", cell.v);
          } catch (e) {
            if (o.WTF)
              throw e;
          }
        try {
          var z = XLMLFormatMap[nf] || nf || "General";
          if (o.cellNF)
            cell.z = z;
          if (o.cellDates && cell.t == "n" && fmt_is_date(z)) {
            var _d = SSF_parse_date_code(cell.v);
            if (_d) {
              cell.t = "d";
              cell.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
            }
          }
        } catch (e) {
          if (o.WTF)
            throw e;
        }
      }
      function process_style_xlml(styles2, stag, opts) {
        if (opts.cellStyles) {
          if (stag.Interior) {
            var I = stag.Interior;
            if (I.Pattern)
              I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
          }
        }
        styles2[stag.ID] = stag;
      }
      function parse_xlml_data(xml, ss, data, cell, base2, styles2, csty, row, arrayf, o) {
        var nf = "General", sid = cell.StyleID, S = {};
        o = o || {};
        var interiors = [];
        var i = 0;
        if (sid === void 0 && row)
          sid = row.StyleID;
        if (sid === void 0 && csty)
          sid = csty.StyleID;
        while (styles2[sid] !== void 0) {
          if (styles2[sid].nf)
            nf = styles2[sid].nf;
          if (styles2[sid].Interior)
            interiors.push(styles2[sid].Interior);
          if (!styles2[sid].Parent)
            break;
          sid = styles2[sid].Parent;
        }
        switch (data.Type) {
          case "Boolean":
            cell.t = "b";
            cell.v = parsexmlbool(xml);
            break;
          case "String":
            cell.t = "s";
            cell.r = xlml_fixstr(unescapexml(xml));
            cell.v = xml.indexOf("<") > -1 ? unescapexml(ss || xml).replace(/<.*?>/g, "") : cell.r;
            break;
          case "DateTime":
            if (xml.slice(-1) != "Z")
              xml += "Z";
            cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
            if (cell.v !== cell.v)
              cell.v = unescapexml(xml);
            else if (cell.v < 60)
              cell.v = cell.v - 1;
            if (!nf || nf == "General")
              nf = "yyyy-mm-dd";
          case "Number":
            if (cell.v === void 0)
              cell.v = +xml;
            if (!cell.t)
              cell.t = "n";
            break;
          case "Error":
            cell.t = "e";
            cell.v = RBErr[xml];
            if (o.cellText !== false)
              cell.w = xml;
            break;
          default:
            if (xml == "" && ss == "") {
              cell.t = "z";
            } else {
              cell.t = "s";
              cell.v = xlml_fixstr(ss || xml);
            }
            break;
        }
        safe_format_xlml(cell, nf, o);
        if (o.cellFormula !== false) {
          if (cell.Formula) {
            var fstr = unescapexml(cell.Formula);
            if (fstr.charCodeAt(0) == 61)
              fstr = fstr.slice(1);
            cell.f = rc_to_a1(fstr, base2);
            delete cell.Formula;
            if (cell.ArrayRange == "RC")
              cell.F = rc_to_a1("RC:RC", base2);
            else if (cell.ArrayRange) {
              cell.F = rc_to_a1(cell.ArrayRange, base2);
              arrayf.push([safe_decode_range(cell.F), cell.F]);
            }
          } else {
            for (i = 0; i < arrayf.length; ++i)
              if (base2.r >= arrayf[i][0].s.r && base2.r <= arrayf[i][0].e.r) {
                if (base2.c >= arrayf[i][0].s.c && base2.c <= arrayf[i][0].e.c)
                  cell.F = arrayf[i][1];
              }
          }
        }
        if (o.cellStyles) {
          interiors.forEach(function(x) {
            if (!S.patternType && x.patternType)
              S.patternType = x.patternType;
          });
          cell.s = S;
        }
        if (cell.StyleID !== void 0)
          cell.ixfe = cell.StyleID;
      }
      function xlml_clean_comment(comment) {
        comment.t = comment.v || "";
        comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        comment.v = comment.w = comment.ixfe = void 0;
      }
      function parse_xlml_xml(d, _opts) {
        var opts = _opts || {};
        make_ssf();
        var str = debom(xlml_normalize(d));
        if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
          str = utf8read(str);
        }
        var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
        opening = opening.replace(/".*?"/g, "");
        if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
          var _o = dup(opts);
          _o.type = "string";
          return PRN.to_workbook(str, _o);
        }
        if (opening.indexOf("<?xml") == -1)
          ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
            if (opening.indexOf("<" + tag) >= 0)
              ishtml = true;
          });
        if (ishtml)
          return html_to_workbook(str, opts);
        XLMLFormatMap = {
          "General Number": "General",
          "General Date": table_fmt[22],
          "Long Date": "dddd, mmmm dd, yyyy",
          "Medium Date": table_fmt[15],
          "Short Date": table_fmt[14],
          "Long Time": table_fmt[19],
          "Medium Time": table_fmt[18],
          "Short Time": table_fmt[20],
          "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
          "Fixed": table_fmt[2],
          "Standard": table_fmt[4],
          "Percent": table_fmt[10],
          "Scientific": table_fmt[11],
          "Yes/No": '"Yes";"Yes";"No";@',
          "True/False": '"True";"True";"False";@',
          "On/Off": '"Yes";"Yes";"No";@'
        };
        var Rn;
        var state = [], tmp;
        var sheets = {}, sheetnames = [], cursheet = opts.dense ? [] : {}, sheetname = "";
        var cell = {}, row = {};
        var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
        var c2 = 0, r = 0;
        var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        var styles2 = {}, stag = {};
        var ss = "", fidx = 0;
        var merges = [];
        var Props = {}, Custprops = {}, pidx = 0, cp = [];
        var comments = [], comment = {};
        var cstys = [], csty, seencol = false;
        var arrayf = [];
        var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
        var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
        xlmlregex.lastIndex = 0;
        str = str.replace(/<!--([\s\S]*?)-->/mg, "");
        var raw_Rn3 = "";
        while (Rn = xlmlregex.exec(str))
          switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
            case "data":
              if (raw_Rn3 == "data") {
                if (Rn[1] === "/") {
                  if ((tmp = state.pop())[0] !== Rn[3])
                    throw new Error("Bad state: " + tmp.join("|"));
                } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
                  state.push([Rn[3], true]);
                break;
              }
              if (state[state.length - 1][1])
                break;
              if (Rn[1] === "/")
                parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == /*"Comment"*/
                "comment" ? comment : cell, { c: c2, r }, styles2, cstys[c2], row, arrayf, opts);
              else {
                ss = "";
                dtag = xlml_parsexmltag(Rn[0]);
                didx = Rn.index + Rn[0].length;
              }
              break;
            case "cell":
              if (Rn[1] === "/") {
                if (comments.length > 0)
                  cell.c = comments;
                if ((!opts.sheetRows || opts.sheetRows > r) && cell.v !== void 0) {
                  if (opts.dense) {
                    if (!cursheet[r])
                      cursheet[r] = [];
                    cursheet[r][c2] = cell;
                  } else
                    cursheet[encode_col(c2) + encode_row(r)] = cell;
                }
                if (cell.HRef) {
                  cell.l = { Target: unescapexml(cell.HRef) };
                  if (cell.HRefScreenTip)
                    cell.l.Tooltip = cell.HRefScreenTip;
                  delete cell.HRef;
                  delete cell.HRefScreenTip;
                }
                if (cell.MergeAcross || cell.MergeDown) {
                  cc = c2 + (parseInt(cell.MergeAcross, 10) | 0);
                  rr = r + (parseInt(cell.MergeDown, 10) | 0);
                  merges.push({ s: { c: c2, r }, e: { c: cc, r: rr } });
                }
                if (!opts.sheetStubs) {
                  if (cell.MergeAcross)
                    c2 = cc + 1;
                  else
                    ++c2;
                } else if (cell.MergeAcross || cell.MergeDown) {
                  for (var cma = c2; cma <= cc; ++cma) {
                    for (var cmd = r; cmd <= rr; ++cmd) {
                      if (cma > c2 || cmd > r) {
                        if (opts.dense) {
                          if (!cursheet[cmd])
                            cursheet[cmd] = [];
                          cursheet[cmd][cma] = { t: "z" };
                        } else
                          cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
                      }
                    }
                  }
                  c2 = cc + 1;
                } else
                  ++c2;
              } else {
                cell = xlml_parsexmltagobj(Rn[0]);
                if (cell.Index)
                  c2 = +cell.Index - 1;
                if (c2 < refguess.s.c)
                  refguess.s.c = c2;
                if (c2 > refguess.e.c)
                  refguess.e.c = c2;
                if (Rn[0].slice(-2) === "/>")
                  ++c2;
                comments = [];
              }
              break;
            case "row":
              if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
                if (r < refguess.s.r)
                  refguess.s.r = r;
                if (r > refguess.e.r)
                  refguess.e.r = r;
                if (Rn[0].slice(-2) === "/>") {
                  row = xlml_parsexmltag(Rn[0]);
                  if (row.Index)
                    r = +row.Index - 1;
                }
                c2 = 0;
                ++r;
              } else {
                row = xlml_parsexmltag(Rn[0]);
                if (row.Index)
                  r = +row.Index - 1;
                rowobj = {};
                if (row.AutoFitHeight == "0" || row.Height) {
                  rowobj.hpx = parseInt(row.Height, 10);
                  rowobj.hpt = px2pt(rowobj.hpx);
                  rowinfo[r] = rowobj;
                }
                if (row.Hidden == "1") {
                  rowobj.hidden = true;
                  rowinfo[r] = rowobj;
                }
              }
              break;
            case "worksheet":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
                sheetnames.push(sheetname);
                if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
                  cursheet["!ref"] = encode_range(refguess);
                  if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
                    cursheet["!fullref"] = cursheet["!ref"];
                    refguess.e.r = opts.sheetRows - 1;
                    cursheet["!ref"] = encode_range(refguess);
                  }
                }
                if (merges.length)
                  cursheet["!merges"] = merges;
                if (cstys.length > 0)
                  cursheet["!cols"] = cstys;
                if (rowinfo.length > 0)
                  cursheet["!rows"] = rowinfo;
                sheets[sheetname] = cursheet;
              } else {
                refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
                r = c2 = 0;
                state.push([Rn[3], false]);
                tmp = xlml_parsexmltag(Rn[0]);
                sheetname = unescapexml(tmp.Name);
                cursheet = opts.dense ? [] : {};
                merges = [];
                arrayf = [];
                rowinfo = [];
                wsprops = { name: sheetname, Hidden: 0 };
                Workbook.Sheets.push(wsprops);
              }
              break;
            case "table":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
              } else if (Rn[0].slice(-2) == "/>")
                break;
              else {
                state.push([Rn[3], false]);
                cstys = [];
                seencol = false;
              }
              break;
            case "style":
              if (Rn[1] === "/")
                process_style_xlml(styles2, stag, opts);
              else
                stag = xlml_parsexmltag(Rn[0]);
              break;
            case "numberformat":
              stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
              if (XLMLFormatMap[stag.nf])
                stag.nf = XLMLFormatMap[stag.nf];
              for (var ssfidx = 0; ssfidx != 392; ++ssfidx)
                if (table_fmt[ssfidx] == stag.nf)
                  break;
              if (ssfidx == 392) {
                for (ssfidx = 57; ssfidx != 392; ++ssfidx)
                  if (table_fmt[ssfidx] == null) {
                    SSF_load(stag.nf, ssfidx);
                    break;
                  }
              }
              break;
            case "column":
              if (state[state.length - 1][0] !== /*'Table'*/
              "table")
                break;
              csty = xlml_parsexmltag(Rn[0]);
              if (csty.Hidden) {
                csty.hidden = true;
                delete csty.Hidden;
              }
              if (csty.Width)
                csty.wpx = parseInt(csty.Width, 10);
              if (!seencol && csty.wpx > 10) {
                seencol = true;
                MDW = DEF_MDW;
                for (var _col = 0; _col < cstys.length; ++_col)
                  if (cstys[_col])
                    process_col(cstys[_col]);
              }
              if (seencol)
                process_col(csty);
              cstys[csty.Index - 1 || cstys.length] = csty;
              for (var i = 0; i < +csty.Span; ++i)
                cstys[cstys.length] = dup(csty);
              break;
            case "namedrange":
              if (Rn[1] === "/")
                break;
              if (!Workbook.Names)
                Workbook.Names = [];
              var _NamedRange = parsexmltag(Rn[0]);
              var _DefinedName = {
                Name: _NamedRange.Name,
                Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
              };
              if (Workbook.Sheets.length > 0)
                _DefinedName.Sheet = Workbook.Sheets.length - 1;
              Workbook.Names.push(_DefinedName);
              break;
            case "namedcell":
              break;
            case "b":
              break;
            case "i":
              break;
            case "u":
              break;
            case "s":
              break;
            case "em":
              break;
            case "h2":
              break;
            case "h3":
              break;
            case "sub":
              break;
            case "sup":
              break;
            case "span":
              break;
            case "alignment":
              break;
            case "borders":
              break;
            case "border":
              break;
            case "font":
              if (Rn[0].slice(-2) === "/>")
                break;
              else if (Rn[1] === "/")
                ss += str.slice(fidx, Rn.index);
              else
                fidx = Rn.index + Rn[0].length;
              break;
            case "interior":
              if (!opts.cellStyles)
                break;
              stag.Interior = xlml_parsexmltag(Rn[0]);
              break;
            case "protection":
              break;
            case "author":
            case "title":
            case "description":
            case "created":
            case "keywords":
            case "subject":
            case "category":
            case "company":
            case "lastauthor":
            case "lastsaved":
            case "lastprinted":
            case "version":
            case "revision":
            case "totaltime":
            case "hyperlinkbase":
            case "manager":
            case "contentstatus":
            case "identifier":
            case "language":
            case "appname":
              if (Rn[0].slice(-2) === "/>")
                break;
              else if (Rn[1] === "/")
                xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
              else
                pidx = Rn.index + Rn[0].length;
              break;
            case "paragraphs":
              break;
            case "styles":
            case "workbook":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
              } else
                state.push([Rn[3], false]);
              break;
            case "comment":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
                xlml_clean_comment(comment);
                comments.push(comment);
              } else {
                state.push([Rn[3], false]);
                tmp = xlml_parsexmltag(Rn[0]);
                comment = { a: tmp.Author };
              }
              break;
            case "autofilter":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                var AutoFilter = xlml_parsexmltag(Rn[0]);
                cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter.Range).replace(/\$/g, "") };
                state.push([Rn[3], true]);
              }
              break;
            case "name":
              break;
            case "datavalidation":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
              } else {
                if (Rn[0].charAt(Rn[0].length - 2) !== "/")
                  state.push([Rn[3], true]);
              }
              break;
            case "pixelsperinch":
              break;
            case "componentoptions":
            case "documentproperties":
            case "customdocumentproperties":
            case "officedocumentsettings":
            case "pivottable":
            case "pivotcache":
            case "names":
            case "mapinfo":
            case "pagebreaks":
            case "querytable":
            case "sorting":
            case "schema":
            case "conditionalformatting":
            case "smarttagtype":
            case "smarttags":
            case "excelworkbook":
            case "workbookoptions":
            case "worksheetoptions":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw new Error("Bad state: " + tmp.join("|"));
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
                state.push([Rn[3], true]);
              break;
            case "null":
              break;
            default:
              if (state.length == 0 && Rn[3] == "document")
                return parse_fods(str, opts);
              if (state.length == 0 && Rn[3] == "uof")
                return parse_fods(str, opts);
              var seen = true;
              switch (state[state.length - 1][0]) {
                case "officedocumentsettings":
                  switch (Rn[3]) {
                    case "allowpng":
                      break;
                    case "removepersonalinformation":
                      break;
                    case "downloadcomponents":
                      break;
                    case "locationofcomponents":
                      break;
                    case "colors":
                      break;
                    case "color":
                      break;
                    case "index":
                      break;
                    case "rgb":
                      break;
                    case "targetscreensize":
                      break;
                    case "readonlyrecommended":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "componentoptions":
                  switch (Rn[3]) {
                    case "toolbar":
                      break;
                    case "hideofficelogo":
                      break;
                    case "spreadsheetautofit":
                      break;
                    case "label":
                      break;
                    case "caption":
                      break;
                    case "maxheight":
                      break;
                    case "maxwidth":
                      break;
                    case "nextsheetnumber":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "excelworkbook":
                  switch (Rn[3]) {
                    case "date1904":
                      Workbook.WBProps.date1904 = true;
                      break;
                    case "windowheight":
                      break;
                    case "windowwidth":
                      break;
                    case "windowtopx":
                      break;
                    case "windowtopy":
                      break;
                    case "tabratio":
                      break;
                    case "protectstructure":
                      break;
                    case "protectwindow":
                      break;
                    case "protectwindows":
                      break;
                    case "activesheet":
                      break;
                    case "displayinknotes":
                      break;
                    case "firstvisiblesheet":
                      break;
                    case "supbook":
                      break;
                    case "sheetname":
                      break;
                    case "sheetindex":
                      break;
                    case "sheetindexfirst":
                      break;
                    case "sheetindexlast":
                      break;
                    case "dll":
                      break;
                    case "acceptlabelsinformulas":
                      break;
                    case "donotsavelinkvalues":
                      break;
                    case "iteration":
                      break;
                    case "maxiterations":
                      break;
                    case "maxchange":
                      break;
                    case "path":
                      break;
                    case "xct":
                      break;
                    case "count":
                      break;
                    case "selectedsheets":
                      break;
                    case "calculation":
                      break;
                    case "uncalced":
                      break;
                    case "startupprompt":
                      break;
                    case "crn":
                      break;
                    case "externname":
                      break;
                    case "formula":
                      break;
                    case "colfirst":
                      break;
                    case "collast":
                      break;
                    case "wantadvise":
                      break;
                    case "boolean":
                      break;
                    case "error":
                      break;
                    case "text":
                      break;
                    case "ole":
                      break;
                    case "noautorecover":
                      break;
                    case "publishobjects":
                      break;
                    case "donotcalculatebeforesave":
                      break;
                    case "number":
                      break;
                    case "refmoder1c1":
                      break;
                    case "embedsavesmarttags":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "workbookoptions":
                  switch (Rn[3]) {
                    case "owcversion":
                      break;
                    case "height":
                      break;
                    case "width":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "worksheetoptions":
                  switch (Rn[3]) {
                    case "visible":
                      if (Rn[0].slice(-2) === "/>")
                        ;
                      else if (Rn[1] === "/")
                        switch (str.slice(pidx, Rn.index)) {
                          case "SheetHidden":
                            wsprops.Hidden = 1;
                            break;
                          case "SheetVeryHidden":
                            wsprops.Hidden = 2;
                            break;
                        }
                      else
                        pidx = Rn.index + Rn[0].length;
                      break;
                    case "header":
                      if (!cursheet["!margins"])
                        default_margins(cursheet["!margins"] = {}, "xlml");
                      if (!isNaN(+parsexmltag(Rn[0]).Margin))
                        cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
                      break;
                    case "footer":
                      if (!cursheet["!margins"])
                        default_margins(cursheet["!margins"] = {}, "xlml");
                      if (!isNaN(+parsexmltag(Rn[0]).Margin))
                        cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
                      break;
                    case "pagemargins":
                      var pagemargins = parsexmltag(Rn[0]);
                      if (!cursheet["!margins"])
                        default_margins(cursheet["!margins"] = {}, "xlml");
                      if (!isNaN(+pagemargins.Top))
                        cursheet["!margins"].top = +pagemargins.Top;
                      if (!isNaN(+pagemargins.Left))
                        cursheet["!margins"].left = +pagemargins.Left;
                      if (!isNaN(+pagemargins.Right))
                        cursheet["!margins"].right = +pagemargins.Right;
                      if (!isNaN(+pagemargins.Bottom))
                        cursheet["!margins"].bottom = +pagemargins.Bottom;
                      break;
                    case "displayrighttoleft":
                      if (!Workbook.Views)
                        Workbook.Views = [];
                      if (!Workbook.Views[0])
                        Workbook.Views[0] = {};
                      Workbook.Views[0].RTL = true;
                      break;
                    case "freezepanes":
                      break;
                    case "frozennosplit":
                      break;
                    case "splithorizontal":
                    case "splitvertical":
                      break;
                    case "donotdisplaygridlines":
                      break;
                    case "activerow":
                      break;
                    case "activecol":
                      break;
                    case "toprowbottompane":
                      break;
                    case "leftcolumnrightpane":
                      break;
                    case "unsynced":
                      break;
                    case "print":
                      break;
                    case "printerrors":
                      break;
                    case "panes":
                      break;
                    case "scale":
                      break;
                    case "pane":
                      break;
                    case "number":
                      break;
                    case "layout":
                      break;
                    case "pagesetup":
                      break;
                    case "selected":
                      break;
                    case "protectobjects":
                      break;
                    case "enableselection":
                      break;
                    case "protectscenarios":
                      break;
                    case "validprinterinfo":
                      break;
                    case "horizontalresolution":
                      break;
                    case "verticalresolution":
                      break;
                    case "numberofcopies":
                      break;
                    case "activepane":
                      break;
                    case "toprowvisible":
                      break;
                    case "leftcolumnvisible":
                      break;
                    case "fittopage":
                      break;
                    case "rangeselection":
                      break;
                    case "papersizeindex":
                      break;
                    case "pagelayoutzoom":
                      break;
                    case "pagebreakzoom":
                      break;
                    case "filteron":
                      break;
                    case "fitwidth":
                      break;
                    case "fitheight":
                      break;
                    case "commentslayout":
                      break;
                    case "zoom":
                      break;
                    case "lefttoright":
                      break;
                    case "gridlines":
                      break;
                    case "allowsort":
                      break;
                    case "allowfilter":
                      break;
                    case "allowinsertrows":
                      break;
                    case "allowdeleterows":
                      break;
                    case "allowinsertcols":
                      break;
                    case "allowdeletecols":
                      break;
                    case "allowinserthyperlinks":
                      break;
                    case "allowformatcells":
                      break;
                    case "allowsizecols":
                      break;
                    case "allowsizerows":
                      break;
                    case "nosummaryrowsbelowdetail":
                      if (!cursheet["!outline"])
                        cursheet["!outline"] = {};
                      cursheet["!outline"].above = true;
                      break;
                    case "tabcolorindex":
                      break;
                    case "donotdisplayheadings":
                      break;
                    case "showpagelayoutzoom":
                      break;
                    case "nosummarycolumnsrightdetail":
                      if (!cursheet["!outline"])
                        cursheet["!outline"] = {};
                      cursheet["!outline"].left = true;
                      break;
                    case "blackandwhite":
                      break;
                    case "donotdisplayzeros":
                      break;
                    case "displaypagebreak":
                      break;
                    case "rowcolheadings":
                      break;
                    case "donotdisplayoutline":
                      break;
                    case "noorientation":
                      break;
                    case "allowusepivottables":
                      break;
                    case "zeroheight":
                      break;
                    case "viewablerange":
                      break;
                    case "selection":
                      break;
                    case "protectcontents":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "pivottable":
                case "pivotcache":
                  switch (Rn[3]) {
                    case "immediateitemsondrop":
                      break;
                    case "showpagemultipleitemlabel":
                      break;
                    case "compactrowindent":
                      break;
                    case "location":
                      break;
                    case "pivotfield":
                      break;
                    case "orientation":
                      break;
                    case "layoutform":
                      break;
                    case "layoutsubtotallocation":
                      break;
                    case "layoutcompactrow":
                      break;
                    case "position":
                      break;
                    case "pivotitem":
                      break;
                    case "datatype":
                      break;
                    case "datafield":
                      break;
                    case "sourcename":
                      break;
                    case "parentfield":
                      break;
                    case "ptlineitems":
                      break;
                    case "ptlineitem":
                      break;
                    case "countofsameitems":
                      break;
                    case "item":
                      break;
                    case "itemtype":
                      break;
                    case "ptsource":
                      break;
                    case "cacheindex":
                      break;
                    case "consolidationreference":
                      break;
                    case "filename":
                      break;
                    case "reference":
                      break;
                    case "nocolumngrand":
                      break;
                    case "norowgrand":
                      break;
                    case "blanklineafteritems":
                      break;
                    case "hidden":
                      break;
                    case "subtotal":
                      break;
                    case "basefield":
                      break;
                    case "mapchilditems":
                      break;
                    case "function":
                      break;
                    case "refreshonfileopen":
                      break;
                    case "printsettitles":
                      break;
                    case "mergelabels":
                      break;
                    case "defaultversion":
                      break;
                    case "refreshname":
                      break;
                    case "refreshdate":
                      break;
                    case "refreshdatecopy":
                      break;
                    case "versionlastrefresh":
                      break;
                    case "versionlastupdate":
                      break;
                    case "versionupdateablemin":
                      break;
                    case "versionrefreshablemin":
                      break;
                    case "calculation":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "pagebreaks":
                  switch (Rn[3]) {
                    case "colbreaks":
                      break;
                    case "colbreak":
                      break;
                    case "rowbreaks":
                      break;
                    case "rowbreak":
                      break;
                    case "colstart":
                      break;
                    case "colend":
                      break;
                    case "rowend":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "autofilter":
                  switch (Rn[3]) {
                    case "autofiltercolumn":
                      break;
                    case "autofiltercondition":
                      break;
                    case "autofilterand":
                      break;
                    case "autofilteror":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "querytable":
                  switch (Rn[3]) {
                    case "id":
                      break;
                    case "autoformatfont":
                      break;
                    case "autoformatpattern":
                      break;
                    case "querysource":
                      break;
                    case "querytype":
                      break;
                    case "enableredirections":
                      break;
                    case "refreshedinxl9":
                      break;
                    case "urlstring":
                      break;
                    case "htmltables":
                      break;
                    case "connection":
                      break;
                    case "commandtext":
                      break;
                    case "refreshinfo":
                      break;
                    case "notitles":
                      break;
                    case "nextid":
                      break;
                    case "columninfo":
                      break;
                    case "overwritecells":
                      break;
                    case "donotpromptforfile":
                      break;
                    case "textwizardsettings":
                      break;
                    case "source":
                      break;
                    case "number":
                      break;
                    case "decimal":
                      break;
                    case "thousandseparator":
                      break;
                    case "trailingminusnumbers":
                      break;
                    case "formatsettings":
                      break;
                    case "fieldtype":
                      break;
                    case "delimiters":
                      break;
                    case "tab":
                      break;
                    case "comma":
                      break;
                    case "autoformatname":
                      break;
                    case "versionlastedit":
                      break;
                    case "versionlastrefresh":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "datavalidation":
                  switch (Rn[3]) {
                    case "range":
                      break;
                    case "type":
                      break;
                    case "min":
                      break;
                    case "max":
                      break;
                    case "sort":
                      break;
                    case "descending":
                      break;
                    case "order":
                      break;
                    case "casesensitive":
                      break;
                    case "value":
                      break;
                    case "errorstyle":
                      break;
                    case "errormessage":
                      break;
                    case "errortitle":
                      break;
                    case "inputmessage":
                      break;
                    case "inputtitle":
                      break;
                    case "combohide":
                      break;
                    case "inputhide":
                      break;
                    case "condition":
                      break;
                    case "qualifier":
                      break;
                    case "useblank":
                      break;
                    case "value1":
                      break;
                    case "value2":
                      break;
                    case "format":
                      break;
                    case "cellrangelist":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "sorting":
                case "conditionalformatting":
                  switch (Rn[3]) {
                    case "range":
                      break;
                    case "type":
                      break;
                    case "min":
                      break;
                    case "max":
                      break;
                    case "sort":
                      break;
                    case "descending":
                      break;
                    case "order":
                      break;
                    case "casesensitive":
                      break;
                    case "value":
                      break;
                    case "errorstyle":
                      break;
                    case "errormessage":
                      break;
                    case "errortitle":
                      break;
                    case "cellrangelist":
                      break;
                    case "inputmessage":
                      break;
                    case "inputtitle":
                      break;
                    case "combohide":
                      break;
                    case "inputhide":
                      break;
                    case "condition":
                      break;
                    case "qualifier":
                      break;
                    case "useblank":
                      break;
                    case "value1":
                      break;
                    case "value2":
                      break;
                    case "format":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "mapinfo":
                case "schema":
                case "data":
                  switch (Rn[3]) {
                    case "map":
                      break;
                    case "entry":
                      break;
                    case "range":
                      break;
                    case "xpath":
                      break;
                    case "field":
                      break;
                    case "xsdtype":
                      break;
                    case "filteron":
                      break;
                    case "aggregate":
                      break;
                    case "elementtype":
                      break;
                    case "attributetype":
                      break;
                    case "schema":
                    case "element":
                    case "complextype":
                    case "datatype":
                    case "all":
                    case "attribute":
                    case "extends":
                      break;
                    case "row":
                      break;
                    default:
                      seen = false;
                  }
                  break;
                case "smarttags":
                  break;
                default:
                  seen = false;
                  break;
              }
              if (seen)
                break;
              if (Rn[3].match(/!\[CDATA/))
                break;
              if (!state[state.length - 1][1])
                throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
              if (state[state.length - 1][0] === /*'CustomDocumentProperties'*/
              "customdocumentproperties") {
                if (Rn[0].slice(-2) === "/>")
                  break;
                else if (Rn[1] === "/")
                  xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
                else {
                  cp = Rn;
                  pidx = Rn.index + Rn[0].length;
                }
                break;
              }
              if (opts.WTF)
                throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
          }
        var out = {};
        if (!opts.bookSheets && !opts.bookProps)
          out.Sheets = sheets;
        out.SheetNames = sheetnames;
        out.Workbook = Workbook;
        out.SSF = dup(table_fmt);
        out.Props = Props;
        out.Custprops = Custprops;
        return out;
      }
      function parse_xlml(data, opts) {
        fix_read_opts(opts = opts || {});
        switch (opts.type || "base64") {
          case "base64":
            return parse_xlml_xml(Base64_decode(data), opts);
          case "binary":
          case "buffer":
          case "file":
            return parse_xlml_xml(data, opts);
          case "array":
            return parse_xlml_xml(a2s(data), opts);
        }
      }
      function parse_compobj(obj) {
        var v = {};
        var o = obj.content;
        o.l = 28;
        v.AnsiUserType = o.read_shift(0, "lpstr-ansi");
        v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);
        if (o.length - o.l <= 4)
          return v;
        var m = o.read_shift(4);
        if (m == 0 || m > 40)
          return v;
        o.l -= 4;
        v.Reserved1 = o.read_shift(0, "lpstr-ansi");
        if (o.length - o.l <= 4)
          return v;
        m = o.read_shift(4);
        if (m !== 1907505652)
          return v;
        v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);
        m = o.read_shift(4);
        if (m == 0 || m > 40)
          return v;
        o.l -= 4;
        v.Reserved2 = o.read_shift(0, "lpwstr");
      }
      var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
      function slurp(RecordType, R, blob, length, opts) {
        var l = length;
        var bufs = [];
        var d = blob.slice(blob.l, blob.l + l);
        if (opts && opts.enc && opts.enc.insitu && d.length > 0)
          switch (RecordType) {
            case 9:
            case 521:
            case 1033:
            case 2057:
            case 47:
            case 405:
            case 225:
            case 406:
            case 312:
            case 404:
            case 10:
              break;
            case 133:
              break;
            default:
              opts.enc.insitu(d);
          }
        bufs.push(d);
        blob.l += l;
        var nextrt = __readUInt16LE(blob, blob.l), next = XLSRecordEnum[nextrt];
        var start = 0;
        while (next != null && CONTINUE_RT.indexOf(nextrt) > -1) {
          l = __readUInt16LE(blob, blob.l + 2);
          start = blob.l + 4;
          if (nextrt == 2066)
            start += 4;
          else if (nextrt == 2165 || nextrt == 2175) {
            start += 12;
          }
          d = blob.slice(start, blob.l + 4 + l);
          bufs.push(d);
          blob.l += 4 + l;
          next = XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)];
        }
        var b = bconcat(bufs);
        prep_blob(b, 0);
        var ll = 0;
        b.lens = [];
        for (var j = 0; j < bufs.length; ++j) {
          b.lens.push(ll);
          ll += bufs[j].length;
        }
        if (b.length < length)
          throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " < " + length;
        return R.f(b, b.length, opts);
      }
      function safe_format_xf(p2, opts, date1904) {
        if (p2.t === "z")
          return;
        if (!p2.XF)
          return;
        var fmtid = 0;
        try {
          fmtid = p2.z || p2.XF.numFmtId || 0;
          if (opts.cellNF)
            p2.z = table_fmt[fmtid];
        } catch (e) {
          if (opts.WTF)
            throw e;
        }
        if (!opts || opts.cellText !== false)
          try {
            if (p2.t === "e") {
              p2.w = p2.w || BErr[p2.v];
            } else if (fmtid === 0 || fmtid == "General") {
              if (p2.t === "n") {
                if ((p2.v | 0) === p2.v)
                  p2.w = p2.v.toString(10);
                else
                  p2.w = SSF_general_num(p2.v);
              } else
                p2.w = SSF_general(p2.v);
            } else
              p2.w = SSF_format(fmtid, p2.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
          } catch (e) {
            if (opts.WTF)
              throw e;
          }
        if (opts.cellDates && fmtid && p2.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
          var _d = SSF_parse_date_code(p2.v);
          if (_d) {
            p2.t = "d";
            p2.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
          }
        }
      }
      function make_cell(val, ixfe, t) {
        return { v: val, ixfe, t };
      }
      function parse_workbook(blob, options) {
        var wb = { opts: {} };
        var Sheets = {};
        var out = options.dense ? [] : {};
        var Directory = {};
        var range2 = {};
        var last_formula = null;
        var sst = [];
        var cur_sheet = "";
        var Preamble = {};
        var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
        var sharedf = {};
        var arrayf = [];
        var temp_val;
        var country;
        var XFs = [];
        var palette = [];
        var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
        var get_rgb = function getrgb(icv) {
          if (icv < 8)
            return XLSIcv[icv];
          if (icv < 64)
            return palette[icv - 8] || XLSIcv[icv];
          return XLSIcv[icv];
        };
        var process_cell_style = function pcs(cell, line, options2) {
          var xfd = line.XF.data;
          if (!xfd || !xfd.patternType || !options2 || !options2.cellStyles)
            return;
          line.s = {};
          line.s.patternType = xfd.patternType;
          var t;
          if (t = rgb2Hex(get_rgb(xfd.icvFore))) {
            line.s.fgColor = { rgb: t };
          }
          if (t = rgb2Hex(get_rgb(xfd.icvBack))) {
            line.s.bgColor = { rgb: t };
          }
        };
        var addcell = function addcell2(cell, line, options2) {
          if (file_depth > 1)
            return;
          if (options2.sheetRows && cell.r >= options2.sheetRows)
            return;
          if (options2.cellStyles && line.XF && line.XF.data)
            process_cell_style(cell, line, options2);
          delete line.ixfe;
          delete line.XF;
          lastcell = cell;
          last_cell = encode_cell(cell);
          if (!range2 || !range2.s || !range2.e)
            range2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
          if (cell.r < range2.s.r)
            range2.s.r = cell.r;
          if (cell.c < range2.s.c)
            range2.s.c = cell.c;
          if (cell.r + 1 > range2.e.r)
            range2.e.r = cell.r + 1;
          if (cell.c + 1 > range2.e.c)
            range2.e.c = cell.c + 1;
          if (options2.cellFormula && line.f) {
            for (var afi = 0; afi < arrayf.length; ++afi) {
              if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r)
                continue;
              if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r)
                continue;
              line.F = encode_range(arrayf[afi][0]);
              if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r)
                delete line.f;
              if (line.f)
                line.f = "" + stringify_formula(arrayf[afi][1], range2, cell, supbooks, opts);
              break;
            }
          }
          {
            if (options2.dense) {
              if (!out[cell.r])
                out[cell.r] = [];
              out[cell.r][cell.c] = line;
            } else
              out[last_cell] = line;
          }
        };
        var opts = {
          enc: false,
          // encrypted
          sbcch: 0,
          // cch in the preceding SupBook
          snames: [],
          // sheetnames
          sharedf,
          // shared formulae by address
          arrayf,
          // array formulae array
          rrtabid: [],
          // RRTabId
          lastuser: "",
          // Last User from WriteAccess
          biff: 8,
          // BIFF version
          codepage: 0,
          // CP from CodePage record
          winlocked: 0,
          // fLockWn from WinProtect
          cellStyles: !!options && !!options.cellStyles,
          WTF: !!options && !!options.wtf
        };
        if (options.password)
          opts.password = options.password;
        var themes;
        var merges = [];
        var objects = [];
        var colinfo = [], rowinfo = [];
        var seencol = false;
        var supbooks = [];
        supbooks.SheetNames = opts.snames;
        supbooks.sharedf = opts.sharedf;
        supbooks.arrayf = opts.arrayf;
        supbooks.names = [];
        supbooks.XTI = [];
        var last_RT = 0;
        var file_depth = 0;
        var BIFF2Fmt = 0, BIFF2FmtTable = [];
        var FilterDatabases = [];
        var last_lbl;
        opts.codepage = 1200;
        set_cp(1200);
        var seen_codepage = false;
        while (blob.l < blob.length - 1) {
          var s = blob.l;
          var RecordType = blob.read_shift(2);
          if (RecordType === 0 && last_RT === 10)
            break;
          var length = blob.l === blob.length ? 0 : blob.read_shift(2);
          var R = XLSRecordEnum[RecordType];
          if (R && R.f) {
            if (options.bookSheets) {
              if (last_RT === 133 && RecordType !== 133)
                break;
            }
            last_RT = RecordType;
            if (R.r === 2 || R.r == 12) {
              var rt = blob.read_shift(2);
              length -= 2;
              if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType)
                throw new Error("rt mismatch: " + rt + "!=" + RecordType);
              if (R.r == 12) {
                blob.l += 10;
                length -= 10;
              }
            }
            var val = {};
            if (RecordType === 10)
              val = /*::(*/
              R.f(blob, length, opts);
            else
              val = /*::(*/
              slurp(RecordType, R, blob, length, opts);
            if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1)
              continue;
            switch (RecordType) {
              case 34:
                wb.opts.Date1904 = Workbook.WBProps.date1904 = val;
                break;
              case 134:
                wb.opts.WriteProtect = true;
                break;
              case 47:
                if (!opts.enc)
                  blob.l = 0;
                opts.enc = val;
                if (!options.password)
                  throw new Error("File is password-protected");
                if (val.valid == null)
                  throw new Error("Encryption scheme unsupported");
                if (!val.valid)
                  throw new Error("Password is incorrect");
                break;
              case 92:
                opts.lastuser = val;
                break;
              case 66:
                var cpval = Number(val);
                switch (cpval) {
                  case 21010:
                    cpval = 1200;
                    break;
                  case 32768:
                    cpval = 1e4;
                    break;
                  case 32769:
                    cpval = 1252;
                    break;
                }
                set_cp(opts.codepage = cpval);
                seen_codepage = true;
                break;
              case 317:
                opts.rrtabid = val;
                break;
              case 25:
                opts.winlocked = val;
                break;
              case 439:
                wb.opts["RefreshAll"] = val;
                break;
              case 12:
                wb.opts["CalcCount"] = val;
                break;
              case 16:
                wb.opts["CalcDelta"] = val;
                break;
              case 17:
                wb.opts["CalcIter"] = val;
                break;
              case 13:
                wb.opts["CalcMode"] = val;
                break;
              case 14:
                wb.opts["CalcPrecision"] = val;
                break;
              case 95:
                wb.opts["CalcSaveRecalc"] = val;
                break;
              case 15:
                opts.CalcRefMode = val;
                break;
              case 2211:
                wb.opts.FullCalc = val;
                break;
              case 129:
                if (val.fDialog)
                  out["!type"] = "dialog";
                if (!val.fBelow)
                  (out["!outline"] || (out["!outline"] = {})).above = true;
                if (!val.fRight)
                  (out["!outline"] || (out["!outline"] = {})).left = true;
                break;
              case 224:
                XFs.push(val);
                break;
              case 430:
                supbooks.push([val]);
                supbooks[supbooks.length - 1].XTI = [];
                break;
              case 35:
              case 547:
                supbooks[supbooks.length - 1].push(val);
                break;
              case 24:
              case 536:
                last_lbl = {
                  Name: val.Name,
                  Ref: stringify_formula(val.rgce, range2, null, supbooks, opts)
                };
                if (val.itab > 0)
                  last_lbl.Sheet = val.itab - 1;
                supbooks.names.push(last_lbl);
                if (!supbooks[0]) {
                  supbooks[0] = [];
                  supbooks[0].XTI = [];
                }
                supbooks[supbooks.length - 1].push(val);
                if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) {
                  if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d")
                    FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };
                }
                break;
              case 22:
                opts.ExternCount = val;
                break;
              case 23:
                if (supbooks.length == 0) {
                  supbooks[0] = [];
                  supbooks[0].XTI = [];
                }
                supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
                supbooks.XTI = supbooks.XTI.concat(val);
                break;
              case 2196:
                if (opts.biff < 8)
                  break;
                if (last_lbl != null)
                  last_lbl.Comment = val[1];
                break;
              case 18:
                out["!protect"] = val;
                break;
              case 19:
                if (val !== 0 && opts.WTF)
                  console.error("Password verifier: " + val);
                break;
              case 133:
                {
                  Directory[val.pos] = val;
                  opts.snames.push(val.name);
                }
                break;
              case 10:
                {
                  if (--file_depth)
                    break;
                  if (range2.e) {
                    if (range2.e.r > 0 && range2.e.c > 0) {
                      range2.e.r--;
                      range2.e.c--;
                      out["!ref"] = encode_range(range2);
                      if (options.sheetRows && options.sheetRows <= range2.e.r) {
                        var tmpri = range2.e.r;
                        range2.e.r = options.sheetRows - 1;
                        out["!fullref"] = out["!ref"];
                        out["!ref"] = encode_range(range2);
                        range2.e.r = tmpri;
                      }
                      range2.e.r++;
                      range2.e.c++;
                    }
                    if (merges.length > 0)
                      out["!merges"] = merges;
                    if (objects.length > 0)
                      out["!objects"] = objects;
                    if (colinfo.length > 0)
                      out["!cols"] = colinfo;
                    if (rowinfo.length > 0)
                      out["!rows"] = rowinfo;
                    Workbook.Sheets.push(wsprops);
                  }
                  if (cur_sheet === "")
                    Preamble = out;
                  else
                    Sheets[cur_sheet] = out;
                  out = options.dense ? [] : {};
                }
                break;
              case 9:
              case 521:
              case 1033:
              case 2057:
                {
                  if (opts.biff === 8)
                    opts.biff = {
                      /*::[*/
                      9: 2,
                      /*::[*/
                      521: 3,
                      /*::[*/
                      1033: 4
                    }[RecordType] || {
                      /*::[*/
                      512: 2,
                      /*::[*/
                      768: 3,
                      /*::[*/
                      1024: 4,
                      /*::[*/
                      1280: 5,
                      /*::[*/
                      1536: 8,
                      /*::[*/
                      2: 2,
                      /*::[*/
                      7: 2
                    }[val.BIFFVer] || 8;
                  opts.biffguess = val.BIFFVer == 0;
                  if (val.BIFFVer == 0 && val.dt == 4096) {
                    opts.biff = 5;
                    seen_codepage = true;
                    set_cp(opts.codepage = 28591);
                  }
                  if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16)
                    opts.biff = 2;
                  if (file_depth++)
                    break;
                  out = options.dense ? [] : {};
                  if (opts.biff < 8 && !seen_codepage) {
                    seen_codepage = true;
                    set_cp(opts.codepage = options.codepage || 1252);
                  }
                  if (opts.biff < 5 || val.BIFFVer == 0 && val.dt == 4096) {
                    if (cur_sheet === "")
                      cur_sheet = "Sheet1";
                    range2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                    var fakebs8 = { pos: blob.l - length, name: cur_sheet };
                    Directory[fakebs8.pos] = fakebs8;
                    opts.snames.push(cur_sheet);
                  } else
                    cur_sheet = (Directory[s] || { name: "" }).name;
                  if (val.dt == 32)
                    out["!type"] = "chart";
                  if (val.dt == 64)
                    out["!type"] = "macro";
                  merges = [];
                  objects = [];
                  opts.arrayf = arrayf = [];
                  colinfo = [];
                  rowinfo = [];
                  seencol = false;
                  wsprops = { Hidden: (Directory[s] || { hs: 0 }).hs, name: cur_sheet };
                }
                break;
              case 515:
              case 3:
              case 2:
                {
                  if (out["!type"] == "chart") {
                    if (options.dense ? (out[val.r] || [])[val.c] : out[encode_cell({ c: val.c, r: val.r })])
                      ++val.c;
                  }
                  temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe] || {}, v: val.val, t: "n" };
                  if (BIFF2Fmt > 0)
                    temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                  safe_format_xf(temp_val, options, wb.opts.Date1904);
                  addcell({ c: val.c, r: val.r }, temp_val, options);
                }
                break;
              case 5:
              case 517:
                {
                  temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.val, t: val.t };
                  if (BIFF2Fmt > 0)
                    temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                  safe_format_xf(temp_val, options, wb.opts.Date1904);
                  addcell({ c: val.c, r: val.r }, temp_val, options);
                }
                break;
              case 638:
                {
                  temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.rknum, t: "n" };
                  if (BIFF2Fmt > 0)
                    temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                  safe_format_xf(temp_val, options, wb.opts.Date1904);
                  addcell({ c: val.c, r: val.r }, temp_val, options);
                }
                break;
              case 189:
                {
                  for (var j = val.c; j <= val.C; ++j) {
                    var ixfe = val.rkrec[j - val.c][0];
                    temp_val = { ixfe, XF: XFs[ixfe], v: val.rkrec[j - val.c][1], t: "n" };
                    if (BIFF2Fmt > 0)
                      temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                    safe_format_xf(temp_val, options, wb.opts.Date1904);
                    addcell({ c: j, r: val.r }, temp_val, options);
                  }
                }
                break;
              case 6:
              case 518:
              case 1030:
                {
                  if (val.val == "String") {
                    last_formula = val;
                    break;
                  }
                  temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
                  temp_val.XF = XFs[temp_val.ixfe];
                  if (options.cellFormula) {
                    var _f = val.formula;
                    if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                      var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                      var _fe = encode_cell({ r: _fr, c: _fc });
                      if (sharedf[_fe])
                        temp_val.f = "" + stringify_formula(val.formula, range2, val.cell, supbooks, opts);
                      else
                        temp_val.F = ((options.dense ? (out[_fr] || [])[_fc] : out[_fe]) || {}).F;
                    } else
                      temp_val.f = "" + stringify_formula(val.formula, range2, val.cell, supbooks, opts);
                  }
                  if (BIFF2Fmt > 0)
                    temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                  safe_format_xf(temp_val, options, wb.opts.Date1904);
                  addcell(val.cell, temp_val, options);
                  last_formula = val;
                }
                break;
              case 7:
              case 519:
                {
                  if (last_formula) {
                    last_formula.val = val;
                    temp_val = make_cell(val, last_formula.cell.ixfe, "s");
                    temp_val.XF = XFs[temp_val.ixfe];
                    if (options.cellFormula) {
                      temp_val.f = "" + stringify_formula(last_formula.formula, range2, last_formula.cell, supbooks, opts);
                    }
                    if (BIFF2Fmt > 0)
                      temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                    safe_format_xf(temp_val, options, wb.opts.Date1904);
                    addcell(last_formula.cell, temp_val, options);
                    last_formula = null;
                  } else
                    throw new Error("String record expects Formula");
                }
                break;
              case 33:
              case 545:
                {
                  arrayf.push(val);
                  var _arraystart = encode_cell(val[0].s);
                  cc = options.dense ? (out[val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
                  if (options.cellFormula && cc) {
                    if (!last_formula)
                      break;
                    if (!_arraystart || !cc)
                      break;
                    cc.f = "" + stringify_formula(val[1], range2, val[0], supbooks, opts);
                    cc.F = encode_range(val[0]);
                  }
                }
                break;
              case 1212:
                {
                  if (!options.cellFormula)
                    break;
                  if (last_cell) {
                    if (!last_formula)
                      break;
                    sharedf[encode_cell(last_formula.cell)] = val[0];
                    cc = options.dense ? (out[last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
                    (cc || {}).f = "" + stringify_formula(val[0], range2, lastcell, supbooks, opts);
                  }
                }
                break;
              case 253:
                temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
                if (sst[val.isst].h)
                  temp_val.h = sst[val.isst].h;
                temp_val.XF = XFs[temp_val.ixfe];
                if (BIFF2Fmt > 0)
                  temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                safe_format_xf(temp_val, options, wb.opts.Date1904);
                addcell({ c: val.c, r: val.r }, temp_val, options);
                break;
              case 513:
                if (options.sheetStubs) {
                  temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], t: "z" };
                  if (BIFF2Fmt > 0)
                    temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                  safe_format_xf(temp_val, options, wb.opts.Date1904);
                  addcell({ c: val.c, r: val.r }, temp_val, options);
                }
                break;
              case 190:
                if (options.sheetStubs) {
                  for (var _j = val.c; _j <= val.C; ++_j) {
                    var _ixfe = val.ixfe[_j - val.c];
                    temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
                    if (BIFF2Fmt > 0)
                      temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                    safe_format_xf(temp_val, options, wb.opts.Date1904);
                    addcell({ c: _j, r: val.r }, temp_val, options);
                  }
                }
                break;
              case 214:
              case 516:
              case 4:
                temp_val = make_cell(val.val, val.ixfe, "s");
                temp_val.XF = XFs[temp_val.ixfe];
                if (BIFF2Fmt > 0)
                  temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                safe_format_xf(temp_val, options, wb.opts.Date1904);
                addcell({ c: val.c, r: val.r }, temp_val, options);
                break;
              case 0:
              case 512:
                {
                  if (file_depth === 1)
                    range2 = val;
                }
                break;
              case 252:
                {
                  sst = val;
                }
                break;
              case 1054:
                {
                  if (opts.biff == 4) {
                    BIFF2FmtTable[BIFF2Fmt++] = val[1];
                    for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx)
                      if (table_fmt[b4idx] == val[1])
                        break;
                    if (b4idx >= 163)
                      SSF_load(val[1], BIFF2Fmt + 163);
                  } else
                    SSF_load(val[1], val[0]);
                }
                break;
              case 30:
                {
                  BIFF2FmtTable[BIFF2Fmt++] = val;
                  for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx)
                    if (table_fmt[b2idx] == val)
                      break;
                  if (b2idx >= 163)
                    SSF_load(val, BIFF2Fmt + 163);
                }
                break;
              case 229:
                merges = merges.concat(val);
                break;
              case 93:
                objects[val.cmo[0]] = opts.lastobj = val;
                break;
              case 438:
                opts.lastobj.TxO = val;
                break;
              case 127:
                opts.lastobj.ImData = val;
                break;
              case 440:
                {
                  for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
                    for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                      cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                      if (cc)
                        cc.l = val[1];
                    }
                }
                break;
              case 2048:
                {
                  for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
                    for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                      cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                      if (cc && cc.l)
                        cc.l.Tooltip = val[1];
                    }
                }
                break;
              case 28:
                {
                  if (opts.biff <= 5 && opts.biff >= 2)
                    break;
                  cc = options.dense ? (out[val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
                  var noteobj = objects[val[2]];
                  if (!cc) {
                    if (options.dense) {
                      if (!out[val[0].r])
                        out[val[0].r] = [];
                      cc = out[val[0].r][val[0].c] = { t: "z" };
                    } else {
                      cc = out[encode_cell(val[0])] = { t: "z" };
                    }
                    range2.e.r = Math.max(range2.e.r, val[0].r);
                    range2.s.r = Math.min(range2.s.r, val[0].r);
                    range2.e.c = Math.max(range2.e.c, val[0].c);
                    range2.s.c = Math.min(range2.s.c, val[0].c);
                  }
                  if (!cc.c)
                    cc.c = [];
                  cmnt = { a: val[1], t: noteobj.TxO.t };
                  cc.c.push(cmnt);
                }
                break;
              case 2173:
                update_xfext(XFs[val.ixfe], val.ext);
                break;
              case 125:
                {
                  if (!opts.cellStyles)
                    break;
                  while (val.e >= val.s) {
                    colinfo[val.e--] = { width: val.w / 256, level: val.level || 0, hidden: !!(val.flags & 1) };
                    if (!seencol) {
                      seencol = true;
                      find_mdw_colw(val.w / 256);
                    }
                    process_col(colinfo[val.e + 1]);
                  }
                }
                break;
              case 520:
                {
                  var rowobj = {};
                  if (val.level != null) {
                    rowinfo[val.r] = rowobj;
                    rowobj.level = val.level;
                  }
                  if (val.hidden) {
                    rowinfo[val.r] = rowobj;
                    rowobj.hidden = true;
                  }
                  if (val.hpt) {
                    rowinfo[val.r] = rowobj;
                    rowobj.hpt = val.hpt;
                    rowobj.hpx = pt2px(val.hpt);
                  }
                }
                break;
              case 38:
              case 39:
              case 40:
              case 41:
                if (!out["!margins"])
                  default_margins(out["!margins"] = {});
                out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val;
                break;
              case 161:
                if (!out["!margins"])
                  default_margins(out["!margins"] = {});
                out["!margins"].header = val.header;
                out["!margins"].footer = val.footer;
                break;
              case 574:
                if (val.RTL)
                  Workbook.Views[0].RTL = true;
                break;
              case 146:
                palette = val;
                break;
              case 2198:
                themes = val;
                break;
              case 140:
                country = val;
                break;
              case 442:
                {
                  if (!cur_sheet)
                    Workbook.WBProps.CodeName = val || "ThisWorkbook";
                  else
                    wsprops.CodeName = val || wsprops.name;
                }
                break;
            }
          } else {
            if (!R)
              console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
            blob.l += length;
          }
        }
        wb.SheetNames = keys(Directory).sort(function(a2, b) {
          return Number(a2) - Number(b);
        }).map(function(x) {
          return Directory[x].name;
        });
        if (!options.bookSheets)
          wb.Sheets = Sheets;
        if (!wb.SheetNames.length && Preamble["!ref"]) {
          wb.SheetNames.push("Sheet1");
          if (wb.Sheets)
            wb.Sheets["Sheet1"] = Preamble;
        } else
          wb.Preamble = Preamble;
        if (wb.Sheets)
          FilterDatabases.forEach(function(r, i) {
            wb.Sheets[wb.SheetNames[i]]["!autofilter"] = r;
          });
        wb.Strings = sst;
        wb.SSF = dup(table_fmt);
        if (opts.enc)
          wb.Encryption = opts.enc;
        if (themes)
          wb.Themes = themes;
        wb.Metadata = {};
        if (country !== void 0)
          wb.Metadata.Country = country;
        if (supbooks.names.length > 0)
          Workbook.Names = supbooks.names;
        wb.Workbook = Workbook;
        return wb;
      }
      var PSCLSID = {
        SI: "e0859ff2f94f6810ab9108002b27b3d9",
        DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
        UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
      };
      function parse_xls_props(cfb, props, o) {
        var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
        if (DSI && DSI.size > 0)
          try {
            var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
            for (var d in DocSummary)
              props[d] = DocSummary[d];
          } catch (e) {
            if (o.WTF)
              throw e;
          }
        var SI = CFB.find(cfb, "/!SummaryInformation");
        if (SI && SI.size > 0)
          try {
            var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
            for (var s in Summary)
              if (props[s] == null)
                props[s] = Summary[s];
          } catch (e) {
            if (o.WTF)
              throw e;
          }
        if (props.HeadingPairs && props.TitlesOfParts) {
          load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);
          delete props.HeadingPairs;
          delete props.TitlesOfParts;
        }
      }
      function parse_xlscfb(cfb, options) {
        if (!options)
          options = {};
        fix_read_opts(options);
        reset_cp();
        if (options.codepage)
          set_ansi(options.codepage);
        var CompObj, WB;
        if (cfb.FullPaths) {
          if (CFB.find(cfb, "/encryption"))
            throw new Error("File is password-protected");
          CompObj = CFB.find(cfb, "!CompObj");
          WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
        } else {
          switch (options.type) {
            case "base64":
              cfb = s2a(Base64_decode(cfb));
              break;
            case "binary":
              cfb = s2a(cfb);
              break;
            case "buffer":
              break;
            case "array":
              if (!Array.isArray(cfb))
                cfb = Array.prototype.slice.call(cfb);
              break;
          }
          prep_blob(cfb, 0);
          WB = { content: cfb };
        }
        var WorkbookP;
        var _data;
        if (CompObj)
          parse_compobj(CompObj);
        if (options.bookProps && !options.bookSheets)
          WorkbookP = {};
        else {
          var T = has_buf ? "buffer" : "array";
          if (WB && WB.content)
            WorkbookP = parse_workbook(WB.content, options);
          else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content)
            WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
          else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content)
            WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
          else if ((_data = CFB.find(cfb, "MN0")) && _data.content)
            throw new Error("Unsupported Works 4 for Mac file");
          else
            throw new Error("Cannot find Workbook stream");
          if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir"))
            WorkbookP.vbaraw = make_vba_xls(cfb);
        }
        var props = {};
        if (cfb.FullPaths)
          parse_xls_props(
            /*::((*/
            cfb,
            props,
            options
          );
        WorkbookP.Props = WorkbookP.Custprops = props;
        if (options.bookFiles)
          WorkbookP.cfb = cfb;
        return WorkbookP;
      }
      var XLSBRecordEnum = {
        /*::[*/
        0: {
          /* n:"BrtRowHdr", */
          f: parse_BrtRowHdr
        },
        /*::[*/
        1: {
          /* n:"BrtCellBlank", */
          f: parse_BrtCellBlank
        },
        /*::[*/
        2: {
          /* n:"BrtCellRk", */
          f: parse_BrtCellRk
        },
        /*::[*/
        3: {
          /* n:"BrtCellError", */
          f: parse_BrtCellError
        },
        /*::[*/
        4: {
          /* n:"BrtCellBool", */
          f: parse_BrtCellBool
        },
        /*::[*/
        5: {
          /* n:"BrtCellReal", */
          f: parse_BrtCellReal
        },
        /*::[*/
        6: {
          /* n:"BrtCellSt", */
          f: parse_BrtCellSt
        },
        /*::[*/
        7: {
          /* n:"BrtCellIsst", */
          f: parse_BrtCellIsst
        },
        /*::[*/
        8: {
          /* n:"BrtFmlaString", */
          f: parse_BrtFmlaString
        },
        /*::[*/
        9: {
          /* n:"BrtFmlaNum", */
          f: parse_BrtFmlaNum
        },
        /*::[*/
        10: {
          /* n:"BrtFmlaBool", */
          f: parse_BrtFmlaBool
        },
        /*::[*/
        11: {
          /* n:"BrtFmlaError", */
          f: parse_BrtFmlaError
        },
        /*::[*/
        12: {
          /* n:"BrtShortBlank", */
          f: parse_BrtShortBlank
        },
        /*::[*/
        13: {
          /* n:"BrtShortRk", */
          f: parse_BrtShortRk
        },
        /*::[*/
        14: {
          /* n:"BrtShortError", */
          f: parse_BrtShortError
        },
        /*::[*/
        15: {
          /* n:"BrtShortBool", */
          f: parse_BrtShortBool
        },
        /*::[*/
        16: {
          /* n:"BrtShortReal", */
          f: parse_BrtShortReal
        },
        /*::[*/
        17: {
          /* n:"BrtShortSt", */
          f: parse_BrtShortSt
        },
        /*::[*/
        18: {
          /* n:"BrtShortIsst", */
          f: parse_BrtShortIsst
        },
        /*::[*/
        19: {
          /* n:"BrtSSTItem", */
          f: parse_RichStr
        },
        /*::[*/
        20: {
          /* n:"BrtPCDIMissing" */
        },
        /*::[*/
        21: {
          /* n:"BrtPCDINumber" */
        },
        /*::[*/
        22: {
          /* n:"BrtPCDIBoolean" */
        },
        /*::[*/
        23: {
          /* n:"BrtPCDIError" */
        },
        /*::[*/
        24: {
          /* n:"BrtPCDIString" */
        },
        /*::[*/
        25: {
          /* n:"BrtPCDIDatetime" */
        },
        /*::[*/
        26: {
          /* n:"BrtPCDIIndex" */
        },
        /*::[*/
        27: {
          /* n:"BrtPCDIAMissing" */
        },
        /*::[*/
        28: {
          /* n:"BrtPCDIANumber" */
        },
        /*::[*/
        29: {
          /* n:"BrtPCDIABoolean" */
        },
        /*::[*/
        30: {
          /* n:"BrtPCDIAError" */
        },
        /*::[*/
        31: {
          /* n:"BrtPCDIAString" */
        },
        /*::[*/
        32: {
          /* n:"BrtPCDIADatetime" */
        },
        /*::[*/
        33: {
          /* n:"BrtPCRRecord" */
        },
        /*::[*/
        34: {
          /* n:"BrtPCRRecordDt" */
        },
        /*::[*/
        35: {
          /* n:"BrtFRTBegin", */
          T: 1
        },
        /*::[*/
        36: {
          /* n:"BrtFRTEnd", */
          T: -1
        },
        /*::[*/
        37: {
          /* n:"BrtACBegin", */
          T: 1
        },
        /*::[*/
        38: {
          /* n:"BrtACEnd", */
          T: -1
        },
        /*::[*/
        39: {
          /* n:"BrtName", */
          f: parse_BrtName
        },
        /*::[*/
        40: {
          /* n:"BrtIndexRowBlock" */
        },
        /*::[*/
        42: {
          /* n:"BrtIndexBlock" */
        },
        /*::[*/
        43: {
          /* n:"BrtFont", */
          f: parse_BrtFont
        },
        /*::[*/
        44: {
          /* n:"BrtFmt", */
          f: parse_BrtFmt
        },
        /*::[*/
        45: {
          /* n:"BrtFill", */
          f: parse_BrtFill
        },
        /*::[*/
        46: {
          /* n:"BrtBorder", */
          f: parse_BrtBorder
        },
        /*::[*/
        47: {
          /* n:"BrtXF", */
          f: parse_BrtXF
        },
        /*::[*/
        48: {
          /* n:"BrtStyle" */
        },
        /*::[*/
        49: {
          /* n:"BrtCellMeta", */
          f: parse_Int32LE
        },
        /*::[*/
        50: {
          /* n:"BrtValueMeta" */
        },
        /*::[*/
        51: {
          /* n:"BrtMdb" */
          f: parse_BrtMdb
        },
        /*::[*/
        52: {
          /* n:"BrtBeginFmd", */
          T: 1
        },
        /*::[*/
        53: {
          /* n:"BrtEndFmd", */
          T: -1
        },
        /*::[*/
        54: {
          /* n:"BrtBeginMdx", */
          T: 1
        },
        /*::[*/
        55: {
          /* n:"BrtEndMdx", */
          T: -1
        },
        /*::[*/
        56: {
          /* n:"BrtBeginMdxTuple", */
          T: 1
        },
        /*::[*/
        57: {
          /* n:"BrtEndMdxTuple", */
          T: -1
        },
        /*::[*/
        58: {
          /* n:"BrtMdxMbrIstr" */
        },
        /*::[*/
        59: {
          /* n:"BrtStr" */
        },
        /*::[*/
        60: {
          /* n:"BrtColInfo", */
          f: parse_ColInfo
        },
        /*::[*/
        62: {
          /* n:"BrtCellRString", */
          f: parse_BrtCellRString
        },
        /*::[*/
        63: {
          /* n:"BrtCalcChainItem$", */
          f: parse_BrtCalcChainItem$
        },
        /*::[*/
        64: {
          /* n:"BrtDVal", */
          f: parse_BrtDVal
        },
        /*::[*/
        65: {
          /* n:"BrtSxvcellNum" */
        },
        /*::[*/
        66: {
          /* n:"BrtSxvcellStr" */
        },
        /*::[*/
        67: {
          /* n:"BrtSxvcellBool" */
        },
        /*::[*/
        68: {
          /* n:"BrtSxvcellErr" */
        },
        /*::[*/
        69: {
          /* n:"BrtSxvcellDate" */
        },
        /*::[*/
        70: {
          /* n:"BrtSxvcellNil" */
        },
        /*::[*/
        128: {
          /* n:"BrtFileVersion" */
        },
        /*::[*/
        129: {
          /* n:"BrtBeginSheet", */
          T: 1
        },
        /*::[*/
        130: {
          /* n:"BrtEndSheet", */
          T: -1
        },
        /*::[*/
        131: {
          /* n:"BrtBeginBook", */
          T: 1,
          f: parsenoop,
          p: 0
        },
        /*::[*/
        132: {
          /* n:"BrtEndBook", */
          T: -1
        },
        /*::[*/
        133: {
          /* n:"BrtBeginWsViews", */
          T: 1
        },
        /*::[*/
        134: {
          /* n:"BrtEndWsViews", */
          T: -1
        },
        /*::[*/
        135: {
          /* n:"BrtBeginBookViews", */
          T: 1
        },
        /*::[*/
        136: {
          /* n:"BrtEndBookViews", */
          T: -1
        },
        /*::[*/
        137: {
          /* n:"BrtBeginWsView", */
          T: 1,
          f: parse_BrtBeginWsView
        },
        /*::[*/
        138: {
          /* n:"BrtEndWsView", */
          T: -1
        },
        /*::[*/
        139: {
          /* n:"BrtBeginCsViews", */
          T: 1
        },
        /*::[*/
        140: {
          /* n:"BrtEndCsViews", */
          T: -1
        },
        /*::[*/
        141: {
          /* n:"BrtBeginCsView", */
          T: 1
        },
        /*::[*/
        142: {
          /* n:"BrtEndCsView", */
          T: -1
        },
        /*::[*/
        143: {
          /* n:"BrtBeginBundleShs", */
          T: 1
        },
        /*::[*/
        144: {
          /* n:"BrtEndBundleShs", */
          T: -1
        },
        /*::[*/
        145: {
          /* n:"BrtBeginSheetData", */
          T: 1
        },
        /*::[*/
        146: {
          /* n:"BrtEndSheetData", */
          T: -1
        },
        /*::[*/
        147: {
          /* n:"BrtWsProp", */
          f: parse_BrtWsProp
        },
        /*::[*/
        148: {
          /* n:"BrtWsDim", */
          f: parse_BrtWsDim,
          p: 16
        },
        /*::[*/
        151: {
          /* n:"BrtPane", */
          f: parse_BrtPane
        },
        /*::[*/
        152: {
          /* n:"BrtSel" */
        },
        /*::[*/
        153: {
          /* n:"BrtWbProp", */
          f: parse_BrtWbProp
        },
        /*::[*/
        154: {
          /* n:"BrtWbFactoid" */
        },
        /*::[*/
        155: {
          /* n:"BrtFileRecover" */
        },
        /*::[*/
        156: {
          /* n:"BrtBundleSh", */
          f: parse_BrtBundleSh
        },
        /*::[*/
        157: {
          /* n:"BrtCalcProp" */
        },
        /*::[*/
        158: {
          /* n:"BrtBookView" */
        },
        /*::[*/
        159: {
          /* n:"BrtBeginSst", */
          T: 1,
          f: parse_BrtBeginSst
        },
        /*::[*/
        160: {
          /* n:"BrtEndSst", */
          T: -1
        },
        /*::[*/
        161: {
          /* n:"BrtBeginAFilter", */
          T: 1,
          f: parse_UncheckedRfX
        },
        /*::[*/
        162: {
          /* n:"BrtEndAFilter", */
          T: -1
        },
        /*::[*/
        163: {
          /* n:"BrtBeginFilterColumn", */
          T: 1
        },
        /*::[*/
        164: {
          /* n:"BrtEndFilterColumn", */
          T: -1
        },
        /*::[*/
        165: {
          /* n:"BrtBeginFilters", */
          T: 1
        },
        /*::[*/
        166: {
          /* n:"BrtEndFilters", */
          T: -1
        },
        /*::[*/
        167: {
          /* n:"BrtFilter" */
        },
        /*::[*/
        168: {
          /* n:"BrtColorFilter" */
        },
        /*::[*/
        169: {
          /* n:"BrtIconFilter" */
        },
        /*::[*/
        170: {
          /* n:"BrtTop10Filter" */
        },
        /*::[*/
        171: {
          /* n:"BrtDynamicFilter" */
        },
        /*::[*/
        172: {
          /* n:"BrtBeginCustomFilters", */
          T: 1
        },
        /*::[*/
        173: {
          /* n:"BrtEndCustomFilters", */
          T: -1
        },
        /*::[*/
        174: {
          /* n:"BrtCustomFilter" */
        },
        /*::[*/
        175: {
          /* n:"BrtAFilterDateGroupItem" */
        },
        /*::[*/
        176: {
          /* n:"BrtMergeCell", */
          f: parse_BrtMergeCell
        },
        /*::[*/
        177: {
          /* n:"BrtBeginMergeCells", */
          T: 1
        },
        /*::[*/
        178: {
          /* n:"BrtEndMergeCells", */
          T: -1
        },
        /*::[*/
        179: {
          /* n:"BrtBeginPivotCacheDef", */
          T: 1
        },
        /*::[*/
        180: {
          /* n:"BrtEndPivotCacheDef", */
          T: -1
        },
        /*::[*/
        181: {
          /* n:"BrtBeginPCDFields", */
          T: 1
        },
        /*::[*/
        182: {
          /* n:"BrtEndPCDFields", */
          T: -1
        },
        /*::[*/
        183: {
          /* n:"BrtBeginPCDField", */
          T: 1
        },
        /*::[*/
        184: {
          /* n:"BrtEndPCDField", */
          T: -1
        },
        /*::[*/
        185: {
          /* n:"BrtBeginPCDSource", */
          T: 1
        },
        /*::[*/
        186: {
          /* n:"BrtEndPCDSource", */
          T: -1
        },
        /*::[*/
        187: {
          /* n:"BrtBeginPCDSRange", */
          T: 1
        },
        /*::[*/
        188: {
          /* n:"BrtEndPCDSRange", */
          T: -1
        },
        /*::[*/
        189: {
          /* n:"BrtBeginPCDFAtbl", */
          T: 1
        },
        /*::[*/
        190: {
          /* n:"BrtEndPCDFAtbl", */
          T: -1
        },
        /*::[*/
        191: {
          /* n:"BrtBeginPCDIRun", */
          T: 1
        },
        /*::[*/
        192: {
          /* n:"BrtEndPCDIRun", */
          T: -1
        },
        /*::[*/
        193: {
          /* n:"BrtBeginPivotCacheRecords", */
          T: 1
        },
        /*::[*/
        194: {
          /* n:"BrtEndPivotCacheRecords", */
          T: -1
        },
        /*::[*/
        195: {
          /* n:"BrtBeginPCDHierarchies", */
          T: 1
        },
        /*::[*/
        196: {
          /* n:"BrtEndPCDHierarchies", */
          T: -1
        },
        /*::[*/
        197: {
          /* n:"BrtBeginPCDHierarchy", */
          T: 1
        },
        /*::[*/
        198: {
          /* n:"BrtEndPCDHierarchy", */
          T: -1
        },
        /*::[*/
        199: {
          /* n:"BrtBeginPCDHFieldsUsage", */
          T: 1
        },
        /*::[*/
        200: {
          /* n:"BrtEndPCDHFieldsUsage", */
          T: -1
        },
        /*::[*/
        201: {
          /* n:"BrtBeginExtConnection", */
          T: 1
        },
        /*::[*/
        202: {
          /* n:"BrtEndExtConnection", */
          T: -1
        },
        /*::[*/
        203: {
          /* n:"BrtBeginECDbProps", */
          T: 1
        },
        /*::[*/
        204: {
          /* n:"BrtEndECDbProps", */
          T: -1
        },
        /*::[*/
        205: {
          /* n:"BrtBeginECOlapProps", */
          T: 1
        },
        /*::[*/
        206: {
          /* n:"BrtEndECOlapProps", */
          T: -1
        },
        /*::[*/
        207: {
          /* n:"BrtBeginPCDSConsol", */
          T: 1
        },
        /*::[*/
        208: {
          /* n:"BrtEndPCDSConsol", */
          T: -1
        },
        /*::[*/
        209: {
          /* n:"BrtBeginPCDSCPages", */
          T: 1
        },
        /*::[*/
        210: {
          /* n:"BrtEndPCDSCPages", */
          T: -1
        },
        /*::[*/
        211: {
          /* n:"BrtBeginPCDSCPage", */
          T: 1
        },
        /*::[*/
        212: {
          /* n:"BrtEndPCDSCPage", */
          T: -1
        },
        /*::[*/
        213: {
          /* n:"BrtBeginPCDSCPItem", */
          T: 1
        },
        /*::[*/
        214: {
          /* n:"BrtEndPCDSCPItem", */
          T: -1
        },
        /*::[*/
        215: {
          /* n:"BrtBeginPCDSCSets", */
          T: 1
        },
        /*::[*/
        216: {
          /* n:"BrtEndPCDSCSets", */
          T: -1
        },
        /*::[*/
        217: {
          /* n:"BrtBeginPCDSCSet", */
          T: 1
        },
        /*::[*/
        218: {
          /* n:"BrtEndPCDSCSet", */
          T: -1
        },
        /*::[*/
        219: {
          /* n:"BrtBeginPCDFGroup", */
          T: 1
        },
        /*::[*/
        220: {
          /* n:"BrtEndPCDFGroup", */
          T: -1
        },
        /*::[*/
        221: {
          /* n:"BrtBeginPCDFGItems", */
          T: 1
        },
        /*::[*/
        222: {
          /* n:"BrtEndPCDFGItems", */
          T: -1
        },
        /*::[*/
        223: {
          /* n:"BrtBeginPCDFGRange", */
          T: 1
        },
        /*::[*/
        224: {
          /* n:"BrtEndPCDFGRange", */
          T: -1
        },
        /*::[*/
        225: {
          /* n:"BrtBeginPCDFGDiscrete", */
          T: 1
        },
        /*::[*/
        226: {
          /* n:"BrtEndPCDFGDiscrete", */
          T: -1
        },
        /*::[*/
        227: {
          /* n:"BrtBeginPCDSDTupleCache", */
          T: 1
        },
        /*::[*/
        228: {
          /* n:"BrtEndPCDSDTupleCache", */
          T: -1
        },
        /*::[*/
        229: {
          /* n:"BrtBeginPCDSDTCEntries", */
          T: 1
        },
        /*::[*/
        230: {
          /* n:"BrtEndPCDSDTCEntries", */
          T: -1
        },
        /*::[*/
        231: {
          /* n:"BrtBeginPCDSDTCEMembers", */
          T: 1
        },
        /*::[*/
        232: {
          /* n:"BrtEndPCDSDTCEMembers", */
          T: -1
        },
        /*::[*/
        233: {
          /* n:"BrtBeginPCDSDTCEMember", */
          T: 1
        },
        /*::[*/
        234: {
          /* n:"BrtEndPCDSDTCEMember", */
          T: -1
        },
        /*::[*/
        235: {
          /* n:"BrtBeginPCDSDTCQueries", */
          T: 1
        },
        /*::[*/
        236: {
          /* n:"BrtEndPCDSDTCQueries", */
          T: -1
        },
        /*::[*/
        237: {
          /* n:"BrtBeginPCDSDTCQuery", */
          T: 1
        },
        /*::[*/
        238: {
          /* n:"BrtEndPCDSDTCQuery", */
          T: -1
        },
        /*::[*/
        239: {
          /* n:"BrtBeginPCDSDTCSets", */
          T: 1
        },
        /*::[*/
        240: {
          /* n:"BrtEndPCDSDTCSets", */
          T: -1
        },
        /*::[*/
        241: {
          /* n:"BrtBeginPCDSDTCSet", */
          T: 1
        },
        /*::[*/
        242: {
          /* n:"BrtEndPCDSDTCSet", */
          T: -1
        },
        /*::[*/
        243: {
          /* n:"BrtBeginPCDCalcItems", */
          T: 1
        },
        /*::[*/
        244: {
          /* n:"BrtEndPCDCalcItems", */
          T: -1
        },
        /*::[*/
        245: {
          /* n:"BrtBeginPCDCalcItem", */
          T: 1
        },
        /*::[*/
        246: {
          /* n:"BrtEndPCDCalcItem", */
          T: -1
        },
        /*::[*/
        247: {
          /* n:"BrtBeginPRule", */
          T: 1
        },
        /*::[*/
        248: {
          /* n:"BrtEndPRule", */
          T: -1
        },
        /*::[*/
        249: {
          /* n:"BrtBeginPRFilters", */
          T: 1
        },
        /*::[*/
        250: {
          /* n:"BrtEndPRFilters", */
          T: -1
        },
        /*::[*/
        251: {
          /* n:"BrtBeginPRFilter", */
          T: 1
        },
        /*::[*/
        252: {
          /* n:"BrtEndPRFilter", */
          T: -1
        },
        /*::[*/
        253: {
          /* n:"BrtBeginPNames", */
          T: 1
        },
        /*::[*/
        254: {
          /* n:"BrtEndPNames", */
          T: -1
        },
        /*::[*/
        255: {
          /* n:"BrtBeginPName", */
          T: 1
        },
        /*::[*/
        256: {
          /* n:"BrtEndPName", */
          T: -1
        },
        /*::[*/
        257: {
          /* n:"BrtBeginPNPairs", */
          T: 1
        },
        /*::[*/
        258: {
          /* n:"BrtEndPNPairs", */
          T: -1
        },
        /*::[*/
        259: {
          /* n:"BrtBeginPNPair", */
          T: 1
        },
        /*::[*/
        260: {
          /* n:"BrtEndPNPair", */
          T: -1
        },
        /*::[*/
        261: {
          /* n:"BrtBeginECWebProps", */
          T: 1
        },
        /*::[*/
        262: {
          /* n:"BrtEndECWebProps", */
          T: -1
        },
        /*::[*/
        263: {
          /* n:"BrtBeginEcWpTables", */
          T: 1
        },
        /*::[*/
        264: {
          /* n:"BrtEndECWPTables", */
          T: -1
        },
        /*::[*/
        265: {
          /* n:"BrtBeginECParams", */
          T: 1
        },
        /*::[*/
        266: {
          /* n:"BrtEndECParams", */
          T: -1
        },
        /*::[*/
        267: {
          /* n:"BrtBeginECParam", */
          T: 1
        },
        /*::[*/
        268: {
          /* n:"BrtEndECParam", */
          T: -1
        },
        /*::[*/
        269: {
          /* n:"BrtBeginPCDKPIs", */
          T: 1
        },
        /*::[*/
        270: {
          /* n:"BrtEndPCDKPIs", */
          T: -1
        },
        /*::[*/
        271: {
          /* n:"BrtBeginPCDKPI", */
          T: 1
        },
        /*::[*/
        272: {
          /* n:"BrtEndPCDKPI", */
          T: -1
        },
        /*::[*/
        273: {
          /* n:"BrtBeginDims", */
          T: 1
        },
        /*::[*/
        274: {
          /* n:"BrtEndDims", */
          T: -1
        },
        /*::[*/
        275: {
          /* n:"BrtBeginDim", */
          T: 1
        },
        /*::[*/
        276: {
          /* n:"BrtEndDim", */
          T: -1
        },
        /*::[*/
        277: {
          /* n:"BrtIndexPartEnd" */
        },
        /*::[*/
        278: {
          /* n:"BrtBeginStyleSheet", */
          T: 1
        },
        /*::[*/
        279: {
          /* n:"BrtEndStyleSheet", */
          T: -1
        },
        /*::[*/
        280: {
          /* n:"BrtBeginSXView", */
          T: 1
        },
        /*::[*/
        281: {
          /* n:"BrtEndSXVI", */
          T: -1
        },
        /*::[*/
        282: {
          /* n:"BrtBeginSXVI", */
          T: 1
        },
        /*::[*/
        283: {
          /* n:"BrtBeginSXVIs", */
          T: 1
        },
        /*::[*/
        284: {
          /* n:"BrtEndSXVIs", */
          T: -1
        },
        /*::[*/
        285: {
          /* n:"BrtBeginSXVD", */
          T: 1
        },
        /*::[*/
        286: {
          /* n:"BrtEndSXVD", */
          T: -1
        },
        /*::[*/
        287: {
          /* n:"BrtBeginSXVDs", */
          T: 1
        },
        /*::[*/
        288: {
          /* n:"BrtEndSXVDs", */
          T: -1
        },
        /*::[*/
        289: {
          /* n:"BrtBeginSXPI", */
          T: 1
        },
        /*::[*/
        290: {
          /* n:"BrtEndSXPI", */
          T: -1
        },
        /*::[*/
        291: {
          /* n:"BrtBeginSXPIs", */
          T: 1
        },
        /*::[*/
        292: {
          /* n:"BrtEndSXPIs", */
          T: -1
        },
        /*::[*/
        293: {
          /* n:"BrtBeginSXDI", */
          T: 1
        },
        /*::[*/
        294: {
          /* n:"BrtEndSXDI", */
          T: -1
        },
        /*::[*/
        295: {
          /* n:"BrtBeginSXDIs", */
          T: 1
        },
        /*::[*/
        296: {
          /* n:"BrtEndSXDIs", */
          T: -1
        },
        /*::[*/
        297: {
          /* n:"BrtBeginSXLI", */
          T: 1
        },
        /*::[*/
        298: {
          /* n:"BrtEndSXLI", */
          T: -1
        },
        /*::[*/
        299: {
          /* n:"BrtBeginSXLIRws", */
          T: 1
        },
        /*::[*/
        300: {
          /* n:"BrtEndSXLIRws", */
          T: -1
        },
        /*::[*/
        301: {
          /* n:"BrtBeginSXLICols", */
          T: 1
        },
        /*::[*/
        302: {
          /* n:"BrtEndSXLICols", */
          T: -1
        },
        /*::[*/
        303: {
          /* n:"BrtBeginSXFormat", */
          T: 1
        },
        /*::[*/
        304: {
          /* n:"BrtEndSXFormat", */
          T: -1
        },
        /*::[*/
        305: {
          /* n:"BrtBeginSXFormats", */
          T: 1
        },
        /*::[*/
        306: {
          /* n:"BrtEndSxFormats", */
          T: -1
        },
        /*::[*/
        307: {
          /* n:"BrtBeginSxSelect", */
          T: 1
        },
        /*::[*/
        308: {
          /* n:"BrtEndSxSelect", */
          T: -1
        },
        /*::[*/
        309: {
          /* n:"BrtBeginISXVDRws", */
          T: 1
        },
        /*::[*/
        310: {
          /* n:"BrtEndISXVDRws", */
          T: -1
        },
        /*::[*/
        311: {
          /* n:"BrtBeginISXVDCols", */
          T: 1
        },
        /*::[*/
        312: {
          /* n:"BrtEndISXVDCols", */
          T: -1
        },
        /*::[*/
        313: {
          /* n:"BrtEndSXLocation", */
          T: -1
        },
        /*::[*/
        314: {
          /* n:"BrtBeginSXLocation", */
          T: 1
        },
        /*::[*/
        315: {
          /* n:"BrtEndSXView", */
          T: -1
        },
        /*::[*/
        316: {
          /* n:"BrtBeginSXTHs", */
          T: 1
        },
        /*::[*/
        317: {
          /* n:"BrtEndSXTHs", */
          T: -1
        },
        /*::[*/
        318: {
          /* n:"BrtBeginSXTH", */
          T: 1
        },
        /*::[*/
        319: {
          /* n:"BrtEndSXTH", */
          T: -1
        },
        /*::[*/
        320: {
          /* n:"BrtBeginISXTHRws", */
          T: 1
        },
        /*::[*/
        321: {
          /* n:"BrtEndISXTHRws", */
          T: -1
        },
        /*::[*/
        322: {
          /* n:"BrtBeginISXTHCols", */
          T: 1
        },
        /*::[*/
        323: {
          /* n:"BrtEndISXTHCols", */
          T: -1
        },
        /*::[*/
        324: {
          /* n:"BrtBeginSXTDMPS", */
          T: 1
        },
        /*::[*/
        325: {
          /* n:"BrtEndSXTDMPs", */
          T: -1
        },
        /*::[*/
        326: {
          /* n:"BrtBeginSXTDMP", */
          T: 1
        },
        /*::[*/
        327: {
          /* n:"BrtEndSXTDMP", */
          T: -1
        },
        /*::[*/
        328: {
          /* n:"BrtBeginSXTHItems", */
          T: 1
        },
        /*::[*/
        329: {
          /* n:"BrtEndSXTHItems", */
          T: -1
        },
        /*::[*/
        330: {
          /* n:"BrtBeginSXTHItem", */
          T: 1
        },
        /*::[*/
        331: {
          /* n:"BrtEndSXTHItem", */
          T: -1
        },
        /*::[*/
        332: {
          /* n:"BrtBeginMetadata", */
          T: 1
        },
        /*::[*/
        333: {
          /* n:"BrtEndMetadata", */
          T: -1
        },
        /*::[*/
        334: {
          /* n:"BrtBeginEsmdtinfo", */
          T: 1
        },
        /*::[*/
        335: {
          /* n:"BrtMdtinfo", */
          f: parse_BrtMdtinfo
        },
        /*::[*/
        336: {
          /* n:"BrtEndEsmdtinfo", */
          T: -1
        },
        /*::[*/
        337: {
          /* n:"BrtBeginEsmdb", */
          f: parse_BrtBeginEsmdb,
          T: 1
        },
        /*::[*/
        338: {
          /* n:"BrtEndEsmdb", */
          T: -1
        },
        /*::[*/
        339: {
          /* n:"BrtBeginEsfmd", */
          T: 1
        },
        /*::[*/
        340: {
          /* n:"BrtEndEsfmd", */
          T: -1
        },
        /*::[*/
        341: {
          /* n:"BrtBeginSingleCells", */
          T: 1
        },
        /*::[*/
        342: {
          /* n:"BrtEndSingleCells", */
          T: -1
        },
        /*::[*/
        343: {
          /* n:"BrtBeginList", */
          T: 1
        },
        /*::[*/
        344: {
          /* n:"BrtEndList", */
          T: -1
        },
        /*::[*/
        345: {
          /* n:"BrtBeginListCols", */
          T: 1
        },
        /*::[*/
        346: {
          /* n:"BrtEndListCols", */
          T: -1
        },
        /*::[*/
        347: {
          /* n:"BrtBeginListCol", */
          T: 1
        },
        /*::[*/
        348: {
          /* n:"BrtEndListCol", */
          T: -1
        },
        /*::[*/
        349: {
          /* n:"BrtBeginListXmlCPr", */
          T: 1
        },
        /*::[*/
        350: {
          /* n:"BrtEndListXmlCPr", */
          T: -1
        },
        /*::[*/
        351: {
          /* n:"BrtListCCFmla" */
        },
        /*::[*/
        352: {
          /* n:"BrtListTrFmla" */
        },
        /*::[*/
        353: {
          /* n:"BrtBeginExternals", */
          T: 1
        },
        /*::[*/
        354: {
          /* n:"BrtEndExternals", */
          T: -1
        },
        /*::[*/
        355: {
          /* n:"BrtSupBookSrc", */
          f: parse_RelID
        },
        /*::[*/
        357: {
          /* n:"BrtSupSelf" */
        },
        /*::[*/
        358: {
          /* n:"BrtSupSame" */
        },
        /*::[*/
        359: {
          /* n:"BrtSupTabs" */
        },
        /*::[*/
        360: {
          /* n:"BrtBeginSupBook", */
          T: 1
        },
        /*::[*/
        361: {
          /* n:"BrtPlaceholderName" */
        },
        /*::[*/
        362: {
          /* n:"BrtExternSheet", */
          f: parse_ExternSheet
        },
        /*::[*/
        363: {
          /* n:"BrtExternTableStart" */
        },
        /*::[*/
        364: {
          /* n:"BrtExternTableEnd" */
        },
        /*::[*/
        366: {
          /* n:"BrtExternRowHdr" */
        },
        /*::[*/
        367: {
          /* n:"BrtExternCellBlank" */
        },
        /*::[*/
        368: {
          /* n:"BrtExternCellReal" */
        },
        /*::[*/
        369: {
          /* n:"BrtExternCellBool" */
        },
        /*::[*/
        370: {
          /* n:"BrtExternCellError" */
        },
        /*::[*/
        371: {
          /* n:"BrtExternCellString" */
        },
        /*::[*/
        372: {
          /* n:"BrtBeginEsmdx", */
          T: 1
        },
        /*::[*/
        373: {
          /* n:"BrtEndEsmdx", */
          T: -1
        },
        /*::[*/
        374: {
          /* n:"BrtBeginMdxSet", */
          T: 1
        },
        /*::[*/
        375: {
          /* n:"BrtEndMdxSet", */
          T: -1
        },
        /*::[*/
        376: {
          /* n:"BrtBeginMdxMbrProp", */
          T: 1
        },
        /*::[*/
        377: {
          /* n:"BrtEndMdxMbrProp", */
          T: -1
        },
        /*::[*/
        378: {
          /* n:"BrtBeginMdxKPI", */
          T: 1
        },
        /*::[*/
        379: {
          /* n:"BrtEndMdxKPI", */
          T: -1
        },
        /*::[*/
        380: {
          /* n:"BrtBeginEsstr", */
          T: 1
        },
        /*::[*/
        381: {
          /* n:"BrtEndEsstr", */
          T: -1
        },
        /*::[*/
        382: {
          /* n:"BrtBeginPRFItem", */
          T: 1
        },
        /*::[*/
        383: {
          /* n:"BrtEndPRFItem", */
          T: -1
        },
        /*::[*/
        384: {
          /* n:"BrtBeginPivotCacheIDs", */
          T: 1
        },
        /*::[*/
        385: {
          /* n:"BrtEndPivotCacheIDs", */
          T: -1
        },
        /*::[*/
        386: {
          /* n:"BrtBeginPivotCacheID", */
          T: 1
        },
        /*::[*/
        387: {
          /* n:"BrtEndPivotCacheID", */
          T: -1
        },
        /*::[*/
        388: {
          /* n:"BrtBeginISXVIs", */
          T: 1
        },
        /*::[*/
        389: {
          /* n:"BrtEndISXVIs", */
          T: -1
        },
        /*::[*/
        390: {
          /* n:"BrtBeginColInfos", */
          T: 1
        },
        /*::[*/
        391: {
          /* n:"BrtEndColInfos", */
          T: -1
        },
        /*::[*/
        392: {
          /* n:"BrtBeginRwBrk", */
          T: 1
        },
        /*::[*/
        393: {
          /* n:"BrtEndRwBrk", */
          T: -1
        },
        /*::[*/
        394: {
          /* n:"BrtBeginColBrk", */
          T: 1
        },
        /*::[*/
        395: {
          /* n:"BrtEndColBrk", */
          T: -1
        },
        /*::[*/
        396: {
          /* n:"BrtBrk" */
        },
        /*::[*/
        397: {
          /* n:"BrtUserBookView" */
        },
        /*::[*/
        398: {
          /* n:"BrtInfo" */
        },
        /*::[*/
        399: {
          /* n:"BrtCUsr" */
        },
        /*::[*/
        400: {
          /* n:"BrtUsr" */
        },
        /*::[*/
        401: {
          /* n:"BrtBeginUsers", */
          T: 1
        },
        /*::[*/
        403: {
          /* n:"BrtEOF" */
        },
        /*::[*/
        404: {
          /* n:"BrtUCR" */
        },
        /*::[*/
        405: {
          /* n:"BrtRRInsDel" */
        },
        /*::[*/
        406: {
          /* n:"BrtRREndInsDel" */
        },
        /*::[*/
        407: {
          /* n:"BrtRRMove" */
        },
        /*::[*/
        408: {
          /* n:"BrtRREndMove" */
        },
        /*::[*/
        409: {
          /* n:"BrtRRChgCell" */
        },
        /*::[*/
        410: {
          /* n:"BrtRREndChgCell" */
        },
        /*::[*/
        411: {
          /* n:"BrtRRHeader" */
        },
        /*::[*/
        412: {
          /* n:"BrtRRUserView" */
        },
        /*::[*/
        413: {
          /* n:"BrtRRRenSheet" */
        },
        /*::[*/
        414: {
          /* n:"BrtRRInsertSh" */
        },
        /*::[*/
        415: {
          /* n:"BrtRRDefName" */
        },
        /*::[*/
        416: {
          /* n:"BrtRRNote" */
        },
        /*::[*/
        417: {
          /* n:"BrtRRConflict" */
        },
        /*::[*/
        418: {
          /* n:"BrtRRTQSIF" */
        },
        /*::[*/
        419: {
          /* n:"BrtRRFormat" */
        },
        /*::[*/
        420: {
          /* n:"BrtRREndFormat" */
        },
        /*::[*/
        421: {
          /* n:"BrtRRAutoFmt" */
        },
        /*::[*/
        422: {
          /* n:"BrtBeginUserShViews", */
          T: 1
        },
        /*::[*/
        423: {
          /* n:"BrtBeginUserShView", */
          T: 1
        },
        /*::[*/
        424: {
          /* n:"BrtEndUserShView", */
          T: -1
        },
        /*::[*/
        425: {
          /* n:"BrtEndUserShViews", */
          T: -1
        },
        /*::[*/
        426: {
          /* n:"BrtArrFmla", */
          f: parse_BrtArrFmla
        },
        /*::[*/
        427: {
          /* n:"BrtShrFmla", */
          f: parse_BrtShrFmla
        },
        /*::[*/
        428: {
          /* n:"BrtTable" */
        },
        /*::[*/
        429: {
          /* n:"BrtBeginExtConnections", */
          T: 1
        },
        /*::[*/
        430: {
          /* n:"BrtEndExtConnections", */
          T: -1
        },
        /*::[*/
        431: {
          /* n:"BrtBeginPCDCalcMems", */
          T: 1
        },
        /*::[*/
        432: {
          /* n:"BrtEndPCDCalcMems", */
          T: -1
        },
        /*::[*/
        433: {
          /* n:"BrtBeginPCDCalcMem", */
          T: 1
        },
        /*::[*/
        434: {
          /* n:"BrtEndPCDCalcMem", */
          T: -1
        },
        /*::[*/
        435: {
          /* n:"BrtBeginPCDHGLevels", */
          T: 1
        },
        /*::[*/
        436: {
          /* n:"BrtEndPCDHGLevels", */
          T: -1
        },
        /*::[*/
        437: {
          /* n:"BrtBeginPCDHGLevel", */
          T: 1
        },
        /*::[*/
        438: {
          /* n:"BrtEndPCDHGLevel", */
          T: -1
        },
        /*::[*/
        439: {
          /* n:"BrtBeginPCDHGLGroups", */
          T: 1
        },
        /*::[*/
        440: {
          /* n:"BrtEndPCDHGLGroups", */
          T: -1
        },
        /*::[*/
        441: {
          /* n:"BrtBeginPCDHGLGroup", */
          T: 1
        },
        /*::[*/
        442: {
          /* n:"BrtEndPCDHGLGroup", */
          T: -1
        },
        /*::[*/
        443: {
          /* n:"BrtBeginPCDHGLGMembers", */
          T: 1
        },
        /*::[*/
        444: {
          /* n:"BrtEndPCDHGLGMembers", */
          T: -1
        },
        /*::[*/
        445: {
          /* n:"BrtBeginPCDHGLGMember", */
          T: 1
        },
        /*::[*/
        446: {
          /* n:"BrtEndPCDHGLGMember", */
          T: -1
        },
        /*::[*/
        447: {
          /* n:"BrtBeginQSI", */
          T: 1
        },
        /*::[*/
        448: {
          /* n:"BrtEndQSI", */
          T: -1
        },
        /*::[*/
        449: {
          /* n:"BrtBeginQSIR", */
          T: 1
        },
        /*::[*/
        450: {
          /* n:"BrtEndQSIR", */
          T: -1
        },
        /*::[*/
        451: {
          /* n:"BrtBeginDeletedNames", */
          T: 1
        },
        /*::[*/
        452: {
          /* n:"BrtEndDeletedNames", */
          T: -1
        },
        /*::[*/
        453: {
          /* n:"BrtBeginDeletedName", */
          T: 1
        },
        /*::[*/
        454: {
          /* n:"BrtEndDeletedName", */
          T: -1
        },
        /*::[*/
        455: {
          /* n:"BrtBeginQSIFs", */
          T: 1
        },
        /*::[*/
        456: {
          /* n:"BrtEndQSIFs", */
          T: -1
        },
        /*::[*/
        457: {
          /* n:"BrtBeginQSIF", */
          T: 1
        },
        /*::[*/
        458: {
          /* n:"BrtEndQSIF", */
          T: -1
        },
        /*::[*/
        459: {
          /* n:"BrtBeginAutoSortScope", */
          T: 1
        },
        /*::[*/
        460: {
          /* n:"BrtEndAutoSortScope", */
          T: -1
        },
        /*::[*/
        461: {
          /* n:"BrtBeginConditionalFormatting", */
          T: 1
        },
        /*::[*/
        462: {
          /* n:"BrtEndConditionalFormatting", */
          T: -1
        },
        /*::[*/
        463: {
          /* n:"BrtBeginCFRule", */
          T: 1
        },
        /*::[*/
        464: {
          /* n:"BrtEndCFRule", */
          T: -1
        },
        /*::[*/
        465: {
          /* n:"BrtBeginIconSet", */
          T: 1
        },
        /*::[*/
        466: {
          /* n:"BrtEndIconSet", */
          T: -1
        },
        /*::[*/
        467: {
          /* n:"BrtBeginDatabar", */
          T: 1
        },
        /*::[*/
        468: {
          /* n:"BrtEndDatabar", */
          T: -1
        },
        /*::[*/
        469: {
          /* n:"BrtBeginColorScale", */
          T: 1
        },
        /*::[*/
        470: {
          /* n:"BrtEndColorScale", */
          T: -1
        },
        /*::[*/
        471: {
          /* n:"BrtCFVO" */
        },
        /*::[*/
        472: {
          /* n:"BrtExternValueMeta" */
        },
        /*::[*/
        473: {
          /* n:"BrtBeginColorPalette", */
          T: 1
        },
        /*::[*/
        474: {
          /* n:"BrtEndColorPalette", */
          T: -1
        },
        /*::[*/
        475: {
          /* n:"BrtIndexedColor" */
        },
        /*::[*/
        476: {
          /* n:"BrtMargins", */
          f: parse_BrtMargins
        },
        /*::[*/
        477: {
          /* n:"BrtPrintOptions" */
        },
        /*::[*/
        478: {
          /* n:"BrtPageSetup" */
        },
        /*::[*/
        479: {
          /* n:"BrtBeginHeaderFooter", */
          T: 1
        },
        /*::[*/
        480: {
          /* n:"BrtEndHeaderFooter", */
          T: -1
        },
        /*::[*/
        481: {
          /* n:"BrtBeginSXCrtFormat", */
          T: 1
        },
        /*::[*/
        482: {
          /* n:"BrtEndSXCrtFormat", */
          T: -1
        },
        /*::[*/
        483: {
          /* n:"BrtBeginSXCrtFormats", */
          T: 1
        },
        /*::[*/
        484: {
          /* n:"BrtEndSXCrtFormats", */
          T: -1
        },
        /*::[*/
        485: {
          /* n:"BrtWsFmtInfo", */
          f: parse_BrtWsFmtInfo
        },
        /*::[*/
        486: {
          /* n:"BrtBeginMgs", */
          T: 1
        },
        /*::[*/
        487: {
          /* n:"BrtEndMGs", */
          T: -1
        },
        /*::[*/
        488: {
          /* n:"BrtBeginMGMaps", */
          T: 1
        },
        /*::[*/
        489: {
          /* n:"BrtEndMGMaps", */
          T: -1
        },
        /*::[*/
        490: {
          /* n:"BrtBeginMG", */
          T: 1
        },
        /*::[*/
        491: {
          /* n:"BrtEndMG", */
          T: -1
        },
        /*::[*/
        492: {
          /* n:"BrtBeginMap", */
          T: 1
        },
        /*::[*/
        493: {
          /* n:"BrtEndMap", */
          T: -1
        },
        /*::[*/
        494: {
          /* n:"BrtHLink", */
          f: parse_BrtHLink
        },
        /*::[*/
        495: {
          /* n:"BrtBeginDCon", */
          T: 1
        },
        /*::[*/
        496: {
          /* n:"BrtEndDCon", */
          T: -1
        },
        /*::[*/
        497: {
          /* n:"BrtBeginDRefs", */
          T: 1
        },
        /*::[*/
        498: {
          /* n:"BrtEndDRefs", */
          T: -1
        },
        /*::[*/
        499: {
          /* n:"BrtDRef" */
        },
        /*::[*/
        500: {
          /* n:"BrtBeginScenMan", */
          T: 1
        },
        /*::[*/
        501: {
          /* n:"BrtEndScenMan", */
          T: -1
        },
        /*::[*/
        502: {
          /* n:"BrtBeginSct", */
          T: 1
        },
        /*::[*/
        503: {
          /* n:"BrtEndSct", */
          T: -1
        },
        /*::[*/
        504: {
          /* n:"BrtSlc" */
        },
        /*::[*/
        505: {
          /* n:"BrtBeginDXFs", */
          T: 1
        },
        /*::[*/
        506: {
          /* n:"BrtEndDXFs", */
          T: -1
        },
        /*::[*/
        507: {
          /* n:"BrtDXF" */
        },
        /*::[*/
        508: {
          /* n:"BrtBeginTableStyles", */
          T: 1
        },
        /*::[*/
        509: {
          /* n:"BrtEndTableStyles", */
          T: -1
        },
        /*::[*/
        510: {
          /* n:"BrtBeginTableStyle", */
          T: 1
        },
        /*::[*/
        511: {
          /* n:"BrtEndTableStyle", */
          T: -1
        },
        /*::[*/
        512: {
          /* n:"BrtTableStyleElement" */
        },
        /*::[*/
        513: {
          /* n:"BrtTableStyleClient" */
        },
        /*::[*/
        514: {
          /* n:"BrtBeginVolDeps", */
          T: 1
        },
        /*::[*/
        515: {
          /* n:"BrtEndVolDeps", */
          T: -1
        },
        /*::[*/
        516: {
          /* n:"BrtBeginVolType", */
          T: 1
        },
        /*::[*/
        517: {
          /* n:"BrtEndVolType", */
          T: -1
        },
        /*::[*/
        518: {
          /* n:"BrtBeginVolMain", */
          T: 1
        },
        /*::[*/
        519: {
          /* n:"BrtEndVolMain", */
          T: -1
        },
        /*::[*/
        520: {
          /* n:"BrtBeginVolTopic", */
          T: 1
        },
        /*::[*/
        521: {
          /* n:"BrtEndVolTopic", */
          T: -1
        },
        /*::[*/
        522: {
          /* n:"BrtVolSubtopic" */
        },
        /*::[*/
        523: {
          /* n:"BrtVolRef" */
        },
        /*::[*/
        524: {
          /* n:"BrtVolNum" */
        },
        /*::[*/
        525: {
          /* n:"BrtVolErr" */
        },
        /*::[*/
        526: {
          /* n:"BrtVolStr" */
        },
        /*::[*/
        527: {
          /* n:"BrtVolBool" */
        },
        /*::[*/
        528: {
          /* n:"BrtBeginCalcChain$", */
          T: 1
        },
        /*::[*/
        529: {
          /* n:"BrtEndCalcChain$", */
          T: -1
        },
        /*::[*/
        530: {
          /* n:"BrtBeginSortState", */
          T: 1
        },
        /*::[*/
        531: {
          /* n:"BrtEndSortState", */
          T: -1
        },
        /*::[*/
        532: {
          /* n:"BrtBeginSortCond", */
          T: 1
        },
        /*::[*/
        533: {
          /* n:"BrtEndSortCond", */
          T: -1
        },
        /*::[*/
        534: {
          /* n:"BrtBookProtection" */
        },
        /*::[*/
        535: {
          /* n:"BrtSheetProtection" */
        },
        /*::[*/
        536: {
          /* n:"BrtRangeProtection" */
        },
        /*::[*/
        537: {
          /* n:"BrtPhoneticInfo" */
        },
        /*::[*/
        538: {
          /* n:"BrtBeginECTxtWiz", */
          T: 1
        },
        /*::[*/
        539: {
          /* n:"BrtEndECTxtWiz", */
          T: -1
        },
        /*::[*/
        540: {
          /* n:"BrtBeginECTWFldInfoLst", */
          T: 1
        },
        /*::[*/
        541: {
          /* n:"BrtEndECTWFldInfoLst", */
          T: -1
        },
        /*::[*/
        542: {
          /* n:"BrtBeginECTwFldInfo", */
          T: 1
        },
        /*::[*/
        548: {
          /* n:"BrtFileSharing" */
        },
        /*::[*/
        549: {
          /* n:"BrtOleSize" */
        },
        /*::[*/
        550: {
          /* n:"BrtDrawing", */
          f: parse_RelID
        },
        /*::[*/
        551: {
          /* n:"BrtLegacyDrawing" */
        },
        /*::[*/
        552: {
          /* n:"BrtLegacyDrawingHF" */
        },
        /*::[*/
        553: {
          /* n:"BrtWebOpt" */
        },
        /*::[*/
        554: {
          /* n:"BrtBeginWebPubItems", */
          T: 1
        },
        /*::[*/
        555: {
          /* n:"BrtEndWebPubItems", */
          T: -1
        },
        /*::[*/
        556: {
          /* n:"BrtBeginWebPubItem", */
          T: 1
        },
        /*::[*/
        557: {
          /* n:"BrtEndWebPubItem", */
          T: -1
        },
        /*::[*/
        558: {
          /* n:"BrtBeginSXCondFmt", */
          T: 1
        },
        /*::[*/
        559: {
          /* n:"BrtEndSXCondFmt", */
          T: -1
        },
        /*::[*/
        560: {
          /* n:"BrtBeginSXCondFmts", */
          T: 1
        },
        /*::[*/
        561: {
          /* n:"BrtEndSXCondFmts", */
          T: -1
        },
        /*::[*/
        562: {
          /* n:"BrtBkHim" */
        },
        /*::[*/
        564: {
          /* n:"BrtColor" */
        },
        /*::[*/
        565: {
          /* n:"BrtBeginIndexedColors", */
          T: 1
        },
        /*::[*/
        566: {
          /* n:"BrtEndIndexedColors", */
          T: -1
        },
        /*::[*/
        569: {
          /* n:"BrtBeginMRUColors", */
          T: 1
        },
        /*::[*/
        570: {
          /* n:"BrtEndMRUColors", */
          T: -1
        },
        /*::[*/
        572: {
          /* n:"BrtMRUColor" */
        },
        /*::[*/
        573: {
          /* n:"BrtBeginDVals", */
          T: 1
        },
        /*::[*/
        574: {
          /* n:"BrtEndDVals", */
          T: -1
        },
        /*::[*/
        577: {
          /* n:"BrtSupNameStart" */
        },
        /*::[*/
        578: {
          /* n:"BrtSupNameValueStart" */
        },
        /*::[*/
        579: {
          /* n:"BrtSupNameValueEnd" */
        },
        /*::[*/
        580: {
          /* n:"BrtSupNameNum" */
        },
        /*::[*/
        581: {
          /* n:"BrtSupNameErr" */
        },
        /*::[*/
        582: {
          /* n:"BrtSupNameSt" */
        },
        /*::[*/
        583: {
          /* n:"BrtSupNameNil" */
        },
        /*::[*/
        584: {
          /* n:"BrtSupNameBool" */
        },
        /*::[*/
        585: {
          /* n:"BrtSupNameFmla" */
        },
        /*::[*/
        586: {
          /* n:"BrtSupNameBits" */
        },
        /*::[*/
        587: {
          /* n:"BrtSupNameEnd" */
        },
        /*::[*/
        588: {
          /* n:"BrtEndSupBook", */
          T: -1
        },
        /*::[*/
        589: {
          /* n:"BrtCellSmartTagProperty" */
        },
        /*::[*/
        590: {
          /* n:"BrtBeginCellSmartTag", */
          T: 1
        },
        /*::[*/
        591: {
          /* n:"BrtEndCellSmartTag", */
          T: -1
        },
        /*::[*/
        592: {
          /* n:"BrtBeginCellSmartTags", */
          T: 1
        },
        /*::[*/
        593: {
          /* n:"BrtEndCellSmartTags", */
          T: -1
        },
        /*::[*/
        594: {
          /* n:"BrtBeginSmartTags", */
          T: 1
        },
        /*::[*/
        595: {
          /* n:"BrtEndSmartTags", */
          T: -1
        },
        /*::[*/
        596: {
          /* n:"BrtSmartTagType" */
        },
        /*::[*/
        597: {
          /* n:"BrtBeginSmartTagTypes", */
          T: 1
        },
        /*::[*/
        598: {
          /* n:"BrtEndSmartTagTypes", */
          T: -1
        },
        /*::[*/
        599: {
          /* n:"BrtBeginSXFilters", */
          T: 1
        },
        /*::[*/
        600: {
          /* n:"BrtEndSXFilters", */
          T: -1
        },
        /*::[*/
        601: {
          /* n:"BrtBeginSXFILTER", */
          T: 1
        },
        /*::[*/
        602: {
          /* n:"BrtEndSXFilter", */
          T: -1
        },
        /*::[*/
        603: {
          /* n:"BrtBeginFills", */
          T: 1
        },
        /*::[*/
        604: {
          /* n:"BrtEndFills", */
          T: -1
        },
        /*::[*/
        605: {
          /* n:"BrtBeginCellWatches", */
          T: 1
        },
        /*::[*/
        606: {
          /* n:"BrtEndCellWatches", */
          T: -1
        },
        /*::[*/
        607: {
          /* n:"BrtCellWatch" */
        },
        /*::[*/
        608: {
          /* n:"BrtBeginCRErrs", */
          T: 1
        },
        /*::[*/
        609: {
          /* n:"BrtEndCRErrs", */
          T: -1
        },
        /*::[*/
        610: {
          /* n:"BrtCrashRecErr" */
        },
        /*::[*/
        611: {
          /* n:"BrtBeginFonts", */
          T: 1
        },
        /*::[*/
        612: {
          /* n:"BrtEndFonts", */
          T: -1
        },
        /*::[*/
        613: {
          /* n:"BrtBeginBorders", */
          T: 1
        },
        /*::[*/
        614: {
          /* n:"BrtEndBorders", */
          T: -1
        },
        /*::[*/
        615: {
          /* n:"BrtBeginFmts", */
          T: 1
        },
        /*::[*/
        616: {
          /* n:"BrtEndFmts", */
          T: -1
        },
        /*::[*/
        617: {
          /* n:"BrtBeginCellXFs", */
          T: 1
        },
        /*::[*/
        618: {
          /* n:"BrtEndCellXFs", */
          T: -1
        },
        /*::[*/
        619: {
          /* n:"BrtBeginStyles", */
          T: 1
        },
        /*::[*/
        620: {
          /* n:"BrtEndStyles", */
          T: -1
        },
        /*::[*/
        625: {
          /* n:"BrtBigName" */
        },
        /*::[*/
        626: {
          /* n:"BrtBeginCellStyleXFs", */
          T: 1
        },
        /*::[*/
        627: {
          /* n:"BrtEndCellStyleXFs", */
          T: -1
        },
        /*::[*/
        628: {
          /* n:"BrtBeginComments", */
          T: 1
        },
        /*::[*/
        629: {
          /* n:"BrtEndComments", */
          T: -1
        },
        /*::[*/
        630: {
          /* n:"BrtBeginCommentAuthors", */
          T: 1
        },
        /*::[*/
        631: {
          /* n:"BrtEndCommentAuthors", */
          T: -1
        },
        /*::[*/
        632: {
          /* n:"BrtCommentAuthor", */
          f: parse_BrtCommentAuthor
        },
        /*::[*/
        633: {
          /* n:"BrtBeginCommentList", */
          T: 1
        },
        /*::[*/
        634: {
          /* n:"BrtEndCommentList", */
          T: -1
        },
        /*::[*/
        635: {
          /* n:"BrtBeginComment", */
          T: 1,
          f: parse_BrtBeginComment
        },
        /*::[*/
        636: {
          /* n:"BrtEndComment", */
          T: -1
        },
        /*::[*/
        637: {
          /* n:"BrtCommentText", */
          f: parse_BrtCommentText
        },
        /*::[*/
        638: {
          /* n:"BrtBeginOleObjects", */
          T: 1
        },
        /*::[*/
        639: {
          /* n:"BrtOleObject" */
        },
        /*::[*/
        640: {
          /* n:"BrtEndOleObjects", */
          T: -1
        },
        /*::[*/
        641: {
          /* n:"BrtBeginSxrules", */
          T: 1
        },
        /*::[*/
        642: {
          /* n:"BrtEndSxRules", */
          T: -1
        },
        /*::[*/
        643: {
          /* n:"BrtBeginActiveXControls", */
          T: 1
        },
        /*::[*/
        644: {
          /* n:"BrtActiveX" */
        },
        /*::[*/
        645: {
          /* n:"BrtEndActiveXControls", */
          T: -1
        },
        /*::[*/
        646: {
          /* n:"BrtBeginPCDSDTCEMembersSortBy", */
          T: 1
        },
        /*::[*/
        648: {
          /* n:"BrtBeginCellIgnoreECs", */
          T: 1
        },
        /*::[*/
        649: {
          /* n:"BrtCellIgnoreEC" */
        },
        /*::[*/
        650: {
          /* n:"BrtEndCellIgnoreECs", */
          T: -1
        },
        /*::[*/
        651: {
          /* n:"BrtCsProp", */
          f: parse_BrtCsProp
        },
        /*::[*/
        652: {
          /* n:"BrtCsPageSetup" */
        },
        /*::[*/
        653: {
          /* n:"BrtBeginUserCsViews", */
          T: 1
        },
        /*::[*/
        654: {
          /* n:"BrtEndUserCsViews", */
          T: -1
        },
        /*::[*/
        655: {
          /* n:"BrtBeginUserCsView", */
          T: 1
        },
        /*::[*/
        656: {
          /* n:"BrtEndUserCsView", */
          T: -1
        },
        /*::[*/
        657: {
          /* n:"BrtBeginPcdSFCIEntries", */
          T: 1
        },
        /*::[*/
        658: {
          /* n:"BrtEndPCDSFCIEntries", */
          T: -1
        },
        /*::[*/
        659: {
          /* n:"BrtPCDSFCIEntry" */
        },
        /*::[*/
        660: {
          /* n:"BrtBeginListParts", */
          T: 1
        },
        /*::[*/
        661: {
          /* n:"BrtListPart" */
        },
        /*::[*/
        662: {
          /* n:"BrtEndListParts", */
          T: -1
        },
        /*::[*/
        663: {
          /* n:"BrtSheetCalcProp" */
        },
        /*::[*/
        664: {
          /* n:"BrtBeginFnGroup", */
          T: 1
        },
        /*::[*/
        665: {
          /* n:"BrtFnGroup" */
        },
        /*::[*/
        666: {
          /* n:"BrtEndFnGroup", */
          T: -1
        },
        /*::[*/
        667: {
          /* n:"BrtSupAddin" */
        },
        /*::[*/
        668: {
          /* n:"BrtSXTDMPOrder" */
        },
        /*::[*/
        669: {
          /* n:"BrtCsProtection" */
        },
        /*::[*/
        671: {
          /* n:"BrtBeginWsSortMap", */
          T: 1
        },
        /*::[*/
        672: {
          /* n:"BrtEndWsSortMap", */
          T: -1
        },
        /*::[*/
        673: {
          /* n:"BrtBeginRRSort", */
          T: 1
        },
        /*::[*/
        674: {
          /* n:"BrtEndRRSort", */
          T: -1
        },
        /*::[*/
        675: {
          /* n:"BrtRRSortItem" */
        },
        /*::[*/
        676: {
          /* n:"BrtFileSharingIso" */
        },
        /*::[*/
        677: {
          /* n:"BrtBookProtectionIso" */
        },
        /*::[*/
        678: {
          /* n:"BrtSheetProtectionIso" */
        },
        /*::[*/
        679: {
          /* n:"BrtCsProtectionIso" */
        },
        /*::[*/
        680: {
          /* n:"BrtRangeProtectionIso" */
        },
        /*::[*/
        681: {
          /* n:"BrtDValList" */
        },
        /*::[*/
        1024: {
          /* n:"BrtRwDescent" */
        },
        /*::[*/
        1025: {
          /* n:"BrtKnownFonts" */
        },
        /*::[*/
        1026: {
          /* n:"BrtBeginSXTupleSet", */
          T: 1
        },
        /*::[*/
        1027: {
          /* n:"BrtEndSXTupleSet", */
          T: -1
        },
        /*::[*/
        1028: {
          /* n:"BrtBeginSXTupleSetHeader", */
          T: 1
        },
        /*::[*/
        1029: {
          /* n:"BrtEndSXTupleSetHeader", */
          T: -1
        },
        /*::[*/
        1030: {
          /* n:"BrtSXTupleSetHeaderItem" */
        },
        /*::[*/
        1031: {
          /* n:"BrtBeginSXTupleSetData", */
          T: 1
        },
        /*::[*/
        1032: {
          /* n:"BrtEndSXTupleSetData", */
          T: -1
        },
        /*::[*/
        1033: {
          /* n:"BrtBeginSXTupleSetRow", */
          T: 1
        },
        /*::[*/
        1034: {
          /* n:"BrtEndSXTupleSetRow", */
          T: -1
        },
        /*::[*/
        1035: {
          /* n:"BrtSXTupleSetRowItem" */
        },
        /*::[*/
        1036: {
          /* n:"BrtNameExt" */
        },
        /*::[*/
        1037: {
          /* n:"BrtPCDH14" */
        },
        /*::[*/
        1038: {
          /* n:"BrtBeginPCDCalcMem14", */
          T: 1
        },
        /*::[*/
        1039: {
          /* n:"BrtEndPCDCalcMem14", */
          T: -1
        },
        /*::[*/
        1040: {
          /* n:"BrtSXTH14" */
        },
        /*::[*/
        1041: {
          /* n:"BrtBeginSparklineGroup", */
          T: 1
        },
        /*::[*/
        1042: {
          /* n:"BrtEndSparklineGroup", */
          T: -1
        },
        /*::[*/
        1043: {
          /* n:"BrtSparkline" */
        },
        /*::[*/
        1044: {
          /* n:"BrtSXDI14" */
        },
        /*::[*/
        1045: {
          /* n:"BrtWsFmtInfoEx14" */
        },
        /*::[*/
        1046: {
          /* n:"BrtBeginConditionalFormatting14", */
          T: 1
        },
        /*::[*/
        1047: {
          /* n:"BrtEndConditionalFormatting14", */
          T: -1
        },
        /*::[*/
        1048: {
          /* n:"BrtBeginCFRule14", */
          T: 1
        },
        /*::[*/
        1049: {
          /* n:"BrtEndCFRule14", */
          T: -1
        },
        /*::[*/
        1050: {
          /* n:"BrtCFVO14" */
        },
        /*::[*/
        1051: {
          /* n:"BrtBeginDatabar14", */
          T: 1
        },
        /*::[*/
        1052: {
          /* n:"BrtBeginIconSet14", */
          T: 1
        },
        /*::[*/
        1053: {
          /* n:"BrtDVal14", */
          f: parse_BrtDVal14
        },
        /*::[*/
        1054: {
          /* n:"BrtBeginDVals14", */
          T: 1
        },
        /*::[*/
        1055: {
          /* n:"BrtColor14" */
        },
        /*::[*/
        1056: {
          /* n:"BrtBeginSparklines", */
          T: 1
        },
        /*::[*/
        1057: {
          /* n:"BrtEndSparklines", */
          T: -1
        },
        /*::[*/
        1058: {
          /* n:"BrtBeginSparklineGroups", */
          T: 1
        },
        /*::[*/
        1059: {
          /* n:"BrtEndSparklineGroups", */
          T: -1
        },
        /*::[*/
        1061: {
          /* n:"BrtSXVD14" */
        },
        /*::[*/
        1062: {
          /* n:"BrtBeginSXView14", */
          T: 1
        },
        /*::[*/
        1063: {
          /* n:"BrtEndSXView14", */
          T: -1
        },
        /*::[*/
        1064: {
          /* n:"BrtBeginSXView16", */
          T: 1
        },
        /*::[*/
        1065: {
          /* n:"BrtEndSXView16", */
          T: -1
        },
        /*::[*/
        1066: {
          /* n:"BrtBeginPCD14", */
          T: 1
        },
        /*::[*/
        1067: {
          /* n:"BrtEndPCD14", */
          T: -1
        },
        /*::[*/
        1068: {
          /* n:"BrtBeginExtConn14", */
          T: 1
        },
        /*::[*/
        1069: {
          /* n:"BrtEndExtConn14", */
          T: -1
        },
        /*::[*/
        1070: {
          /* n:"BrtBeginSlicerCacheIDs", */
          T: 1
        },
        /*::[*/
        1071: {
          /* n:"BrtEndSlicerCacheIDs", */
          T: -1
        },
        /*::[*/
        1072: {
          /* n:"BrtBeginSlicerCacheID", */
          T: 1
        },
        /*::[*/
        1073: {
          /* n:"BrtEndSlicerCacheID", */
          T: -1
        },
        /*::[*/
        1075: {
          /* n:"BrtBeginSlicerCache", */
          T: 1
        },
        /*::[*/
        1076: {
          /* n:"BrtEndSlicerCache", */
          T: -1
        },
        /*::[*/
        1077: {
          /* n:"BrtBeginSlicerCacheDef", */
          T: 1
        },
        /*::[*/
        1078: {
          /* n:"BrtEndSlicerCacheDef", */
          T: -1
        },
        /*::[*/
        1079: {
          /* n:"BrtBeginSlicersEx", */
          T: 1
        },
        /*::[*/
        1080: {
          /* n:"BrtEndSlicersEx", */
          T: -1
        },
        /*::[*/
        1081: {
          /* n:"BrtBeginSlicerEx", */
          T: 1
        },
        /*::[*/
        1082: {
          /* n:"BrtEndSlicerEx", */
          T: -1
        },
        /*::[*/
        1083: {
          /* n:"BrtBeginSlicer", */
          T: 1
        },
        /*::[*/
        1084: {
          /* n:"BrtEndSlicer", */
          T: -1
        },
        /*::[*/
        1085: {
          /* n:"BrtSlicerCachePivotTables" */
        },
        /*::[*/
        1086: {
          /* n:"BrtBeginSlicerCacheOlapImpl", */
          T: 1
        },
        /*::[*/
        1087: {
          /* n:"BrtEndSlicerCacheOlapImpl", */
          T: -1
        },
        /*::[*/
        1088: {
          /* n:"BrtBeginSlicerCacheLevelsData", */
          T: 1
        },
        /*::[*/
        1089: {
          /* n:"BrtEndSlicerCacheLevelsData", */
          T: -1
        },
        /*::[*/
        1090: {
          /* n:"BrtBeginSlicerCacheLevelData", */
          T: 1
        },
        /*::[*/
        1091: {
          /* n:"BrtEndSlicerCacheLevelData", */
          T: -1
        },
        /*::[*/
        1092: {
          /* n:"BrtBeginSlicerCacheSiRanges", */
          T: 1
        },
        /*::[*/
        1093: {
          /* n:"BrtEndSlicerCacheSiRanges", */
          T: -1
        },
        /*::[*/
        1094: {
          /* n:"BrtBeginSlicerCacheSiRange", */
          T: 1
        },
        /*::[*/
        1095: {
          /* n:"BrtEndSlicerCacheSiRange", */
          T: -1
        },
        /*::[*/
        1096: {
          /* n:"BrtSlicerCacheOlapItem" */
        },
        /*::[*/
        1097: {
          /* n:"BrtBeginSlicerCacheSelections", */
          T: 1
        },
        /*::[*/
        1098: {
          /* n:"BrtSlicerCacheSelection" */
        },
        /*::[*/
        1099: {
          /* n:"BrtEndSlicerCacheSelections", */
          T: -1
        },
        /*::[*/
        1100: {
          /* n:"BrtBeginSlicerCacheNative", */
          T: 1
        },
        /*::[*/
        1101: {
          /* n:"BrtEndSlicerCacheNative", */
          T: -1
        },
        /*::[*/
        1102: {
          /* n:"BrtSlicerCacheNativeItem" */
        },
        /*::[*/
        1103: {
          /* n:"BrtRangeProtection14" */
        },
        /*::[*/
        1104: {
          /* n:"BrtRangeProtectionIso14" */
        },
        /*::[*/
        1105: {
          /* n:"BrtCellIgnoreEC14" */
        },
        /*::[*/
        1111: {
          /* n:"BrtList14" */
        },
        /*::[*/
        1112: {
          /* n:"BrtCFIcon" */
        },
        /*::[*/
        1113: {
          /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
          T: 1
        },
        /*::[*/
        1114: {
          /* n:"BrtEndSlicerCachesPivotCacheIDs", */
          T: -1
        },
        /*::[*/
        1115: {
          /* n:"BrtBeginSlicers", */
          T: 1
        },
        /*::[*/
        1116: {
          /* n:"BrtEndSlicers", */
          T: -1
        },
        /*::[*/
        1117: {
          /* n:"BrtWbProp14" */
        },
        /*::[*/
        1118: {
          /* n:"BrtBeginSXEdit", */
          T: 1
        },
        /*::[*/
        1119: {
          /* n:"BrtEndSXEdit", */
          T: -1
        },
        /*::[*/
        1120: {
          /* n:"BrtBeginSXEdits", */
          T: 1
        },
        /*::[*/
        1121: {
          /* n:"BrtEndSXEdits", */
          T: -1
        },
        /*::[*/
        1122: {
          /* n:"BrtBeginSXChange", */
          T: 1
        },
        /*::[*/
        1123: {
          /* n:"BrtEndSXChange", */
          T: -1
        },
        /*::[*/
        1124: {
          /* n:"BrtBeginSXChanges", */
          T: 1
        },
        /*::[*/
        1125: {
          /* n:"BrtEndSXChanges", */
          T: -1
        },
        /*::[*/
        1126: {
          /* n:"BrtSXTupleItems" */
        },
        /*::[*/
        1128: {
          /* n:"BrtBeginSlicerStyle", */
          T: 1
        },
        /*::[*/
        1129: {
          /* n:"BrtEndSlicerStyle", */
          T: -1
        },
        /*::[*/
        1130: {
          /* n:"BrtSlicerStyleElement" */
        },
        /*::[*/
        1131: {
          /* n:"BrtBeginStyleSheetExt14", */
          T: 1
        },
        /*::[*/
        1132: {
          /* n:"BrtEndStyleSheetExt14", */
          T: -1
        },
        /*::[*/
        1133: {
          /* n:"BrtBeginSlicerCachesPivotCacheID", */
          T: 1
        },
        /*::[*/
        1134: {
          /* n:"BrtEndSlicerCachesPivotCacheID", */
          T: -1
        },
        /*::[*/
        1135: {
          /* n:"BrtBeginConditionalFormattings", */
          T: 1
        },
        /*::[*/
        1136: {
          /* n:"BrtEndConditionalFormattings", */
          T: -1
        },
        /*::[*/
        1137: {
          /* n:"BrtBeginPCDCalcMemExt", */
          T: 1
        },
        /*::[*/
        1138: {
          /* n:"BrtEndPCDCalcMemExt", */
          T: -1
        },
        /*::[*/
        1139: {
          /* n:"BrtBeginPCDCalcMemsExt", */
          T: 1
        },
        /*::[*/
        1140: {
          /* n:"BrtEndPCDCalcMemsExt", */
          T: -1
        },
        /*::[*/
        1141: {
          /* n:"BrtPCDField14" */
        },
        /*::[*/
        1142: {
          /* n:"BrtBeginSlicerStyles", */
          T: 1
        },
        /*::[*/
        1143: {
          /* n:"BrtEndSlicerStyles", */
          T: -1
        },
        /*::[*/
        1144: {
          /* n:"BrtBeginSlicerStyleElements", */
          T: 1
        },
        /*::[*/
        1145: {
          /* n:"BrtEndSlicerStyleElements", */
          T: -1
        },
        /*::[*/
        1146: {
          /* n:"BrtCFRuleExt" */
        },
        /*::[*/
        1147: {
          /* n:"BrtBeginSXCondFmt14", */
          T: 1
        },
        /*::[*/
        1148: {
          /* n:"BrtEndSXCondFmt14", */
          T: -1
        },
        /*::[*/
        1149: {
          /* n:"BrtBeginSXCondFmts14", */
          T: 1
        },
        /*::[*/
        1150: {
          /* n:"BrtEndSXCondFmts14", */
          T: -1
        },
        /*::[*/
        1152: {
          /* n:"BrtBeginSortCond14", */
          T: 1
        },
        /*::[*/
        1153: {
          /* n:"BrtEndSortCond14", */
          T: -1
        },
        /*::[*/
        1154: {
          /* n:"BrtEndDVals14", */
          T: -1
        },
        /*::[*/
        1155: {
          /* n:"BrtEndIconSet14", */
          T: -1
        },
        /*::[*/
        1156: {
          /* n:"BrtEndDatabar14", */
          T: -1
        },
        /*::[*/
        1157: {
          /* n:"BrtBeginColorScale14", */
          T: 1
        },
        /*::[*/
        1158: {
          /* n:"BrtEndColorScale14", */
          T: -1
        },
        /*::[*/
        1159: {
          /* n:"BrtBeginSxrules14", */
          T: 1
        },
        /*::[*/
        1160: {
          /* n:"BrtEndSxrules14", */
          T: -1
        },
        /*::[*/
        1161: {
          /* n:"BrtBeginPRule14", */
          T: 1
        },
        /*::[*/
        1162: {
          /* n:"BrtEndPRule14", */
          T: -1
        },
        /*::[*/
        1163: {
          /* n:"BrtBeginPRFilters14", */
          T: 1
        },
        /*::[*/
        1164: {
          /* n:"BrtEndPRFilters14", */
          T: -1
        },
        /*::[*/
        1165: {
          /* n:"BrtBeginPRFilter14", */
          T: 1
        },
        /*::[*/
        1166: {
          /* n:"BrtEndPRFilter14", */
          T: -1
        },
        /*::[*/
        1167: {
          /* n:"BrtBeginPRFItem14", */
          T: 1
        },
        /*::[*/
        1168: {
          /* n:"BrtEndPRFItem14", */
          T: -1
        },
        /*::[*/
        1169: {
          /* n:"BrtBeginCellIgnoreECs14", */
          T: 1
        },
        /*::[*/
        1170: {
          /* n:"BrtEndCellIgnoreECs14", */
          T: -1
        },
        /*::[*/
        1171: {
          /* n:"BrtDxf14" */
        },
        /*::[*/
        1172: {
          /* n:"BrtBeginDxF14s", */
          T: 1
        },
        /*::[*/
        1173: {
          /* n:"BrtEndDxf14s", */
          T: -1
        },
        /*::[*/
        1177: {
          /* n:"BrtFilter14" */
        },
        /*::[*/
        1178: {
          /* n:"BrtBeginCustomFilters14", */
          T: 1
        },
        /*::[*/
        1180: {
          /* n:"BrtCustomFilter14" */
        },
        /*::[*/
        1181: {
          /* n:"BrtIconFilter14" */
        },
        /*::[*/
        1182: {
          /* n:"BrtPivotCacheConnectionName" */
        },
        /*::[*/
        2048: {
          /* n:"BrtBeginDecoupledPivotCacheIDs", */
          T: 1
        },
        /*::[*/
        2049: {
          /* n:"BrtEndDecoupledPivotCacheIDs", */
          T: -1
        },
        /*::[*/
        2050: {
          /* n:"BrtDecoupledPivotCacheID" */
        },
        /*::[*/
        2051: {
          /* n:"BrtBeginPivotTableRefs", */
          T: 1
        },
        /*::[*/
        2052: {
          /* n:"BrtEndPivotTableRefs", */
          T: -1
        },
        /*::[*/
        2053: {
          /* n:"BrtPivotTableRef" */
        },
        /*::[*/
        2054: {
          /* n:"BrtSlicerCacheBookPivotTables" */
        },
        /*::[*/
        2055: {
          /* n:"BrtBeginSxvcells", */
          T: 1
        },
        /*::[*/
        2056: {
          /* n:"BrtEndSxvcells", */
          T: -1
        },
        /*::[*/
        2057: {
          /* n:"BrtBeginSxRow", */
          T: 1
        },
        /*::[*/
        2058: {
          /* n:"BrtEndSxRow", */
          T: -1
        },
        /*::[*/
        2060: {
          /* n:"BrtPcdCalcMem15" */
        },
        /*::[*/
        2067: {
          /* n:"BrtQsi15" */
        },
        /*::[*/
        2068: {
          /* n:"BrtBeginWebExtensions", */
          T: 1
        },
        /*::[*/
        2069: {
          /* n:"BrtEndWebExtensions", */
          T: -1
        },
        /*::[*/
        2070: {
          /* n:"BrtWebExtension" */
        },
        /*::[*/
        2071: {
          /* n:"BrtAbsPath15" */
        },
        /*::[*/
        2072: {
          /* n:"BrtBeginPivotTableUISettings", */
          T: 1
        },
        /*::[*/
        2073: {
          /* n:"BrtEndPivotTableUISettings", */
          T: -1
        },
        /*::[*/
        2075: {
          /* n:"BrtTableSlicerCacheIDs" */
        },
        /*::[*/
        2076: {
          /* n:"BrtTableSlicerCacheID" */
        },
        /*::[*/
        2077: {
          /* n:"BrtBeginTableSlicerCache", */
          T: 1
        },
        /*::[*/
        2078: {
          /* n:"BrtEndTableSlicerCache", */
          T: -1
        },
        /*::[*/
        2079: {
          /* n:"BrtSxFilter15" */
        },
        /*::[*/
        2080: {
          /* n:"BrtBeginTimelineCachePivotCacheIDs", */
          T: 1
        },
        /*::[*/
        2081: {
          /* n:"BrtEndTimelineCachePivotCacheIDs", */
          T: -1
        },
        /*::[*/
        2082: {
          /* n:"BrtTimelineCachePivotCacheID" */
        },
        /*::[*/
        2083: {
          /* n:"BrtBeginTimelineCacheIDs", */
          T: 1
        },
        /*::[*/
        2084: {
          /* n:"BrtEndTimelineCacheIDs", */
          T: -1
        },
        /*::[*/
        2085: {
          /* n:"BrtBeginTimelineCacheID", */
          T: 1
        },
        /*::[*/
        2086: {
          /* n:"BrtEndTimelineCacheID", */
          T: -1
        },
        /*::[*/
        2087: {
          /* n:"BrtBeginTimelinesEx", */
          T: 1
        },
        /*::[*/
        2088: {
          /* n:"BrtEndTimelinesEx", */
          T: -1
        },
        /*::[*/
        2089: {
          /* n:"BrtBeginTimelineEx", */
          T: 1
        },
        /*::[*/
        2090: {
          /* n:"BrtEndTimelineEx", */
          T: -1
        },
        /*::[*/
        2091: {
          /* n:"BrtWorkBookPr15" */
        },
        /*::[*/
        2092: {
          /* n:"BrtPCDH15" */
        },
        /*::[*/
        2093: {
          /* n:"BrtBeginTimelineStyle", */
          T: 1
        },
        /*::[*/
        2094: {
          /* n:"BrtEndTimelineStyle", */
          T: -1
        },
        /*::[*/
        2095: {
          /* n:"BrtTimelineStyleElement" */
        },
        /*::[*/
        2096: {
          /* n:"BrtBeginTimelineStylesheetExt15", */
          T: 1
        },
        /*::[*/
        2097: {
          /* n:"BrtEndTimelineStylesheetExt15", */
          T: -1
        },
        /*::[*/
        2098: {
          /* n:"BrtBeginTimelineStyles", */
          T: 1
        },
        /*::[*/
        2099: {
          /* n:"BrtEndTimelineStyles", */
          T: -1
        },
        /*::[*/
        2100: {
          /* n:"BrtBeginTimelineStyleElements", */
          T: 1
        },
        /*::[*/
        2101: {
          /* n:"BrtEndTimelineStyleElements", */
          T: -1
        },
        /*::[*/
        2102: {
          /* n:"BrtDxf15" */
        },
        /*::[*/
        2103: {
          /* n:"BrtBeginDxfs15", */
          T: 1
        },
        /*::[*/
        2104: {
          /* n:"BrtEndDxfs15", */
          T: -1
        },
        /*::[*/
        2105: {
          /* n:"BrtSlicerCacheHideItemsWithNoData" */
        },
        /*::[*/
        2106: {
          /* n:"BrtBeginItemUniqueNames", */
          T: 1
        },
        /*::[*/
        2107: {
          /* n:"BrtEndItemUniqueNames", */
          T: -1
        },
        /*::[*/
        2108: {
          /* n:"BrtItemUniqueName" */
        },
        /*::[*/
        2109: {
          /* n:"BrtBeginExtConn15", */
          T: 1
        },
        /*::[*/
        2110: {
          /* n:"BrtEndExtConn15", */
          T: -1
        },
        /*::[*/
        2111: {
          /* n:"BrtBeginOledbPr15", */
          T: 1
        },
        /*::[*/
        2112: {
          /* n:"BrtEndOledbPr15", */
          T: -1
        },
        /*::[*/
        2113: {
          /* n:"BrtBeginDataFeedPr15", */
          T: 1
        },
        /*::[*/
        2114: {
          /* n:"BrtEndDataFeedPr15", */
          T: -1
        },
        /*::[*/
        2115: {
          /* n:"BrtTextPr15" */
        },
        /*::[*/
        2116: {
          /* n:"BrtRangePr15" */
        },
        /*::[*/
        2117: {
          /* n:"BrtDbCommand15" */
        },
        /*::[*/
        2118: {
          /* n:"BrtBeginDbTables15", */
          T: 1
        },
        /*::[*/
        2119: {
          /* n:"BrtEndDbTables15", */
          T: -1
        },
        /*::[*/
        2120: {
          /* n:"BrtDbTable15" */
        },
        /*::[*/
        2121: {
          /* n:"BrtBeginDataModel", */
          T: 1
        },
        /*::[*/
        2122: {
          /* n:"BrtEndDataModel", */
          T: -1
        },
        /*::[*/
        2123: {
          /* n:"BrtBeginModelTables", */
          T: 1
        },
        /*::[*/
        2124: {
          /* n:"BrtEndModelTables", */
          T: -1
        },
        /*::[*/
        2125: {
          /* n:"BrtModelTable" */
        },
        /*::[*/
        2126: {
          /* n:"BrtBeginModelRelationships", */
          T: 1
        },
        /*::[*/
        2127: {
          /* n:"BrtEndModelRelationships", */
          T: -1
        },
        /*::[*/
        2128: {
          /* n:"BrtModelRelationship" */
        },
        /*::[*/
        2129: {
          /* n:"BrtBeginECTxtWiz15", */
          T: 1
        },
        /*::[*/
        2130: {
          /* n:"BrtEndECTxtWiz15", */
          T: -1
        },
        /*::[*/
        2131: {
          /* n:"BrtBeginECTWFldInfoLst15", */
          T: 1
        },
        /*::[*/
        2132: {
          /* n:"BrtEndECTWFldInfoLst15", */
          T: -1
        },
        /*::[*/
        2133: {
          /* n:"BrtBeginECTWFldInfo15", */
          T: 1
        },
        /*::[*/
        2134: {
          /* n:"BrtFieldListActiveItem" */
        },
        /*::[*/
        2135: {
          /* n:"BrtPivotCacheIdVersion" */
        },
        /*::[*/
        2136: {
          /* n:"BrtSXDI15" */
        },
        /*::[*/
        2137: {
          /* n:"BrtBeginModelTimeGroupings", */
          T: 1
        },
        /*::[*/
        2138: {
          /* n:"BrtEndModelTimeGroupings", */
          T: -1
        },
        /*::[*/
        2139: {
          /* n:"BrtBeginModelTimeGrouping", */
          T: 1
        },
        /*::[*/
        2140: {
          /* n:"BrtEndModelTimeGrouping", */
          T: -1
        },
        /*::[*/
        2141: {
          /* n:"BrtModelTimeGroupingCalcCol" */
        },
        /*::[*/
        3072: {
          /* n:"BrtUid" */
        },
        /*::[*/
        3073: {
          /* n:"BrtRevisionPtr" */
        },
        /*::[*/
        4096: {
          /* n:"BrtBeginDynamicArrayPr", */
          T: 1
        },
        /*::[*/
        4097: {
          /* n:"BrtEndDynamicArrayPr", */
          T: -1
        },
        /*::[*/
        5002: {
          /* n:"BrtBeginRichValueBlock", */
          T: 1
        },
        /*::[*/
        5003: {
          /* n:"BrtEndRichValueBlock", */
          T: -1
        },
        /*::[*/
        5081: {
          /* n:"BrtBeginRichFilters", */
          T: 1
        },
        /*::[*/
        5082: {
          /* n:"BrtEndRichFilters", */
          T: -1
        },
        /*::[*/
        5083: {
          /* n:"BrtRichFilter" */
        },
        /*::[*/
        5084: {
          /* n:"BrtBeginRichFilterColumn", */
          T: 1
        },
        /*::[*/
        5085: {
          /* n:"BrtEndRichFilterColumn", */
          T: -1
        },
        /*::[*/
        5086: {
          /* n:"BrtBeginCustomRichFilters", */
          T: 1
        },
        /*::[*/
        5087: {
          /* n:"BrtEndCustomRichFilters", */
          T: -1
        },
        /*::[*/
        5088: {
          /* n:"BrtCustomRichFilter" */
        },
        /*::[*/
        5089: {
          /* n:"BrtTop10RichFilter" */
        },
        /*::[*/
        5090: {
          /* n:"BrtDynamicRichFilter" */
        },
        /*::[*/
        5092: {
          /* n:"BrtBeginRichSortCondition", */
          T: 1
        },
        /*::[*/
        5093: {
          /* n:"BrtEndRichSortCondition", */
          T: -1
        },
        /*::[*/
        5094: {
          /* n:"BrtRichFilterDateGroupItem" */
        },
        /*::[*/
        5095: {
          /* n:"BrtBeginCalcFeatures", */
          T: 1
        },
        /*::[*/
        5096: {
          /* n:"BrtEndCalcFeatures", */
          T: -1
        },
        /*::[*/
        5097: {
          /* n:"BrtCalcFeature" */
        },
        /*::[*/
        5099: {
          /* n:"BrtExternalLinksPr" */
        },
        /*::[*/
        65535: { n: "" }
      };
      var XLSRecordEnum = {
        /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
        /*::[*/
        6: {
          /* n:"Formula", */
          f: parse_Formula
        },
        /*::[*/
        10: {
          /* n:"EOF", */
          f: parsenoop2
        },
        /*::[*/
        12: {
          /* n:"CalcCount", */
          f: parseuint16
        },
        //
        /*::[*/
        13: {
          /* n:"CalcMode", */
          f: parseuint16
        },
        //
        /*::[*/
        14: {
          /* n:"CalcPrecision", */
          f: parsebool
        },
        //
        /*::[*/
        15: {
          /* n:"CalcRefMode", */
          f: parsebool
        },
        //
        /*::[*/
        16: {
          /* n:"CalcDelta", */
          f: parse_Xnum
        },
        //
        /*::[*/
        17: {
          /* n:"CalcIter", */
          f: parsebool
        },
        //
        /*::[*/
        18: {
          /* n:"Protect", */
          f: parsebool
        },
        /*::[*/
        19: {
          /* n:"Password", */
          f: parseuint16
        },
        /*::[*/
        20: {
          /* n:"Header", */
          f: parse_XLHeaderFooter
        },
        /*::[*/
        21: {
          /* n:"Footer", */
          f: parse_XLHeaderFooter
        },
        /*::[*/
        23: {
          /* n:"ExternSheet", */
          f: parse_ExternSheet
        },
        /*::[*/
        24: {
          /* n:"Lbl", */
          f: parse_Lbl
        },
        /*::[*/
        25: {
          /* n:"WinProtect", */
          f: parsebool
        },
        /*::[*/
        26: {
          /* n:"VerticalPageBreaks", */
        },
        /*::[*/
        27: {
          /* n:"HorizontalPageBreaks", */
        },
        /*::[*/
        28: {
          /* n:"Note", */
          f: parse_Note
        },
        /*::[*/
        29: {
          /* n:"Selection", */
        },
        /*::[*/
        34: {
          /* n:"Date1904", */
          f: parsebool
        },
        /*::[*/
        35: {
          /* n:"ExternName", */
          f: parse_ExternName
        },
        /*::[*/
        38: {
          /* n:"LeftMargin", */
          f: parse_Xnum
        },
        // *
        /*::[*/
        39: {
          /* n:"RightMargin", */
          f: parse_Xnum
        },
        // *
        /*::[*/
        40: {
          /* n:"TopMargin", */
          f: parse_Xnum
        },
        // *
        /*::[*/
        41: {
          /* n:"BottomMargin", */
          f: parse_Xnum
        },
        // *
        /*::[*/
        42: {
          /* n:"PrintRowCol", */
          f: parsebool
        },
        /*::[*/
        43: {
          /* n:"PrintGrid", */
          f: parsebool
        },
        /*::[*/
        47: {
          /* n:"FilePass", */
          f: parse_FilePass
        },
        /*::[*/
        49: {
          /* n:"Font", */
          f: parse_Font
        },
        /*::[*/
        51: {
          /* n:"PrintSize", */
          f: parseuint16
        },
        /*::[*/
        60: {
          /* n:"Continue", */
        },
        /*::[*/
        61: {
          /* n:"Window1", */
          f: parse_Window1
        },
        /*::[*/
        64: {
          /* n:"Backup", */
          f: parsebool
        },
        /*::[*/
        65: {
          /* n:"Pane", */
          f: parse_Pane
        },
        /*::[*/
        66: {
          /* n:"CodePage", */
          f: parseuint16
        },
        /*::[*/
        77: {
          /* n:"Pls", */
        },
        /*::[*/
        80: {
          /* n:"DCon", */
        },
        /*::[*/
        81: {
          /* n:"DConRef", */
        },
        /*::[*/
        82: {
          /* n:"DConName", */
        },
        /*::[*/
        85: {
          /* n:"DefColWidth", */
          f: parseuint16
        },
        /*::[*/
        89: {
          /* n:"XCT", */
        },
        /*::[*/
        90: {
          /* n:"CRN", */
        },
        /*::[*/
        91: {
          /* n:"FileSharing", */
        },
        /*::[*/
        92: {
          /* n:"WriteAccess", */
          f: parse_WriteAccess
        },
        /*::[*/
        93: {
          /* n:"Obj", */
          f: parse_Obj
        },
        /*::[*/
        94: {
          /* n:"Uncalced", */
        },
        /*::[*/
        95: {
          /* n:"CalcSaveRecalc", */
          f: parsebool
        },
        //
        /*::[*/
        96: {
          /* n:"Template", */
        },
        /*::[*/
        97: {
          /* n:"Intl", */
        },
        /*::[*/
        99: {
          /* n:"ObjProtect", */
          f: parsebool
        },
        /*::[*/
        125: {
          /* n:"ColInfo", */
          f: parse_ColInfo
        },
        /*::[*/
        128: {
          /* n:"Guts", */
          f: parse_Guts
        },
        /*::[*/
        129: {
          /* n:"WsBool", */
          f: parse_WsBool
        },
        /*::[*/
        130: {
          /* n:"GridSet", */
          f: parseuint16
        },
        /*::[*/
        131: {
          /* n:"HCenter", */
          f: parsebool
        },
        /*::[*/
        132: {
          /* n:"VCenter", */
          f: parsebool
        },
        /*::[*/
        133: {
          /* n:"BoundSheet8", */
          f: parse_BoundSheet8
        },
        /*::[*/
        134: {
          /* n:"WriteProtect", */
        },
        /*::[*/
        140: {
          /* n:"Country", */
          f: parse_Country
        },
        /*::[*/
        141: {
          /* n:"HideObj", */
          f: parseuint16
        },
        /*::[*/
        144: {
          /* n:"Sort", */
        },
        /*::[*/
        146: {
          /* n:"Palette", */
          f: parse_Palette
        },
        /*::[*/
        151: {
          /* n:"Sync", */
        },
        /*::[*/
        152: {
          /* n:"LPr", */
        },
        /*::[*/
        153: {
          /* n:"DxGCol", */
        },
        /*::[*/
        154: {
          /* n:"FnGroupName", */
        },
        /*::[*/
        155: {
          /* n:"FilterMode", */
        },
        /*::[*/
        156: {
          /* n:"BuiltInFnGroupCount", */
          f: parseuint16
        },
        /*::[*/
        157: {
          /* n:"AutoFilterInfo", */
        },
        /*::[*/
        158: {
          /* n:"AutoFilter", */
        },
        /*::[*/
        160: {
          /* n:"Scl", */
          f: parse_Scl
        },
        /*::[*/
        161: {
          /* n:"Setup", */
          f: parse_Setup
        },
        /*::[*/
        174: {
          /* n:"ScenMan", */
        },
        /*::[*/
        175: {
          /* n:"SCENARIO", */
        },
        /*::[*/
        176: {
          /* n:"SxView", */
        },
        /*::[*/
        177: {
          /* n:"Sxvd", */
        },
        /*::[*/
        178: {
          /* n:"SXVI", */
        },
        /*::[*/
        180: {
          /* n:"SxIvd", */
        },
        /*::[*/
        181: {
          /* n:"SXLI", */
        },
        /*::[*/
        182: {
          /* n:"SXPI", */
        },
        /*::[*/
        184: {
          /* n:"DocRoute", */
        },
        /*::[*/
        185: {
          /* n:"RecipName", */
        },
        /*::[*/
        189: {
          /* n:"MulRk", */
          f: parse_MulRk
        },
        /*::[*/
        190: {
          /* n:"MulBlank", */
          f: parse_MulBlank
        },
        /*::[*/
        193: {
          /* n:"Mms", */
          f: parsenoop2
        },
        /*::[*/
        197: {
          /* n:"SXDI", */
        },
        /*::[*/
        198: {
          /* n:"SXDB", */
        },
        /*::[*/
        199: {
          /* n:"SXFDB", */
        },
        /*::[*/
        200: {
          /* n:"SXDBB", */
        },
        /*::[*/
        201: {
          /* n:"SXNum", */
        },
        /*::[*/
        202: {
          /* n:"SxBool", */
          f: parsebool
        },
        /*::[*/
        203: {
          /* n:"SxErr", */
        },
        /*::[*/
        204: {
          /* n:"SXInt", */
        },
        /*::[*/
        205: {
          /* n:"SXString", */
        },
        /*::[*/
        206: {
          /* n:"SXDtr", */
        },
        /*::[*/
        207: {
          /* n:"SxNil", */
        },
        /*::[*/
        208: {
          /* n:"SXTbl", */
        },
        /*::[*/
        209: {
          /* n:"SXTBRGIITM", */
        },
        /*::[*/
        210: {
          /* n:"SxTbpg", */
        },
        /*::[*/
        211: {
          /* n:"ObProj", */
        },
        /*::[*/
        213: {
          /* n:"SXStreamID", */
        },
        /*::[*/
        215: {
          /* n:"DBCell", */
        },
        /*::[*/
        216: {
          /* n:"SXRng", */
        },
        /*::[*/
        217: {
          /* n:"SxIsxoper", */
        },
        /*::[*/
        218: {
          /* n:"BookBool", */
          f: parseuint16
        },
        /*::[*/
        220: {
          /* n:"DbOrParamQry", */
        },
        /*::[*/
        221: {
          /* n:"ScenarioProtect", */
          f: parsebool
        },
        /*::[*/
        222: {
          /* n:"OleObjectSize", */
        },
        /*::[*/
        224: {
          /* n:"XF", */
          f: parse_XF
        },
        /*::[*/
        225: {
          /* n:"InterfaceHdr", */
          f: parse_InterfaceHdr
        },
        /*::[*/
        226: {
          /* n:"InterfaceEnd", */
          f: parsenoop2
        },
        /*::[*/
        227: {
          /* n:"SXVS", */
        },
        /*::[*/
        229: {
          /* n:"MergeCells", */
          f: parse_MergeCells
        },
        /*::[*/
        233: {
          /* n:"BkHim", */
        },
        /*::[*/
        235: {
          /* n:"MsoDrawingGroup", */
        },
        /*::[*/
        236: {
          /* n:"MsoDrawing", */
        },
        /*::[*/
        237: {
          /* n:"MsoDrawingSelection", */
        },
        /*::[*/
        239: {
          /* n:"PhoneticInfo", */
        },
        /*::[*/
        240: {
          /* n:"SxRule", */
        },
        /*::[*/
        241: {
          /* n:"SXEx", */
        },
        /*::[*/
        242: {
          /* n:"SxFilt", */
        },
        /*::[*/
        244: {
          /* n:"SxDXF", */
        },
        /*::[*/
        245: {
          /* n:"SxItm", */
        },
        /*::[*/
        246: {
          /* n:"SxName", */
        },
        /*::[*/
        247: {
          /* n:"SxSelect", */
        },
        /*::[*/
        248: {
          /* n:"SXPair", */
        },
        /*::[*/
        249: {
          /* n:"SxFmla", */
        },
        /*::[*/
        251: {
          /* n:"SxFormat", */
        },
        /*::[*/
        252: {
          /* n:"SST", */
          f: parse_SST
        },
        /*::[*/
        253: {
          /* n:"LabelSst", */
          f: parse_LabelSst
        },
        /*::[*/
        255: {
          /* n:"ExtSST", */
          f: parse_ExtSST
        },
        /*::[*/
        256: {
          /* n:"SXVDEx", */
        },
        /*::[*/
        259: {
          /* n:"SXFormula", */
        },
        /*::[*/
        290: {
          /* n:"SXDBEx", */
        },
        /*::[*/
        311: {
          /* n:"RRDInsDel", */
        },
        /*::[*/
        312: {
          /* n:"RRDHead", */
        },
        /*::[*/
        315: {
          /* n:"RRDChgCell", */
        },
        /*::[*/
        317: {
          /* n:"RRTabId", */
          f: parseuint16a
        },
        /*::[*/
        318: {
          /* n:"RRDRenSheet", */
        },
        /*::[*/
        319: {
          /* n:"RRSort", */
        },
        /*::[*/
        320: {
          /* n:"RRDMove", */
        },
        /*::[*/
        330: {
          /* n:"RRFormat", */
        },
        /*::[*/
        331: {
          /* n:"RRAutoFmt", */
        },
        /*::[*/
        333: {
          /* n:"RRInsertSh", */
        },
        /*::[*/
        334: {
          /* n:"RRDMoveBegin", */
        },
        /*::[*/
        335: {
          /* n:"RRDMoveEnd", */
        },
        /*::[*/
        336: {
          /* n:"RRDInsDelBegin", */
        },
        /*::[*/
        337: {
          /* n:"RRDInsDelEnd", */
        },
        /*::[*/
        338: {
          /* n:"RRDConflict", */
        },
        /*::[*/
        339: {
          /* n:"RRDDefName", */
        },
        /*::[*/
        340: {
          /* n:"RRDRstEtxp", */
        },
        /*::[*/
        351: {
          /* n:"LRng", */
        },
        /*::[*/
        352: {
          /* n:"UsesELFs", */
          f: parsebool
        },
        /*::[*/
        353: {
          /* n:"DSF", */
          f: parsenoop2
        },
        /*::[*/
        401: {
          /* n:"CUsr", */
        },
        /*::[*/
        402: {
          /* n:"CbUsr", */
        },
        /*::[*/
        403: {
          /* n:"UsrInfo", */
        },
        /*::[*/
        404: {
          /* n:"UsrExcl", */
        },
        /*::[*/
        405: {
          /* n:"FileLock", */
        },
        /*::[*/
        406: {
          /* n:"RRDInfo", */
        },
        /*::[*/
        407: {
          /* n:"BCUsrs", */
        },
        /*::[*/
        408: {
          /* n:"UsrChk", */
        },
        /*::[*/
        425: {
          /* n:"UserBView", */
        },
        /*::[*/
        426: {
          /* n:"UserSViewBegin", */
        },
        /*::[*/
        427: {
          /* n:"UserSViewEnd", */
        },
        /*::[*/
        428: {
          /* n:"RRDUserView", */
        },
        /*::[*/
        429: {
          /* n:"Qsi", */
        },
        /*::[*/
        430: {
          /* n:"SupBook", */
          f: parse_SupBook
        },
        /*::[*/
        431: {
          /* n:"Prot4Rev", */
          f: parsebool
        },
        /*::[*/
        432: {
          /* n:"CondFmt", */
        },
        /*::[*/
        433: {
          /* n:"CF", */
        },
        /*::[*/
        434: {
          /* n:"DVal", */
        },
        /*::[*/
        437: {
          /* n:"DConBin", */
        },
        /*::[*/
        438: {
          /* n:"TxO", */
          f: parse_TxO
        },
        /*::[*/
        439: {
          /* n:"RefreshAll", */
          f: parsebool
        },
        //
        /*::[*/
        440: {
          /* n:"HLink", */
          f: parse_HLink
        },
        /*::[*/
        441: {
          /* n:"Lel", */
        },
        /*::[*/
        442: {
          /* n:"CodeName", */
          f: parse_XLUnicodeString
        },
        /*::[*/
        443: {
          /* n:"SXFDBType", */
        },
        /*::[*/
        444: {
          /* n:"Prot4RevPass", */
          f: parseuint16
        },
        /*::[*/
        445: {
          /* n:"ObNoMacros", */
        },
        /*::[*/
        446: {
          /* n:"Dv", */
        },
        /*::[*/
        448: {
          /* n:"Excel9File", */
          f: parsenoop2
        },
        /*::[*/
        449: {
          /* n:"RecalcId", */
          f: parse_RecalcId,
          r: 2
        },
        /*::[*/
        450: {
          /* n:"EntExU2", */
          f: parsenoop2
        },
        /*::[*/
        512: {
          /* n:"Dimensions", */
          f: parse_Dimensions
        },
        /*::[*/
        513: {
          /* n:"Blank", */
          f: parse_Blank
        },
        /*::[*/
        515: {
          /* n:"Number", */
          f: parse_Number
        },
        /*::[*/
        516: {
          /* n:"Label", */
          f: parse_Label
        },
        /*::[*/
        517: {
          /* n:"BoolErr", */
          f: parse_BoolErr
        },
        /*::[*/
        519: {
          /* n:"String", */
          f: parse_String
        },
        /*::[*/
        520: {
          /* n:"Row", */
          f: parse_Row
        },
        /*::[*/
        523: {
          /* n:"Index", */
        },
        /*::[*/
        545: {
          /* n:"Array", */
          f: parse_Array
        },
        /*::[*/
        549: {
          /* n:"DefaultRowHeight", */
          f: parse_DefaultRowHeight
        },
        /*::[*/
        566: {
          /* n:"Table", */
        },
        /*::[*/
        574: {
          /* n:"Window2", */
          f: parse_Window2
        },
        /*::[*/
        638: {
          /* n:"RK", */
          f: parse_RK
        },
        /*::[*/
        659: {
          /* n:"Style", */
        },
        /*::[*/
        1048: {
          /* n:"BigName", */
        },
        /*::[*/
        1054: {
          /* n:"Format", */
          f: parse_Format
        },
        /*::[*/
        1084: {
          /* n:"ContinueBigName", */
        },
        /*::[*/
        1212: {
          /* n:"ShrFmla", */
          f: parse_ShrFmla
        },
        /*::[*/
        2048: {
          /* n:"HLinkTooltip", */
          f: parse_HLinkTooltip
        },
        /*::[*/
        2049: {
          /* n:"WebPub", */
        },
        /*::[*/
        2050: {
          /* n:"QsiSXTag", */
        },
        /*::[*/
        2051: {
          /* n:"DBQueryExt", */
        },
        /*::[*/
        2052: {
          /* n:"ExtString", */
        },
        /*::[*/
        2053: {
          /* n:"TxtQry", */
        },
        /*::[*/
        2054: {
          /* n:"Qsir", */
        },
        /*::[*/
        2055: {
          /* n:"Qsif", */
        },
        /*::[*/
        2056: {
          /* n:"RRDTQSIF", */
        },
        /*::[*/
        2057: {
          /* n:"BOF", */
          f: parse_BOF
        },
        /*::[*/
        2058: {
          /* n:"OleDbConn", */
        },
        /*::[*/
        2059: {
          /* n:"WOpt", */
        },
        /*::[*/
        2060: {
          /* n:"SXViewEx", */
        },
        /*::[*/
        2061: {
          /* n:"SXTH", */
        },
        /*::[*/
        2062: {
          /* n:"SXPIEx", */
        },
        /*::[*/
        2063: {
          /* n:"SXVDTEx", */
        },
        /*::[*/
        2064: {
          /* n:"SXViewEx9", */
        },
        /*::[*/
        2066: {
          /* n:"ContinueFrt", */
        },
        /*::[*/
        2067: {
          /* n:"RealTimeData", */
        },
        /*::[*/
        2128: {
          /* n:"ChartFrtInfo", */
        },
        /*::[*/
        2129: {
          /* n:"FrtWrapper", */
        },
        /*::[*/
        2130: {
          /* n:"StartBlock", */
        },
        /*::[*/
        2131: {
          /* n:"EndBlock", */
        },
        /*::[*/
        2132: {
          /* n:"StartObject", */
        },
        /*::[*/
        2133: {
          /* n:"EndObject", */
        },
        /*::[*/
        2134: {
          /* n:"CatLab", */
        },
        /*::[*/
        2135: {
          /* n:"YMult", */
        },
        /*::[*/
        2136: {
          /* n:"SXViewLink", */
        },
        /*::[*/
        2137: {
          /* n:"PivotChartBits", */
        },
        /*::[*/
        2138: {
          /* n:"FrtFontList", */
        },
        /*::[*/
        2146: {
          /* n:"SheetExt", */
        },
        /*::[*/
        2147: {
          /* n:"BookExt", */
          r: 12
        },
        /*::[*/
        2148: {
          /* n:"SXAddl", */
        },
        /*::[*/
        2149: {
          /* n:"CrErr", */
        },
        /*::[*/
        2150: {
          /* n:"HFPicture", */
        },
        /*::[*/
        2151: {
          /* n:"FeatHdr", */
          f: parsenoop2
        },
        /*::[*/
        2152: {
          /* n:"Feat", */
        },
        /*::[*/
        2154: {
          /* n:"DataLabExt", */
        },
        /*::[*/
        2155: {
          /* n:"DataLabExtContents", */
        },
        /*::[*/
        2156: {
          /* n:"CellWatch", */
        },
        /*::[*/
        2161: {
          /* n:"FeatHdr11", */
        },
        /*::[*/
        2162: {
          /* n:"Feature11", */
        },
        /*::[*/
        2164: {
          /* n:"DropDownObjIds", */
        },
        /*::[*/
        2165: {
          /* n:"ContinueFrt11", */
        },
        /*::[*/
        2166: {
          /* n:"DConn", */
        },
        /*::[*/
        2167: {
          /* n:"List12", */
        },
        /*::[*/
        2168: {
          /* n:"Feature12", */
        },
        /*::[*/
        2169: {
          /* n:"CondFmt12", */
        },
        /*::[*/
        2170: {
          /* n:"CF12", */
        },
        /*::[*/
        2171: {
          /* n:"CFEx", */
        },
        /*::[*/
        2172: {
          /* n:"XFCRC", */
          f: parse_XFCRC,
          r: 12
        },
        /*::[*/
        2173: {
          /* n:"XFExt", */
          f: parse_XFExt,
          r: 12
        },
        /*::[*/
        2174: {
          /* n:"AutoFilter12", */
        },
        /*::[*/
        2175: {
          /* n:"ContinueFrt12", */
        },
        /*::[*/
        2180: {
          /* n:"MDTInfo", */
        },
        /*::[*/
        2181: {
          /* n:"MDXStr", */
        },
        /*::[*/
        2182: {
          /* n:"MDXTuple", */
        },
        /*::[*/
        2183: {
          /* n:"MDXSet", */
        },
        /*::[*/
        2184: {
          /* n:"MDXProp", */
        },
        /*::[*/
        2185: {
          /* n:"MDXKPI", */
        },
        /*::[*/
        2186: {
          /* n:"MDB", */
        },
        /*::[*/
        2187: {
          /* n:"PLV", */
        },
        /*::[*/
        2188: {
          /* n:"Compat12", */
          f: parsebool,
          r: 12
        },
        /*::[*/
        2189: {
          /* n:"DXF", */
        },
        /*::[*/
        2190: {
          /* n:"TableStyles", */
          r: 12
        },
        /*::[*/
        2191: {
          /* n:"TableStyle", */
        },
        /*::[*/
        2192: {
          /* n:"TableStyleElement", */
        },
        /*::[*/
        2194: {
          /* n:"StyleExt", */
        },
        /*::[*/
        2195: {
          /* n:"NamePublish", */
        },
        /*::[*/
        2196: {
          /* n:"NameCmt", */
          f: parse_NameCmt,
          r: 12
        },
        /*::[*/
        2197: {
          /* n:"SortData", */
        },
        /*::[*/
        2198: {
          /* n:"Theme", */
          f: parse_Theme,
          r: 12
        },
        /*::[*/
        2199: {
          /* n:"GUIDTypeLib", */
        },
        /*::[*/
        2200: {
          /* n:"FnGrp12", */
        },
        /*::[*/
        2201: {
          /* n:"NameFnGrp12", */
        },
        /*::[*/
        2202: {
          /* n:"MTRSettings", */
          f: parse_MTRSettings,
          r: 12
        },
        /*::[*/
        2203: {
          /* n:"CompressPictures", */
          f: parsenoop2
        },
        /*::[*/
        2204: {
          /* n:"HeaderFooter", */
        },
        /*::[*/
        2205: {
          /* n:"CrtLayout12", */
        },
        /*::[*/
        2206: {
          /* n:"CrtMlFrt", */
        },
        /*::[*/
        2207: {
          /* n:"CrtMlFrtContinue", */
        },
        /*::[*/
        2211: {
          /* n:"ForceFullCalculation", */
          f: parse_ForceFullCalculation
        },
        /*::[*/
        2212: {
          /* n:"ShapePropsStream", */
        },
        /*::[*/
        2213: {
          /* n:"TextPropsStream", */
        },
        /*::[*/
        2214: {
          /* n:"RichTextStream", */
        },
        /*::[*/
        2215: {
          /* n:"CrtLayout12A", */
        },
        /*::[*/
        4097: {
          /* n:"Units", */
        },
        /*::[*/
        4098: {
          /* n:"Chart", */
        },
        /*::[*/
        4099: {
          /* n:"Series", */
        },
        /*::[*/
        4102: {
          /* n:"DataFormat", */
        },
        /*::[*/
        4103: {
          /* n:"LineFormat", */
        },
        /*::[*/
        4105: {
          /* n:"MarkerFormat", */
        },
        /*::[*/
        4106: {
          /* n:"AreaFormat", */
        },
        /*::[*/
        4107: {
          /* n:"PieFormat", */
        },
        /*::[*/
        4108: {
          /* n:"AttachedLabel", */
        },
        /*::[*/
        4109: {
          /* n:"SeriesText", */
        },
        /*::[*/
        4116: {
          /* n:"ChartFormat", */
        },
        /*::[*/
        4117: {
          /* n:"Legend", */
        },
        /*::[*/
        4118: {
          /* n:"SeriesList", */
        },
        /*::[*/
        4119: {
          /* n:"Bar", */
        },
        /*::[*/
        4120: {
          /* n:"Line", */
        },
        /*::[*/
        4121: {
          /* n:"Pie", */
        },
        /*::[*/
        4122: {
          /* n:"Area", */
        },
        /*::[*/
        4123: {
          /* n:"Scatter", */
        },
        /*::[*/
        4124: {
          /* n:"CrtLine", */
        },
        /*::[*/
        4125: {
          /* n:"Axis", */
        },
        /*::[*/
        4126: {
          /* n:"Tick", */
        },
        /*::[*/
        4127: {
          /* n:"ValueRange", */
        },
        /*::[*/
        4128: {
          /* n:"CatSerRange", */
        },
        /*::[*/
        4129: {
          /* n:"AxisLine", */
        },
        /*::[*/
        4130: {
          /* n:"CrtLink", */
        },
        /*::[*/
        4132: {
          /* n:"DefaultText", */
        },
        /*::[*/
        4133: {
          /* n:"Text", */
        },
        /*::[*/
        4134: {
          /* n:"FontX", */
          f: parseuint16
        },
        /*::[*/
        4135: {
          /* n:"ObjectLink", */
        },
        /*::[*/
        4146: {
          /* n:"Frame", */
        },
        /*::[*/
        4147: {
          /* n:"Begin", */
        },
        /*::[*/
        4148: {
          /* n:"End", */
        },
        /*::[*/
        4149: {
          /* n:"PlotArea", */
        },
        /*::[*/
        4154: {
          /* n:"Chart3d", */
        },
        /*::[*/
        4156: {
          /* n:"PicF", */
        },
        /*::[*/
        4157: {
          /* n:"DropBar", */
        },
        /*::[*/
        4158: {
          /* n:"Radar", */
        },
        /*::[*/
        4159: {
          /* n:"Surf", */
        },
        /*::[*/
        4160: {
          /* n:"RadarArea", */
        },
        /*::[*/
        4161: {
          /* n:"AxisParent", */
        },
        /*::[*/
        4163: {
          /* n:"LegendException", */
        },
        /*::[*/
        4164: {
          /* n:"ShtProps", */
          f: parse_ShtProps
        },
        /*::[*/
        4165: {
          /* n:"SerToCrt", */
        },
        /*::[*/
        4166: {
          /* n:"AxesUsed", */
        },
        /*::[*/
        4168: {
          /* n:"SBaseRef", */
        },
        /*::[*/
        4170: {
          /* n:"SerParent", */
        },
        /*::[*/
        4171: {
          /* n:"SerAuxTrend", */
        },
        /*::[*/
        4174: {
          /* n:"IFmtRecord", */
        },
        /*::[*/
        4175: {
          /* n:"Pos", */
        },
        /*::[*/
        4176: {
          /* n:"AlRuns", */
        },
        /*::[*/
        4177: {
          /* n:"BRAI", */
        },
        /*::[*/
        4187: {
          /* n:"SerAuxErrBar", */
        },
        /*::[*/
        4188: {
          /* n:"ClrtClient", */
          f: parse_ClrtClient
        },
        /*::[*/
        4189: {
          /* n:"SerFmt", */
        },
        /*::[*/
        4191: {
          /* n:"Chart3DBarShape", */
        },
        /*::[*/
        4192: {
          /* n:"Fbi", */
        },
        /*::[*/
        4193: {
          /* n:"BopPop", */
        },
        /*::[*/
        4194: {
          /* n:"AxcExt", */
        },
        /*::[*/
        4195: {
          /* n:"Dat", */
        },
        /*::[*/
        4196: {
          /* n:"PlotGrowth", */
        },
        /*::[*/
        4197: {
          /* n:"SIIndex", */
        },
        /*::[*/
        4198: {
          /* n:"GelFrame", */
        },
        /*::[*/
        4199: {
          /* n:"BopPopCustom", */
        },
        /*::[*/
        4200: {
          /* n:"Fbi2", */
        },
        /*::[*/
        0: {
          /* n:"Dimensions", */
          f: parse_Dimensions
        },
        /*::[*/
        1: {
          /* n:"BIFF2BLANK", */
        },
        /*::[*/
        2: {
          /* n:"BIFF2INT", */
          f: parse_BIFF2INT
        },
        /*::[*/
        3: {
          /* n:"BIFF2NUM", */
          f: parse_BIFF2NUM
        },
        /*::[*/
        4: {
          /* n:"BIFF2STR", */
          f: parse_BIFF2STR
        },
        /*::[*/
        5: {
          /* n:"BoolErr", */
          f: parse_BoolErr
        },
        /*::[*/
        7: {
          /* n:"String", */
          f: parse_BIFF2STRING
        },
        /*::[*/
        8: {
          /* n:"BIFF2ROW", */
        },
        /*::[*/
        9: {
          /* n:"BOF", */
          f: parse_BOF
        },
        /*::[*/
        11: {
          /* n:"Index", */
        },
        /*::[*/
        22: {
          /* n:"ExternCount", */
          f: parseuint16
        },
        /*::[*/
        30: {
          /* n:"BIFF2FORMAT", */
          f: parse_BIFF2Format
        },
        /*::[*/
        31: {
          /* n:"BIFF2FMTCNT", */
        },
        /* 16-bit cnt of BIFF2FORMAT records */
        /*::[*/
        32: {
          /* n:"BIFF2COLINFO", */
        },
        /*::[*/
        33: {
          /* n:"Array", */
          f: parse_Array
        },
        /*::[*/
        36: {
          /* n:"COLWIDTH", */
        },
        /*::[*/
        37: {
          /* n:"DefaultRowHeight", */
          f: parse_DefaultRowHeight
        },
        // 0x2c ??
        // 0x2d ??
        // 0x2e ??
        // 0x30 FONTCOUNT: number of fonts
        /*::[*/
        50: {
          /* n:"BIFF2FONTXTRA", */
          f: parse_BIFF2FONTXTRA
        },
        // 0x35: INFOOPTS
        // 0x36: TABLE (BIFF2 only)
        // 0x37: TABLE2 (BIFF2 only)
        // 0x38: WNDESK
        // 0x39 ??
        // 0x3a: BEGINPREF
        // 0x3b: ENDPREF
        /*::[*/
        62: {
          /* n:"BIFF2WINDOW2", */
        },
        // 0x3f ??
        // 0x46: SHOWSCROLL
        // 0x47: SHOWFORMULA
        // 0x48: STATUSBAR
        // 0x49: SHORTMENUS
        // 0x4A:
        // 0x4B:
        // 0x4C:
        // 0x4E:
        // 0x4F:
        // 0x58: TOOLBAR (BIFF3)
        /* - - - */
        /*::[*/
        52: {
          /* n:"DDEObjName", */
        },
        /*::[*/
        67: {
          /* n:"BIFF2XF", */
        },
        /*::[*/
        68: {
          /* n:"BIFF2XFINDEX", */
          f: parseuint16
        },
        /*::[*/
        69: {
          /* n:"BIFF2FONTCLR", */
        },
        /*::[*/
        86: {
          /* n:"BIFF4FMTCNT", */
        },
        /* 16-bit cnt, similar to BIFF2 */
        /*::[*/
        126: {
          /* n:"RK", */
        },
        /* Not necessarily same as 0x027e */
        /*::[*/
        127: {
          /* n:"ImData", */
          f: parse_ImData
        },
        /*::[*/
        135: {
          /* n:"Addin", */
        },
        /*::[*/
        136: {
          /* n:"Edg", */
        },
        /*::[*/
        137: {
          /* n:"Pub", */
        },
        // 0x8A
        // 0x8B LH: alternate menu key flag (BIFF3/4)
        // 0x8E
        // 0x8F
        /*::[*/
        145: {
          /* n:"Sub", */
        },
        // 0x93 STYLE
        /*::[*/
        148: {
          /* n:"LHRecord", */
        },
        /*::[*/
        149: {
          /* n:"LHNGraph", */
        },
        /*::[*/
        150: {
          /* n:"Sound", */
        },
        // 0xA2 FNPROTO: function prototypes (BIFF4)
        // 0xA3
        // 0xA8
        /*::[*/
        169: {
          /* n:"CoordList", */
        },
        /*::[*/
        171: {
          /* n:"GCW", */
        },
        /*::[*/
        188: {
          /* n:"ShrFmla", */
        },
        /* Not necessarily same as 0x04bc */
        /*::[*/
        191: {
          /* n:"ToolbarHdr", */
        },
        /*::[*/
        192: {
          /* n:"ToolbarEnd", */
        },
        /*::[*/
        194: {
          /* n:"AddMenu", */
        },
        /*::[*/
        195: {
          /* n:"DelMenu", */
        },
        /*::[*/
        214: {
          /* n:"RString", */
          f: parse_RString
        },
        /*::[*/
        223: {
          /* n:"UDDesc", */
        },
        /*::[*/
        234: {
          /* n:"TabIdConf", */
        },
        /*::[*/
        354: {
          /* n:"XL5Modify", */
        },
        /*::[*/
        421: {
          /* n:"FileSharing2", */
        },
        /*::[*/
        518: {
          /* n:"Formula", */
          f: parse_Formula
        },
        /*::[*/
        521: {
          /* n:"BOF", */
          f: parse_BOF
        },
        /*::[*/
        536: {
          /* n:"Lbl", */
          f: parse_Lbl
        },
        /*::[*/
        547: {
          /* n:"ExternName", */
          f: parse_ExternName
        },
        /*::[*/
        561: {
          /* n:"Font", */
        },
        /*::[*/
        579: {
          /* n:"BIFF3XF", */
        },
        /*::[*/
        1030: {
          /* n:"Formula", */
          f: parse_Formula
        },
        /*::[*/
        1033: {
          /* n:"BOF", */
          f: parse_BOF
        },
        /*::[*/
        1091: {
          /* n:"BIFF4XF", */
        },
        /*::[*/
        2157: {
          /* n:"FeatInfo", */
        },
        /*::[*/
        2163: {
          /* n:"FeatInfo11", */
        },
        /*::[*/
        2177: {
          /* n:"SXAddl12", */
        },
        /*::[*/
        2240: {
          /* n:"AutoWebPub", */
        },
        /*::[*/
        2241: {
          /* n:"ListObj", */
        },
        /*::[*/
        2242: {
          /* n:"ListField", */
        },
        /*::[*/
        2243: {
          /* n:"ListDV", */
        },
        /*::[*/
        2244: {
          /* n:"ListCondFmt", */
        },
        /*::[*/
        2245: {
          /* n:"ListCF", */
        },
        /*::[*/
        2246: {
          /* n:"FMQry", */
        },
        /*::[*/
        2247: {
          /* n:"FMSQry", */
        },
        /*::[*/
        2248: {
          /* n:"PLV", */
        },
        /*::[*/
        2249: {
          /* n:"LnExt", */
        },
        /*::[*/
        2250: {
          /* n:"MkrExt", */
        },
        /*::[*/
        2251: {
          /* n:"CrtCoopt", */
        },
        /*::[*/
        2262: {
          /* n:"FRTArchId$", */
          r: 12
        },
        /*::[*/
        29282: {}
      };
      function write_biff_rec(ba, type2, payload, length) {
        var t = type2;
        if (isNaN(t))
          return;
        var len2 = length || (payload || []).length || 0;
        var o = ba.next(4);
        o.write_shift(2, t);
        o.write_shift(2, len2);
        if (
          /*:: len != null &&*/
          len2 > 0 && is_buf(payload)
        )
          ba.push(payload);
      }
      function html_to_sheet(str, _opts) {
        var opts = _opts || {};
        var ws = opts.dense ? [] : {};
        str = str.replace(/<!--.*?-->/g, "");
        var mtch = str.match(/<table/i);
        if (!mtch)
          throw new Error("Invalid HTML: could not find <table>");
        var mtch2 = str.match(/<\/table/i);
        var i = mtch.index, j = mtch2 && mtch2.index || str.length;
        var rows = split_regex(str.slice(i, j), /(:?<tr[^>]*>)/i, "<tr>");
        var R = -1, C = 0, RS = 0, CS = 0;
        var range2 = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
        var merges = [];
        for (i = 0; i < rows.length; ++i) {
          var row = rows[i].trim();
          var hd = row.slice(0, 3).toLowerCase();
          if (hd == "<tr") {
            ++R;
            if (opts.sheetRows && opts.sheetRows <= R) {
              --R;
              break;
            }
            C = 0;
            continue;
          }
          if (hd != "<td" && hd != "<th")
            continue;
          var cells = row.split(/<\/t[dh]>/i);
          for (j = 0; j < cells.length; ++j) {
            var cell = cells[j].trim();
            if (!cell.match(/<t[dh]/i))
              continue;
            var m = cell, cc = 0;
            while (m.charAt(0) == "<" && (cc = m.indexOf(">")) > -1)
              m = m.slice(cc + 1);
            for (var midx = 0; midx < merges.length; ++midx) {
              var _merge = merges[midx];
              if (_merge.s.c == C && _merge.s.r < R && R <= _merge.e.r) {
                C = _merge.e.c + 1;
                midx = -1;
              }
            }
            var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
            CS = tag.colspan ? +tag.colspan : 1;
            if ((RS = +tag.rowspan) > 1 || CS > 1)
              merges.push({ s: { r: R, c: C }, e: { r: R + (RS || 1) - 1, c: C + CS - 1 } });
            var _t = tag.t || tag["data-t"] || "";
            if (!m.length) {
              C += CS;
              continue;
            }
            m = htmldecode(m);
            if (range2.s.r > R)
              range2.s.r = R;
            if (range2.e.r < R)
              range2.e.r = R;
            if (range2.s.c > C)
              range2.s.c = C;
            if (range2.e.c < C)
              range2.e.c = C;
            if (!m.length) {
              C += CS;
              continue;
            }
            var o = { t: "s", v: m };
            if (opts.raw || !m.trim().length || _t == "s")
              ;
            else if (m === "TRUE")
              o = { t: "b", v: true };
            else if (m === "FALSE")
              o = { t: "b", v: false };
            else if (!isNaN(fuzzynum(m)))
              o = { t: "n", v: fuzzynum(m) };
            else if (!isNaN(fuzzydate(m).getDate())) {
              o = { t: "d", v: parseDate(m) };
              if (!opts.cellDates)
                o = { t: "n", v: datenum(o.v) };
              o.z = opts.dateNF || table_fmt[14];
            }
            if (opts.dense) {
              if (!ws[R])
                ws[R] = [];
              ws[R][C] = o;
            } else
              ws[encode_cell({ r: R, c: C })] = o;
            C += CS;
          }
        }
        ws["!ref"] = encode_range(range2);
        if (merges.length)
          ws["!merges"] = merges;
        return ws;
      }
      function make_html_row(ws, r, R, o) {
        var M = ws["!merges"] || [];
        var oo = [];
        for (var C = r.s.c; C <= r.e.c; ++C) {
          var RS = 0, CS = 0;
          for (var j = 0; j < M.length; ++j) {
            if (M[j].s.r > R || M[j].s.c > C)
              continue;
            if (M[j].e.r < R || M[j].e.c < C)
              continue;
            if (M[j].s.r < R || M[j].s.c < C) {
              RS = -1;
              break;
            }
            RS = M[j].e.r - M[j].s.r + 1;
            CS = M[j].e.c - M[j].s.c + 1;
            break;
          }
          if (RS < 0)
            continue;
          var coord = encode_cell({ r: R, c: C });
          var cell = o.dense ? (ws[R] || [])[C] : ws[coord];
          var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
          var sp = {};
          if (RS > 1)
            sp.rowspan = RS;
          if (CS > 1)
            sp.colspan = CS;
          if (o.editable)
            w = '<span contenteditable="true">' + w + "</span>";
          else if (cell) {
            sp["data-t"] = cell && cell.t || "z";
            if (cell.v != null)
              sp["data-v"] = cell.v;
            if (cell.z != null)
              sp["data-z"] = cell.z;
            if (cell.l && (cell.l.Target || "#").charAt(0) != "#")
              w = '<a href="' + cell.l.Target + '">' + w + "</a>";
          }
          sp.id = (o.id || "sjs") + "-" + coord;
          oo.push(writextag("td", w, sp));
        }
        var preamble = "<tr>";
        return preamble + oo.join("") + "</tr>";
      }
      var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
      var HTML_END = "</body></html>";
      function html_to_workbook(str, opts) {
        var mtch = str.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
        if (!mtch || mtch.length == 0)
          throw new Error("Invalid HTML: could not find <table>");
        if (mtch.length == 1)
          return sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
        var wb = book_new();
        mtch.forEach(function(s, idx) {
          book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx + 1));
        });
        return wb;
      }
      function make_html_preamble(ws, R, o) {
        var out = [];
        return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
      }
      function sheet_to_html(ws, opts) {
        var o = opts || {};
        var header = o.header != null ? o.header : HTML_BEGIN;
        var footer = o.footer != null ? o.footer : HTML_END;
        var out = [header];
        var r = decode_range(ws["!ref"]);
        o.dense = Array.isArray(ws);
        out.push(make_html_preamble(ws, r, o));
        for (var R = r.s.r; R <= r.e.r; ++R)
          out.push(make_html_row(ws, r, R, o));
        out.push("</table>" + footer);
        return out.join("");
      }
      function sheet_add_dom(ws, table, _opts) {
        var opts = _opts || {};
        var or_R = 0, or_C = 0;
        if (opts.origin != null) {
          if (typeof opts.origin == "number")
            or_R = opts.origin;
          else {
            var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
            or_R = _origin.r;
            or_C = _origin.c;
          }
        }
        var rows = table.getElementsByTagName("tr");
        var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
        var range2 = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
        if (ws["!ref"]) {
          var _range = decode_range(ws["!ref"]);
          range2.s.r = Math.min(range2.s.r, _range.s.r);
          range2.s.c = Math.min(range2.s.c, _range.s.c);
          range2.e.r = Math.max(range2.e.r, _range.e.r);
          range2.e.c = Math.max(range2.e.c, _range.e.c);
          if (or_R == -1)
            range2.e.r = or_R = _range.e.r + 1;
        }
        var merges = [], midx = 0;
        var rowinfo = ws["!rows"] || (ws["!rows"] = []);
        var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;
        if (!ws["!cols"])
          ws["!cols"] = [];
        for (; _R < rows.length && R < sheetRows; ++_R) {
          var row = rows[_R];
          if (is_dom_element_hidden(row)) {
            if (opts.display)
              continue;
            rowinfo[R] = { hidden: true };
          }
          var elts = row.children;
          for (_C = C = 0; _C < elts.length; ++_C) {
            var elt = elts[_C];
            if (opts.display && is_dom_element_hidden(elt))
              continue;
            var v = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
            var z = elt.getAttribute("data-z") || elt.getAttribute("z");
            for (midx = 0; midx < merges.length; ++midx) {
              var m = merges[midx];
              if (m.s.c == C + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) {
                C = m.e.c + 1 - or_C;
                midx = -1;
              }
            }
            CS = +elt.getAttribute("colspan") || 1;
            if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1)
              merges.push({ s: { r: R + or_R, c: C + or_C }, e: { r: R + or_R + (RS || 1) - 1, c: C + or_C + (CS || 1) - 1 } });
            var o = { t: "s", v };
            var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
            if (v != null) {
              if (v.length == 0)
                o.t = _t || "z";
              else if (opts.raw || v.trim().length == 0 || _t == "s")
                ;
              else if (v === "TRUE")
                o = { t: "b", v: true };
              else if (v === "FALSE")
                o = { t: "b", v: false };
              else if (!isNaN(fuzzynum(v)))
                o = { t: "n", v: fuzzynum(v) };
              else if (!isNaN(fuzzydate(v).getDate())) {
                o = { t: "d", v: parseDate(v) };
                if (!opts.cellDates)
                  o = { t: "n", v: datenum(o.v) };
                o.z = opts.dateNF || table_fmt[14];
              }
            }
            if (o.z === void 0 && z != null)
              o.z = z;
            var l = "", Aelts = elt.getElementsByTagName("A");
            if (Aelts && Aelts.length) {
              for (var Aelti = 0; Aelti < Aelts.length; ++Aelti)
                if (Aelts[Aelti].hasAttribute("href")) {
                  l = Aelts[Aelti].getAttribute("href");
                  if (l.charAt(0) != "#")
                    break;
                }
            }
            if (l && l.charAt(0) != "#")
              o.l = { Target: l };
            if (opts.dense) {
              if (!ws[R + or_R])
                ws[R + or_R] = [];
              ws[R + or_R][C + or_C] = o;
            } else
              ws[encode_cell({ c: C + or_C, r: R + or_R })] = o;
            if (range2.e.c < C + or_C)
              range2.e.c = C + or_C;
            C += CS;
          }
          ++R;
        }
        if (merges.length)
          ws["!merges"] = (ws["!merges"] || []).concat(merges);
        range2.e.r = Math.max(range2.e.r, R - 1 + or_R);
        ws["!ref"] = encode_range(range2);
        if (R >= sheetRows)
          ws["!fullref"] = encode_range((range2.e.r = rows.length - _R + R - 1 + or_R, range2));
        return ws;
      }
      function parse_dom_table(table, _opts) {
        var opts = _opts || {};
        var ws = opts.dense ? [] : {};
        return sheet_add_dom(ws, table, _opts);
      }
      function table_to_book(table, opts) {
        return sheet_to_workbook(parse_dom_table(table, opts), opts);
      }
      function is_dom_element_hidden(element) {
        var display = "";
        var get_computed_style = get_get_computed_style_function(element);
        if (get_computed_style)
          display = get_computed_style(element).getPropertyValue("display");
        if (!display)
          display = element.style && element.style.display;
        return display === "none";
      }
      function get_get_computed_style_function(element) {
        if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function")
          return element.ownerDocument.defaultView.getComputedStyle;
        if (typeof getComputedStyle === "function")
          return getComputedStyle;
        return null;
      }
      function parse_text_p(text) {
        var fixed = text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
          return Array(parseInt($1, 10) + 1).join(" ");
        }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
        var v = unescapexml(fixed.replace(/<[^>]*>/g, ""));
        return [v];
      }
      var number_formats_ods = {
        /* ods name: [short ssf fmt, long ssf fmt] */
        day: ["d", "dd"],
        month: ["m", "mm"],
        year: ["y", "yy"],
        hours: ["h", "hh"],
        minutes: ["m", "mm"],
        seconds: ["s", "ss"],
        "am-pm": ["A/P", "AM/PM"],
        "day-of-week": ["ddd", "dddd"],
        era: ["e", "ee"],
        /* there is no native representation of LO "Q" format */
        quarter: ["\\Qm", 'm\\"th quarter"']
      };
      function parse_content_xml(d, _opts) {
        var opts = _opts || {};
        var str = xlml_normalize(d);
        var state = [], tmp;
        var tag;
        var NFtag = { name: "" }, NF = "", pidx = 0;
        var sheetag;
        var rowtag;
        var Sheets = {}, SheetNames = [];
        var ws = opts.dense ? [] : {};
        var Rn, q;
        var ctag = { value: "" };
        var textp = "", textpidx = 0;
        var textR = [];
        var R = -1, C = -1, range2 = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
        var row_ol = 0;
        var number_format_map = {};
        var merges = [], mrange = {}, mR = 0, mC = 0;
        var rowinfo = [], rowpeat = 1, colpeat = 1;
        var arrayf = [];
        var WB = { Names: [] };
        var atag = {};
        var _Ref = ["", ""];
        var comments = [], comment = {};
        var creator = "", creatoridx = 0;
        var isstub = false, intable = false;
        var i = 0;
        xlmlregex.lastIndex = 0;
        str = str.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
        while (Rn = xlmlregex.exec(str))
          switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
            case "table":
            case "":
              if (Rn[1] === "/") {
                if (range2.e.c >= range2.s.c && range2.e.r >= range2.s.r)
                  ws["!ref"] = encode_range(range2);
                else
                  ws["!ref"] = "A1:A1";
                if (opts.sheetRows > 0 && opts.sheetRows <= range2.e.r) {
                  ws["!fullref"] = ws["!ref"];
                  range2.e.r = opts.sheetRows - 1;
                  ws["!ref"] = encode_range(range2);
                }
                if (merges.length)
                  ws["!merges"] = merges;
                if (rowinfo.length)
                  ws["!rows"] = rowinfo;
                sheetag.name = sheetag[""] || sheetag.name;
                if (typeof JSON !== "undefined")
                  JSON.stringify(sheetag);
                SheetNames.push(sheetag.name);
                Sheets[sheetag.name] = ws;
                intable = false;
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                sheetag = parsexmltag(Rn[0], false);
                R = C = -1;
                range2.s.r = range2.s.c = 1e7;
                range2.e.r = range2.e.c = 0;
                ws = opts.dense ? [] : {};
                merges = [];
                rowinfo = [];
                intable = true;
              }
              break;
            case "table-row-group":
              if (Rn[1] === "/")
                --row_ol;
              else
                ++row_ol;
              break;
            case "table-row":
            case "":
              if (Rn[1] === "/") {
                R += rowpeat;
                rowpeat = 1;
                break;
              }
              rowtag = parsexmltag(Rn[0], false);
              if (rowtag[""])
                R = rowtag[""] - 1;
              else if (R == -1)
                R = 0;
              rowpeat = +rowtag["number-rows-repeated"] || 1;
              if (rowpeat < 10) {
                for (i = 0; i < rowpeat; ++i)
                  if (row_ol > 0)
                    rowinfo[R + i] = { level: row_ol };
              }
              C = -1;
              break;
            case "covered-table-cell":
              if (Rn[1] !== "/")
                ++C;
              if (opts.sheetStubs) {
                if (opts.dense) {
                  if (!ws[R])
                    ws[R] = [];
                  ws[R][C] = { t: "z" };
                } else
                  ws[encode_cell({ r: R, c: C })] = { t: "z" };
              }
              textp = "";
              textR = [];
              break;
            case "table-cell":
            case "":
              if (Rn[0].charAt(Rn[0].length - 2) === "/") {
                ++C;
                ctag = parsexmltag(Rn[0], false);
                colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                q = {
                  t: "z",
                  v: null
                  /*:: , z:null, w:"",c:[]*/
                };
                if (ctag.formula && opts.cellFormula != false)
                  q.f = ods_to_csf_formula(unescapexml(ctag.formula));
                if ((ctag[""] || ctag["value-type"]) == "string") {
                  q.t = "s";
                  q.v = unescapexml(ctag["string-value"] || "");
                  if (opts.dense) {
                    if (!ws[R])
                      ws[R] = [];
                    ws[R][C] = q;
                  } else {
                    ws[encode_cell({ r: R, c: C })] = q;
                  }
                }
                C += colpeat - 1;
              } else if (Rn[1] !== "/") {
                ++C;
                textp = "";
                textpidx = 0;
                textR = [];
                colpeat = 1;
                var rptR = rowpeat ? R + rowpeat - 1 : R;
                if (C > range2.e.c)
                  range2.e.c = C;
                if (C < range2.s.c)
                  range2.s.c = C;
                if (R < range2.s.r)
                  range2.s.r = R;
                if (rptR > range2.e.r)
                  range2.e.r = rptR;
                ctag = parsexmltag(Rn[0], false);
                comments = [];
                comment = {};
                q = {
                  t: ctag[""] || ctag["value-type"],
                  v: null
                  /*:: , z:null, w:"",c:[]*/
                };
                if (opts.cellFormula) {
                  if (ctag.formula)
                    ctag.formula = unescapexml(ctag.formula);
                  if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
                    mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
                    mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
                    mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
                    q.F = encode_range(mrange);
                    arrayf.push([mrange, q.F]);
                  }
                  if (ctag.formula)
                    q.f = ods_to_csf_formula(ctag.formula);
                  else
                    for (i = 0; i < arrayf.length; ++i)
                      if (R >= arrayf[i][0].s.r && R <= arrayf[i][0].e.r) {
                        if (C >= arrayf[i][0].s.c && C <= arrayf[i][0].e.c)
                          q.F = arrayf[i][1];
                      }
                }
                if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
                  mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
                  mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
                  mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
                  merges.push(mrange);
                }
                if (ctag["number-columns-repeated"])
                  colpeat = parseInt(ctag["number-columns-repeated"], 10);
                switch (q.t) {
                  case "boolean":
                    q.t = "b";
                    q.v = parsexmlbool(ctag["boolean-value"]);
                    break;
                  case "float":
                    q.t = "n";
                    q.v = parseFloat(ctag.value);
                    break;
                  case "percentage":
                    q.t = "n";
                    q.v = parseFloat(ctag.value);
                    break;
                  case "currency":
                    q.t = "n";
                    q.v = parseFloat(ctag.value);
                    break;
                  case "date":
                    q.t = "d";
                    q.v = parseDate(ctag["date-value"]);
                    if (!opts.cellDates) {
                      q.t = "n";
                      q.v = datenum(q.v);
                    }
                    q.z = "m/d/yy";
                    break;
                  case "time":
                    q.t = "n";
                    q.v = parse_isodur(ctag["time-value"]) / 86400;
                    if (opts.cellDates) {
                      q.t = "d";
                      q.v = numdate(q.v);
                    }
                    q.z = "HH:MM:SS";
                    break;
                  case "number":
                    q.t = "n";
                    q.v = parseFloat(ctag[""]);
                    break;
                  default:
                    if (q.t === "string" || q.t === "text" || !q.t) {
                      q.t = "s";
                      if (ctag["string-value"] != null) {
                        textp = unescapexml(ctag["string-value"]);
                        textR = [];
                      }
                    } else
                      throw new Error("Unsupported value type " + q.t);
                }
              } else {
                isstub = false;
                if (q.t === "s") {
                  q.v = textp || "";
                  if (textR.length)
                    q.R = textR;
                  isstub = textpidx == 0;
                }
                if (atag.Target)
                  q.l = atag;
                if (comments.length > 0) {
                  q.c = comments;
                  comments = [];
                }
                if (textp && opts.cellText !== false)
                  q.w = textp;
                if (isstub) {
                  q.t = "z";
                  delete q.v;
                }
                if (!isstub || opts.sheetStubs) {
                  if (!(opts.sheetRows && opts.sheetRows <= R)) {
                    for (var rpt = 0; rpt < rowpeat; ++rpt) {
                      colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                      if (opts.dense) {
                        if (!ws[R + rpt])
                          ws[R + rpt] = [];
                        ws[R + rpt][C] = rpt == 0 ? q : dup(q);
                        while (--colpeat > 0)
                          ws[R + rpt][C + colpeat] = dup(q);
                      } else {
                        ws[encode_cell({ r: R + rpt, c: C })] = q;
                        while (--colpeat > 0)
                          ws[encode_cell({ r: R + rpt, c: C + colpeat })] = dup(q);
                      }
                      if (range2.e.c <= C)
                        range2.e.c = C;
                    }
                  }
                }
                colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                C += colpeat - 1;
                colpeat = 0;
                q = {
                  /*:: t:"", v:null, z:null, w:"",c:[]*/
                };
                textp = "";
                textR = [];
              }
              atag = {};
              break;
            case "document":
            case "document-content":
            case "":
            case "spreadsheet":
            case "":
            case "scripts":
            case "styles":
            case "font-face-decls":
            case "master-styles":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw "Bad state: " + tmp;
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
                state.push([Rn[3], true]);
              break;
            case "annotation":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw "Bad state: " + tmp;
                comment.t = textp;
                if (textR.length)
                  comment.R = textR;
                comment.a = creator;
                comments.push(comment);
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                state.push([Rn[3], false]);
              }
              creator = "";
              creatoridx = 0;
              textp = "";
              textpidx = 0;
              textR = [];
              break;
            case "creator":
              if (Rn[1] === "/") {
                creator = str.slice(creatoridx, Rn.index);
              } else
                creatoridx = Rn.index + Rn[0].length;
              break;
            case "meta":
            case "":
            case "settings":
            case "config-item-set":
            case "config-item-map-indexed":
            case "config-item-map-entry":
            case "config-item-map-named":
            case "shapes":
            case "frame":
            case "text-box":
            case "image":
            case "data-pilot-tables":
            case "list-style":
            case "form":
            case "dde-links":
            case "event-listeners":
            case "chart":
              if (Rn[1] === "/") {
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw "Bad state: " + tmp;
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
                state.push([Rn[3], false]);
              textp = "";
              textpidx = 0;
              textR = [];
              break;
            case "scientific-number":
              break;
            case "currency-symbol":
              break;
            case "currency-style":
              break;
            case "number-style":
            case "percentage-style":
            case "date-style":
            case "time-style":
              if (Rn[1] === "/") {
                number_format_map[NFtag.name] = NF;
                if ((tmp = state.pop())[0] !== Rn[3])
                  throw "Bad state: " + tmp;
              } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
                NF = "";
                NFtag = parsexmltag(Rn[0], false);
                state.push([Rn[3], true]);
              }
              break;
            case "script":
              break;
            case "libraries":
              break;
            case "automatic-styles":
              break;
            case "default-style":
            case "page-layout":
              break;
            case "style":
              break;
            case "map":
              break;
            case "font-face":
              break;
            case "paragraph-properties":
              break;
            case "table-properties":
              break;
            case "table-column-properties":
              break;
            case "table-row-properties":
              break;
            case "table-cell-properties":
              break;
            case "number":
              switch (state[state.length - 1][0]) {
                case "time-style":
                case "date-style":
                  tag = parsexmltag(Rn[0], false);
                  NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
                  break;
              }
              break;
            case "fraction":
              break;
            case "day":
            case "month":
            case "year":
            case "era":
            case "day-of-week":
            case "week-of-year":
            case "quarter":
            case "hours":
            case "minutes":
            case "seconds":
            case "am-pm":
              switch (state[state.length - 1][0]) {
                case "time-style":
                case "date-style":
                  tag = parsexmltag(Rn[0], false);
                  NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
                  break;
              }
              break;
            case "boolean-style":
              break;
            case "boolean":
              break;
            case "text-style":
              break;
            case "text":
              if (Rn[0].slice(-2) === "/>")
                break;
              else if (Rn[1] === "/")
                switch (state[state.length - 1][0]) {
                  case "number-style":
                  case "date-style":
                  case "time-style":
                    NF += str.slice(pidx, Rn.index);
                    break;
                }
              else
                pidx = Rn.index + Rn[0].length;
              break;
            case "named-range":
              tag = parsexmltag(Rn[0], false);
              _Ref = ods_to_csf_3D(tag["cell-range-address"]);
              var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
              if (intable)
                nrange.Sheet = SheetNames.length;
              WB.Names.push(nrange);
              break;
            case "text-content":
              break;
            case "text-properties":
              break;
            case "embedded-text":
              break;
            case "body":
            case "":
              break;
            case "forms":
              break;
            case "table-column":
              break;
            case "table-header-rows":
              break;
            case "table-rows":
              break;
            case "table-column-group":
              break;
            case "table-header-columns":
              break;
            case "table-columns":
              break;
            case "null-date":
              break;
            case "graphic-properties":
              break;
            case "calculation-settings":
              break;
            case "named-expressions":
              break;
            case "label-range":
              break;
            case "label-ranges":
              break;
            case "named-expression":
              break;
            case "sort":
              break;
            case "sort-by":
              break;
            case "sort-groups":
              break;
            case "tab":
              break;
            case "line-break":
              break;
            case "span":
              break;
            case "p":
            case "":
              if (["master-styles"].indexOf(state[state.length - 1][0]) > -1)
                break;
              if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
                var ptp = parse_text_p(str.slice(textpidx, Rn.index));
                textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
              } else {
                parsexmltag(Rn[0], false);
                textpidx = Rn.index + Rn[0].length;
              }
              break;
            case "s":
              break;
            case "database-range":
              if (Rn[1] === "/")
                break;
              try {
                _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
                Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
              } catch (e) {
              }
              break;
            case "date":
              break;
            case "object":
              break;
            case "title":
            case "":
              break;
            case "desc":
              break;
            case "binary-data":
              break;
            case "table-source":
              break;
            case "scenario":
              break;
            case "iteration":
              break;
            case "content-validations":
              break;
            case "content-validation":
              break;
            case "help-message":
              break;
            case "error-message":
              break;
            case "database-ranges":
              break;
            case "filter":
              break;
            case "filter-and":
              break;
            case "filter-or":
              break;
            case "filter-condition":
              break;
            case "list-level-style-bullet":
              break;
            case "list-level-style-number":
              break;
            case "list-level-properties":
              break;
            case "sender-firstname":
            case "sender-lastname":
            case "sender-initials":
            case "sender-title":
            case "sender-position":
            case "sender-email":
            case "sender-phone-private":
            case "sender-fax":
            case "sender-company":
            case "sender-phone-work":
            case "sender-street":
            case "sender-city":
            case "sender-postal-code":
            case "sender-country":
            case "sender-state-or-province":
            case "author-name":
            case "author-initials":
            case "chapter":
            case "file-name":
            case "template-name":
            case "sheet-name":
              break;
            case "event-listener":
              break;
            case "initial-creator":
            case "creation-date":
            case "print-date":
            case "generator":
            case "document-statistic":
            case "user-defined":
            case "editing-duration":
            case "editing-cycles":
              break;
            case "config-item":
              break;
            case "page-number":
              break;
            case "page-count":
              break;
            case "time":
              break;
            case "cell-range-source":
              break;
            case "detective":
              break;
            case "operation":
              break;
            case "highlighted-range":
              break;
            case "data-pilot-table":
            case "source-cell-range":
            case "source-service":
            case "data-pilot-field":
            case "data-pilot-level":
            case "data-pilot-subtotals":
            case "data-pilot-subtotal":
            case "data-pilot-members":
            case "data-pilot-member":
            case "data-pilot-display-info":
            case "data-pilot-sort-info":
            case "data-pilot-layout-info":
            case "data-pilot-field-reference":
            case "data-pilot-groups":
            case "data-pilot-group":
            case "data-pilot-group-member":
              break;
            case "rect":
              break;
            case "dde-connection-decls":
            case "dde-connection-decl":
            case "dde-link":
            case "dde-source":
              break;
            case "properties":
              break;
            case "property":
              break;
            case "a":
              if (Rn[1] !== "/") {
                atag = parsexmltag(Rn[0], false);
                if (!atag.href)
                  break;
                atag.Target = unescapexml(atag.href);
                delete atag.href;
                if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
                  _Ref = ods_to_csf_3D(atag.Target.slice(1));
                  atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
                } else if (atag.Target.match(/^\.\.[\\\/]/))
                  atag.Target = atag.Target.slice(3);
              }
              break;
            case "table-protection":
              break;
            case "data-pilot-grand-total":
              break;
            case "office-document-common-attrs":
              break;
            default:
              switch (Rn[2]) {
                case "dc:":
                case "calcext:":
                case "loext:":
                case "ooo:":
                case "chartooo:":
                case "draw:":
                case "style:":
                case "chart:":
                case "form:":
                case "uof:":
                case ":":
                case ":":
                  break;
                default:
                  if (opts.WTF)
                    throw new Error(Rn);
              }
          }
        var out = {
          Sheets,
          SheetNames,
          Workbook: WB
        };
        if (opts.bookSheets)
          delete /*::(*/
          out.Sheets;
        return out;
      }
      function parse_ods(zip, opts) {
        opts = opts || {};
        if (safegetzipfile(zip, "META-INF/manifest.xml"))
          parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
        var content = getzipstr(zip, "content.xml");
        if (!content)
          throw new Error("Missing content.xml in ODS / UOF file");
        var wb = parse_content_xml(utf8read(content), opts);
        if (safegetzipfile(zip, "meta.xml"))
          wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
        return wb;
      }
      function parse_fods(data, opts) {
        return parse_content_xml(data, opts);
      }
      /*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
      function u8_to_dataview(array2) {
        return new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      }
      function u8str(u8) {
        return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));
      }
      function u8concat(u8a) {
        var len2 = u8a.reduce(function(acc, x) {
          return acc + x.length;
        }, 0);
        var out = new Uint8Array(len2);
        var off2 = 0;
        u8a.forEach(function(u8) {
          out.set(u8, off2);
          off2 += u8.length;
        });
        return out;
      }
      function popcnt(x) {
        x -= x >> 1 & 1431655765;
        x = (x & 858993459) + (x >> 2 & 858993459);
        return (x + (x >> 4) & 252645135) * 16843009 >>> 24;
      }
      function readDecimal128LE(buf, offset) {
        var exp = (buf[offset + 15] & 127) << 7 | buf[offset + 14] >> 1;
        var mantissa = buf[offset + 14] & 1;
        for (var j = offset + 13; j >= offset; --j)
          mantissa = mantissa * 256 + buf[j];
        return (buf[offset + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
      }
      function parse_varint49(buf, ptr) {
        var l = ptr ? ptr[0] : 0;
        var usz = buf[l] & 127;
        varint:
          if (buf[l++] >= 128) {
            usz |= (buf[l] & 127) << 7;
            if (buf[l++] < 128)
              break varint;
            usz |= (buf[l] & 127) << 14;
            if (buf[l++] < 128)
              break varint;
            usz |= (buf[l] & 127) << 21;
            if (buf[l++] < 128)
              break varint;
            usz += (buf[l] & 127) * Math.pow(2, 28);
            ++l;
            if (buf[l++] < 128)
              break varint;
            usz += (buf[l] & 127) * Math.pow(2, 35);
            ++l;
            if (buf[l++] < 128)
              break varint;
            usz += (buf[l] & 127) * Math.pow(2, 42);
            ++l;
            if (buf[l++] < 128)
              break varint;
          }
        if (ptr)
          ptr[0] = l;
        return usz;
      }
      function varint_to_i32(buf) {
        var l = 0, i32 = buf[l] & 127;
        varint:
          if (buf[l++] >= 128) {
            i32 |= (buf[l] & 127) << 7;
            if (buf[l++] < 128)
              break varint;
            i32 |= (buf[l] & 127) << 14;
            if (buf[l++] < 128)
              break varint;
            i32 |= (buf[l] & 127) << 21;
            if (buf[l++] < 128)
              break varint;
            i32 |= (buf[l] & 127) << 28;
          }
        return i32;
      }
      function parse_shallow(buf) {
        var out = [], ptr = [0];
        while (ptr[0] < buf.length) {
          var off2 = ptr[0];
          var num = parse_varint49(buf, ptr);
          var type2 = num & 7;
          num = Math.floor(num / 8);
          var len2 = 0;
          var res;
          if (num == 0)
            break;
          switch (type2) {
            case 0:
              {
                var l = ptr[0];
                while (buf[ptr[0]++] >= 128)
                  ;
                res = buf.slice(l, ptr[0]);
              }
              break;
            case 5:
              len2 = 4;
              res = buf.slice(ptr[0], ptr[0] + len2);
              ptr[0] += len2;
              break;
            case 1:
              len2 = 8;
              res = buf.slice(ptr[0], ptr[0] + len2);
              ptr[0] += len2;
              break;
            case 2:
              len2 = parse_varint49(buf, ptr);
              res = buf.slice(ptr[0], ptr[0] + len2);
              ptr[0] += len2;
              break;
            case 3:
            case 4:
            default:
              throw new Error("PB Type ".concat(type2, " for Field ").concat(num, " at offset ").concat(off2));
          }
          var v = { data: res, type: type2 };
          if (out[num] == null)
            out[num] = [v];
          else
            out[num].push(v);
        }
        return out;
      }
      function mappa(data, cb) {
        return (data == null ? void 0 : data.map(function(d) {
          return cb(d.data);
        })) || [];
      }
      function parse_iwa_file(buf) {
        var _a;
        var out = [], ptr = [0];
        while (ptr[0] < buf.length) {
          var len2 = parse_varint49(buf, ptr);
          var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len2));
          ptr[0] += len2;
          var res = {
            id: varint_to_i32(ai[1][0].data),
            messages: []
          };
          ai[2].forEach(function(b) {
            var mi = parse_shallow(b.data);
            var fl = varint_to_i32(mi[3][0].data);
            res.messages.push({
              meta: mi,
              data: buf.slice(ptr[0], ptr[0] + fl)
            });
            ptr[0] += fl;
          });
          if ((_a = ai[3]) == null ? void 0 : _a[0])
            res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
          out.push(res);
        }
        return out;
      }
      function parse_snappy_chunk(type2, buf) {
        if (type2 != 0)
          throw new Error("Unexpected Snappy chunk type ".concat(type2));
        var ptr = [0];
        var usz = parse_varint49(buf, ptr);
        var chunks = [];
        while (ptr[0] < buf.length) {
          var tag = buf[ptr[0]] & 3;
          if (tag == 0) {
            var len2 = buf[ptr[0]++] >> 2;
            if (len2 < 60)
              ++len2;
            else {
              var c2 = len2 - 59;
              len2 = buf[ptr[0]];
              if (c2 > 1)
                len2 |= buf[ptr[0] + 1] << 8;
              if (c2 > 2)
                len2 |= buf[ptr[0] + 2] << 16;
              if (c2 > 3)
                len2 |= buf[ptr[0] + 3] << 24;
              len2 >>>= 0;
              len2++;
              ptr[0] += c2;
            }
            chunks.push(buf.slice(ptr[0], ptr[0] + len2));
            ptr[0] += len2;
            continue;
          } else {
            var offset = 0, length = 0;
            if (tag == 1) {
              length = (buf[ptr[0]] >> 2 & 7) + 4;
              offset = (buf[ptr[0]++] & 224) << 3;
              offset |= buf[ptr[0]++];
            } else {
              length = (buf[ptr[0]++] >> 2) + 1;
              if (tag == 2) {
                offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
                ptr[0] += 2;
              } else {
                offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
                ptr[0] += 4;
              }
            }
            chunks = [u8concat(chunks)];
            if (offset == 0)
              throw new Error("Invalid offset 0");
            if (offset > chunks[0].length)
              throw new Error("Invalid offset beyond length");
            if (length >= offset) {
              chunks.push(chunks[0].slice(-offset));
              length -= offset;
              while (length >= chunks[chunks.length - 1].length) {
                chunks.push(chunks[chunks.length - 1]);
                length -= chunks[chunks.length - 1].length;
              }
            }
            chunks.push(chunks[0].slice(-offset, -offset + length));
          }
        }
        var o = u8concat(chunks);
        if (o.length != usz)
          throw new Error("Unexpected length: ".concat(o.length, " != ").concat(usz));
        return o;
      }
      function decompress_iwa_file(buf) {
        var out = [];
        var l = 0;
        while (l < buf.length) {
          var t = buf[l++];
          var len2 = buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16;
          l += 3;
          out.push(parse_snappy_chunk(t, buf.slice(l, l + len2)));
          l += len2;
        }
        if (l !== buf.length)
          throw new Error("data is not a valid framed stream!");
        return u8concat(out);
      }
      function parse_old_storage(buf, sst, rsst, v) {
        var dv = u8_to_dataview(buf);
        var flags = dv.getUint32(4, true);
        var data_offset = (v > 1 ? 12 : 8) + popcnt(flags & (v > 1 ? 3470 : 398)) * 4;
        var ridx = -1, sidx = -1, ieee = NaN, dt = new Date(2001, 0, 1);
        if (flags & 512) {
          ridx = dv.getUint32(data_offset, true);
          data_offset += 4;
        }
        data_offset += popcnt(flags & (v > 1 ? 12288 : 4096)) * 4;
        if (flags & 16) {
          sidx = dv.getUint32(data_offset, true);
          data_offset += 4;
        }
        if (flags & 32) {
          ieee = dv.getFloat64(data_offset, true);
          data_offset += 8;
        }
        if (flags & 64) {
          dt.setTime(dt.getTime() + dv.getFloat64(data_offset, true) * 1e3);
          data_offset += 8;
        }
        var ret;
        switch (buf[2]) {
          case 0:
            break;
          case 2:
            ret = { t: "n", v: ieee };
            break;
          case 3:
            ret = { t: "s", v: sst[sidx] };
            break;
          case 5:
            ret = { t: "d", v: dt };
            break;
          case 6:
            ret = { t: "b", v: ieee > 0 };
            break;
          case 7:
            ret = { t: "n", v: ieee / 86400 };
            break;
          case 8:
            ret = { t: "e", v: 0 };
            break;
          case 9:
            {
              if (ridx > -1)
                ret = { t: "s", v: rsst[ridx] };
              else if (sidx > -1)
                ret = { t: "s", v: sst[sidx] };
              else if (!isNaN(ieee))
                ret = { t: "n", v: ieee };
              else
                throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
            }
            break;
          default:
            throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
        }
        return ret;
      }
      function parse_new_storage(buf, sst, rsst) {
        var dv = u8_to_dataview(buf);
        var flags = dv.getUint32(8, true);
        var data_offset = 12;
        var ridx = -1, sidx = -1, d128 = NaN, ieee = NaN, dt = new Date(2001, 0, 1);
        if (flags & 1) {
          d128 = readDecimal128LE(buf, data_offset);
          data_offset += 16;
        }
        if (flags & 2) {
          ieee = dv.getFloat64(data_offset, true);
          data_offset += 8;
        }
        if (flags & 4) {
          dt.setTime(dt.getTime() + dv.getFloat64(data_offset, true) * 1e3);
          data_offset += 8;
        }
        if (flags & 8) {
          sidx = dv.getUint32(data_offset, true);
          data_offset += 4;
        }
        if (flags & 16) {
          ridx = dv.getUint32(data_offset, true);
          data_offset += 4;
        }
        var ret;
        switch (buf[1]) {
          case 0:
            break;
          case 2:
            ret = { t: "n", v: d128 };
            break;
          case 3:
            ret = { t: "s", v: sst[sidx] };
            break;
          case 5:
            ret = { t: "d", v: dt };
            break;
          case 6:
            ret = { t: "b", v: ieee > 0 };
            break;
          case 7:
            ret = { t: "n", v: ieee / 86400 };
            break;
          case 8:
            ret = { t: "e", v: 0 };
            break;
          case 9:
            {
              if (ridx > -1)
                ret = { t: "s", v: rsst[ridx] };
              else
                throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
            }
            break;
          case 10:
            ret = { t: "n", v: d128 };
            break;
          default:
            throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
        }
        return ret;
      }
      function parse_cell_storage(buf, sst, rsst) {
        switch (buf[0]) {
          case 0:
          case 1:
          case 2:
          case 3:
            return parse_old_storage(buf, sst, rsst, buf[0]);
          case 5:
            return parse_new_storage(buf, sst, rsst);
          default:
            throw new Error("Unsupported payload version ".concat(buf[0]));
        }
      }
      function parse_TSP_Reference(buf) {
        var pb = parse_shallow(buf);
        return parse_varint49(pb[1][0].data);
      }
      function parse_TST_TableDataList(M, root2) {
        var pb = parse_shallow(root2.data);
        var type2 = varint_to_i32(pb[1][0].data);
        var entries = pb[3];
        var data = [];
        (entries || []).forEach(function(entry) {
          var le = parse_shallow(entry.data);
          var key = varint_to_i32(le[1][0].data) >>> 0;
          switch (type2) {
            case 1:
              data[key] = u8str(le[3][0].data);
              break;
            case 8:
              {
                var rt = M[parse_TSP_Reference(le[9][0].data)][0];
                var rtp = parse_shallow(rt.data);
                var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];
                var mtype = varint_to_i32(rtpref.meta[1][0].data);
                if (mtype != 2001)
                  throw new Error("2000 unexpected reference to ".concat(mtype));
                var tswpsa = parse_shallow(rtpref.data);
                data[key] = tswpsa[3].map(function(x) {
                  return u8str(x.data);
                }).join("");
              }
              break;
          }
        });
        return data;
      }
      function parse_TST_TileRowInfo(u8, type2) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        var pb = parse_shallow(u8);
        var R = varint_to_i32(pb[1][0].data) >>> 0;
        var cnt = varint_to_i32(pb[2][0].data) >>> 0;
        var wide_offsets = ((_b = (_a = pb[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) && varint_to_i32(pb[8][0].data) > 0 || false;
        var used_storage_u8, used_storage;
        if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && type2 != 0) {
          used_storage_u8 = (_f = (_e = pb[7]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data;
          used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
        } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type2 != 1) {
          used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
          used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
        } else
          throw "NUMBERS Tile missing ".concat(type2, " cell storage");
        var width = wide_offsets ? 4 : 1;
        var used_storage_offsets = u8_to_dataview(used_storage_u8);
        var offsets = [];
        for (var C = 0; C < used_storage_u8.length / 2; ++C) {
          var off2 = used_storage_offsets.getUint16(C * 2, true);
          if (off2 < 65535)
            offsets.push([C, off2]);
        }
        if (offsets.length != cnt)
          throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
        var cells = [];
        for (C = 0; C < offsets.length - 1; ++C)
          cells[offsets[C][0]] = used_storage.subarray(offsets[C][1] * width, offsets[C + 1][1] * width);
        if (offsets.length >= 1)
          cells[offsets[offsets.length - 1][0]] = used_storage.subarray(offsets[offsets.length - 1][1] * width);
        return { R, cells };
      }
      function parse_TST_Tile(M, root2) {
        var _a;
        var pb = parse_shallow(root2.data);
        var storage = ((_a = pb == null ? void 0 : pb[7]) == null ? void 0 : _a[0]) ? varint_to_i32(pb[7][0].data) >>> 0 > 0 ? 1 : 0 : -1;
        var ri = mappa(pb[5], function(u8) {
          return parse_TST_TileRowInfo(u8, storage);
        });
        return {
          nrows: varint_to_i32(pb[4][0].data) >>> 0,
          data: ri.reduce(function(acc, x) {
            if (!acc[x.R])
              acc[x.R] = [];
            x.cells.forEach(function(cell, C) {
              if (acc[x.R][C])
                throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C));
              acc[x.R][C] = cell;
            });
            return acc;
          }, [])
        };
      }
      function parse_TST_TableModelArchive(M, root2, ws) {
        var _a;
        var pb = parse_shallow(root2.data);
        var range2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
        range2.e.r = (varint_to_i32(pb[6][0].data) >>> 0) - 1;
        if (range2.e.r < 0)
          throw new Error("Invalid row varint ".concat(pb[6][0].data));
        range2.e.c = (varint_to_i32(pb[7][0].data) >>> 0) - 1;
        if (range2.e.c < 0)
          throw new Error("Invalid col varint ".concat(pb[7][0].data));
        ws["!ref"] = encode_range(range2);
        var store = parse_shallow(pb[4][0].data);
        var sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);
        var rsst = ((_a = store[17]) == null ? void 0 : _a[0]) ? parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]) : [];
        var tile = parse_shallow(store[3][0].data);
        var _R = 0;
        tile[1].forEach(function(t) {
          var tl = parse_shallow(t.data);
          var ref2 = M[parse_TSP_Reference(tl[2][0].data)][0];
          var mtype = varint_to_i32(ref2.meta[1][0].data);
          if (mtype != 6002)
            throw new Error("6001 unexpected reference to ".concat(mtype));
          var _tile = parse_TST_Tile(M, ref2);
          _tile.data.forEach(function(row, R) {
            row.forEach(function(buf, C) {
              var addr = encode_cell({ r: _R + R, c: C });
              var res = parse_cell_storage(buf, sst, rsst);
              if (res)
                ws[addr] = res;
            });
          });
          _R += _tile.nrows;
        });
      }
      function parse_TST_TableInfoArchive(M, root2) {
        var pb = parse_shallow(root2.data);
        var out = { "!ref": "A1" };
        var tableref = M[parse_TSP_Reference(pb[2][0].data)];
        var mtype = varint_to_i32(tableref[0].meta[1][0].data);
        if (mtype != 6001)
          throw new Error("6000 unexpected reference to ".concat(mtype));
        parse_TST_TableModelArchive(M, tableref[0], out);
        return out;
      }
      function parse_TN_SheetArchive(M, root2) {
        var _a;
        var pb = parse_shallow(root2.data);
        var out = {
          name: ((_a = pb[1]) == null ? void 0 : _a[0]) ? u8str(pb[1][0].data) : "",
          sheets: []
        };
        var shapeoffs = mappa(pb[2], parse_TSP_Reference);
        shapeoffs.forEach(function(off2) {
          M[off2].forEach(function(m) {
            var mtype = varint_to_i32(m.meta[1][0].data);
            if (mtype == 6e3)
              out.sheets.push(parse_TST_TableInfoArchive(M, m));
          });
        });
        return out;
      }
      function parse_TN_DocumentArchive(M, root2) {
        var out = book_new();
        var pb = parse_shallow(root2.data);
        var sheetoffs = mappa(pb[1], parse_TSP_Reference);
        sheetoffs.forEach(function(off2) {
          M[off2].forEach(function(m) {
            var mtype = varint_to_i32(m.meta[1][0].data);
            if (mtype == 2) {
              var root22 = parse_TN_SheetArchive(M, m);
              root22.sheets.forEach(function(sheet, idx) {
                book_append_sheet(out, sheet, idx == 0 ? root22.name : root22.name + "_" + idx, true);
              });
            }
          });
        });
        if (out.SheetNames.length == 0)
          throw new Error("Empty NUMBERS file");
        return out;
      }
      function parse_numbers_iwa(cfb) {
        var _a, _b, _c, _d;
        var M = {}, indices = [];
        cfb.FullPaths.forEach(function(p2) {
          if (p2.match(/\.iwpv2/))
            throw new Error("Unsupported password protection");
        });
        cfb.FileIndex.forEach(function(s) {
          if (!s.name.match(/\.iwa$/))
            return;
          var o;
          try {
            o = decompress_iwa_file(s.content);
          } catch (e) {
            return console.log("?? " + s.content.length + " " + (e.message || e));
          }
          var packets;
          try {
            packets = parse_iwa_file(o);
          } catch (e) {
            return console.log("## " + (e.message || e));
          }
          packets.forEach(function(packet) {
            M[packet.id] = packet.messages;
            indices.push(packet.id);
          });
        });
        if (!indices.length)
          throw new Error("File has no messages");
        var docroot = ((_d = (_c = (_b = (_a = M == null ? void 0 : M[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.meta) == null ? void 0 : _c[1]) == null ? void 0 : _d[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1 && M[1][0];
        if (!docroot)
          indices.forEach(function(idx) {
            M[idx].forEach(function(iwam) {
              var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
              if (mtype == 1) {
                if (!docroot)
                  docroot = iwam;
                else
                  throw new Error("Document has multiple roots");
              }
            });
          });
        if (!docroot)
          throw new Error("Cannot find Document root");
        return parse_TN_DocumentArchive(M, docroot);
      }
      function fix_opts_func(defaults2) {
        return function fix_opts(opts) {
          for (var i = 0; i != defaults2.length; ++i) {
            var d = defaults2[i];
            if (opts[d[0]] === void 0)
              opts[d[0]] = d[1];
            if (d[2] === "n")
              opts[d[0]] = Number(opts[d[0]]);
          }
        };
      }
      function fix_read_opts(opts) {
        fix_opts_func([
          ["cellNF", false],
          /* emit cell number format string as .z */
          ["cellHTML", true],
          /* emit html string as .h */
          ["cellFormula", true],
          /* emit formulae as .f */
          ["cellStyles", false],
          /* emits style/theme as .s */
          ["cellText", true],
          /* emit formatted text as .w */
          ["cellDates", false],
          /* emit date cells with type `d` */
          ["sheetStubs", false],
          /* emit empty cells */
          ["sheetRows", 0, "n"],
          /* read n rows (0 = read all rows) */
          ["bookDeps", false],
          /* parse calculation chains */
          ["bookSheets", false],
          /* only try to get sheet names (no Sheets) */
          ["bookProps", false],
          /* only try to get properties (no Sheets) */
          ["bookFiles", false],
          /* include raw file structure (keys, files, cfb) */
          ["bookVBA", false],
          /* include vba raw data (vbaraw) */
          ["password", ""],
          /* password */
          ["WTF", false]
          /* WTF mode (throws errors) */
        ])(opts);
      }
      function get_sheet_type(n) {
        if (RELS.WS.indexOf(n) > -1)
          return "sheet";
        if (n == RELS.CS)
          return "chart";
        if (n == RELS.DS)
          return "dialog";
        if (n == RELS.MS)
          return "macro";
        return n && n.length ? n : "sheet";
      }
      function safe_parse_wbrels(wbrels, sheets) {
        if (!wbrels)
          return 0;
        try {
          wbrels = sheets.map(function pwbr(w) {
            if (!w.id)
              w.id = w.strRelID;
            return [w.name, wbrels["!id"][w.id].Target, get_sheet_type(wbrels["!id"][w.id].Type)];
          });
        } catch (e) {
          return null;
        }
        return !wbrels || wbrels.length === 0 ? null : wbrels;
      }
      function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles2) {
        try {
          sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
          var data = getzipdata(zip, path);
          var _ws;
          switch (stype) {
            case "sheet":
              _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
              break;
            case "chart":
              _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
              if (!_ws || !_ws["!drawel"])
                break;
              var dfile = resolve_path(_ws["!drawel"].Target, path);
              var drelsp = get_rels_path(dfile);
              var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
              var chartp = resolve_path(draw, dfile);
              var crelsp = get_rels_path(chartp);
              _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
              break;
            case "macro":
              _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
              break;
            case "dialog":
              _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
              break;
            default:
              throw new Error("Unrecognized sheet type " + stype);
          }
          sheets[sheet] = _ws;
          var tcomments = [];
          if (sheetRels && sheetRels[sheet])
            keys(sheetRels[sheet]).forEach(function(n) {
              var dfile2 = "";
              if (sheetRels[sheet][n].Type == RELS.CMNT) {
                dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
                var comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
                if (!comments || !comments.length)
                  return;
                sheet_insert_comments(_ws, comments, false);
              }
              if (sheetRels[sheet][n].Type == RELS.TCMNT) {
                dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
                tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
              }
            });
          if (tcomments && tcomments.length)
            sheet_insert_comments(_ws, tcomments, true, opts.people || []);
        } catch (e) {
          if (opts.WTF)
            throw e;
        }
      }
      function strip_front_slash(x) {
        return x.charAt(0) == "/" ? x.slice(1) : x;
      }
      function parse_zip(zip, opts) {
        make_ssf();
        opts = opts || {};
        fix_read_opts(opts);
        if (safegetzipfile(zip, "META-INF/manifest.xml"))
          return parse_ods(zip, opts);
        if (safegetzipfile(zip, "objectdata.xml"))
          return parse_ods(zip, opts);
        if (safegetzipfile(zip, "Index/Document.iwa")) {
          if (typeof Uint8Array == "undefined")
            throw new Error("NUMBERS file parsing requires Uint8Array support");
          if (typeof parse_numbers_iwa != "undefined") {
            if (zip.FileIndex)
              return parse_numbers_iwa(zip);
            var _zip = CFB.utils.cfb_new();
            zipentries(zip).forEach(function(e) {
              zip_add_file(_zip, e, getzipbin(zip, e));
            });
            return parse_numbers_iwa(_zip);
          }
          throw new Error("Unsupported NUMBERS file");
        }
        if (!safegetzipfile(zip, "[Content_Types].xml")) {
          if (safegetzipfile(zip, "index.xml.gz"))
            throw new Error("Unsupported NUMBERS 08 file");
          if (safegetzipfile(zip, "index.xml"))
            throw new Error("Unsupported NUMBERS 09 file");
          throw new Error("Unsupported ZIP file");
        }
        var entries = zipentries(zip);
        var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
        var xlsb = false;
        var sheets, binname;
        if (dir.workbooks.length === 0) {
          binname = "xl/workbook.xml";
          if (getzipdata(zip, binname, true))
            dir.workbooks.push(binname);
        }
        if (dir.workbooks.length === 0) {
          binname = "xl/workbook.bin";
          if (!getzipdata(zip, binname, true))
            throw new Error("Could not find workbook");
          dir.workbooks.push(binname);
          xlsb = true;
        }
        if (dir.workbooks[0].slice(-3) == "bin")
          xlsb = true;
        var themes = {};
        var styles2 = {};
        if (!opts.bookSheets && !opts.bookProps) {
          strs = [];
          if (dir.sst)
            try {
              strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
            } catch (e) {
              if (opts.WTF)
                throw e;
            }
          if (opts.cellStyles && dir.themes.length)
            themes = parse_theme(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", dir.themes[0], opts);
          if (dir.style)
            styles2 = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
        }
        dir.links.map(function(link) {
          try {
            var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
            return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
          } catch (e) {
          }
        });
        var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
        var props = {}, propdata = "";
        if (dir.coreprops.length) {
          propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
          if (propdata)
            props = parse_core_props(propdata);
          if (dir.extprops.length !== 0) {
            propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
            if (propdata)
              parse_ext_props(propdata, props, opts);
          }
        }
        var custprops = {};
        if (!opts.bookSheets || opts.bookProps) {
          if (dir.custprops.length !== 0) {
            propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
            if (propdata)
              custprops = parse_cust_props(propdata, opts);
          }
        }
        var out = {};
        if (opts.bookSheets || opts.bookProps) {
          if (wb.Sheets)
            sheets = wb.Sheets.map(function pluck(x) {
              return x.name;
            });
          else if (props.Worksheets && props.SheetNames.length > 0)
            sheets = props.SheetNames;
          if (opts.bookProps) {
            out.Props = props;
            out.Custprops = custprops;
          }
          if (opts.bookSheets && typeof sheets !== "undefined")
            out.SheetNames = sheets;
          if (opts.bookSheets ? out.SheetNames : opts.bookProps)
            return out;
        }
        sheets = {};
        var deps = {};
        if (opts.bookDeps && dir.calcchain)
          deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
        var i = 0;
        var sheetRels = {};
        var path, relsPath;
        {
          var wbsheets = wb.Sheets;
          props.Worksheets = wbsheets.length;
          props.SheetNames = [];
          for (var j = 0; j != wbsheets.length; ++j) {
            props.SheetNames[j] = wbsheets[j].name;
          }
        }
        var wbext = xlsb ? "bin" : "xml";
        var wbrelsi = dir.workbooks[0].lastIndexOf("/");
        var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
        if (!safegetzipfile(zip, wbrelsfile))
          wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
        var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
        if ((dir.metadata || []).length >= 1) {
          opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
        }
        if ((dir.people || []).length >= 1) {
          opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
        }
        if (wbrels)
          wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
        var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
        wsloop:
          for (i = 0; i != props.Worksheets; ++i) {
            var stype = "sheet";
            if (wbrels && wbrels[i]) {
              path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
              if (!safegetzipfile(zip, path))
                path = wbrels[i][1];
              if (!safegetzipfile(zip, path))
                path = wbrelsfile.replace(/_rels\/.*$/, "") + wbrels[i][1];
              stype = wbrels[i][2];
            } else {
              path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
              path = path.replace(/sheet0\./, "sheet.");
            }
            relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
            if (opts && opts.sheets != null)
              switch (typeof opts.sheets) {
                case "number":
                  if (i != opts.sheets)
                    continue wsloop;
                  break;
                case "string":
                  if (props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase())
                    continue wsloop;
                  break;
                default:
                  if (Array.isArray && Array.isArray(opts.sheets)) {
                    var snjseen = false;
                    for (var snj = 0; snj != opts.sheets.length; ++snj) {
                      if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i)
                        snjseen = 1;
                      if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase())
                        snjseen = 1;
                    }
                    if (!snjseen)
                      continue wsloop;
                  }
              }
            safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles2);
          }
        out = {
          Directory: dir,
          Workbook: wb,
          Props: props,
          Custprops: custprops,
          Deps: deps,
          Sheets: sheets,
          SheetNames: props.SheetNames,
          Strings: strs,
          Styles: styles2,
          Themes: themes,
          SSF: dup(table_fmt)
        };
        if (opts && opts.bookFiles) {
          if (zip.files) {
            out.keys = entries;
            out.files = zip.files;
          } else {
            out.keys = [];
            out.files = {};
            zip.FullPaths.forEach(function(p2, idx) {
              p2 = p2.replace(/^Root Entry[\/]/, "");
              out.keys.push(p2);
              out.files[p2] = zip.FileIndex[idx];
            });
          }
        }
        if (opts && opts.bookVBA) {
          if (dir.vba.length > 0)
            out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
          else if (dir.defaults && dir.defaults.bin === CT_VBA)
            out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
        }
        return out;
      }
      function parse_xlsxcfb(cfb, _opts) {
        var opts = _opts || {};
        var f = "Workbook", data = CFB.find(cfb, f);
        try {
          f = "/!DataSpaces/Version";
          data = CFB.find(cfb, f);
          if (!data || !data.content)
            throw new Error("ECMA-376 Encrypted file missing " + f);
          parse_DataSpaceVersionInfo(data.content);
          f = "/!DataSpaces/DataSpaceMap";
          data = CFB.find(cfb, f);
          if (!data || !data.content)
            throw new Error("ECMA-376 Encrypted file missing " + f);
          var dsm = parse_DataSpaceMap(data.content);
          if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
            throw new Error("ECMA-376 Encrypted file bad " + f);
          f = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
          data = CFB.find(cfb, f);
          if (!data || !data.content)
            throw new Error("ECMA-376 Encrypted file missing " + f);
          var seds = parse_DataSpaceDefinition(data.content);
          if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
            throw new Error("ECMA-376 Encrypted file bad " + f);
          f = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
          data = CFB.find(cfb, f);
          if (!data || !data.content)
            throw new Error("ECMA-376 Encrypted file missing " + f);
          parse_Primary(data.content);
        } catch (e) {
        }
        f = "/EncryptionInfo";
        data = CFB.find(cfb, f);
        if (!data || !data.content)
          throw new Error("ECMA-376 Encrypted file missing " + f);
        var einfo = parse_EncryptionInfo(data.content);
        f = "/EncryptedPackage";
        data = CFB.find(cfb, f);
        if (!data || !data.content)
          throw new Error("ECMA-376 Encrypted file missing " + f);
        if (einfo[0] == 4 && typeof decrypt_agile !== "undefined")
          return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
        if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined")
          return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
        throw new Error("File is password-protected");
      }
      function firstbyte(f, o) {
        var x = "";
        switch ((o || {}).type || "base64") {
          case "buffer":
            return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
          case "base64":
            x = Base64_decode(f.slice(0, 12));
            break;
          case "binary":
            x = f;
            break;
          case "array":
            return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
          default:
            throw new Error("Unrecognized type " + (o && o.type || "undefined"));
        }
        return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
      }
      function read_cfb(cfb, opts) {
        if (CFB.find(cfb, "EncryptedPackage"))
          return parse_xlsxcfb(cfb, opts);
        return parse_xlscfb(cfb, opts);
      }
      function read_zip(data, opts) {
        var zip, d = data;
        var o = opts || {};
        if (!o.type)
          o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
        zip = zip_read(d, o);
        return parse_zip(zip, o);
      }
      function read_plaintext(data, o) {
        var i = 0;
        main:
          while (i < data.length)
            switch (data.charCodeAt(i)) {
              case 10:
              case 13:
              case 32:
                ++i;
                break;
              case 60:
                return parse_xlml(data.slice(i), o);
              default:
                break main;
            }
        return PRN.to_workbook(data, o);
      }
      function read_plaintext_raw(data, o) {
        var str = "", bytes = firstbyte(data, o);
        switch (o.type) {
          case "base64":
            str = Base64_decode(data);
            break;
          case "binary":
            str = data;
            break;
          case "buffer":
            str = data.toString("binary");
            break;
          case "array":
            str = cc2str(data);
            break;
          default:
            throw new Error("Unrecognized type " + o.type);
        }
        if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
          str = utf8read(str);
        o.type = "binary";
        return read_plaintext(str, o);
      }
      function read_utf16(data, o) {
        var d = data;
        if (o.type == "base64")
          d = Base64_decode(d);
        d = $cptable.utils.decode(1200, d.slice(2), "str");
        o.type = "binary";
        return read_plaintext(d, o);
      }
      function bstrify(data) {
        return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
      }
      function read_prn(data, d, o, str) {
        if (str) {
          o.type = "string";
          return PRN.to_workbook(data, o);
        }
        return PRN.to_workbook(d, o);
      }
      function readSync(data, opts) {
        reset_cp();
        var o = opts || {};
        if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer)
          return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));
        if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o.type)
          o.type = typeof Deno !== "undefined" ? "buffer" : "array";
        var d = data, n = [0, 0, 0, 0], str = false;
        if (o.cellStyles) {
          o.cellNF = true;
          o.sheetStubs = true;
        }
        _ssfopts = {};
        if (o.dateNF)
          _ssfopts.dateNF = o.dateNF;
        if (!o.type)
          o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
        if (o.type == "file") {
          o.type = has_buf ? "buffer" : "binary";
          d = read_binary(data);
          if (typeof Uint8Array !== "undefined" && !has_buf)
            o.type = "array";
        }
        if (o.type == "string") {
          str = true;
          o.type = "binary";
          o.codepage = 65001;
          d = bstrify(data);
        }
        if (o.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
          var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
          vu.foo = "bar";
          if (!vu.foo) {
            o = dup(o);
            o.type = "array";
            return readSync(ab2a(d), o);
          }
        }
        switch ((n = firstbyte(d, o))[0]) {
          case 208:
            if (n[1] === 207 && n[2] === 17 && n[3] === 224 && n[4] === 161 && n[5] === 177 && n[6] === 26 && n[7] === 225)
              return read_cfb(CFB.read(d, o), o);
            break;
          case 9:
            if (n[1] <= 8)
              return parse_xlscfb(d, o);
            break;
          case 60:
            return parse_xlml(d, o);
          case 73:
            if (n[1] === 73 && n[2] === 42 && n[3] === 0)
              throw new Error("TIFF Image File is not a spreadsheet");
            if (n[1] === 68)
              return read_wb_ID(d, o);
            break;
          case 84:
            if (n[1] === 65 && n[2] === 66 && n[3] === 76)
              return DIF.to_workbook(d, o);
            break;
          case 80:
            return n[1] === 75 && n[2] < 9 && n[3] < 9 ? read_zip(d, o) : read_prn(data, d, o, str);
          case 239:
            return n[3] === 60 ? parse_xlml(d, o) : read_prn(data, d, o, str);
          case 255:
            if (n[1] === 254) {
              return read_utf16(d, o);
            } else if (n[1] === 0 && n[2] === 2 && n[3] === 0)
              return WK_.to_workbook(d, o);
            break;
          case 0:
            if (n[1] === 0) {
              if (n[2] >= 2 && n[3] === 0)
                return WK_.to_workbook(d, o);
              if (n[2] === 0 && (n[3] === 8 || n[3] === 9))
                return WK_.to_workbook(d, o);
            }
            break;
          case 3:
          case 131:
          case 139:
          case 140:
            return DBF.to_workbook(d, o);
          case 123:
            if (n[1] === 92 && n[2] === 114 && n[3] === 116)
              return RTF.to_workbook(d, o);
            break;
          case 10:
          case 13:
          case 32:
            return read_plaintext_raw(d, o);
          case 137:
            if (n[1] === 80 && n[2] === 78 && n[3] === 71)
              throw new Error("PNG Image File is not a spreadsheet");
            break;
        }
        if (DBF_SUPPORTED_VERSIONS.indexOf(n[0]) > -1 && n[2] <= 12 && n[3] <= 31)
          return DBF.to_workbook(d, o);
        return read_prn(data, d, o, str);
      }
      function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {
        var rr = encode_row(R);
        var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
        var isempty = true;
        var row = header === 1 ? [] : {};
        if (header !== 1) {
          if (Object.defineProperty)
            try {
              Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
            } catch (e) {
              row.__rowNum__ = R;
            }
          else
            row.__rowNum__ = R;
        }
        if (!dense || sheet[R])
          for (var C = r.s.c; C <= r.e.c; ++C) {
            var val = dense ? sheet[R][C] : sheet[cols[C] + rr];
            if (val === void 0 || val.t === void 0) {
              if (defval === void 0)
                continue;
              if (hdr[C] != null) {
                row[hdr[C]] = defval;
              }
              continue;
            }
            var v = val.v;
            switch (val.t) {
              case "z":
                if (v == null)
                  break;
                continue;
              case "e":
                v = v == 0 ? null : void 0;
                break;
              case "s":
              case "d":
              case "b":
              case "n":
                break;
              default:
                throw new Error("unrecognized type " + val.t);
            }
            if (hdr[C] != null) {
              if (v == null) {
                if (val.t == "e" && v === null)
                  row[hdr[C]] = null;
                else if (defval !== void 0)
                  row[hdr[C]] = defval;
                else if (raw && v === null)
                  row[hdr[C]] = null;
                else
                  continue;
              } else {
                row[hdr[C]] = raw && (val.t !== "n" || val.t === "n" && o.rawNumbers !== false) ? v : format_cell(val, v, o);
              }
              if (v != null)
                isempty = false;
            }
          }
        return { row, isempty };
      }
      function sheet_to_json(sheet, opts) {
        if (sheet == null || sheet["!ref"] == null)
          return [];
        var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
        var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
        var o = opts || {};
        var range2 = o.range != null ? o.range : sheet["!ref"];
        if (o.header === 1)
          header = 1;
        else if (o.header === "A")
          header = 2;
        else if (Array.isArray(o.header))
          header = 3;
        else if (o.header == null)
          header = 0;
        switch (typeof range2) {
          case "string":
            r = safe_decode_range(range2);
            break;
          case "number":
            r = safe_decode_range(sheet["!ref"]);
            r.s.r = range2;
            break;
          default:
            r = range2;
        }
        if (header > 0)
          offset = 0;
        var rr = encode_row(r.s.r);
        var cols = [];
        var out = [];
        var outi = 0, counter = 0;
        var dense = Array.isArray(sheet);
        var R = r.s.r, C = 0;
        var header_cnt = {};
        if (dense && !sheet[R])
          sheet[R] = [];
        var colinfo = o.skipHidden && sheet["!cols"] || [];
        var rowinfo = o.skipHidden && sheet["!rows"] || [];
        for (C = r.s.c; C <= r.e.c; ++C) {
          if ((colinfo[C] || {}).hidden)
            continue;
          cols[C] = encode_col(C);
          val = dense ? sheet[R][C] : sheet[cols[C] + rr];
          switch (header) {
            case 1:
              hdr[C] = C - r.s.c;
              break;
            case 2:
              hdr[C] = cols[C];
              break;
            case 3:
              hdr[C] = o.header[C - r.s.c];
              break;
            default:
              if (val == null)
                val = { w: "__EMPTY", t: "s" };
              vv = v = format_cell(val, null, o);
              counter = header_cnt[v] || 0;
              if (!counter)
                header_cnt[v] = 1;
              else {
                do {
                  vv = v + "_" + counter++;
                } while (header_cnt[vv]);
                header_cnt[v] = counter;
                header_cnt[vv] = 1;
              }
              hdr[C] = vv;
          }
        }
        for (R = r.s.r + offset; R <= r.e.r; ++R) {
          if ((rowinfo[R] || {}).hidden)
            continue;
          var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
          if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows))
            out[outi++] = row.row;
        }
        out.length = outi;
        return out;
      }
      var qreg = /"/g;
      function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
        var isempty = true;
        var row = [], txt = "", rr = encode_row(R);
        for (var C = r.s.c; C <= r.e.c; ++C) {
          if (!cols[C])
            continue;
          var val = o.dense ? (sheet[R] || [])[C] : sheet[cols[C] + rr];
          if (val == null)
            txt = "";
          else if (val.v != null) {
            isempty = false;
            txt = "" + (o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
            for (var i = 0, cc = 0; i !== txt.length; ++i)
              if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
                txt = '"' + txt.replace(qreg, '""') + '"';
                break;
              }
            if (txt == "ID")
              txt = '"ID"';
          } else if (val.f != null && !val.F) {
            isempty = false;
            txt = "=" + val.f;
            if (txt.indexOf(",") >= 0)
              txt = '"' + txt.replace(qreg, '""') + '"';
          } else
            txt = "";
          row.push(txt);
        }
        if (o.blankrows === false && isempty)
          return null;
        return row.join(FS);
      }
      function sheet_to_csv(sheet, opts) {
        var out = [];
        var o = opts == null ? {} : opts;
        if (sheet == null || sheet["!ref"] == null)
          return "";
        var r = safe_decode_range(sheet["!ref"]);
        var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
        var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
        var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
        var row = "", cols = [];
        o.dense = Array.isArray(sheet);
        var colinfo = o.skipHidden && sheet["!cols"] || [];
        var rowinfo = o.skipHidden && sheet["!rows"] || [];
        for (var C = r.s.c; C <= r.e.c; ++C)
          if (!(colinfo[C] || {}).hidden)
            cols[C] = encode_col(C);
        var w = 0;
        for (var R = r.s.r; R <= r.e.r; ++R) {
          if ((rowinfo[R] || {}).hidden)
            continue;
          row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
          if (row == null) {
            continue;
          }
          if (o.strip)
            row = row.replace(endregex, "");
          if (row || o.blankrows !== false)
            out.push((w++ ? RS : "") + row);
        }
        delete o.dense;
        return out.join("");
      }
      function sheet_to_txt(sheet, opts) {
        if (!opts)
          opts = {};
        opts.FS = "	";
        opts.RS = "\n";
        var s = sheet_to_csv(sheet, opts);
        return s;
      }
      function sheet_to_formulae(sheet) {
        var y = "", x, val = "";
        if (sheet == null || sheet["!ref"] == null)
          return [];
        var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C;
        var cmds = [];
        var dense = Array.isArray(sheet);
        for (C = r.s.c; C <= r.e.c; ++C)
          cols[C] = encode_col(C);
        for (var R = r.s.r; R <= r.e.r; ++R) {
          rr = encode_row(R);
          for (C = r.s.c; C <= r.e.c; ++C) {
            y = cols[C] + rr;
            x = dense ? (sheet[R] || [])[C] : sheet[y];
            val = "";
            if (x === void 0)
              continue;
            else if (x.F != null) {
              y = x.F;
              if (!x.f)
                continue;
              val = x.f;
              if (y.indexOf(":") == -1)
                y = y + ":" + y;
            }
            if (x.f != null)
              val = x.f;
            else if (x.t == "z")
              continue;
            else if (x.t == "n" && x.v != null)
              val = "" + x.v;
            else if (x.t == "b")
              val = x.v ? "TRUE" : "FALSE";
            else if (x.w !== void 0)
              val = "'" + x.w;
            else if (x.v === void 0)
              continue;
            else if (x.t == "s")
              val = "'" + x.v;
            else
              val = "" + x.v;
            cmds[cmds.length] = y + "=" + val;
          }
        }
        return cmds;
      }
      function sheet_add_json(_ws, js, opts) {
        var o = opts || {};
        var offset = +!o.skipHeader;
        var ws = _ws || {};
        var _R = 0, _C = 0;
        if (ws && o.origin != null) {
          if (typeof o.origin == "number")
            _R = o.origin;
          else {
            var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
            _R = _origin.r;
            _C = _origin.c;
          }
        }
        var cell;
        var range2 = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
        if (ws["!ref"]) {
          var _range = safe_decode_range(ws["!ref"]);
          range2.e.c = Math.max(range2.e.c, _range.e.c);
          range2.e.r = Math.max(range2.e.r, _range.e.r);
          if (_R == -1) {
            _R = _range.e.r + 1;
            range2.e.r = _R + js.length - 1 + offset;
          }
        } else {
          if (_R == -1) {
            _R = 0;
            range2.e.r = js.length - 1 + offset;
          }
        }
        var hdr = o.header || [], C = 0;
        js.forEach(function(JS, R) {
          keys(JS).forEach(function(k) {
            if ((C = hdr.indexOf(k)) == -1)
              hdr[C = hdr.length] = k;
            var v = JS[k];
            var t = "z";
            var z = "";
            var ref2 = encode_cell({ c: _C + C, r: _R + R + offset });
            cell = ws_get_cell_stub(ws, ref2);
            if (v && typeof v === "object" && !(v instanceof Date)) {
              ws[ref2] = v;
            } else {
              if (typeof v == "number")
                t = "n";
              else if (typeof v == "boolean")
                t = "b";
              else if (typeof v == "string")
                t = "s";
              else if (v instanceof Date) {
                t = "d";
                if (!o.cellDates) {
                  t = "n";
                  v = datenum(v);
                }
                z = o.dateNF || table_fmt[14];
              } else if (v === null && o.nullError) {
                t = "e";
                v = 0;
              }
              if (!cell)
                ws[ref2] = cell = { t, v };
              else {
                cell.t = t;
                cell.v = v;
                delete cell.w;
                delete cell.R;
                if (z)
                  cell.z = z;
              }
              if (z)
                cell.z = z;
            }
          });
        });
        range2.e.c = Math.max(range2.e.c, _C + hdr.length - 1);
        var __R = encode_row(_R);
        if (offset)
          for (C = 0; C < hdr.length; ++C)
            ws[encode_col(C + _C) + __R] = { t: "s", v: hdr[C] };
        ws["!ref"] = encode_range(range2);
        return ws;
      }
      function json_to_sheet(js, opts) {
        return sheet_add_json(null, js, opts);
      }
      function ws_get_cell_stub(ws, R, C) {
        if (typeof R == "string") {
          if (Array.isArray(ws)) {
            var RC = decode_cell(R);
            if (!ws[RC.r])
              ws[RC.r] = [];
            return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = { t: "z" });
          }
          return ws[R] || (ws[R] = { t: "z" });
        }
        if (typeof R != "number")
          return ws_get_cell_stub(ws, encode_cell(R));
        return ws_get_cell_stub(ws, encode_cell({ r: R, c: C || 0 }));
      }
      function wb_sheet_idx(wb, sh) {
        if (typeof sh == "number") {
          if (sh >= 0 && wb.SheetNames.length > sh)
            return sh;
          throw new Error("Cannot find sheet # " + sh);
        } else if (typeof sh == "string") {
          var idx = wb.SheetNames.indexOf(sh);
          if (idx > -1)
            return idx;
          throw new Error("Cannot find sheet name |" + sh + "|");
        } else
          throw new Error("Cannot find sheet |" + sh + "|");
      }
      function book_new() {
        return { SheetNames: [], Sheets: {} };
      }
      function book_append_sheet(wb, ws, name, roll) {
        var i = 1;
        if (!name) {
          for (; i <= 65535; ++i, name = void 0)
            if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1)
              break;
        }
        if (!name || wb.SheetNames.length >= 65535)
          throw new Error("Too many worksheets");
        if (roll && wb.SheetNames.indexOf(name) >= 0) {
          var m = name.match(/(^.*?)(\d+)$/);
          i = m && +m[2] || 0;
          var root2 = m && m[1] || name;
          for (++i; i <= 65535; ++i)
            if (wb.SheetNames.indexOf(name = root2 + i) == -1)
              break;
        }
        check_ws_name(name);
        if (wb.SheetNames.indexOf(name) >= 0)
          throw new Error("Worksheet with name |" + name + "| already exists!");
        wb.SheetNames.push(name);
        wb.Sheets[name] = ws;
        return name;
      }
      function book_set_sheet_visibility(wb, sh, vis) {
        if (!wb.Workbook)
          wb.Workbook = {};
        if (!wb.Workbook.Sheets)
          wb.Workbook.Sheets = [];
        var idx = wb_sheet_idx(wb, sh);
        if (!wb.Workbook.Sheets[idx])
          wb.Workbook.Sheets[idx] = {};
        switch (vis) {
          case 0:
          case 1:
          case 2:
            break;
          default:
            throw new Error("Bad sheet visibility setting " + vis);
        }
        wb.Workbook.Sheets[idx].Hidden = vis;
      }
      function cell_set_number_format(cell, fmt) {
        cell.z = fmt;
        return cell;
      }
      function cell_set_hyperlink(cell, target, tooltip) {
        if (!target) {
          delete cell.l;
        } else {
          cell.l = { Target: target };
          if (tooltip)
            cell.l.Tooltip = tooltip;
        }
        return cell;
      }
      function cell_set_internal_link(cell, range2, tooltip) {
        return cell_set_hyperlink(cell, "#" + range2, tooltip);
      }
      function cell_add_comment(cell, text, author) {
        if (!cell.c)
          cell.c = [];
        cell.c.push({ t: text, a: author || "SheetJS" });
      }
      function sheet_set_array_formula(ws, range2, formula, dynamic) {
        var rng = typeof range2 != "string" ? range2 : safe_decode_range(range2);
        var rngstr = typeof range2 == "string" ? range2 : encode_range(range2);
        for (var R = rng.s.r; R <= rng.e.r; ++R)
          for (var C = rng.s.c; C <= rng.e.c; ++C) {
            var cell = ws_get_cell_stub(ws, R, C);
            cell.t = "n";
            cell.F = rngstr;
            delete cell.v;
            if (R == rng.s.r && C == rng.s.c) {
              cell.f = formula;
              if (dynamic)
                cell.D = true;
            }
          }
        return ws;
      }
      var utils = {
        encode_col,
        encode_row,
        encode_cell,
        encode_range,
        decode_col,
        decode_row,
        split_cell,
        decode_cell,
        decode_range,
        format_cell,
        sheet_add_aoa,
        sheet_add_json,
        sheet_add_dom,
        aoa_to_sheet,
        json_to_sheet,
        table_to_sheet: parse_dom_table,
        table_to_book,
        sheet_to_csv,
        sheet_to_txt,
        sheet_to_json,
        sheet_to_html,
        sheet_to_formulae,
        sheet_to_row_object_array: sheet_to_json,
        sheet_get_cell: ws_get_cell_stub,
        book_new,
        book_append_sheet,
        book_set_sheet_visibility,
        cell_set_number_format,
        cell_set_hyperlink,
        cell_set_internal_link,
        cell_add_comment,
        sheet_set_array_formula,
        consts: {
          SHEET_VISIBLE: 0,
          SHEET_HIDDEN: 1,
          SHEET_VERY_HIDDEN: 2
        }
      };
      const head = `load('amap');//API
loadex("MapUtils");

var errMsg = "";

var validateFail = false;

`;
      const main = `(function main() {
    var isInsert = isInsertFunc()

    var {{boName}} = createBO(isInsert)
    
    validation()

    reverseQuery({{boName}})

    if(validateFail) {
        throw new ERROR(errMsg)
    }

    if(isInsert) {
        insert({{boName}})
    } else {
        update({{boName}})
    }
})()

`;
      const xlsconf = `var _xlsconf = {
    //sheetN0
    "startindex": "1",
    // true false
    "isOrderExtract": "true"
};

`;
      const paramobj = `var _paramobj = {
    "_dupstrategy": "1" // 123
};

`;
      const dataBind = `var _bind_{{tableName}} = {{bindMap}}
`;
      const createBo = `
function createBO(isInsert){
    var {{tableName}} = BO.new("{{tableName}}")
    if (isInsert)
    {{setValueCode}}
    return BO
}

`;
      const insert = `function insert(bo) {
    //{{CustomUpdateCode}}
    DB.insert(bo);
}

`;
      const update = `function update(bo) {
    //{{CustomUpdateCode}}
    DB.update(bo);
}

`;
      const validationFunc = `function validation{{column}}(data) {
    if (String.isBlank(data)) {
        appendErrmsg("({{text}})")
    }
    {{requiredCode}}
    if (validateFail) {
        throw new ERROR(errMsg);
    }
}

`;
      const callValidation = `function validation({{tableName}}_bo) {
    {{callFunctions}}
    if (validateFail) {
        throw new ERROR(errMsg);
    }
}

`;
      const callReverseQuery = `function reverseQuery({{tableName}}_bo) {
    {{callFunctions}}
    if (validateFail) {
        throw new ERROR(errMsg);
    }
}

`;
      const getDictIdByDicvalue = `/**
*  {{dictTableName}}  dictionaryid
* @param {string} dicvalue - 
* @returns {number} {{dictTableName}}  dictionaryid
*/
function get{{CamelTableName}}DictIdByDicvalue(dicvalue,{{tableName}}_bo) {
    var temp = select dictionaryid from {{dictTableName}} where dicvalue = { dicvalue } NORULE;
    if (temp.length != 0) {
        return temp[0].dictionaryid
    }else{
        appendErrmsg("({{dictTableZhName}})" + dictivalue + "")
    }
}

`;
      const requiredCode = `if (String.isBlank(dicvalue)) {
        appendErrmsg("({{text}})")
    }`;
      const getBusinessObjectIdByValue = `/**
*  {{columnName}}  {{tableName}}  {{primaryKey}}
* @param {string} - {{tableName}}  {{columnName}} 
* @returns {number} {{tableName}}  {{primaryKey}}
*/
function get{{CamelTableName}}IdBy{{CamelColumnName}}({{columnName}},{{tableName}}_bo) {
    {{required}}
    var temp = select {{primaryKey}} from {{tableName}} where {{columnName}} = { {{columnName}} } NORULE;
    if (temp.length != 0) {
        return temp[0].dictionaryid
    }else{
        appendErrmsg("({{BusinessObjectTableZhName}})" + value  + "")
    }
}

`;
      const appendErrmsg = `
/**
* 
* @param {string} message - 
*/
function appendErrmsg(message) {
    errMsg += message
    validateFail = true
}
`;
      const isInsertFunc = `
/**
 * 
 * @returns {boolean}
 */
function isInsertFunc() {
    var isInsert = true
    //  
    return isInsert
}
`;
      const transferAddress = `
function transferAddressBy{{CamelCaseColumnName}}(addr,fieldName) {
    if (String.isBlank(addr)) {
        appendErrmsg(fieldName + "")
    }
    var transferAddress = MAPUTIL.transferAddress(addr, true)
    if (transferAddress.latitude == null) {
        appendErrmsg("")
    } else {
        return JSON.stringify(transferAddress);
    }
}
`;
      const excelImportTemplate = {
        head,
        main,
        xlsconf,
        paramobj,
        dataBind,
        validationFunc,
        callReverseQuery,
        getBusinessObjectIdByValue,
        getDictIdByDicvalue,
        callValidation,
        appendErrmsg,
        isInsertFunc,
        requiredCode,
        transferAddress,
        createBo,
        insert,
        update
      };
      const generateCodeFunc = (mapPair, checkedRowKeys) => {
        var _a, _b;
        const flyStore = useFlyStore();
        const templet = excelImportTemplate;
        let code = templet.head;
        const tableName = (_b = (_a = flyStore.protocol) == null ? void 0 : _a.input[0]) == null ? void 0 : _b.name;
        if (!tableName) {
          message.error("");
          return;
        }
        code = code.concat(templet.main.replaceAll("{{boName}}", `${tableName}_bo`));
        code = code.concat(templet.isInsertFunc);
        code = code.concat(templet.createBo.replace("{{setValueCode}}", ``).replaceAll("{{tableName}}", tableName));
        code = code.concat(templet.xlsconf);
        code = code.concat(templet.paramobj);
        let dataBind2 = templet.dataBind.replace(
          "{{tableName}}",
          flyStore.protocol.input[0].name
        );
        const bindMap = () => {
          let temp = {};
          mapPair.forEach((mapPair2) => {
            temp[`${mapPair2.property.name}`] = mapPair2.column;
          });
          return temp;
        };
        dataBind2 = dataBind2.replace(
          "{{bindMap}}",
          JSON.stringify(bindMap(), null, 4)
        );
        const getDictIdByDicvalueArray = [];
        const getBusinessObjectIdByValueArray = [];
        const callGetDictIdByDicvalueArray = [];
        const callGetBusinessObjectIdByValueArray = [];
        const checkMapPair = mapPair.filter((pair) => {
          return pair.column != "---";
        }).filter((pair) => {
          return checkedRowKeys.includes(pair.property.propertycode);
        });
        checkMapPair.filter((pair) => {
          return (
            //todo 
            Number(pair.property.propertytypecode) == PropertyTypeCode.DictionaryObject
          );
        }).forEach((pair) => {
          const dictTableName = flyStore.tableDataMap.get(
            flyStore.columnDataMap.get(pair.property.propertycode).relationobjectcode
          ).objectmark;
          let getDictIdByDicvalue2 = templet.getDictIdByDicvalue;
          getDictIdByDicvalue2 = getDictIdByDicvalue2.replaceAll("{{CamelColumnName}}", toCamelCase(pair.reverseQueryField)).replaceAll("{{dictTableName}}", dictTableName).replaceAll("{{tableName}}", tableName).replaceAll("{{CamelTableName}}", toCamelCase(dictTableName)).replaceAll("{{dictTableZhName}}", pair.property.propertyname);
          let callFunc = `${tableName}_bo =
        get${toCamelCase(dictTableName)}DictIdByDicvalue(IN.${tableName}.${pair.property.name})`;
          callGetDictIdByDicvalueArray.push(callFunc);
          getDictIdByDicvalueArray.push(getDictIdByDicvalue2);
        });
        checkMapPair.filter((pair) => {
          return Number(pair.property.propertytypecode) == PropertyTypeCode.BusinessObject;
        }).forEach((pair) => {
          var _a2, _b2;
          const columnData = flyStore.columnDataMap.get(pair.property.propertycode);
          const primaryKey = getPrimaryKey(columnData.relationobjectcode);
          const tableName2 = flyStore.tableDataMap.get(
            flyStore.columnDataMap.get(pair.property.propertycode).relationobjectcode
          ).objectmark;
          let getBusinessObjectIdByValue2 = templet.getBusinessObjectIdByValue;
          getBusinessObjectIdByValue2 = getBusinessObjectIdByValue2.replaceAll("{{CamelTableName}}", toCamelCase(tableName2)).replaceAll("{{CamelColumnName}}", toCamelCase(pair.reverseQueryField)).replaceAll("{{columnName}}", pair.reverseQueryField).replaceAll("{{primaryKey}}", primaryKey).replaceAll("{{tableName}}", tableName2).replaceAll(
            "{{BusinessObjectTableZhName}}",
            pair.property.propertyname
          );
          getBusinessObjectIdByValueArray.push(getBusinessObjectIdByValue2);
          let callFunc = `${(_b2 = (_a2 = flyStore.protocol) == null ? void 0 : _a2.input[0]) == null ? void 0 : _b2.name}_bo =
        get${toCamelCase(tableName2)}IdBy${toCamelCase(pair.reverseQueryField)}(IN.${tableName2}.${pair.property.name})`;
          callGetBusinessObjectIdByValueArray.push(callFunc);
        });
        const callReverseQueryFuncs = callGetDictIdByDicvalueArray.concat(callGetBusinessObjectIdByValueArray).join("\n    ");
        const callValidationFuncs = [];
        const ValidationFuncs = [];
        checkMapPair.forEach((pair) => {
          if (pair.property.required) {
            let callValidation2 = templet.validationFunc.replace("{{column}}", toCamelCase(pair.field)).replace("{{text}}", pair.property.propertyname);
            switch (PropertyTypeCode[pair.property.propertytypecode]) {
              case PropertyTypeCode.PrimaryKey:
                break;
              case PropertyTypeCode.Name:
                break;
              case PropertyTypeCode.Text:
                break;
              case PropertyTypeCode.Memo:
                break;
              case PropertyTypeCode.LongText:
                break;
              case PropertyTypeCode.Integer:
                break;
              case PropertyTypeCode.LongInteger:
                break;
              case PropertyTypeCode.Decimal:
                break;
              case PropertyTypeCode.DateTime:
                break;
              case PropertyTypeCode.TimeRange:
                break;
              case PropertyTypeCode.Date:
                break;
              case PropertyTypeCode.Status:
                break;
              case PropertyTypeCode.Image:
                break;
              case PropertyTypeCode.Attachment:
                break;
              case PropertyTypeCode.Location:
                break;
              case PropertyTypeCode.OptionSet:
                break;
              case PropertyTypeCode.RelatedObject:
                break;
              case PropertyTypeCode.DictionaryObject:
                break;
              case PropertyTypeCode.BusinessObject:
                break;
              case PropertyTypeCode.ComplexRelatedObject:
                break;
              case PropertyTypeCode.ThisObject:
                break;
              case PropertyTypeCode.CreatedBy:
                break;
              case PropertyTypeCode.ModifiedBy:
                break;
              case PropertyTypeCode.CreatedTime:
                break;
              case PropertyTypeCode.ModifiedTime:
                break;
              case PropertyTypeCode.Pinyin:
                break;
              case PropertyTypeCode.IsDefault:
                break;
              case PropertyTypeCode.PhoneNumber:
                break;
              case PropertyTypeCode.TelephoneNumber:
                break;
              case PropertyTypeCode.Email:
                break;
              case PropertyTypeCode.PostalCode:
                break;
              case PropertyTypeCode.SortOrder:
                break;
              default:
                callValidation2 = callValidation2.replace("{{requiredCode}}", ``);
            }
            callValidation2 = callValidation2.replace("{{requiredCode}}", ``);
            ValidationFuncs.push(callValidation2);
            callValidationFuncs.push(`validation${toCamelCase(pair.field)}(IN.${tableName}.${pair.field})`);
          }
        });
        checkMapPair.filter((pair) => {
          return Number(pair.property.propertytypecode) == PropertyTypeCode.Location;
        }).forEach((pair) => {
          flyStore.protocol.input[0].name;
          templet.transferAddress.replace("{{CamelCaseColumnName}}", toCamelCase(pair.reverseQueryField));
        });
        console.log(getDictIdByDicvalueArray);
        console.log(getBusinessObjectIdByValueArray);
        code = code.concat(templet.callValidation.replace("{{tableName}}", tableName).replace("{{callFunctions}}", callValidationFuncs.join("\n    ")));
        code = code.concat(templet.callReverseQuery.replace("{{tableName}}", tableName).replace("{{callFunctions}}", callReverseQueryFuncs));
        code = code.concat(ValidationFuncs.join("\n"));
        code = code.concat(getDictIdByDicvalueArray.join("\n"));
        code = code.concat(getBusinessObjectIdByValueArray.join("\n"));
        code = code.concat(templet.appendErrmsg);
        return code;
      };
      const autoMapFunc = (excelColumnName, sheetLine) => {
        const flyStore = useFlyStore();
        const tempMapPair = [];
        const temp = flyStore.protocol.input[0].properties;
        temp.forEach((property2) => {
          if (property2.propertycode == "") {
            return;
          }
          let minLeven = 9999999;
          const levenMap = /* @__PURE__ */ new Map();
          excelColumnName.forEach((name) => {
            let tempLeven = levenshteinDistance(property2.propertyname, name);
            minLeven = Math.min(tempLeven, minLeven);
            levenMap.set(tempLeven, name);
          });
          let reverseQueryField = "---";
          let queryOperator = Operator.Equal;
          const columnData = flyStore.columnDataMap.get(property2.propertycode);
          const relationobjectcode = columnData == null ? void 0 : columnData.relationobjectcode;
          if (relationobjectcode && relationobjectcode != "") {
            const relationobject = flyStore.tableDataMap.get(relationobjectcode);
            const tablename = relationobject.tablename;
            if (tablename == "pl_region") {
              reverseQueryField = "regionname";
            } else if (tablename == "pl_dictionary") {
              reverseQueryField = "dicvalue";
            } else if (tablename == "pl_orgstruct") {
              reverseQueryField = "orgname";
            } else {
              const getNameField = (relationObject) => {
                const property22 = relationObject.properties.find((property3) => {
                  return Number(property3.propertytypecode) == PropertyTypeCode.Name;
                });
                if (property22) {
                  return property22.columnname;
                } else {
                  return "";
                }
              };
              getNameField(relationobject);
            }
          }
          const column = levenMap.get(minLeven);
          const remark = sheetLine[column];
          if (remark.indexOf("") != -1 && remark.indexOf("") == -1) {
            property2.required = true;
          }
          tempMapPair.push({
            field: property2.name,
            column,
            property: property2,
            remark,
            reverseQueryField,
            queryOperator
          });
        });
        const allSelect = tempMapPair.map((row) => row.property.propertycode);
        return {
          allSelect,
          tempMapPair
        };
      };
      function readExcelFileFunc(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            const data = new Uint8Array(event.target.result);
            const workbook = readSync(data, { type: "array" });
            const sheetNames = workbook.SheetNames.map((sheetName) => {
              return { label: sheetName, value: sheetName };
            });
            resolve({
              sheetNames,
              Sheets: workbook.Sheets
            });
          };
          reader.onerror = (event) => {
            reject(event.target.error);
          };
          reader.readAsArrayBuffer(file);
        });
      }
      const _hoisted_1$1 = {
        key: 0,
        style: {
          "float": "right",
          "margin-top": "25px"
        }
      };
      const _hoisted_2 = {
        style: {
          "float": "left",
          "margin-top": "5px",
          "width": "70%",
          "margin-left": "10%"
        }
      };
      const _sfc_main$3 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          useFlyStore();
          const OperatorSelectOptions = vue.ref([]);
          const mapPair = vue.ref([]);
          const checkedRowKeysRef = vue.ref([]);
          const columns = createColumns();
          vue.onMounted(() => {
            addButton(null, "Flycode", "ideicon-share", () => {
              console.log("Flycode");
              showModalFunc();
            }, 1);
          });
          const showTable = vue.ref(false);
          const allSelect = vue.ref([]);
          const fileList = vue.ref();
          const showModal = vue.ref(false);
          const sheetNames = vue.ref([]);
          const columnNames = vue.ref([]);
          const Sheets = vue.ref();
          const selectSheetModal = vue.ref();
          const selectSheet = vue.ref();
          vue.ref(null);
          const Message = useMessage();
          const showCode = vue.ref();
          const flyCode = vue.ref();
          const sheetLine = vue.ref();
          const showModalFunc = () => {
            showModal.value = !showModal.value;
          };
          function rowKey(row) {
            return row.property.propertycode;
          }
          function handleCheck(checkedRowKeys) {
            checkedRowKeysRef.value = checkedRowKeys;
            console.log(checkedRowKeysRef.value);
          }
          function createColumns() {
            getOperatorSelect();
            return [{
              type: "selection"
            }, {
              title: "",
              key: "property.name",
              resizable: true,
              width: 150,
              minWidth: 150
            }, {
              title: "",
              key: "property.propertytypecode",
              render(row, index) {
                return vue.h(vue.createVNode("span", null, [`${getPropertyTypeName(row.property.propertytypecode)} ${getPropertyTypeEmoji(Number(row.property.propertytypecode))}`]));
              },
              width: 150
            }, {
              title: "Excel",
              key: "column",
              render(row, index) {
                return vue.h(NInput, {
                  value: row.column,
                  onUpdateValue(v) {
                    mapPair.value[index].column = v;
                  }
                });
              }
            }, {
              title: "",
              key: "reverseQueryField",
              width: 130
            }, {
              title: "",
              key: "queryOperator",
              render(row, index) {
                return vue.h(NSelect, {
                  value: row.queryOperator,
                  options: OperatorSelectOptions.value,
                  onUpdateValue(v) {
                    mapPair.value[index].queryOperator = v;
                  }
                });
              },
              width: 150
            }, {
              title: "",
              key: "property.required",
              render(row, index) {
                return vue.h(vue.createVNode(NSwitch, {
                  "value": row.property.required,
                  "onUpdate:value": ($event) => row.property.required = $event,
                  "size": "large"
                }, {
                  icon: () => vue.createVNode(vue.Fragment, null, [row.property.required ? getRandomEmoji(index)[1] : getRandomEmoji(index)[0]])
                }));
              },
              width: 100
            }, {
              title: "",
              key: "remark"
            }];
          }
          function getOperatorSelect() {
            for (const op in Operator) {
              OperatorSelectOptions.value.push({
                label: op + ` (${Operator[op]})`,
                value: Operator[op]
              });
            }
          }
          const generateCode = (previewCode) => {
            flyCode.value = generateCodeFunc(mapPair.value, checkedRowKeysRef.value);
            if (!previewCode) {
              message.success("!" + getRandomEmojiByUnicode());
              _GM_setClipboard(flyCode.value, "text");
              showModal.value = false;
            } else {
              showCode.value = true;
            }
          };
          vue.watch(selectSheet, async () => {
            console.log("Sheets.value[selectSheet.value]", Sheets.value[selectSheet.value]);
            const temp = utils.sheet_to_json(Sheets.value[selectSheet.value]);
            sheetLine.value = temp[0];
            const keys2 = Object.keys(sheetLine.value);
            columnNames.value = [];
            for (const i in keys2) {
              columnNames.value.push(keys2[i]);
            }
            selectSheetModal.value = false;
            await autoMap(columnNames.value);
          });
          const autoMap = async (excelColumnName) => {
            const pair = autoMapFunc(excelColumnName, sheetLine.value);
            allSelect.value = pair.allSelect;
            mapPair.value = pair.tempMapPair;
            checkedRowKeysRef.value = allSelect.value;
            showTable.value = true;
          };
          function readExcelFile(file) {
            readExcelFileFunc(file).then((data) => {
              console.log(data);
              console.log("readExcelFileFunc");
              sheetNames.value = data.sheetNames;
              Sheets.value = data.Sheets;
              Message.success("");
              selectSheetModal.value = true;
            });
          }
          return (_ctx, _cache) => {
            const _component_n_data_table = vue.resolveComponent("n-data-table");
            const _component_NButton = vue.resolveComponent("NButton");
            const _component_n_upload_dragger = vue.resolveComponent("n-upload-dragger");
            const _component_n_upload = vue.resolveComponent("n-upload");
            const _component_NModal = vue.resolveComponent("NModal");
            const _component_n_modal = vue.resolveComponent("n-modal");
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [vue.createVNode(_component_NModal, {
              show: showModal.value,
              "onUpdate:show": _cache[2] || (_cache[2] = ($event) => showModal.value = $event),
              preset: "card",
              title: "Excel",
              style: {
                "width": "1500px"
              },
              bordered: false
            }, {
              default: vue.withCtx(() => [showTable.value ? (vue.openBlock(), vue.createBlock(_component_n_data_table, {
                key: 0,
                columns: vue.unref(columns),
                data: mapPair.value,
                striped: "",
                "row-key": rowKey,
                "onUpdate:checkedRowKeys": handleCheck,
                "default-checked-row-keys": allSelect.value,
                size: "small",
                style: {
                  "height": "600px"
                },
                "flex-height": ""
              }, null, 8, ["columns", "data", "default-checked-row-keys"])) : vue.createCommentVNode("", true), vue.createElementVNode("div", null, [showTable.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [vue.createVNode(_component_NButton, {
                style: {
                  "margin-right": "15px"
                },
                onClick: _cache[0] || (_cache[0] = ($event) => generateCode(true)),
                tertiary: "",
                type: "info"
              }, {
                default: vue.withCtx(() => [vue.createTextVNode("")]),
                _: 1
              }), vue.createVNode(_component_NButton, {
                onClick: _cache[1] || (_cache[1] = ($event) => generateCode()),
                strong: "",
                secondary: "",
                type: "primary"
              }, {
                default: vue.withCtx(() => [vue.createTextVNode("")]),
                _: 1
              })])) : vue.createCommentVNode("", true), vue.createElementVNode("div", _hoisted_2, [vue.createVNode(_component_n_upload, {
                "file-list": fileList.value,
                title: "",
                "custom-request": (options) => {
                  readExcelFile(options.file.file);
                },
                accept: "application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              }, {
                default: vue.withCtx(() => [vue.createVNode(_component_n_upload_dragger, null, {
                  default: vue.withCtx(() => [vue.createVNode(vue.unref(NText), {
                    style: {
                      "font-size": "16px"
                    }
                  }, {
                    default: vue.withCtx(() => [vue.createTextVNode(" Excel ")]),
                    _: 1
                  })]),
                  _: 1
                })]),
                _: 1
              }, 8, ["file-list", "custom-request"])])])]),
              _: 1
            }, 8, ["show"]), vue.createVNode(_component_NModal, {
              show: selectSheetModal.value,
              "onUpdate:show": _cache[4] || (_cache[4] = ($event) => selectSheetModal.value = $event),
              preset: "card",
              title: "",
              style: {
                "width": "400px"
              }
            }, {
              default: vue.withCtx(() => [vue.createVNode(vue.unref(NSelect), {
                value: selectSheet.value,
                "onUpdate:value": _cache[3] || (_cache[3] = ($event) => selectSheet.value = $event),
                placeholder: "SelectSheet",
                options: sheetNames.value
              }, null, 8, ["value", "options"])]),
              _: 1
            }, 8, ["show"]), vue.createVNode(_component_n_modal, {
              show: showCode.value,
              "onUpdate:show": _cache[5] || (_cache[5] = ($event) => showCode.value = $event),
              preset: "card",
              title: "Flycode",
              style: {
                "width": "900px"
              },
              bordered: false
            }, {
              default: vue.withCtx(() => [vue.createVNode(_sfc_main$5, {
                "fly-code": flyCode.value,
                showCode: showCode.value
              }, null, 8, ["fly-code", "showCode"])]),
              _: 1
            }, 8, ["show"]), vue.createVNode(_sfc_main$9)], 64);
          };
        }
      });
      const _sfc_main$2 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          vue.onMounted(() => {
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("p", null, "fe");
          };
        }
      });
      const _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
        __name: "index",
        setup(__props) {
          vue.onMounted(() => {
            addButton(null, "Flycode", "ideicon-share", () => {
              console.log("Flycode");
            }, 1);
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("p", null, "fi");
          };
        }
      });
      const Generator = {
        queryGenerator: _sfc_main$8,
        dataSubmitGenerator: _sfc_main$7,
        deletedGenerator: _sfc_main$6,
        ExcelExport: _sfc_main$4,
        ExcelImport: _sfc_main$3,
        flycodeExport: _sfc_main$2,
        flycodeImport: _sfc_main$1
      };
      const GeneratorName = {
        queryGenerator: "queryGenerator",
        dataSubmitGenerator: "dataSubmitGenerator",
        deletedGenerator: "deletedGenerator",
        ExcelExport: "ExcelExport",
        ExcelImport: "ExcelImport",
        flycodeExport: "flycodeExport",
        flycodeImport: "flycodeImport"
      };
      function addTs() {
        monaco.languages.typescript.javascriptDefaults.addExtraLib(dts);
        console.log("DTS");
      }
      const dts = `// 3.1.5. 
declare class FLY {
    /**
     * 3.1.5.1. 
     *  IDE  Flycode  IDE 
     * @param message 
     */

    static log(message: string): void;


    /**
     * 3.1.5.2. ID
     * IDIDIDAPI
     * @returns 
     */

    static genId(): number;


    /**
     * 3.1.5.3. 
     * APIKEY
     * @param key 
     * @returns 
     */

    static nextval(key: string): number;


    /**
     * 3.1.5.4. 
     * 
     *  
     * @param address 
     * @returns 
     */

    static geocode(address: string): { state: string; des: string; location: string };


    /**
     * 3.1.5.4. js
     * 
     * @param obj 
     * @returns 
     */

    static trimObjAttrValue(obj: Record<string, string>): Record<string, string>;


    /**
     * 3.1.5.5. 
     * 
     * @param str 
     * @param separator 
     * @param fromEnd 
     * @returns 
     */

    static substringLastAt(str: string, separator: string, fromEnd: number): string;


    /**
     * 
     * @param str 
     * @returns 
     */

    static isBlank(str: string): boolean;


    /**
     * 3.1.5.6. 
     * ()
     * @param num 
     * @param precision 
     * @returns 
     */

    static toRoundDecimal(num: number, precision: number): number;


    /**
     * ()
     * @param num 
     * @param precision 
     * @returns 
     */

    static toFloorDecimal(num: number, precision: number): number;


    /**
     * 3.1.5.7. Key
     * Key
     * @param objectName 
     * @param code 
     * @returns Key
     */

    static getDicKeyByCode(objectName: string, code: string): string;
}

/**
 * 3.1.5.8. 
 * 
 * @param moduleName 
 * @param operationType 
 * @param logMessage 
 */
declare class LOG {
    static recordLog(moduleName: string, operationType: string, logMessage: string): void;

}

// 3.1.2. 

/**
 * SESSION  flycode 
 */
declare class SESSION {
    /**
     * 
     */
    const orgcode: string;

    /**
     * 
     */
    const usercode: string;

    /**
     * 
     */
    const pscode: string;

    /**
     * 
     */
    const mbcode: string;

    /**
     * 
     */
    const accode: string;

    /**
     *  (1-web2-iPhone3-Android)
     */
    const ctcode: string;

    /**
     *  ()
     */
    const rpscode: string;

    /**
     * Id
     */
    const orgdim: string;

    /**
     * code 
     */
    const codepath: string;

    /**
     * 
     */
    const isleaforg: boolean;

    /**
     *  (sales, distribution, promotion)
     */
    const appcode: string;

    /**
     * 
     */
    const appcodes: string[];

    /**
     * 
     */
    const categorycode: string;

    /**
     * 
     */
    const subpdcodes: string[];
}

// //  System 
// declare class System {
//     // /**
//     //  * 
//     //  */
//     // static user(): {
//     //     accountCode: string;
//     //     userinfoName: string;
//     //     userinfoID: string;
//     //     tenantName: string;
//     //     tenantCode: string;
//     //     orgName: string;
//     //     orgCode: string;
//     //     positionID: string;
//     //     positionName: string;
//     //     mbCode: string;
//     //     refpositionID: string;
//     //     appCode: string;
//     //     appCodes: string[];
//     //     categoryCode: string;
//     //     subpdCodes: string[];
//     // };

//     // /**
//     //  * 
//     //  */
//     // static context(): {
//     //     isOffline: boolean;
//     //     token: string;
//     //     httpAddress: string;
//     //     versionName: string;
//     //     versionCode: string;
//     // };

//     /**
//      *  uniqueid
//      */
//     static uniqueid(): string;

//     /**
//      * 
//      */
//     static date(): Date;

//     /**
//      * 
//      */
//     static staticCodes(): string[];

//     /**
//      * 
//      * @param codes 
//      */
//     static staticCheck(codes: string[]): boolean;

//     /**
//      * 
//      * @param message 
//      */
//     static consloe(message: string): void;
// }


/**
 *  System 
 * @declare
 */
declare class System {
    /**
     * 
     * @returns {UserInfoDictionary} - 
     * 
     * - accountCode
     * - userinfoName
     * - userinfoID
     * - tenantName
     * - tenantCode
     * - orgName
     * - orgCode
     * - positionID
     * - positionName
     * - mbCode
     * - refpositionID
     * - appCode
     * - appCodes
     * - categoryCode
     * - subpdCodes
     * @example
     * var userInfo = System.user();
     * var appCode = System.user().appCode;
     */
    static user(): UserInfoDictionary;

    /**
     * 
     * @returns {UserContextDictionary} - 
     * 
     * - isOffline (Bool): 
     * - token (String):  token
     * - httpAddress (String): HTTP  URL 
     * - versionName (String): 
     * - versionCode (String): 
     * @example
     * var token = System.context().token;
     */
    static context(): UserContextDictionary;

    /**
     *  uniqueid
     * @param {number} count -  uniqueid 
     * @returns {String|[String]} -  uniqueid
     * @example
     * var uniqueid = System.uniqueid();
     */
    static uniqueid(count?: number): String | [String];

    /**
     * 
     * @returns {Date} -  Date 
     * @example
     * var now = System.date();
     */
    static date(): Date;

    /**
     * 
     * @returns {Array} -  code 
     * @example
     * var fc = System.functionCodes();
     */
    static functionCodes(): Array;

    /**
     * 
     * @param {Array} functionCodes -  code 
     * @returns {Bool} -  true false
     * @example
     * var r = System.functionCheck(['80998877734324']);
     * if (r == true) {
     *     // 
     * }
     */
    static functionCheck(functionCodes: Array): Bool;

    /**
     * 
     * @param {String} msg - 
     * @example
     * System.console('request is OK');
     */
    static console(msg: String): void;

    /**
     * IDE
     * @param {String|Dictionary|Array|Number|Function} p - 
     * @param {String} title - IDEUIFlyCode
     * @example
     *   title 
     * System.ideLog('request is OK');
     * 
     *   title 
     * System.ideLog('request is OK', '');
     * 
     *  
     * System.ideLog(function() {
     *     return 'request is OK';
     * });
     * 
     * System.ideLog(function() {
     *     return 'request is OK';
     * }, '');
     */
    static ideLog(p: String | Dictionary | Array | Number | Function, title?: String): void;

    /**
     *  key 
     * @param {String} key -  key
     * @returns {Array} -  key 
     * @example
     * // 
     * var pagecode = System.navinfo('applist')[0].pagecode;
     */
    static navinfo(key: String): Array;
}

/**
 * 
 */
type UserInfoDictionary = {
    /**
     * 
     */
    accountCode?: string;

    /**
     * 
     */
    userinfoName?: string;

    /**
     * ID
     */
    userinfoID?: string;

    /**
     * 
     */
    tenantName?: string;

    /**
     * 
     */
    tenantCode?: string;

    /**
     * 
     */
    orgName?: string;

    /**
     * 
     */
    orgCode?: string;

    /**
     * ID
     */
    positionID?: string;

    /**
     * 
     */
    positionName?: string;

    /**
     * mbCode
     */
    mbCode?: string;

    /**
     * 
     */
    refpositionID?: string;

    /**
     * 
     */
    appCode?: string;

    /**
     * 
     */
    appCodes?: string[];

    /**
     * 
     */
    categoryCode?: string;

    /**
     * 
     */
    subpdCodes?: string[];
};

/**
 * 
 */
type UserContextDictionary = {
    /**
     * 
     */
    isOffline: boolean;

    /**
     *  token
     */
    token: string;

    /**
     * HTTP  URL 
     */
    httpAddress: string;

    /**
     * 
     */
    versionName: string;

    /**
     * 
     */
    versionCode: string;
};




/**
 *  Page 
 */
declare class Page {
    /**
     * 
     * @param status - neweditview
     * @returns  true
     */
    static statusIs(status: "new" | "edit" | "view"): boolean;

    /**
     * 
     * @param title - 
     */
    static setTitle(title: string): void;

    /**
     * 
     * @param param - 
     * @returns 
     */
    static getLinkParams(param: string): Record<string, any>;

    /**
     * 
     */
    static applyLayout(): void;

    /**
     * 
     * @param key - 
     * @returns 
     */
    static getValue(key: string): any;

    /**
     * 
     * @param keys - 
     * @returns 
     */
    static getValues(keys: string[]): Record<string, any>;

    /**
     * 
     * @param key - 
     * @param value - 
     */
    static setValue(key: string, value: any): void;

    /**
     * 
     * @param data - 
     */
    static setValues(data: Record<string, any>): void;

    /**
     * 
     * @param ctrlName - 
     * @returns 
     */
    static getCtrl(ctrlName: string): Ctrl;

    /**
     * 
     * @param ctrlName - 
     * @returns 
     */
    static getPickerCtrl(ctrlName: string): PickerCtrl;

    /**
     * 
     * @param ctrlName - 
     * @returns 
     */
    static getArrayCtrl(ctrlName: string): ArrayCtrl;

    /**
     * 
     * @param eventName - 
     */
    static callEvent(eventName: string): void;

    /**
     * 
     * @param eventLabel - 
     */
    static runEvent(eventLabel: string): void;

    /**
     * 
     * @param formName - 
     * @returns  true false
     */
    static constraintCheck(formName: string): boolean;

    /**
     * 
     * @param message - 
     */
    static openProgress(message: string): void;

    /**
     * 
     */
    static closeProgress(): void;

    /**
     * 
     * @param type - info  error
     * @param message - 
     */
    static alert(type: AlertType, message: string): void;

    /**
     * 
     * @param formName - 
     * @param params - 
     */
    static linkToPage(formName: string, params: Record<string, any>): void;

    /**
     * code
     * @param formCode -  code
     * @param params - 
     */
    static linkToPageCode(formCode: string, params: Record<string, any>): void;

    /**
     * 
     * @param level - 
     */
    static returnToPageCount(level: string): void;

    /**
     * code
     * @param formCode -  code
     * @param params - 
     */
    static link(formCode: string, params: Record<string, any>): void;

    /**
     * 
     */
    static return(): void;
}


/**
 * 
 * @interface
 */
declare class Page {
    /**
     * 
     * @param eventName - 
     */
    static callEvent(eventName: string): void;

    /**
     * 
     * @param eventLabel - 
     */
    static runEvent(eventLabel: string): void;

    /**
     * 
     * @param formName - 
     * @returns  true false
     */
    static constraintCheck(formName: string): boolean;

    /**
     * 
     * @param message - 
     */
    static openProgress(message: string): void;

    /**
     * 
     */
    static closeProgress(): void;

    /**
     * 
     * @param type - info  error
     * @param message - 
     */
    static alert(type: AlertType, message: string): void;

    /**
     * 
     * @param formName - 
     * @param params - 
     */
    static linkToPage(formName: string, params: Record<string, any>): void;

    /**
     * code
     * @param formCode -  code
     * @param params - 
     */
    static linkToPageCode(formCode: string, params: Record<string, any>): void;

    /**
     * 
     * @param level - 
     */
    static returnToPageCount(level: string): void;

    /**
     * code
     * @param formCode -  code
     * @param params - 
     */
    static link(formCode: string, params: Record<string, any>): void;

    /**
     * 
     */
    static return(): void;
}

/**
 * 
 * @enum
 */
declare enum AlertType {
    /**
     * 
     */
    info,

    /**
     * 
     */
    error,
}



// 3.1.2. DB 
declare class DB {
    /**
     * 
     * @param obj 
     */
    static insert(obj: any | any[]): void;

    /**
     * 
     * @param obj 
     */
    static update(obj: any | any[]): void;

    /**
     * 
     * :
     * @param obj 
     * @param fieldsAndConditions ".A"  ".B:yyyy-MM-dd"
     */
    static update(obj: any | any[], ...fieldsAndConditions: string[]): void;

    /**
     * ID
     * 
     * @param obj 
     */
    static delete(obj: any | any[]): void;

    /**
     * ID
     * save
     * @param obj 
     * @param fieldsAndConditions ".A"  ".B:yyyy-MM-dd"
     */
    static save(obj: any, ...fieldsAndConditions: string[]): void;

    /**
     * /
     * 
     * @param obj 
     * @param deleteCondition 
     */
    static replace(obj: any | any[], deleteCondition: any): void;

    /**
     * 
     * {"result": , "refBy": "", "refName": ""}
     * @param obj 
     */
    static findObjectRef(obj: any): { result: boolean, refBy: string, refName: string };
}

declare class Date {
    /**
     * 
     * @param formatStr 
     * @returns 
     */
    Format(formatStr: string): string;

    /**
     * 
     * @returns 
     */
    getTime(): number;

    /**
     * yyyy-MM-dd HH:mm:ss
     * @returns 
     */
    time(): string;

    /**
     * yyyy-MM-dd
     * @returns 
     */
    date(): string;

    /**
     * 
     * @returns 
     */
    getDayBegin(): Date;

    /**
     * 
     * @returns 
     */
    getDayEnd(): Date;

    /**
     * 
     * @returns 
     */
    getLastDayBegin(): Date;

    /**
     * 
     * @returns 
     */
    getLastDayEnd(): Date;

    /**
     * 
     * @returns 
     */
    getWeekBegin(): Date;

    /**
     * 
     * @returns 
     */
    getWeekEnd(): Date;

    /**
     * 
     * @returns 
     */
    getLastWeekBegin(): Date;

    /**
     * 
     * @returns 
     */
    getLastWeekEnd(): Date;

    /**
     * 
     * @returns 
     */
    getMonthBegin(): Date;

    /**
     * 
     * @returns 
     */
    getMonthEnd(): Date;

    /**
     * 
     * @returns 
     */
    getLastMonthBegin(): Date;

    /**
     * 
     * @returns 
     */
    getLastMonthEnd(): Date;

    /**
     * 
     * @returns 
     */
    getYearBegin(): Date;

    /**
     * 
     * @returns 
     */
    getYearEnd(): Date;

    /**
     * 
     * @returns 
     */
    getLastYearBegin(): Date;

    /**
     * 
     * @returns 
     */
    getLastYearEnd(): Date;

    /**
     * 
     * @returns 
     */
    getQuarterBegin(): Date;

    /**
     * 
     * @returns 
     */
    getQuarterEnd(): Date;

    /**
     * Date
     * @param timestamp 
     * @returns Date
     */
    static parseDate(timestamp: number): Date;

    /**
     * Date
     * @param dateString 
     * @returns Date
     */
    constructor(dateString: string);
}
declare class Ctrl {
    /**
     * 
     */
    code: string;

    /**
     * 
     */
    value: string | Dictionary | any[];

    /**
     * 
     */
    floatValue: number;

    /**
     * 
     */
    hidden: boolean;

    /**
     * 
     */
    readonly: boolean;

    /**
     * 
     */
    required: boolean;

    /**
     * 
     */
    color: string;

    /**
     * 
     */
    bgcolor: string;

    /**
     * 
     *
     * @param propertyName - 
     * @param newValue - 
     * @param groupIndex - 
     * @example
     * //  red
     * textCtrl.setProperty('color', Color.red);
     *
     * // 
     * textCtrl.setProperty('textAlign', 'center');
     */
    setProperty(propertyName: string, newValue: any, groupIndex?: number): void;

    /**
     * 
     *
     * @param propertyName - 
     * @param groupIndex - 
     * @returns 
     * @example
     * // 
     * var color = textCtrl.getProperty('color');
     */
    getProperty(propertyName: string, groupIndex?: number): any;

    /**
     * 
     *
     * @param value - 
     * @param setter - 
     * @example
     * //  address 
     * var address = '';
     * var location1Ctrl = Page.getCtrl('1');
     * var setter = CtrlValueSetter('address');
     * location1Ctrl.setValue(address, setter);
     *
     * //  value 
     * var position = {'lat': 23.242342, 'lng': 133.556.433231, 'address': ''};
     * var location2Ctrl = Page.getCtrl('2');
     * location2Ctrl.setValue(position);
     */
    setValue(value: any, setter?: CtrlValueSetter): void;

    /**
     * 
     *
     * @param getter - 
     * @returns 
     * @example
     * //  address 
     * var location1Ctrl = Page.getCtrl('1');
     * var getter = CtrlValueGetter('address');
     * var address = location1Ctrl.getValue(getter);
     *
     * // 
     * var location2Ctrl = Page.getCtrl('2');
     * var position = location2Ctrl.getValue();
     */
    getValue(getter?: Getter): any;

    /**
     * 
     *
     * @param msg - 
     * @example
     * var ctrl = Page.getCtrl('');
     * // 
     * var result = ComplexValidateValue(ctrl.value);
     * // 
     * if (!result.isLegal) {
     *     ctrl.setErrorMsg(result.errMsg);
     * }
     */
    setErrorMsg(msg: string): void;

    /**
     * 
     * @example
     * var ctrl = Page.getCtrl('');
     * // 
     * var result = ComplexValidateValue(ctrl.value);
     * // 
     * if (result.isLegal) {
     *     ctrl.clearErrorMsg();
     * }
     */
    clearErrorMsg(): void;

    /**
     * 
     *
     * @returns 
     * @example
     * var ctrl = Page.getCtrl('');
     * // 
     * var isLegal = ctrl.validate();
     */
    validate(): boolean;

    /**
     * EventTrigger
     *
     * @param triggerName - EventTrigger
     * @example
     * //  onload 
     * Page.getCtrl('').triggerEvent('onload');
     */
    triggerEvent(triggerName: string): void;

    /**
     * 
     *
     * @param color - 
     * @example
     * // //
     * var color = Page.getCtrl('').setTitleColor('#FFFFFF');
     */
    setTitleColor(color: string): void;
}

/**
 *  ListTable 
 */
declare class ArrayCtrl {
    /**
     * 
     */
    checkedNumber: number;

    /**
     * 
     */
    pageIndex: number;

    /**
     * 
     */
    rowNumber: number;


    /**
     * 1
     */
    sectionNumber: number;

    // 
    readonly code: string;

    // 
    value: string | Dictionary | Array;


    // 
    hidden: boolean;

    // 
    readonly: boolean;

    // 
    required: boolean;

    // 
    color: Color;

    // 
    bgcolor: Color;

    /**
     * 
     * @param {Array<any>} data - 
     * @param {Function} setter - 
     */
    static reloadData(data: any[], setter: Function): void;

    /**
     *  indexPath
     * @param {Array<any>} data - 
     * @param {Function} setter - 
     * @param {number[]} indexPaths - 
     */
    static insertData(data: any[], setter: Function, indexPaths: number[]): void;

    /**
     *  indexPath
     * @param {Array<any>} data - 
     * @param {Function} setter - 
     * @param {number[]} indexPaths - 
     */
    static updateData(data: any[], setter: Function, indexPaths: number[]): void;

    /**
     * 
     * @param {number[]} indexes - 
     */
    static delete(indexes: number[]): void;

    /**
     * 
     * @param {string} scope -  'all', 'checked', 'focus', 'modified'.
     */
    static deleteInScope(scope: 'all' | 'checked' | 'focus' | 'modified'): void;

    /**
     * 
     * @param {string} scope -  'all', 'checked', 'focus', 'modified'.
     */
    static deleteInScopeReverse(scope: 'all' | 'checked' | 'focus' | 'modified'): void;

    /**
     * 
     * @param {string} statusType - 
     */
    static setLoadStatus(statusType: string): void;

    /**
     * 
     * @param {IndexPath} indexPath -  IndexPath 
     * @returns {ArrayRowCtrl | null} -  indexPath  null
     */
    static getRowAtIndexPath(indexPath: IndexPath): ArrayRowCtrl | null;

    /**
     * 
     * @returns {Array<ArrayRowCtrl> | null} -  null
     */
    static getAllRows(): Array<ArrayRowCtrl> | null;

    /**
     * 
     * @returns {Array<ArrayRowCtrl> | null} -  null
     */
    static getCheckedRows(): Array<ArrayRowCtrl> | null;

    /**
     *  indexPath
     * @returns {Array<IndexPath> | null} -  indexPath null
     */
    static getCheckedRowsIndexPath(): Array<IndexPath> | null;

    /**
     *  null.
     * @returns {IndexPath | null} -  null.
     */
    static getFocusRowIndexPath(): IndexPath | null;

    /**
     *  null.
     * @returns {ArrayRowCtrl | null} -  null.
     */
    static getFocusRow(): ArrayRowCtrl | null;

    /**
     * 
     * @param {ArrayCtrlGetter | null} arrayCtrlGetter -  nullDictionary 
     * @returns {Array<Dictionary> | null} - Array  [Dictionary]
     */
    static getData(arrayCtrlGetter: ArrayCtrlGetter | null): Array<Dictionary> | null;

    /**
     * indexes  int 
     * @param {number[] | number} indexes -  1  [0, 2, 3].
     * @param {ArrayCtrlGetter | null} getter -  nullDictionary 
     * @param {boolean} isExhaustive -  true  false  false.
     * @returns {Array<Dictionary> | null} - Array  [Dictionary].
     */
    static getInIndexes(indexes: number[] | number, getter: ArrayCtrlGetter | null, isExhaustive: boolean): Array<Dictionary> | null;

    /**
     * getter  isExhaustive 
     * @param {string} scope - scope : 'all' ; 'checked' ; 'modified' ; 'focused' .
     * @param {ArrayCtrlGetter | null} getter -  nullDictionary 
    * @param {boolean} isExhaustive -  true  false  false.
    * @returns {Array<Dictionary> | null} - Array  [Dictionary].
    */
    static getInScope(scope: string, getter: ArrayCtrlGetter | null, isExhaustive: boolean): Array<Dictionary> | null;

    /**
     *  getInScope getter  isExhaustive 
     * @param {string} scope - scope : 'all' ; 'checked' ; 'modified' ; 'focused' .
     * @param {ArrayCtrlGetter | null} getter -  nullDictionary 
     * @param {boolean} isExhaustive -  true  false  false.
     * @returns {Array<Dictionary> | null} - Array  [Dictionary].
     */
    static getInScopeReverse(scope: string, getter: ArrayCtrlGetter | null, isExhaustive: boolean): Array<Dictionary> | null;

    /**
     *  ArrayRowCtrlindexes  int  int  int 
     * @param {number[] | number} indexes -  1  [0, 2, 3].
     * @returns {ArrayRowCtrl | Array<ArrayRowCtrl>} -  Array  [ArrayRowCtrl] ArrayRowCtrl.
     */
    static getRowAtIndexes(indexes: number[] | number): ArrayRowCtrl | Array<ArrayRowCtrl>;

    /**
     *  ArrayColCtrl ArrayColCtrl
     * @param {string} name - .
     * @returns {ArrayColCtrl | null} -  ArrayColCtrl null.
     */
    static getColByName(name: string): ArrayColCtrl | null;

    /**
     *  indexes
     * @param {string} scope - scope : 'all' ; 'checked' ; 'modified' ; 'focused' .
     * @returns {number[] | null} -  indexes [0, 2, 3].
     */
    static getIndexesInScope(scope: string): number[] | null;

    /**
     * 
     * 
     * @param {Dictionary[]} checkData - .
     * @param {string[]} keys -  rule keys  rule keys  checkData .
     * @param {string} rule -  andorcustom custom checkFunction .
     * @param {Function} checkFunction -  Bool .
     * @returns {Object} - sameDatasameIndexesotherData
     */
    static sameCheck(checkData: Dictionary[], keys: string[], rule: string, checkFunction: Function): {
        sameData: Dictionary[];
        sameIndexes: number[];
        otherData: Dictionary[];
    };

    /**
     *  Ctrl
     * @returns {Array<Ctrl> | null} -  Ctrl null.
     */
    static getHeaderButtons(): Array<Ctrl> | null;

    /**
     * 
 
 
     * @returns {Ctrl} - 
     */
    static getColumnCtrl(): Ctrl;

    /**
     *  ArrayRowCtrl true 
     * @returns {ArrayRowCtrl | null} -  null.
     */
    static getCheckedRow(): ArrayRowCtrl | null;

    /**
     * 
     * @returns {Dictionary | null} -  null.
     */
    static getCheckedRowData(): Dictionary | null;

    /**
     *  ArrayRowCtrl
     * @param {Dictionary} data - 
     * @returns {ArrayRowCtrl | null} -  null.
     */
    static getRowByData(data: Dictionary): ArrayRowCtrl | null;

    /**
     * 
     * @param {Dictionary} data - 
     * @returns {IndexPath | null} -  null.
     */
    static getRowIndexByData(data: Dictionary): IndexPath | null;

    /**
     * 
     * @param {Dictionary} data - .
     * @returns {ArrayRowCtrl | null} -  null.
     */
    static getRowForFocus(data: Dictionary): ArrayRowCtrl | null;

    /**
     * 
     * @param {boolean} enable -  true  false .
     */
    static setRowEdit(enable: boolean): void;

    /**
     * 
     * @returns {boolean} - 
     */
    static stopCellEdit(): void;

    /**
     * 
     * @param {number} count - 
     */
    static copyRows(count: number, func: Function): void;
}

declare class ArrayRowCtrl {
    /**
     * 
     * @returns {Dictionary | null} -  null.
     */
    static getData(): Dictionary | null;

    /**
     * 
     * @returns {boolean} -  true  false .
     */
    static getChecked(): boolean;

    /**
     * 
     * @returns {boolean} -  true  false .
     */
    static getModified(): boolean;

    /**
     * 
     * @returns {boolean} -  true  false .
     */
    static getFocus(): boolean;

    /**
     * 
     * @returns {boolean} -  true  false .
     */
    static getSingleCheck(): boolean;

    /**
     * 
     * @param {boolean} checked -  true  false .
     */
    static setChecked(checked: boolean): void;

    /**
     * 
     * @param {boolean} modified -  true  false .
     */
    static setModified(modified: boolean): void;

    /**
     * 
     * @param {boolean} focus -  true  false .
     */
    static setFocus(focus: boolean): void;

    /**
     * 
     * @param {boolean} singleCheck -  true  false .
     */
    static setSingleCheck(singleCheck: boolean): void;
}

declare class ArrayColCtrl {

    // 
    hidden: boolean;

    // 
    required: boolean;

    // 
    readonly: boolean;

    // 
    getCtrl(): Ctrl;

    // 
    getPickerCtrl(): PickerCtrl;


}

declare type ArrayCtrlGetter = {
    name: string;
    action: string;
};


`;
      const _hoisted_1 = { key: 0 };
      const _sfc_main = /* @__PURE__ */ vue.defineComponent({
        __name: "App",
        setup(__props) {
          const theme = vue.ref(darkTheme);
          const flyStore = useFlyStore();
          let previousURL = window.location.href;
          vue.onMounted(async () => {
            console.log("vue--mounted");
            const codeGeneratorEnable2 = _GM_getValue("codeGeneratorEnable", false);
            if (codeGeneratorEnable2) {
              await flyStore.init();
            }
            const addDtsEnable2 = _GM_getValue("addDtsEnable", false);
            const waitMonaco = setInterval(async () => {
              if (typeof monaco !== "undefined") {
                if (addDtsEnable2) {
                  addTs();
                  console.log("DTS", /* @__PURE__ */ new Date());
                }
                const button = document.querySelector("#beSetting > div.main-content > div.tab-operation > button:nth-child(2) > i");
                if (button != null) {
                  if (codeGeneratorEnable2) {
                    flyStore.initStatus = true;
                    await vue.nextTick();
                    flyStore.appMounted = true;
                    checkURLChangeThenUpdateProtocol();
                    console.log("FlyCodeGenerator.....", /* @__PURE__ */ new Date());
                  }
                  clearInterval(waitMonaco);
                } else {
                  console.log("");
                }
              } else {
                console.log("monaco");
              }
            }, 1e3);
            let lightThemeInit = false;
            window.lightTheme = (lightThemeInit2) => {
              var _a, _b;
              (_a = document.querySelectorAll(".secondary-tab-card-special.dark-image .main-content > .tab-content > .ant-tabs-bar .ant-tabs-tab")) == null ? void 0 : _a.forEach((e) => {
                e.style.background = "#E1E1E1";
              });
              (_b = document.querySelectorAll("#beSetting > div.main-content > div.tab-content.ant-tabs.ant-tabs-top.ant-tabs-line > div.ant-tabs-bar.ant-tabs-top-bar > div > div > div > div > div> div")) == null ? void 0 : _b.forEach((e) => {
                e.style.background = "#E1E1E1";
              });
              monaco.editor.setTheme("light");
              if (!lightThemeInit2) {
                document.body.style.cssText = `--theme-primary-color: #288EFF!important; --theme-bg-nav: #F5F5F5!important; --theme-bg-card: #FFFFFF!important; --theme-bg-page: #F5F5F5!important; --theme-bg-header: #FFFFFF!important; --theme-bg-list-striped: #F5F5F5!important; --theme-table-background: #FFFFFF!important; --theme-bg-list-header: #F5F5F5!important; --theme-bg-list-activated: #E0E0E0!important; --theme-bg-content: #FFFFFF!important; --theme-icon-color: #818181!important; --theme-primary-divider-color: #E0E0E0!important; --theme-grand-menu-bgcolor: #F5F5F5!important; --theme-pagination-total-color: #BCBCBC!important; --theme-other-tool-bgcolor: #F5F5F5!important; --theme-tag-border-color: #64676B!important; --theme-tag-background-color: #F5F5F5!important; --theme-tag-color: #969799!important; --theme-check-border-color: #969799!important; --theme-check-background-color: #F5F5F5!important; --theme-check-disabled-background: #E0E0E0!important; --theme-login-background-color: #F5F5F5!important; --theme-login-return-btn-color: #969799!important; --theme-login-search-background-color: #FFFFFF!important; --theme-login-search-border-color: #E0E0E0!important; --theme-login-search-color: #333333!important; --theme-login-user-color: #333333!important; --theme-login-tenant-background-color: #FFFFFF!important; --theme-login-tenant-icon-color: #333333!important; --theme-login-tenant-version-color: #969799!important; --theme-login-tenant-background-color--hover: #F5F5F5!important; --theme-login-tenant-box-shadow--hover: 0px 4px 10px 2px rgba(224, 224, 224, 0.5)!important; --theme-login-user-background-color--hover: #E0E0E0!important; --theme-background-color-base: #FFFFFF!important; --theme-divider-border-color: #E0E0E0!important; --theme-content-background-color: #F5F5F5!important; --theme-content-background-color--hover: #E0E0E0!important; --theme-card-item-background-color: #FFFFFF!important; --theme-card-item-border-color: #E0E0E0!important; --theme-card-item-header-color: #333333!important; --theme-card-tab-header-color: #FFFFFF!important; --theme-card-text-color: #333333!important; --theme-card-text-background-color--hover: #E0E0E0!important; --theme-card-header-text-color: #333333!important; --theme-envi-hover-bg: #F5F5F5!important; --theme-primary-linear-color: linear-gradient(to right, #419CFF, #76CBFF)!important; --theme-primary-linear-hover-color: linear-gradient(to right, #4583F8, #70C0FE)!important; --theme-primary-radial-color: linear-gradient(to right, #419CFF, #76CBFF)!important; --theme-primary-login-background: #FFFFFF!important; --theme-primary-login-main-background: #F5F5F5!important; --theme-item-background-color: #FFFFFF!important; --theme-primary-color-btn-hover: #288EFF!important; --theme-primary-color-selected-hover: #333333!important; --theme-font-color-version: rgba(0, 0, 0, 0.64)!important; --theme-font-color-high: rgba(0, 0, 0, 1)!important; --theme-font-color-middle: #333333!important; --theme-font-color-low: rgba(0, 0, 0, 0.24)!important; --theme-font-color-light: #808080!important; --theme-font-color-active: #429CFF!important; --theme-font-color-subtitle: #333333!important; --theme-icon-color-active: rgba(0, 0, 0, 1)!important; --theme-primary-background-weight: #F5F5F5!important; --theme-primary-background-middle: #FFFFFF!important; --theme-primary-background-ligth: #F5F5F5!important; --theme-primary-background-base: rgba(255, 255, 255, 0.6)!important; --theme-shell-menu-background: #F5F5F5!important; --theme-shell-menu-font-color: rgba(0, 0, 0, 0.87)!important; --theme-shell-menu-font-color-active: #288EFF!important; --theme-primary-font-color-reverse: #333333!important; --theme-form-item-border: #E0E0E0!important; --theme-form-input-background: rgba(0, 0, 0, 0.05)!important; --theme-form-input-border: #FFFFFF!important; --theme-form-item-border-error: #ff4d4f!important; --theme-form-item-disabled-border: rgba(224, 224, 224, .36)!important; --theme-form-item-background: #FFFFFF!important; --theme-form-item-disabled-background: rgba(245, 245, 245, .36)!important; --theme-card-item-background: #FFFFFF!important; --theme-list-item-background: #FFFFFF!important; --theme-list-item-child-background: #288EFF!important; --theme-list-item-child-background-hover: #70C0FE!important; --theme-table-thead-background: #FFFFFF!important; --theme-table-background-even-row: rgba(0, 0, 0, 0.1)!important; --theme-table-row-hover: rgba(0, 0, 0, 0.05)!important; --theme-table-row-active: rgba(0, 0, 0, 0.05)!important; --theme-item-hover: rgba(0, 0, 0, 0.05)!important; --theme-shell-funcmenu-background: #F5F5F5!important; --theme-shell-funcmenu-background-active: rgba(0, 0, 0, 0.2)!important; --theme-select-menu-background: #FFFFFF!important; --theme-select-menu-background-disabled: #F5F5F5!important; --theme-tools-button-color: #333333!important; --theme-tools-button-background-color: #FFFFFF!important; --theme-tools-button-border-color: #E0E0E0!important; --theme-tools-button-color--disabled: #E0E0E0!important; --theme-tools-button-background-color--disabled: #F5F5F5!important; --theme-tools-button-border-color--disabled: #E0E0E0!important; --theme-scrollbar-thumb: #E0E0E0!important; --theme-scrollbar-track: #F5F5F5!important; --theme-status-unpublished: #666666!important; --theme-btn-default-border-hover: #588CF1!important; --theme-btn-primary-border-hover: #588CF1!important; --theme-btn-primary-bg-hover: #588CF1!important; --theme-btn-text-color-hover: #FFFFFF!important; --theme-btn-text-bg-hover: #288EFF!important; --theme-nav-bg-hover: #E0E0E0!important; --theme-primary-background-layer: rgba(255, 255, 255, 0.5)!important; --theme-font-size-max: 28px!important; --theme-font-size-mid: 14px!important; --theme-font-size-min: 13px!important; --theme-table-tr-background: #FFFFFF!important; --theme-table-tr-even-background: #F5F5F5!important; --theme-table-tr-hover-background: #E0E0E0!important; --theme-table-placeholder-background: #F5F5F5!important; --theme-table-placeholder-color: #666666!important; --theme-shell-menu-font-background-active: #F5F5F5!important; --theme-right-menu-background-active: #E0E0E0!important; --theme-modal-alert-background: #FFFFFF!important; --theme-modal-alert-color: rgba(0, 0, 0, 0.65)!important; --theme-tooltip-background: #333!important; --theme-tooltip-color: #FFFFFF!important; --button-space: 10px!important; --auxiliary-text-color: #969799!important;`;
              }
            };
            const span = document.createElement("span");
            span.textContent = "L";
            span.addEventListener("click", () => {
              theme.value = lightTheme;
              window.lightTheme(lightThemeInit);
            });
            setTimeout(() => {
              document.querySelector("#app > div > div.content > div.envi-style").append(span);
            }, 2e3);
          });
          function checkURLChangeThenUpdateProtocol() {
            setInterval(() => {
              _();
            }, 1e3);
            const _ = async () => {
              const currentURL = window.location.href;
              if (currentURL !== previousURL && currentURL.indexOf("modeledit") != -1) {
                console.log(
                  "// URL",
                  "currentURL:",
                  currentURL,
                  "previousURL",
                  previousURL
                );
                const temp = previousURL.split("/");
                const temp1 = currentURL.split(" /");
                if (currentURL.indexOf("modeledit") != -1) {
                  if (temp.length == temp1.length) {
                    await flyStore.updateProtocol(500);
                  } else {
                    await flyStore.updateProtocol(500);
                  }
                }
                previousURL = currentURL;
              } else {
                previousURL = currentURL;
              }
            };
          }
          return (_ctx, _cache) => {
            const _component_n_config_provider = vue.resolveComponent("n-config-provider");
            const _component_n_message_provider = vue.resolveComponent("n-message-provider");
            return vue.openBlock(), vue.createBlock(_component_n_message_provider, null, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_n_config_provider, { theme: theme.value }, {
                  default: vue.withCtx(() => [
                    vue.unref(flyStore).initStatus ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1, [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(Generator)[vue.unref(flyStore).ActiveGenerator])))
                    ])) : vue.createCommentVNode("", true)
                  ]),
                  _: 1
                }, 8, ["theme"])
              ]),
              _: 1
            });
          };
        }
      });
      const pinia = createPinia();
      const app = document.createElement("div");
      app.className = "queryGenerator";
      document.body.append(app);
      vue.createApp(_sfc_main).use(naive$1).use(pinia).mount(app);
      _GM_registerMenuCommand("", () => {
        window.lightTheme(false);
      });
      const codeGeneratorEnable = _GM_getValue("codeGeneratorEnable", false);
      _GM_registerMenuCommand(`${codeGeneratorEnable ? "" : ""}Beta Version`, () => {
        _GM_setValue("codeGeneratorEnable", !codeGeneratorEnable);
        setTimeout(() => {
          window.location.reload();
        }, 100);
      });
      const addDtsEnable = _GM_getValue("addDtsEnable", false);
      _GM_registerMenuCommand(`${addDtsEnable ? "" : ""}Beta Version`, () => {
        _GM_setValue("addDtsEnable", !addDtsEnable);
        setTimeout(() => {
          window.location.reload();
        }, 100);
      });
    }
  });
  require_main_001();

})(Vue);